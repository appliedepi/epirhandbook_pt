[{"path":"index.html","id":"section","chapter":"","heading":"","text":"Este manual se esforça para:Servir como um manual rápido de referência código RFornecer exemplos centrados em tarefas que abordam problemas epidemiológicos comunsAuxiliar os epidemiologistas na transição para o RSer acessível em ambientes com baixa conectividade com Internet por meio de uma versão offline \nEscrito por epidemiologistas, para epidemiologistasSomos epidemiologistas aplicados de todo o mundo, escrevendo em nosso tempo livre para oferecer este recurso à comunidade. Seu encorajamento e feedback são muito bem-vindos:Formulário estruturado de feedbackEmail epiRhandbook@gmail.com ou tweet @epiRhandbookSubmeta issues nosso repositório Github","code":""},{"path":"index.html","id":"como-usar-este-manual","chapter":"","heading":"Como usar este manual","text":"Navegue pelas páginas Índice, ou use caixa de buscaClique nos ícones “copiar” para copiar o códigoVocê pode seguir - junto com os dados exemplo.Consulte seção “Recursos” de cada página para obter mais materialVersão -lineVeja instruções na página Fazer o Download manual e dos dados.LínguasEsta é uma versão traduzida para Português. Se você quer colaborar em melhorá-la, corrigindo algum erro, ou traduzir para outra língua, por favor, nos contacte!","code":""},{"path":"index.html","id":"agradecimentos","chapter":"","heading":"0.1 Agradecimentos","text":"Este manual é produzido por uma colaboração de epidemiologistas de todo o mundo, aproveitando experiência de organizações que incluem agências de saúde locais, estaduais, provinciais e nacionais, Organização Mundial da Saúde (OMS), Médicos Sem Fronteiras / Médicos sem Fronteiras (MSF), sistemas hospitalares e instituições acadêmicas.Este manual é não um produto aprovado de qualquer organização específica. Embora nos esforcemos para ser precisos, não damos nenhuma garantia conteúdo deste livro.","code":""},{"path":"index.html","id":"colaboradores","chapter":"","heading":"Colaboradores","text":"Editor: Neale BatraEquipe principal projeto: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay Campbell, Paula Blomquist, Aminata Ndiaye, Isaac Florence, Isha Berry, Mathilde Mousset, Sara Hollis, Liza Coyer, Kate Kelsey, Marie-Amélie Degail Chabrat, Joao MuiangaAutores: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinRevisores: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIlustradores: Calder FongTradutores da versão em língua portuguesa (Brasil): Carolina Musso, César Augusto Galvão , Halian Vilela, Laís Relvas, Felipe Cardoso, Rafaela Tadei, Pauliana Galvão, Nathalia Zini, Paula Maçaira, João Pedro Angelici, Ademar Barbosa Dantas Junior, Eucilene Santana, Hudson Gabriel Virtuoso Fontenele","code":""},{"path":"index.html","id":"financiamento-e-apoio","chapter":"","heading":"Financiamento e apoio","text":"O manual recebeu financiamento de apoio através de uma subvenção de emergência COVID-19 da TEPHINET, rede global de Programas de Treinamento em Epidemiologia de Campo (FETPs).O apoio administrativo foi fornecido pela EPIET Alumni Network (EAN), com agradecimentos especiais à Annika Wendland. O EPIET é o Programa Europeu de Treinamento em Epidemiologia de Intervenção.Agradecimentos especiais aos Médicos Sem Fronteiras (MSF) Centro Operacional Amsterdã (OCA) por seu apoio durante o desenvolvimento deste manual.Esta publicação foi apoiada pelo Acordo Cooperativo número NU2GGH001873, financiado pelos Centros de Controle e Prevenção de Doenças através TEPHINET, um programa da Força Tarefa para Saúde Global. Seu conteúdo é de responsabilidade exclusiva dos autores e não representa necessariamente visão oficial dos Centros de Controle e Prevenção de Doenças, Departamento de Saúde e Serviços Humanos, Task Force Global Health, Inc. ou TEPHINET.","code":""},{"path":"index.html","id":"inspiração","chapter":"","heading":"Inspiração","text":"infinidade de tutoriais e vinhetas que forneceram conhecimento para o desenvolvimento conteúdo manual são creditados dentro de suas respectivas páginas.De modo mais geral, seguintes fontes forneceram inspiração para este manual:“R4Epis” project (colaboração entre MSF e RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"termos-de-uso-e-contribuição","chapter":"","heading":"Termos de Uso e Contribuição","text":"","code":""},{"path":"index.html","id":"licença","chapter":"","heading":"Licença","text":"Esta obra está licenciada sob uma Licença Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.Cursos acadêmicos e programas de treinamento de epidemiologistas são bem-vindos para usar este manual com seus alunos. Se você tiver dúvidas sobre o uso pretendido, envie um e-mail para epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"citação","chapter":"","heading":"Citação","text":"Batra, Neale, et ai. O Manual Epidemiologista R. 2021. ","code":""},{"path":"index.html","id":"contribuição","chapter":"","heading":"Contribuição","text":"Se você quiser fazer uma contribuição de conteúdo, entre em contato conosco primeiro por meio de questões Github ou por e-mail. Estamos implementando um cronograma de atualizações e criando um guia contribuidor.Observe que o projeto epiRhandbook é lançado com um Código de Conduta Contribuidor. Ao contribuir para este projeto, você concorda em respeitar seus termos.","code":""},{"path":"editorial-style.html","id":"editorial-style","chapter":"1 Notas editoriais e técnicas","heading":"1 Notas editoriais e técnicas","text":"Nesta página descrevemos abordagem filosófica, o estilo e decisões editoriais específicas tomadas durante criação deste manual.","code":""},{"path":"editorial-style.html","id":"abordagem-e-estilo","chapter":"1 Notas editoriais e técnicas","heading":"1.1 Abordagem e estilo","text":"O público em potencial para este livro é grande. Ele será certamente utilizado por pessoas muito novas R, e também por usuários experientes R que procuram melhores práticas e dicas. Portanto, deve ser ao mesmo tempo acessível e sucinto. Portanto, nossa abordagem foi fornecer o suficiente texto para que alguém muito novo R possa aplicar o código e seguir o que o código está fazendo.Alguns outros pontos:Este é um livro de referência de códigos, acompanhado de exemplos relativamente breves - não um livro de texto completo sobre R ou sobre ciência de dadosEste é um manual de R para utilização âmbito da epidemiologia aplicada - não um manual sobre os métodos ou ciência da epidemiologia aplicadaEste destina-se ser um documento “vivo” - os pacotes R que são ideais para uma determinada tarefa tendem mudar frequentemente, e estamos abertos discussão sobre qual pacote deveríamos enfatizar neste manual","code":""},{"path":"editorial-style.html","id":"pacotes-do-r","chapter":"1 Notas editoriais e técnicas","heading":"Pacotes do R","text":"São tantas escolhasUm dos aspectos mais desafiadores da aprendizagem de R é saber qual o pacote R utilizar para uma dada tarefa. É uma ocorrência comum esforçar-se demais em uma tarefa e só mais tarde perceber - ei, há um pacote R que faz tudo isso numa única linha de código!Neste manual, tentamos oferecer-lhe pelo menos duas formas de completar cada tarefa: um método experimentado e validado (provavelmente em R base ou tidyverse) e um pacote especial R que tenha sido construído para esse fim. Queremos que tenham algumas opções caso não consigam fazer o download de um determinado pacote ou que este não funcione.Ao escolher os pacotes utilizar, nós demos prioridade aos pacotes R e às abordagens que foram testados e aprovados pela comunidade. Também minimizamos o número de pacotes utilizados numa sessão de trabalho típica, e escolhemos aqueles que são estáveis (não mudam com muita frequência), e que cumprem tarefa de forma simples e limpaEste manual dá, de modo geral, prioridade aos pacotes e funções R tidyverse. Tidyverse é uma colecção de pacotes de R concebidos para ciência de dados que partilham gramática e estruturas de dados em comum. Todos os pacotes tidyverse podem ser instalados ou carregados através pacote tidyverse. Leia mais em tidyverse website.Quando aplicável, também oferecemos opções de código usando o R base - os pacotes e funções que já vêm com R na sua instalação. Isto porque reconhecemos que parte público deste livro podem não ter Internet estável para realizar o download de pacotes extra.Explicitando os pacotes de origem de cada funçãoGeralmente é frustrante quando, nos tutoriais de R, uma função é mostrada em código, mas não se sabe de que pacote ela é! Tentamos evitar esta situação.texto narrativo, os nomes dos pacotes são escritos negrito (por exemplo dplyr) e funções são escritas desta forma: mutate(). Esforçamo-nos por ser explícitos sobre de que pacote vem uma função, seja referenciando o pacote em texto próximo ou especificando o pacote explicitamente código: dplyr::mutate(). Pode parecer redundante, mas estamos fazendo isso de propósito.Veja página em Introdução ao R para saber mais sobre pacotes e funções.","code":""},{"path":"editorial-style.html","id":"estilo-do-código","chapter":"1 Notas editoriais e técnicas","heading":"Estilo do código","text":"manual, nós utilizamos frequentemente “novas linhas”, fazendo o nosso código parecer “longo”. Fazemos isso por algumas razões:Dessa forma podemos escrever comentários explicativos com `#’, colocando-os posicionados de forma adjacente cada pequena parte códigoGeralmente, o código mais longo (vertical) é mais fácil de lerÉ mais fácil de ler em uma tela estreita (não é necessária rolagem lateral)partir das indentações, pode ser mais fácil saber que argumentos pertencem que funçãoComo resultado, código que poderia ser escrito desta forma:…é escrito assim:O código R não é geralmente afetado por novas linhas ou indentações. Ao escrever o código, se você iniciar uma nova linha após uma vírgula, ele aplicará padrões de recuo automáticamente.Também utilizamos muitos espaços (por exemplo n = 1 em vez de n=1) porque é mais fácil de ler. Seja gentil com pessoas que lêem o seu código!","code":"\nlinelist %>% \n  group_by(hospital) %>%  # agrupe as linhas por hospital\n  slice_max(date, n = 1, with_ties = F) # se houver um empate (de data), pegue a primeira linha\nlinelist %>% \n  group_by(hospital) %>% # agrupe as linhas por hospital\n  slice_max(\n    date,                # mantenha a linha que contem o valor máximo de data para cada grupo k\n    n = 1,               # mantenha unicamente a linha com o valor mais alto\n    with_ties = F)       # se houver um empate (de data), pegue a primeira linha"},{"path":"editorial-style.html","id":"nomenclatura","chapter":"1 Notas editoriais e técnicas","heading":"Nomenclatura","text":"Neste manual, referimos geralmente “colunas” e “linhas” em vez de “variáveis” e “observações”. Como explicado neste manual em “tidy data”, maioria dos conjuntos de dados estatísticos epidemiológicos consistem estruturalmente em linhas, colunas e valores.variáveis contêm os valores que medem o mesmo atributo subjacente (como grupo etário, resultado, ou data de início). Observações contêm todos os valores medidos na mesma unidade (por exemplo, uma pessoa, local, ou amostra de laboratório). Portanto, estes aspectos podem ser mais difíceis de definir de forma tangível.Em conjuntos de dados “arrumados” (tidy), cada coluna é uma variável, cada linha é uma observação, e cada célula é um valor único. entanto, alguns conjuntos de dados que encontrarem podem não seguir esse modelo - um conjunto de dados de formato “largo” pode ter uma variável dividida em várias colunas (ver um exemplo na página Pivoteando Dados). Da mesma forma, uma única observação pode estar divididas em várias linhas.maior parte deste manual trata da gestão e transformação de dados, e por isso, se referir às estruturas concretas de dados (linhas e colunas) é mais relevante que se referir às observações e às variáveis de forma mais abstractas. exceções ocorrem principalmente em páginas sobre análise de dados, onde se verá mais referências variáveis e observações.","code":""},{"path":"editorial-style.html","id":"notas","chapter":"1 Notas editoriais e técnicas","heading":"Notas","text":"Aqui estão os tipos de notas que você poderá encontrar neste manual:NOTA: Isso é uma notaDICA: Isso é uma dica.CUIDADO: Esta é uma nota de precaução.PERIGO: Isso é uma advertência.","code":""},{"path":"editorial-style.html","id":"decisões-editoriais","chapter":"1 Notas editoriais e técnicas","heading":"1.2 Decisões editoriais","text":"Abaixo, relacionamos decisões editoriais significativas em torno da escolha pacote e da função. Se discordar ou quiser oferecer uma nova ferramenta para consideração, por favor, junte-se/ inicie uma conversa na nossa página Github.Tabela de pacote, função, e outras decisões editoriais*","code":""},{"path":"editorial-style.html","id":"principais-revisões","chapter":"1 Notas editoriais e técnicas","heading":"1.3 Principais revisões","text":"","code":""},{"path":"editorial-style.html","id":"informação-da-sessão-r-rstudio-pacotes","chapter":"1 Notas editoriais e técnicas","heading":"1.4 Informação da sessão (R, RStudio, pacotes)","text":"Abaixo estão informações sobre versões dos pacotes R, RStudio, e R utilizados durante esta elaboração deste Manual.","code":"\nsessioninfo::session_info()## ─ Session info ─────────────────────────────────────────────────────────────────────\n##  setting  value\n##  version  R version 4.3.0 (2023-04-21 ucrt)\n##  os       Windows 11 x64 (build 22621)\n##  system   x86_64, mingw32\n##  ui       RStudio\n##  language (EN)\n##  collate  English_United States.utf8\n##  ctype    English_United States.utf8\n##  tz       Europe/Berlin\n##  date     2023-10-22\n##  rstudio  2023.09.0+463 Desert Sunflower (desktop)\n##  pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n## \n## ─ Packages ─────────────────────────────────────────────────────────────────────────\n##  ! package              * version    date (UTC) lib source\n##    abind                  1.4-5      2016-07-21 [1] CRAN (R 4.3.0)\n##    ada                    2.0-5      2016-05-13 [1] CRAN (R 4.3.0)\n##    adagio                 0.8.5      2022-10-03 [1] CRAN (R 4.3.0)\n##    ade4                   1.7-22     2023-02-06 [1] CRAN (R 4.3.0)\n##    anytime                0.3.9      2020-08-27 [1] CRAN (R 4.3.0)\n##    ape                  * 5.7-1      2023-03-13 [1] CRAN (R 4.3.0)\n##    aplot                  0.2.1      2023-09-15 [1] CRAN (R 4.3.1)\n##    apyramid             * 0.1.3      2023-02-14 [1] CRAN (R 4.3.0)\n##    askpass                1.2.0      2023-09-03 [1] CRAN (R 4.3.1)\n##    assertive.base         0.0-9      2021-02-08 [1] CRAN (R 4.3.0)\n##    assertive.properties   0.0-5      2022-04-21 [1] CRAN (R 4.3.0)\n##    assertive.types        0.0-3      2016-12-30 [1] CRAN (R 4.3.0)\n##    aweek                * 1.0.3      2022-10-06 [1] CRAN (R 4.3.0)\n##    backports              1.4.1      2021-12-13 [1] CRAN (R 4.3.0)\n##    base64enc              0.1-3      2015-07-28 [1] CRAN (R 4.3.0)\n##    bayestestR           * 0.13.1     2023-04-07 [1] CRAN (R 4.3.0)\n##    BiocManager            1.30.22    2023-08-08 [1] CRAN (R 4.3.1)\n##    bit                  * 4.0.5      2022-11-15 [1] CRAN (R 4.3.0)\n##    bit64                  4.0.5      2020-08-30 [1] CRAN (R 4.3.0)\n##    blob                   1.2.4      2023-03-17 [1] CRAN (R 4.3.0)\n##    bookdown               0.35       2023-08-09 [1] CRAN (R 4.3.1)\n##    boot                 * 1.3-28.1   2022-11-22 [2] CRAN (R 4.3.0)\n##    broom                * 1.0.5      2023-06-09 [1] CRAN (R 4.3.1)\n##    broom.helpers          1.14.0     2023-08-07 [1] CRAN (R 4.3.1)\n##    bslib                  0.5.1      2023-08-11 [1] CRAN (R 4.3.1)\n##    cachem                 1.0.8      2023-05-01 [1] CRAN (R 4.3.0)\n##    callr                  3.7.3      2022-11-02 [1] CRAN (R 4.3.0)\n##    car                    3.1-2      2023-03-30 [1] CRAN (R 4.3.0)\n##    carData                3.0-5      2022-01-06 [1] CRAN (R 4.3.0)\n##    cellranger             1.1.0      2016-07-27 [1] CRAN (R 4.3.0)\n##    class                  7.3-21     2023-01-23 [2] CRAN (R 4.3.0)\n##    classInt               0.4-10     2023-09-05 [1] CRAN (R 4.3.1)\n##    cli                    3.6.1      2023-03-23 [1] CRAN (R 4.3.0)\n##    cmprsk                 2.2-11     2022-01-06 [1] CRAN (R 4.3.0)\n##    coarseDataTools        0.6-6      2021-12-09 [1] CRAN (R 4.3.0)\n##    coda                   0.19-4     2020-09-30 [1] CRAN (R 4.3.0)\n##    codetools              0.2-19     2023-02-01 [2] CRAN (R 4.3.0)\n##    colorspace             2.1-0      2023-01-23 [1] CRAN (R 4.3.0)\n##    commonmark             1.9.0      2023-03-17 [1] CRAN (R 4.3.0)\n##    correlation          * 0.8.4      2023-04-06 [1] CRAN (R 4.3.0)\n##    corrr                * 0.4.4      2022-08-16 [1] CRAN (R 4.3.0)\n##    cowplot              * 1.1.1      2020-12-30 [1] CRAN (R 4.3.0)\n##    crayon                 1.5.2      2022-09-29 [1] CRAN (R 4.3.0)\n##    crosstalk              1.2.0      2021-11-04 [1] CRAN (R 4.3.0)\n##    crul                   1.4.0      2023-05-17 [1] CRAN (R 4.3.0)\n##    curl                   5.0.2      2023-08-14 [1] CRAN (R 4.3.1)\n##    data.table             1.14.8     2023-02-17 [1] CRAN (R 4.3.0)\n##    datawizard           * 0.9.0      2023-09-15 [1] CRAN (R 4.3.1)\n##    DBI                  * 1.1.3      2022-06-18 [1] CRAN (R 4.3.0)\n##    Deriv                  4.1.3      2021-02-24 [1] CRAN (R 4.3.0)\n##    DiagrammeR           * 1.0.10     2023-05-18 [1] CRAN (R 4.3.0)\n##    digest                 0.6.33     2023-07-07 [1] CRAN (R 4.3.1)\n##    distcrete            * 1.0.3      2017-11-23 [1] CRAN (R 4.3.0)\n##    doBy                 * 4.6.19     2023-10-02 [1] CRAN (R 4.3.0)\n##    doParallel             1.0.17     2022-02-07 [1] CRAN (R 4.3.0)\n##    downlit                0.4.3      2023-06-29 [1] CRAN (R 4.3.1)\n##    dplyr                * 1.1.3      2023-09-03 [1] CRAN (R 4.3.1)\n##    dsr                  * 0.2.2      2019-08-23 [1] CRAN (R 4.3.0)\n##    DT                   * 0.29       2023-08-29 [1] CRAN (R 4.3.1)\n##    e1071                  1.7-13     2023-02-01 [1] CRAN (R 4.3.0)\n##    easystats            * 0.6.0      2022-11-29 [1] CRAN (R 4.3.0)\n##    effectsize           * 0.8.6      2023-09-14 [1] CRAN (R 4.3.1)\n##    ellipsis               0.3.2      2021-04-29 [1] CRAN (R 4.3.0)\n##    Epi                  * 2.47.1     2023-04-25 [1] CRAN (R 4.3.0)\n##    epicontacts          * 1.2.0      2023-05-21 [1] Github (reconhub/epicontacts@7df53e5)\n##    epidict                0.0.0.9001 2023-05-21 [1] Github (R4EPI/epidict@9cf5a53)\n##    EpiEstim             * 2.2-4      2021-01-07 [1] CRAN (R 4.3.0)\n##    epikit               * 0.1.5      2023-02-15 [1] CRAN (R 4.3.0)\n##    EpiNow2              * 1.4.0      2023-09-26 [1] CRAN (R 4.3.1)\n##    epitabulate            0.0.0.9007 2023-05-21 [1] Github (R4EPI/epitabulate@56370b8)\n##    epitrix              * 0.4.0      2023-01-13 [1] CRAN (R 4.3.0)\n##    etm                    1.1.1      2020-09-08 [1] CRAN (R 4.3.0)\n##    evaluate               0.22       2023-09-29 [1] CRAN (R 4.3.1)\n##    evd                    2.3-6.1    2022-07-04 [1] CRAN (R 4.3.0)\n##    FactoClass             1.2.8      2023-09-14 [1] CRAN (R 4.3.1)\n##    fansi                  1.0.4      2023-01-22 [1] CRAN (R 4.3.0)\n##    farver                 2.1.1      2022-07-06 [1] CRAN (R 4.3.0)\n##    fastLink             * 0.6.0      2020-04-29 [1] CRAN (R 4.3.0)\n##    fastmap                1.1.1      2023-02-24 [1] CRAN (R 4.3.0)\n##    ff                   * 4.0.9      2023-01-25 [1] CRAN (R 4.3.0)\n##    fitdistrplus           1.1-11     2023-04-25 [1] CRAN (R 4.3.0)\n##    flextable            * 0.9.3      2023-09-07 [1] CRAN (R 4.3.1)\n##    fontBitstreamVera      0.1.1      2017-02-01 [1] CRAN (R 4.3.0)\n##    fontLiberation         0.1.0      2016-10-15 [1] CRAN (R 4.3.0)\n##    fontquiver             0.2.1      2017-02-01 [1] CRAN (R 4.3.0)\n##    forcats              * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n##    foreach                1.5.2      2022-02-02 [1] CRAN (R 4.3.0)\n##    formatR                1.14       2023-01-17 [1] CRAN (R 4.3.0)\n##    formattable          * 0.2.1      2021-01-07 [1] CRAN (R 4.3.0)\n##    Formula              * 1.2-5      2023-02-24 [1] CRAN (R 4.3.0)\n##    frailtypack          * 3.5.0      2021-12-20 [1] CRAN (R 4.3.0)\n##    fs                   * 1.6.3      2023-07-20 [1] CRAN (R 4.3.1)\n##    futile.logger          1.4.3      2016-07-10 [1] CRAN (R 4.3.0)\n##    futile.options         1.0.1      2018-04-20 [1] CRAN (R 4.3.0)\n##    future                 1.33.0     2023-07-01 [1] CRAN (R 4.3.1)\n##    future.apply           1.11.0     2023-05-21 [1] CRAN (R 4.3.0)\n##    gdtools                0.3.3      2023-03-27 [1] CRAN (R 4.3.0)\n##    generics               0.1.3      2022-07-05 [1] CRAN (R 4.3.0)\n##    gfonts                 0.2.0      2023-01-08 [1] CRAN (R 4.3.0)\n##    ggExtra              * 0.10.1     2023-08-21 [1] CRAN (R 4.3.1)\n##    ggforce              * 0.4.1      2022-10-04 [1] CRAN (R 4.3.0)\n##    ggfun                  0.1.3      2023-09-15 [1] CRAN (R 4.3.1)\n##    gghighlight          * 0.4.0      2022-10-16 [1] CRAN (R 4.3.0)\n##    ggnewscale           * 0.4.9      2023-05-25 [1] CRAN (R 4.3.1)\n##    ggplot2              * 3.4.3      2023-08-14 [1] CRAN (R 4.3.1)\n##    ggplotify              0.1.2      2023-08-09 [1] CRAN (R 4.3.1)\n##    ggpubr               * 0.6.0      2023-02-10 [1] CRAN (R 4.3.0)\n##    ggrepel              * 0.9.3      2023-02-03 [1] CRAN (R 4.3.0)\n##    ggsignif               0.6.4      2022-10-13 [1] CRAN (R 4.3.0)\n##    ggtext                 0.1.2      2022-09-16 [1] CRAN (R 4.3.0)\n##    ggtree               * 3.8.2      2023-07-25 [1] Bioconductor\n##    ggupset              * 0.3.0      2020-05-05 [1] CRAN (R 4.3.0)\n##    glmnet                 4.1-8      2023-08-22 [1] CRAN (R 4.3.1)\n##    globals                0.16.2     2022-11-21 [1] CRAN (R 4.3.0)\n##    glue                   1.6.2      2022-02-24 [1] CRAN (R 4.3.0)\n##    grates               * 1.1.0      2023-06-08 [1] CRAN (R 4.3.1)\n##    gridExtra              2.3        2017-09-09 [1] CRAN (R 4.3.0)\n##    gridGraphics           0.5-1      2020-12-13 [1] CRAN (R 4.3.0)\n##    gridtext               0.1.5      2022-09-16 [1] CRAN (R 4.3.0)\n##    gt                     0.9.0      2023-03-31 [1] CRAN (R 4.3.0)\n##    gtable                 0.3.4      2023-08-21 [1] CRAN (R 4.3.1)\n##    gtools                 3.9.4      2022-11-27 [1] CRAN (R 4.3.0)\n##    gtsummary            * 1.7.2      2023-07-15 [1] CRAN (R 4.3.1)\n##    haven                  2.5.3      2023-06-30 [1] CRAN (R 4.3.1)\n##    here                 * 1.0.1      2020-12-13 [1] CRAN (R 4.3.0)\n##    highr                  0.10       2022-12-22 [1] CRAN (R 4.3.0)\n##    hms                    1.1.3      2023-03-21 [1] CRAN (R 4.3.0)\n##    htmltools              0.5.6      2023-08-10 [1] CRAN (R 4.3.1)\n##    htmlwidgets            1.6.2      2023-03-17 [1] CRAN (R 4.3.0)\n##    httpcode               0.3.0      2020-04-10 [1] CRAN (R 4.3.0)\n##    httpuv                 1.6.11     2023-05-11 [1] CRAN (R 4.3.0)\n##    httr                   1.4.7      2023-08-15 [1] CRAN (R 4.3.1)\n##    i2extras             * 0.2.1      2023-03-17 [1] CRAN (R 4.3.0)\n##    igraph                 1.5.1      2023-08-10 [1] CRAN (R 4.3.1)\n##    incidence              1.7.3      2020-11-04 [1] CRAN (R 4.3.0)\n##    incidence2           * 2.2.1      2023-06-13 [1] CRAN (R 4.3.1)\n##    inline                 0.3.19     2021-05-31 [1] CRAN (R 4.3.0)\n##    insight              * 0.19.5     2023-09-13 [1] CRAN (R 4.3.1)\n##    ipred                  0.9-14     2023-03-09 [1] CRAN (R 4.3.0)\n##    isoband                0.2.7      2022-12-20 [1] CRAN (R 4.3.0)\n##    iterators              1.0.14     2022-02-05 [1] CRAN (R 4.3.0)\n##    janitor              * 2.2.0      2023-02-02 [1] CRAN (R 4.3.0)\n##    jomo                   2.7-6      2023-04-15 [1] CRAN (R 4.3.1)\n##    jquerylib              0.1.4      2021-04-26 [1] CRAN (R 4.3.0)\n##    jsonlite               1.8.7      2023-06-29 [1] CRAN (R 4.3.1)\n##    kableExtra           * 1.3.4      2021-02-20 [1] CRAN (R 4.3.0)\n##    KernSmooth             2.23-20    2021-05-03 [2] CRAN (R 4.3.0)\n##    km.ci                  0.5-6      2022-04-06 [1] CRAN (R 4.3.0)\n##    KMsurv                 0.1-5      2012-12-03 [1] CRAN (R 4.3.0)\n##    knitr                  1.44       2023-09-11 [1] CRAN (R 4.3.1)\n##    labeling               0.4.3      2023-08-29 [1] CRAN (R 4.3.1)\n##    labelled               2.12.0     2023-06-21 [1] CRAN (R 4.3.1)\n##    lambda.r               1.2.4      2019-09-18 [1] CRAN (R 4.3.0)\n##    later                  1.3.1      2023-05-02 [1] CRAN (R 4.3.0)\n##    lattice                0.21-8     2023-04-05 [2] CRAN (R 4.3.0)\n##    lava                   1.7.2.1    2023-02-27 [1] CRAN (R 4.3.0)\n##    lazyeval               0.2.2      2019-03-15 [1] CRAN (R 4.3.0)\n##    lifecycle              1.0.3      2022-10-07 [1] CRAN (R 4.3.0)\n##    listenv                0.9.0      2022-12-16 [1] CRAN (R 4.3.0)\n##    lme4                   1.1-34     2023-07-04 [1] CRAN (R 4.3.1)\n##    lmtest               * 0.9-40     2022-03-21 [1] CRAN (R 4.3.0)\n##    loo                    2.6.0      2023-03-31 [1] CRAN (R 4.3.0)\n##    lpSolve                5.6.19     2023-09-13 [1] CRAN (R 4.3.1)\n##    lubridate            * 1.9.3      2023-09-27 [1] CRAN (R 4.3.1)\n##    magrittr             * 2.0.3      2022-03-30 [1] CRAN (R 4.3.0)\n##    markdown               1.9        2023-09-30 [1] CRAN (R 4.3.1)\n##    MASS                 * 7.3-58.4   2023-03-07 [2] CRAN (R 4.3.0)\n##    matchmaker           * 0.1.1      2020-02-21 [1] CRAN (R 4.3.0)\n##    Matrix               * 1.6-1.1    2023-09-18 [1] CRAN (R 4.3.1)\n##    MatrixModels           0.5-2      2023-07-10 [1] CRAN (R 4.3.1)\n##    matrixStats            1.0.0      2023-06-02 [1] CRAN (R 4.3.1)\n##    mcmc                   0.9-7      2020-03-21 [1] CRAN (R 4.3.0)\n##    MCMCpack               1.6-3      2022-04-13 [1] CRAN (R 4.3.0)\n##    memoise                2.0.1      2021-11-26 [1] CRAN (R 4.3.0)\n##    mgcv                   1.8-42     2023-03-02 [2] CRAN (R 4.3.0)\n##    mice                 * 3.16.0     2023-06-05 [1] CRAN (R 4.3.1)\n##    microbenchmark         1.4.10     2023-04-28 [1] CRAN (R 4.3.0)\n##    mime                   0.12       2021-09-28 [1] CRAN (R 4.3.0)\n##    miniUI                 0.1.1.1    2018-05-18 [1] CRAN (R 4.3.0)\n##    minqa                  1.2.6      2023-09-11 [1] CRAN (R 4.3.1)\n##    mitml                  0.4-5      2023-03-08 [1] CRAN (R 4.3.1)\n##    mitools                2.4        2019-04-26 [1] CRAN (R 4.3.0)\n##    modelbased           * 0.8.6      2023-01-13 [1] CRAN (R 4.3.0)\n##    munsell                0.5.0      2018-06-12 [1] CRAN (R 4.3.0)\n##    naniar               * 1.0.0      2023-02-02 [1] CRAN (R 4.3.0)\n##    networkD3            * 0.4        2017-03-18 [1] CRAN (R 4.3.0)\n##    nlme                   3.1-162    2023-01-31 [2] CRAN (R 4.3.0)\n##    nloptr                 2.0.3      2022-05-26 [1] CRAN (R 4.3.0)\n##    nnet                   7.3-18     2022-09-28 [2] CRAN (R 4.3.0)\n##    numDeriv               2016.8-1.1 2019-06-06 [1] CRAN (R 4.3.0)\n##    officer              * 0.6.2      2023-03-28 [1] CRAN (R 4.3.0)\n##    openssl                2.1.1      2023-09-25 [1] CRAN (R 4.3.1)\n##    pacman                 0.5.1      2019-03-11 [1] CRAN (R 4.3.0)\n##    pan                    1.9        2023-08-21 [1] CRAN (R 4.3.1)\n##    parallelly             1.36.0     2023-05-26 [1] CRAN (R 4.3.0)\n##    parameters           * 0.21.2     2023-09-16 [1] CRAN (R 4.3.1)\n##    parsedate            * 1.3.1      2022-10-27 [1] CRAN (R 4.3.0)\n##    patchwork            * 1.1.3      2023-08-14 [1] CRAN (R 4.3.1)\n##    performance          * 0.10.5     2023-09-12 [1] CRAN (R 4.3.1)\n##    PerformanceAnalytics * 2.0.4      2020-02-06 [1] CRAN (R 4.3.0)\n##    PHEindicatormethods  * 2.0.1      2023-05-05 [1] CRAN (R 4.3.0)\n##    pillar                 1.9.0      2023-03-22 [1] CRAN (R 4.3.0)\n##    pkgbuild               1.4.2      2023-06-26 [1] CRAN (R 4.3.1)\n##    pkgconfig              2.0.3      2019-09-22 [1] CRAN (R 4.3.0)\n##    plotly               * 4.10.2     2023-06-03 [1] CRAN (R 4.3.1)\n##    plotrix                3.8-2      2021-09-08 [1] CRAN (R 4.3.0)\n##    plyr                   1.8.8      2022-11-11 [1] CRAN (R 4.3.1)\n##    png                    0.1-8      2022-11-29 [1] CRAN (R 4.3.0)\n##    polyclip               1.10-6     2023-09-27 [1] CRAN (R 4.3.1)\n##    prettyunits            1.2.0      2023-09-24 [1] CRAN (R 4.3.1)\n##    processx               3.8.2      2023-06-30 [1] CRAN (R 4.3.1)\n##    prodlim                2023.08.28 2023-08-28 [1] CRAN (R 4.3.1)\n##    progressr              0.14.0     2023-08-10 [1] CRAN (R 4.3.1)\n##    projections          * 0.6.0      2023-03-23 [1] CRAN (R 4.3.0)\n##    promises               1.2.1      2023-08-10 [1] CRAN (R 4.3.1)\n##    proxy                  0.4-27     2022-06-09 [1] CRAN (R 4.3.0)\n##    ps                     1.7.5      2023-04-18 [1] CRAN (R 4.3.0)\n##    purrr                * 1.0.2      2023-08-10 [1] CRAN (R 4.3.1)\n##    quadprog               1.5-8      2019-11-20 [1] CRAN (R 4.3.0)\n##    Quandl                 2.11.0     2021-08-11 [1] CRAN (R 4.3.0)\n##    quantmod             * 0.4.25     2023-08-22 [1] CRAN (R 4.3.1)\n##    quantreg               5.97       2023-08-19 [1] CRAN (R 4.3.1)\n##    QuickJSR               1.0.6      2023-09-12 [1] CRAN (R 4.3.1)\n##    R.methodsS3            1.8.2      2022-06-13 [1] CRAN (R 4.3.0)\n##    R.oo                   1.25.0     2022-06-12 [1] CRAN (R 4.3.0)\n##    R.utils                2.12.2     2022-11-11 [1] CRAN (R 4.3.0)\n##    R6                     2.5.1      2021-08-19 [1] CRAN (R 4.3.0)\n##    ragg                   1.2.5      2023-01-12 [1] CRAN (R 4.3.0)\n##    RColorBrewer         * 1.1-3      2022-04-03 [1] CRAN (R 4.3.0)\n##    Rcpp                 * 1.0.11     2023-07-06 [1] CRAN (R 4.3.1)\n##  D RcppParallel           5.1.7      2023-02-27 [1] CRAN (R 4.3.0)\n##    readr                * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n##    readxl               * 1.4.3      2023-07-06 [1] CRAN (R 4.3.1)\n##    RecordLinkage        * 0.4-12.4   2022-11-08 [1] CRAN (R 4.3.0)\n##    report               * 0.5.7      2023-03-22 [1] CRAN (R 4.3.0)\n##    repr                   1.1.6      2023-01-26 [1] CRAN (R 4.3.0)\n##    reshape2               1.4.4      2020-04-09 [1] CRAN (R 4.3.0)\n##    rio                  * 1.0.1      2023-09-19 [1] CRAN (R 4.3.1)\n##    rlang                  1.1.1      2023-04-28 [1] CRAN (R 4.3.0)\n##    rmarkdown              2.25       2023-09-18 [1] CRAN (R 4.3.1)\n##    rootSolve              1.8.2.4    2023-09-21 [1] CRAN (R 4.3.1)\n##    rpart                  4.1.19     2022-10-21 [2] CRAN (R 4.3.0)\n##    rprojroot              2.0.3      2022-04-02 [1] CRAN (R 4.3.0)\n##    RSQLite              * 2.3.1      2023-04-03 [1] CRAN (R 4.3.0)\n##    rstan                  2.26.23    2023-09-08 [1] CRAN (R 4.3.1)\n##    rstantools             2.3.1.1    2023-07-18 [1] CRAN (R 4.3.1)\n##    rstatix              * 0.7.2      2023-02-01 [1] CRAN (R 4.3.0)\n##    rstudioapi             0.15.0     2023-07-07 [1] CRAN (R 4.3.1)\n##    runner                 0.4.3      2023-03-21 [1] CRAN (R 4.3.0)\n##    rvest                  1.0.3      2022-08-19 [1] CRAN (R 4.3.0)\n##    sass                   0.4.7      2023-07-15 [1] CRAN (R 4.3.1)\n##    scales               * 1.2.1      2022-08-20 [1] CRAN (R 4.3.0)\n##    scatterplot3d          0.3-44     2023-05-05 [1] CRAN (R 4.3.0)\n##    see                  * 0.8.0      2023-06-05 [1] CRAN (R 4.3.1)\n##    SemiCompRisks        * 3.4        2021-02-03 [1] CRAN (R 4.3.0)\n##    sessioninfo            1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n##    sf                     1.0-14     2023-07-11 [1] CRAN (R 4.3.1)\n##    shape                  1.4.6      2021-05-19 [1] CRAN (R 4.3.0)\n##    shiny                  1.7.5      2023-08-12 [1] CRAN (R 4.3.1)\n##    sitrep               * 0.2.3      2023-05-21 [1] Github (r4epi/sitrep@b96906b)\n##    skimr                * 2.1.5      2022-12-23 [1] CRAN (R 4.3.0)\n##    slider               * 0.3.0      2022-11-16 [1] CRAN (R 4.3.0)\n##    snakecase              0.11.1     2023-08-27 [1] CRAN (R 4.3.1)\n##    SparseM                1.81       2021-02-18 [1] CRAN (R 4.3.0)\n##    srvyr                * 1.2.0      2023-02-21 [1] CRAN (R 4.3.0)\n##    StanHeaders            2.26.28    2023-09-07 [1] CRAN (R 4.3.1)\n##    statmod                1.5.0      2023-01-06 [1] CRAN (R 4.3.0)\n##    stringdist           * 0.9.10     2022-11-07 [1] CRAN (R 4.3.0)\n##    stringi                1.7.12     2023-01-11 [1] CRAN (R 4.3.0)\n##    stringr              * 1.5.0      2022-12-02 [1] CRAN (R 4.3.0)\n##    survC1               * 1.0-3      2021-02-10 [1] CRAN (R 4.3.0)\n##    survey               * 4.2-1      2023-05-03 [1] CRAN (R 4.3.0)\n##    survival             * 3.5-5      2023-03-12 [2] CRAN (R 4.3.0)\n##    survminer            * 0.4.9      2021-03-09 [1] CRAN (R 4.3.0)\n##    survMisc               0.5.6      2022-04-07 [1] CRAN (R 4.3.0)\n##    svglite                2.1.1      2023-01-10 [1] CRAN (R 4.3.0)\n##    systemfonts            1.0.4      2022-02-11 [1] CRAN (R 4.3.0)\n##    textshaping            0.3.6      2021-10-13 [1] CRAN (R 4.3.0)\n##    tibble               * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n##    tidyquant            * 1.0.7      2023-03-31 [1] CRAN (R 4.3.0)\n##    tidyr                * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n##    tidyselect             1.2.0      2022-10-10 [1] CRAN (R 4.3.0)\n##    tidytree               0.4.5      2023-08-10 [1] CRAN (R 4.3.1)\n##    tidyverse            * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n##    timechange             0.2.0      2023-01-11 [1] CRAN (R 4.3.0)\n##    treeio               * 1.24.0     2023-04-25 [1] Bioconductor\n##    truncnorm              1.0-9      2023-03-20 [1] CRAN (R 4.3.0)\n##    tsibble              * 1.1.3      2022-10-09 [1] CRAN (R 4.3.0)\n##    TTR                  * 0.24.3     2021-12-12 [1] CRAN (R 4.3.0)\n##    tweenr                 2.0.2      2022-09-06 [1] CRAN (R 4.3.0)\n##    tzdb                   0.4.0      2023-05-12 [1] CRAN (R 4.3.0)\n##    units                  0.8-4      2023-09-13 [1] CRAN (R 4.3.1)\n##    UpSetR               * 1.4.0      2019-05-22 [1] CRAN (R 4.3.0)\n##    utf8                   1.2.3      2023-01-31 [1] CRAN (R 4.3.0)\n##    uuid                   1.1-1      2023-08-17 [1] CRAN (R 4.3.1)\n##    vctrs                  0.6.3      2023-06-14 [1] CRAN (R 4.3.1)\n##    viridis                0.6.4      2023-07-22 [1] CRAN (R 4.3.1)\n##    viridisLite            0.4.2      2023-05-02 [1] CRAN (R 4.3.0)\n##    visdat                 0.6.0      2023-02-02 [1] CRAN (R 4.3.0)\n##    visNetwork           * 2.1.2      2022-09-29 [1] CRAN (R 4.3.0)\n##    vistime              * 1.2.3      2022-10-16 [1] CRAN (R 4.3.0)\n##    warp                   0.2.0      2020-10-21 [1] CRAN (R 4.3.0)\n##    webshot              * 0.5.5      2023-06-26 [1] CRAN (R 4.3.1)\n##    withr                  2.5.1      2023-09-26 [1] CRAN (R 4.3.1)\n##    writexl              * 1.4.2      2023-01-06 [1] CRAN (R 4.3.0)\n##    xfun                   0.40       2023-08-09 [1] CRAN (R 4.3.1)\n##    xml2                   1.3.5      2023-07-06 [1] CRAN (R 4.3.1)\n##    xtable                 1.8-4      2019-04-21 [1] CRAN (R 4.3.0)\n##    xts                  * 0.13.1     2023-04-16 [1] CRAN (R 4.3.0)\n##    yaml                   2.3.7      2023-01-23 [1] CRAN (R 4.3.0)\n##    yulab.utils            0.1.0      2023-09-20 [1] CRAN (R 4.3.1)\n##    zip                    2.3.0      2023-04-17 [1] CRAN (R 4.3.0)\n##    zoo                  * 1.8-12     2023-04-13 [1] CRAN (R 4.3.0)\n## \n##  [1] C:/Users/neale/AppData/Local/R/win-library/4.3\n##  [2] C:/Program Files/R/R-4.3.0/library\n## \n##  D ── DLL MD5 mismatch, broken installation.\n## \n## ────────────────────────────────────────────────────────────────────────────────────"},{"path":"data-used.html","id":"data-used","chapter":"2 Baixe o livro e os dados","heading":"2 Baixe o livro e os dados","text":"","code":""},{"path":"data-used.html","id":"baixe-o-livro-offline","chapter":"2 Baixe o livro e os dados","heading":"2.1 Baixe o livro offline","text":"Você pode baixar versão offline deste livro como um arquivo HTML para que você possa ver o arquivo em seu navegador, mesmo se você não tiver mais acesso à Internet. Se você está considerando o uso offline livro Epi R, aqui estão algumas coisas serem consideradas:Quando você abre o arquivo, pode levar um ou dois minutos para imagens e o índice serem carregadosO livro -line tem um layout ligeiramente diferente - uma página muito longa com Índice à esquerda. Para pesquisar termos específicos, use Ctrl+f (Cmd+f)Consulte página Pacotes sugeridos para ajudá-lo instalar os pacotes R apropriados antes que você perca conectividade com InternetInstale nosso pacote R epirhandbook que contém todos os dados de exemplo (processo de instalação descrito abaixo)Existem duas maneiras de baixar o livro:","code":""},{"path":"data-used.html","id":"use-o-link-de-download","chapter":"2 Baixe o livro e os dados","heading":"Use o link de download","text":"Para acesso rápido, clique com o botão direito neste link e selecione “Salvar link como”.Se estiver em um Mac, use Cmd+clique. Se estiver em um celular, pressione e segure o link e selecione “Salvar link”. O livro será baixado para o seu dispositivo. Se uma tela com código HTML bruto exibida, certifique-se de seguir instruções acima ou tente Opção 2.","code":""},{"path":"data-used.html","id":"use-nosso-pacote-r","chapter":"2 Baixe o livro e os dados","heading":"Use nosso pacote R","text":"Oferecemos um pacote R denominado epirhandbook. Inclui uma função download_book () que baixa o arquivo livro de nosso repositório Github para o seu computador.Este pacote também contém uma função get_data() que baixa todos os dados de exemplo para o seu computador.Execute o seguinte código para instalar nosso pacote R epirhandbook repositório Github applyepi. Este pacote não está CRAN, então use função especial p_install_gh() para instalá-lo Github.Agora, carregue o pacote para uso em sua sessão R atual:Em seguida, execute função pacote download_book() (com parênteses vazios) para baixar o livro para o seu computador. Supondo que você esteja RStudio, uma janela aparecerá permitindo que você selecione um local para salvar.","code":"\n# instale a última versão do pacote do livro do Epi R\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n# carregue o pacote para uso\npacman::p_load(epirhandbook)\n# baixe o livro offline para o seu computador\ndownload_book()"},{"path":"data-used.html","id":"baixe-os-dados-para-acompanhar","chapter":"2 Baixe o livro e os dados","heading":"2.2 Baixe os dados para acompanhar","text":"Para acompanhar páginas livro, você pode baixar os dados e resultados de exemplo.","code":""},{"path":"data-used.html","id":"use-nosso-pacote-r-1","chapter":"2 Baixe o livro e os dados","heading":"Use nosso pacote R","text":"abordagem mais fácil para baixar todos os dados é instalar nosso pacote R epirhandbook. Ele contém uma função get_data() que salva todos os dados de exemplo em uma pasta de sua escolha em seu computador.Para instalar nosso pacote R epirhandbook, execute o seguinte código. Este pacote não está CRAN, então use função p_install_gh() para instalá-lo. entrada faz referência à nossa organização Github (“appliedepi”) e o pacote epirhandbook.Agora, carregue o pacote para uso em sua sessão R atual:seguir, use função pacote get_data() para baixar os dados de exemplo para o seu computador. Execute get_data(\"\") para obter todos os dados de exemplo ou forneça um nome de arquivo específico e extensão entre aspas para recuperar apenas um arquivo.Os dados já foram baixados com o pacote e simplesmente precisam ser transferidos para uma pasta em seu computador. Uma janela pop-aparecerá, permitindo que você selecione um local para salvar pasta. Sugerimos que você crie uma nova pasta de “dados”, pois há cerca de 30 arquivos (incluindo dados de exemplo e saídas de exemplo).Depois de usar get_data() para salvar um arquivo em seu computador, você ainda precisará importá-lo para R. Consulte página Importar e exportar para obter detalhes.Se desejar, você pode revisar todos os dados usados neste livro na pasta “data” de nosso repositório Github.","code":"\n# instale a última versão do pacote do livro do Epi R\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n# carregue o pacote para uso\npacman::p_load(epirhandbook)\n# baixe todos os dados de exemplo em uma pasta em seu computador\nget_data(\"all\")\n\n# baixe apenas os dados de exemplo da lista de linha em uma pasta em seu computador\nget_data(file = \"linelist_cleaned.rds\")\n# baixe um arquivo específico em uma pasta em seu computador\nget_data(\"linelist_cleaned.rds\")"},{"path":"data-used.html","id":"baixe-um-por-um","chapter":"2 Baixe o livro e os dados","heading":"Baixe um por um","text":"Esta opção envolve o download dos dados arquivo por arquivo de nosso repositório Github por meio de um link ou de um comando R específico para o arquivo. Alguns tipos de arquivo permitem um botão de download, enquanto outros podem ser baixados por meio de um comando R.","code":""},{"path":"data-used.html","id":"linelist-de-casos","chapter":"2 Baixe o livro e os dados","heading":"“Linelist” de casos","text":"Este é um surto fictício de Ebola, expandido pela equipe livro partir conjunto de dados de prática ebola_sim pacote outbreaks. Clique para baixar linelist “bruta” (.xlsx)  . linelist caso “bruta” é uma planilha Excel com dados confusos. Use-o para acompanhar página Limpeza de dados e funções principais.Se você quiser acompanhar,  clique para baixar o linelist “limpo” (clean)  (.rds file). Use este arquivo para todas outras páginas deste livro que usam lista de linha. Um arquivo .rds é um tipo de arquivo específico de R que preserva classes de coluna. Isso garante que você terá apenas uma limpeza mínima para fazer após importar os dados para R.Outros arquivos relacionados:Se você quiser acompanhar,  clique para baixar o linelist “limpo” (clean)  (.rds file).Parte da página de limpeza usa um “dicionário de limpeza” (arquivo .csv). Você pode carregá-lo diretamente R executando os seguintes comandos:","code":"\npacman::p_load(rio) # instalar / carregar o pacote rio\n\n# importe o arquivo diretamente do Github\ncleaning_dict <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")"},{"path":"data-used.html","id":"data_malaria","chapter":"2 Baixe o livro e os dados","heading":"Dados de contagem de malária","text":"Esses dados são contagens fictícias de casos de malária por faixa etária, serviço e dia. Um arquivo .rds é um tipo de arquivo específico de R que preserva classes de coluna. Isso garante que você terá apenas uma limpeza mínima para fazer após importar os dados para R.\nClique para fazer o download\n os dados de contagem de malária (arquivo .rds) \n","code":""},{"path":"data-used.html","id":"dados-em-escala-likert","chapter":"2 Baixe o livro e os dados","heading":"Dados em escala Likert","text":"Estes são dados fictícios de uma pesquisa estilo Likert, usados na página Pirâmides demográficas e escalas Likert. Você pode carregar esses dados diretamente R executando os seguintes comandos:","code":"\npacman::p_load(rio) # instalar / carregar o pacote rio\n\n# importe o arquivo diretamente do Github\nlikert_data <- import(\"https://raw.githubusercontent.com/appliedepi/epirhandbook_eng/master/data/likert_data.csv\")"},{"path":"data-used.html","id":"painéis-com-flexdashboard","chapter":"2 Baixe o livro e os dados","heading":"Painéis com flexdashboard","text":"Abaixo estão os links para o arquivo associado à página em Painéis (Dashboards) com R Markdown:Para baixar o R Markdown para o painel de surto, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.Para baixar o painel HTML, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.","code":""},{"path":"data-used.html","id":"rastreamento-de-contato","chapter":"2 Baixe o livro e os dados","heading":"Rastreamento de contato","text":"página Rastreamento de contato demonstra análise dos dados de rastreamento de contato, usando dados de exemplo de [Go.Data] (https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting). Os dados usados na página podem ser baixados como arquivos .rds clicando nos seguintes links:\nClique para fazer o download\n os dados de investigação caso (arquivo .rds) \n\nClique para fazer o download\n os dados de registro contato (arquivo .rds) \n\nClique para fazer o download\n os dados de acompanhamento contato (arquivo .rds) \n NOTA: Dados de rastreamento de contato estruturado de outro software (por exemplo, KoBo, DHIS2 Tracker, CommCare) podem parecer diferentes. Se desejar contribuir com dados de amostra ou conteúdo alternativo para esta página, entre em contato.  DICA: Se você estiver implantando Go.Data e quiser se conectar à API da sua instância, consulte página Importar e exportar (seção API) e Go.Data Community Practice. ","code":""},{"path":"data-used.html","id":"sobre-o-gis","chapter":"2 Baixe o livro e os dados","heading":"Sobre o GIS","text":"Os shapefiles têm muitos arquivos de subcomponentes, cada um com uma extensão de arquivo diferente. Um arquivo terá extensão “.shp”, mas outros podem ter “.dbf”, “.prj”, etc.página GIS básico fornece links para o site Humanitarian Data Exchange onde você pode baixar os shapefiles diretamente como arquivos compactados.Por exemplo, os dados dos pontos das unidades de saúde podem ser baixados aqui. Download “hotosm_sierra_leone_health_facilities_points_shp.zip”. Depois de salvar em seu computador, “descompacte” pasta. Você verá vários arquivos com extensões diferentes (por exemplo, “.shp”, “.prj”, “.shx”) - todos eles devem ser salvos na mesma pasta em seu computador. Então, para importar para o R, forneça o caminho arquivo e o nome arquivo “.shp” para st_read() pacote sf (conforme descrito na página Introdução ao GIS).Se você seguir Opção 1 para baixar todos os dados de exemplo (por meio de nosso pacote R epirhandbook), todos os shapefiles serão incluídos.Alternativamente, você pode baixar os shapefiles da pasta “data” R Handbook Github (veja subpasta “gis”). entanto, esteja ciente de que você precisará baixar cada subarquivo individualmente para o seu computador. Github, clique em cada arquivo individualmente e baixe-os clicando botão “Baixar”. Abaixo, você pode ver como o arquivo de forma “sle_adm3” consiste em muitos arquivos - cada um dos quais precisaria ser baixado Github.","code":""},{"path":"data-used.html","id":"árvores-filogenéticas","chapter":"2 Baixe o livro e os dados","heading":"2.2.0.1 Árvores filogenéticas","text":"Veja página sobre Árvores filogenéticas. Arquivo Newick da árvore filogenética construída partir sequenciamento genoma completo de 299 amostras de Shigella sonnei e dados de amostra correspondentes (convertidos em um arquivo de texto). amostras belgas e os dados resultantes são gentilmente fornecidos pelo NRC belga para Salmonella e Shigella âmbito de um projeto conduzido por um bolsista ECDC EUPHEM, e também serão publicados em um manuscrito. Os dados internacionais estão disponíveis abertamente em bases de dados públicas (NCBI) e foram publicados previamente.Para baixar o arquivo da árvore filogenética “Shigella_tree.txt”, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.Para baixar o “sample_data_Shigella_tree.csv” com informações adicionais sobre cada amostra, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.Para ver nova árvore de subconjunto criada, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”. O arquivo .txt será baixado para o seu computador.Você pode então importar os arquivos .txt com read.tree() pacote ape, conforme explicado na página.","code":"\nape::read.tree(\"Shigella_tree.txt\")"},{"path":"data-used.html","id":"padronização","chapter":"2 Baixe o livro e os dados","heading":"Padronização","text":"Consulte página sobre Taxas padronizadas. Você pode carregar os dados diretamente de nosso repositório Github na Internet em sua sessão R com os seguintes comandos:","code":"# instalar / carregar o pacote rio\npacman::p_load(rio) \n\n)\n# País A\n)\n# importar dados demográficos para o país A diretamente do Github\nA_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# importação de mortes para o país A diretamente do Github\nA_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n)\n# País B\n)\n# importar dados demográficos para o país B diretamente do Github\nB_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# importação de mortes para o país B diretamente do Github\nB_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n\n)\n# População Referência \n)\n# importar dados demográficos para o país B diretamente do Github\nstandard_pop_data <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")"},{"path":"data-used.html","id":"data_outbreak","chapter":"2 Baixe o livro e os dados","heading":"Séries temporais e detecção de surto","text":"Consulte página em Séries temporais e detecção de surto. Usamos casos de Campylobacter relatados na Alemanha 2002-2011, conforme disponível pacote surveillance R. (nb. este conjunto de dados foi adaptado original, em que 3 meses de dados foram excluídos final de 2011 para fins de demonstração).\nClique para fazer o download\n Campylobacter na Alemanha (.xlsx) \nTambém usamos dados climáticos da Alemanha 2002-2011 (temperatura em graus Celsius e queda de chuva em milímetros). Eles foram baixados conjunto de dados de reanálise satélite Copernicus da UE usando o pacote ecmwfr. Você precisará baixar tudo isso e importá-los com stars::read_stars() conforme explicado na página da série temporal.\nClique para fazer o download\n Alemanha meteorologia 2002 (arquivo .nc) \n\nClique para fazer o download\n Alemanha meteorologia 2003 (arquivo .nc) \n\nClique para fazer o download\n Alemanha meteorologia 2004 (arquivo .nc) \n\nClique para fazer o download\n Clima Alemanha 2005 (arquivo .nc) \n\nClique para fazer o download\n Clima Alemanha 2006 (arquivo .nc) \n\nClique para fazer o download\n Clima Alemanha 2007 (arquivo .nc) \n\nClique para fazer o download\n Clima Alemanha 2008 (arquivo .nc) \n\nClique para fazer o download\n Clima Alemanha 2009 (arquivo .nc) \n\nClique para fazer o download\n Clima Alemanha 2010 (arquivo .nc) \n\nClique para fazer o download\n Clima Alemanha 2011 (arquivo .nc) \n","code":""},{"path":"data-used.html","id":"data_survey","chapter":"2 Baixe o livro e os dados","heading":"Análise da pesquisa","text":"Para página análise da pesquisa, usamos dados fictícios de pesquisa de mortalidade baseados em modelos de pesquisa OCA MSF. Esses dados fictícios foram gerados como parte projeto “R4Epis”.\nClique para fazer o download\n Dados de pesquisa fictícios (.xlsx) \n\nClique para fazer o download\n Dicionário fictício de dados de pesquisa (.xlsx) \n\nClique para fazer o download\n Dados fictícios da população de pesquisas (.xlsx) \n","code":""},{"path":"data-used.html","id":"data_shiny","chapter":"2 Baixe o livro e os dados","heading":"Shiny","text":"página em Painéis com Shiny demonstra construção de um aplicativo simples para exibir dados da malária.Para baixar os arquivos R que produzem o aplicativo Shiny:Você pode \nclique aqui para baixar o arquivo app.R  que contém IU e o código servidor para o aplicativo Shiny.  Você pode \nclique aqui para baixar o arquivo facility_count_data.rds   que contém dados de malária para o aplicativo Shiny. Observe que pode ser necessário armazená-lo em uma pasta “data” para que os caminhos de arquivo () funcionem corretamente.Você pode \nclique aqui para baixar o arquivo global.R   que deve ser executado antes da abertura aplicativo, conforme explicado na página.Você pode \nclique aqui para baixar o arquivo plot_epicurve.R   que é fornecido pela global.R. Observe que pode ser necessário armazená-lo em uma pasta “funcs” para que os caminhos de arquivo () funcionem corretamente.","code":""},{"path":"basics.html","id":"basics","chapter":"3 Introdução ao R","heading":"3 Introdução ao R","text":"Bem-vindo!Esta página analisa o essencial de R. Ela não pretende ser um tutorial abrangente, mas fornece o básico e pode ser útil para refrescar sua memória. secção Recurso para aprendizagem tem links para tutoriais mais abrangentes.Partes desta página foram adaptadas com permissão projecto R4Epis.Ver página em Transição para R para dicas sobre como mudar para R de STATA, SAS, ou Excel.","code":""},{"path":"basics.html","id":"porque-usar-o-r","chapter":"3 Introdução ao R","heading":"3.1 Porque usar o R?","text":"Segundo definição site R project, R é uma linguagem de programação e também um ambiente para computação estatística e gráfica. É altamente versátil, extensível, e orientado para comunidade.CustoR é de utilização livre! Há uma política forte na comunidade para que o material seja gratuito e de código aberto.ReprodutibilidadeA prática de conduzir análise e gestão dos dados por meio de uma linguagem de programação (em comparação com o Excel ou outra dessas ferramentas que requerem cliques manuais) melhora reprodutibilidade, torna detecção de erros mais fácil e alivia sua carga de trabalho.ComunidadeA comunidade de usuários de R é enorme e colaborativa. Novos pacotes e ferramentas para resolver problemas da vida real são desenvolvidos diariamente e recebe críticas e contribuições da comunidade de utilizadores. Como um exemplo, R-Ladies é uma organização mundial cuja missão é promover diversidade de gênero na comunidade R, e é uma das maiores organizações de utilizadores de R. É provável que tenha uma divisão perto de você!","code":""},{"path":"basics.html","id":"termos-chave","chapter":"3 Introdução ao R","heading":"3.2 Termos chave","text":"RStudio - RStudio é uma Interface Gráfica de Utilizador (GUI) para uma utilização mais fácil da linguagem R. Leia mais na secção RStudio.Objetos - Tudo o que se armazena em R - conjuntos de dados, variáveis, uma lista de nomes de cidades, um número total da população, mesmo saídas como gráficos - são objetos aos quais é atribuído um nome e podem ser referenciados em comandos posteriores. Ler mais na secção Objectos.Funções - Uma função é uma operação de código que aceita entradas e devolve uma saída transformada. Leia mais na secção Funções.Pacotes - Um pacote R é um pacote partilhável de funções. Leia mais na secção PacotesScripts/Códigos - Um script é um arquivo que contém linhas de comando que escreveu. Leia mais na secção Scripts","code":""},{"path":"basics.html","id":"learning","chapter":"3 Introdução ao R","heading":"3.3 Recursos para a aprendizagem","text":"","code":""},{"path":"basics.html","id":"recursos-dentro-do-rstudio","chapter":"3 Introdução ao R","heading":"Recursos dentro do RStudio","text":"Documentação de ajudaPesquisar na aba “Ajuda” RStudio pela documentação sobre pacotes R e funções específicas. Isto está dentro painel que também contém “Arquivos”, “Gráficos” e “Pacotes” (tipicamente painel inferior direito). Como atalho, também se pode digitar o nome de um pacote ou função console R após um ponto de interrogação para abrir página de Ajuda relevante. Não inclui parênteses.Por exemplo: ?filter ou ?diagrammeR.Tutoriais interativosHá várias maneiras de aprender R interactivamente dentro RStudio.O próprio RStudio oferece um painel Tutorial que é alimentado pelo pacote R learnr. Basta instalar este pacote e abrir um tutorial através da nova aba “Tutorial” painel superior direito RStudio, que também contém os separadores Environment (Ambiente) e History (Histórico).O pacote R swirl oferece cursos interativos Console R. Instale e carregue este pacote, depois execute o comando swirl() (parênteses vazios) Console R. Você verá avisos aparecerem Console. Responda digitando Console. Ele irá guiá-lo através de um curso à sua escolha.","code":""},{"path":"basics.html","id":"página-de-dicas","chapter":"3 Introdução ao R","heading":"Página de dicas","text":"Há várias “cheatsheets” (“colinhas”) em pdf disponíveis website RStudio, por exemplo:Fatores com o pacote forcatsDatas e horas com o pacote lubridateCaracteres com o pacote stringrOperações iterativas com o pacote purrrImportação de dadosFolha de dica para transformação de dadas com o pacote dplyrR Markdown (para criar documentos como PDF, Word, Powerpoint…)Shiny (para construir aplicativos de web interativos)Visualização de dados com o pacote ggplot2Cartografia (GIS)Pacote leaflet (mapas interativos)Python com R (pacote reticulate)Este é um recurso online R especificamente para usuários Excel","code":""},{"path":"basics.html","id":"twitter","chapter":"3 Introdução ao R","heading":"Twitter","text":"R tem uma vibrante comunidade twitter onde você pode aprender dicas, atalhos e notícias, siga estas contas:Siga nos! @epiRhandbookR Function Day (Uma função por dia) @rfuntionaday é um recurso incrívelR Data Science (R para Ciência de Dados) @rstats4dsRStudio @RStudioDicas RStudio@rstudiotipsR-Bloggers @RbloggersR-ladies @RLadiesGlobalHadley Wickham @hadleywickhamTambém:#epitwitter e #rstats","code":""},{"path":"basics.html","id":"recursos-online-gratuitos","chapter":"3 Introdução ao R","heading":"Recursos online gratuitos","text":"Um texto definitivo é o livro R Data Science de Garrett Grolemund e Hadley WickhamO site projeto R4Epis tem como objetivo “desenvolver ferramentas padronizadas de limpeza, análise e relatório de dados para cobrir tipos comuns de surtos e pesquisas populacionais que seriam conduzidas em um ambiente de resposta emergências de MSF”. Você pode encontrar materiais de treinamento básicos R, modelos para relatórios RMarkdown sobre surtos e pesquisas e tutoriais para ajudá-lo configurá-los.","code":""},{"path":"basics.html","id":"idiomas-além-do-inglês","chapter":"3 Introdução ao R","heading":"Idiomas além do inglês","text":"Materiais RStudio em EspanholIntrodução ao R e ao tidyverse (Francês)Ciência de Dados em R (Português)","code":""},{"path":"basics.html","id":"instalação","chapter":"3 Introdução ao R","heading":"3.4 Instalação","text":"","code":""},{"path":"basics.html","id":"r-e-r-studio","chapter":"3 Introdução ao R","heading":"R e R Studio","text":"Como instalar o RVisite o site https://www.r-project.org/ e faça o download da versão mais recente R que seja adequada para o seu computador.Como instalar o RStudioVisite esse website https://rstudio.com/products/rstudio/download/ e faça o download da versão gratuita mais recente para Desktop RStudio que seja adequada para seu computador.PermissõesNote que você deve instalar R e RStudio em um drive onde você tenha permissões de leitura e escrita. Caso contrário, sua capacidade de instalar pacotes R (um problema de ocorrência freqüente) será impactada. Se você encontrar problemas, tente abrir o RStudio clicando com o botão direito mouse ícone e selecionando “Executar como administrador”. Outras dicas podem ser encontradas na página R em unidades de rede.Como atualizar o R e o RStudioSua versão de R é exibida (“printada”) o Console R na inicialização. Você também pode executar o sessionInfo().Para atualizar o R, vá para o site mencionado acima e reinstale o R. Alternativamente, você pode utilizar o pacote installr (Windows) executando installr::updateR(). Isto abrirá caixas de diálogo para ajudá-lo baixar última versão R e atualizar seus pacotes para nova versão R. Mais detalhes podem ser encontrados na installr documentação.Esteja ciente de que antiga versão R ainda existirá em seu computador. Você pode executar temporariamente uma versão antiga (antiga “instalação”) R clicando em “Tools” (Ferramentas) -> “Global Options” (Opções Globais) RStudio e escolhendo uma versão R. Isto pode ser útil se você quiser usar um pacote que não tenha sido atualizado para funcionar na versão mais nova R.Para atualizar o RStudio, você pode ir ao site acima e fazer o download novamente RStudio. Outra opção é clicar em “Help” (Ajuda) -> “Check Updates” (Verificar Atualizações) dentro RStudio, mas isto pode não mostrar últimas atualizações.Para ver quais versões R, RStudio, ou pacotes foram usados quando este Manual foi feito, veja página em Notas editoriais e técnicas.","code":""},{"path":"basics.html","id":"outros-softwares-você-pode-precisar-instalar","chapter":"3 Introdução ao R","heading":"Outros softwares você pode precisar instalar","text":"TinyTeX (para compilaar documentos de RMarkdown em PDF)Pandoc (para compilar documentos de RMarkdown)RTools (para construir pacotes em R)phantomjs (para salvar imagens ou redes animadas, como redes de transmissão)","code":""},{"path":"basics.html","id":"tinytex","chapter":"3 Introdução ao R","heading":"TinyTex","text":"TinyTex é uma distribuição LaTeX customizada, útil quando tentar produzir PDFs R.\nVeja https://yihui.org/tinytex/ para mais informações.Para instalar o TinyTex R:","code":"\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# para desisntalar o TinyTeX, corra tinytex::uninstall_tinytex()"},{"path":"basics.html","id":"pandoc","chapter":"3 Introdução ao R","heading":"Pandoc","text":"Sua versão de R é impressa o Console R na inicialização. Você também pode executar o Pandoc é um conversor de documentos, um software separado R. Ele vem junto com o RStudio , provavelmente não precisará ser baixado. Ele ajuda processo de conversão de documentos Rmarkdown para formatos como .pdf e adição de funcionalidades complexas.","code":""},{"path":"basics.html","id":"rtools","chapter":"3 Introdução ao R","heading":"RTools","text":"RTools é uma coleção de softwares para construção de pacotes para R.Instale desse website: https://cran.r-project.org/bin/windows/Rtools/","code":""},{"path":"basics.html","id":"phantomjs","chapter":"3 Introdução ao R","heading":"phantomjs","text":"Esta ferramenta é freqüentemente usada para tirar “fotografias da tela” de páginas da web. Por exemplo, quando você cria uma cadeia de transmissão com o pacote epicontacts, um arquivo HTML é produzido e ele é interativo e dinâmico. Se você quiser uma imagem estática, pode ser útil usar o pacote webshot para automatizar este processo. Isto exigirá o programa externo “phantomjs”. Você pode instalar o phantomjs através pacote webshot com o comando webshot::install_phantomjs().","code":""},{"path":"basics.html","id":"rstudio","chapter":"3 Introdução ao R","heading":"3.5 RStudio","text":"","code":""},{"path":"basics.html","id":"se-orientando-no-rstudio","chapter":"3 Introdução ao R","heading":"Se orientando no RStudio","text":"Primeiramente, abra o RStudio. Como os ícones deles podem ser muito parecidos, certifique-se de que você está abrindo mesmo o RStudio e não R.Para que o RStudio funcione, você também deve ter R instalado computador (veja acima instruções de instalação).RStudio é uma interface (GUI) para facilitar o uso de R. Você pode pensar em R como sendo o motor de um veículo, fazendo o trabalho crucial, e RStudio como carroceria veículo (com assentos, acessórios, etc.) que ajuda você realmente usar o motor para seguir em frente! Você pode ver ficha completa da interface de usuário RStudio (PDF) aquiPor padrão, o RStudio exibe quatro painéis retangulares.DICA: Se o seu RStudio mostrar apenas um painel esquerdo, é porque não há nenhum script aberto aindaO Painel Fonte (Source)\nEste painel, por padrão localizado na parte superior esquerda, é um espaço onde é possível editar, executar e salvar seus scripts. Os scripts contêm os comandos que você deseja executar. Este painel também pode exibir conjuntos de dados (quadros de dados) para visualização.Para usuários da Stata, este painel é similar às janelas de seu -file e Data Editor.O Painel Console RO Console R, ou simplesmente Console, é por padrão o painel esquerdo ou inferior esquerdo RStudio. Ele é casa “motor” de R. É aqui que os comandos são realmente executados e saídas não gráficas e mensagens de erro/aviso aparecem. Você pode digitar e executar comandos diretamente Console, mas perceba que estes comandos não são salvos como são ao executar comandos de um script.Se você está familiarizado com Stata, o Console R é como Janela de Comando e também Janela de Resultados.O Painel Ambiente (Environment)Este painel, por padrão na parte superior direita, é mais freqüentemente usado para ver resumos breves de objetos Ambiente R na sessão atual. Estes objetos podem incluir conjuntos de dados importados, modificados ou criados, parâmetros que você definiu (por exemplo, uma semana epidemiológica específica para análise), ou vetores ou listas que você definiu durante análise (por exemplo, nomes de regiões). Você pode clicar na seta ao lado de um nome de data frame para ver suas variáveis.Stata, isto é mais parecido com janela Gerenciador de Variáveis.Este painel também contém aba History onde você pode ver comandos que você pode ver anteriormente. Tem também uma aba “Tutorial” onde você pode completar tutoriais R interativos se você tiver o pacote learnr instalado. Tem também um painel “Conections” para conexões externas, e pode ter um painel “Git” se você optar por fazer interface com o Github.Paineis: Gráficos (Plots), Visualizador (Viewer), Pacotes (Packages), Ajuda (Help)O painel inferior-direito inclui várias abas importantes. Gráficos típicos, incluindo mapas, serão exibidos painel Plo. Saídas interativas ou HTML serão exibidas painel Visualizador (Viewer). O painel de Ajuda (Help) pode exibir documentação e arquivos de ajuda. O painel Arquivos (Files) é um navegador que pode ser usado para abrir ou excluir arquivos. O painel Pacotes (Packages) permite ver, instalar, atualizar, excluir, carregar/descarregar pacotes R, e ver qual versão pacote você tem. Para saber mais sobre pacotes, veja seção pacotes abaixo.Este painel contém os equivalentes Stata das janelas Plots Manager e Project Manager.","code":""},{"path":"basics.html","id":"configurações-do-rstudio","chapter":"3 Introdução ao R","heading":"Configurações do RStudio","text":"Altere configurações e aparência RStudio menu suspenso Ferramentas (Tools), selecionando Opções Globais (Global Options). Lá você pode alterar configurações padrão, incluindo cor da aparência/fundo.Restart (Reiniciar)Se seu R travar, você pode reiniciar o R indo ao menu Sessão (Session) e clicando em “Reiniciar R” (Restart R). Isto evita o incômodo de fechar e abrir o RStudio. Tudo em seu ambiente R será removido quando você fizer isso.","code":""},{"path":"basics.html","id":"atalhos-no-teclado","chapter":"3 Introdução ao R","heading":"Atalhos no teclado","text":"Alguns atalhos de teclado muito úteis estão abaixo. Veja todos os atalhos de teclado para Windows, Mac e Linux na segunda página deste RStudio cheatsheet da interface usuário.DICA: Use sua tecla Tab ao digitar para ativar funcionalidade de auto-completar RStudio. Isto pode evitar erros ortográficos. Pressione Tab enquanto digita para produzir um menu suspenso de funções e objetos prováveis, com base que você digitou até agora.","code":""},{"path":"basics.html","id":"functions","chapter":"3 Introdução ao R","heading":"3.6 Funções","text":"funções estão cerne uso de R. funções são forma como você executa tarefas e operações. Muitas funções vêm instaladas com R, muitas mais estão disponíveis para download em packages (explicado na seção pacotes), e você pode até mesmo escrever suas próprias funções personalizadas!Esta seção básica sobre funções explica:O que é uma função e como funcionamO que são os argumentos/parâmetros de uma funçãoComo conseguir ajuda para compreender uma funçãoUma nota rápida sobre sintaxe: Neste manual, funções são escritas em texto de código com parênteses abertos, como este: filter(). Como explicado na seção pacotes, funções são baixadas dentro de pacotes. Neste manual, os nomes dos pacotes são escritos em negrito, como dplyr. Às vezes, código de exemplo, você pode ver o nome da função ligado explicitamente ao nome de seu pacote com um par de dois-pontos (::) como este: dplyr::filter(). O propósito desta ligação é explicado na seção de pacotes.","code":""},{"path":"basics.html","id":"funções-simples","chapter":"3 Introdução ao R","heading":"Funções simples","text":"Uma função é como uma máquina que recebe entradas, faz alguma ação com essas entradas e produz uma saída. O que é saída depende da função.Funções normalmente operam sobre algum objeto colocado dentro dos parênteses da função. Por exemplo, função sqrt() calcula raiz quadrada de um número:O objeto fornecido uma função também pode ser uma coluna em um conjunto de dados (veja seção Objetos para detalhes sobre todos os tipos de objetos). Como R pode armazenar vários conjuntos de dados, será necessário especificar tanto o conjunto de dados quanto coluna. Uma maneira de fazer isso é utilizar notação $ para ligar o nome conjunto de dados e o nome da coluna (dataset$coluna). exemplo abaixo, função summary() é aplicada à coluna numérica age (idade) conjunto de dados linelist, e saída é um resumo dos valores numéricos e valores ausentes da coluna.NOTA: Nos bastidores, uma função representa um código adicional complexo que foi condensado para o usuário em um comando fácil.","code":"\nsqrt(49)## [1] 7\n#Imprimir estatísticas resumidas da coluna 'age' (idade) no conjunto de dados 'linelist'.\nsummary(linelist$age)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.07   23.00   84.00      86"},{"path":"basics.html","id":"funções-com-argumentos-múltiplos","chapter":"3 Introdução ao R","heading":"Funções com argumentos múltiplos","text":"funções frequentemente pedem várias entradas, chamadas argumentos, ou parâmetros, localizadas dentro dos parênteses da função, geralmente separadas por vírgulas.Alguns argumentos são necessários para que função funcione corretamente, outros são opcionaisArgumentos opcionais têm configurações padrãoOs argumentos podem ter caráter, numérico, lógico (TRUE/FALSE)(verdadeiro/falso), e outros inputsAqui está uma função ficcional divertida, chamada oven_bake() ( inglês: assar forno), como um exemplo de uma função típica. Ela pega um objeto de entrada (por exemplo, um conjunto de dados, ou neste exemplo “dough” - massa) e realiza operações sobre ele como especificado por argumentos adicionais (minutes = e temperature =). saída pode ser impressa para o console, ou salva como um objeto utilizando o operador de atribuição <-.Em um exemplo mais realístico, o comando age_pyramid() abaixo produz uma pirâmide etária baseado em faixas-etárias e uma coluna divisória binária, como gender (gênero). função recebe três argumentos dentro dos parênteses, separados por vírgulas. Os valores fornecidos aos argumentos estabelecem linelist como o quadro de dados utilizar, age_cat5 como coluna contar, e gender como coluna binária utilizar para dividir pirâmide por cor.O comando acima pode ser escrito de forma equivalente ao abaixo, em um estilo mais longo com uma nova linha para cada argumento. Este estilo pode ser mais fácil de ler, e mais fácil de escrever “comentários” com # para explicar cada parte (comentar extensivamente é uma boa prática!). Para executar este comando mais longo, você pode destacar todo o comando e clicar em “Run”, ou simplesmente colocar o cursor na primeira linha e, em seguida, pressionar simultaneamente teclas Ctrl e Enter.primeira metade de uma atribuição de argumentos (por exemplo, dados =) não precisa ser especificada se os argumentos forem escritos em uma ordem específica (especificada na documentação da função). O código abaixo produz exatamente mesma pirâmide que o acima, porque função espera ordem dos argumentos: quadro de dados, variável age_group, variável split_by.Um comando mais complexo de age_pyramid() poderia incluir os argumentos opcionais para:Mostrar proporções em vez de contagens (definir proportional = TRUE quando o padrão é FALSE)Especifique duas cores serem utilizadas (pal = é abreviação de “paleta” e é fornecido com um vetor de dois nomes de cores. Veja página objetos para saber como função c() faz um vetor)NOTA: Para argumentos que você especificar com ambas partes argumento (por exemplo, proportional = TRUE), sua ordem entre todos os argumentos não importa.","code":"\n# Crie uma pirâmide etária\nage_pyramid(data = linelist, age_group = \"age_cat5\", split_by = \"gender\")\n# Crie uma pirâmide etária\nage_pyramid(\n  data = linelist,        # Use a linelist de casos\n  age_group = \"age_cat5\", # disponibilize a coluna de faixa-etária\n  split_by = \"gender\"     #usee a coluna de gênero para criar dois lados da pirâmide \n  )\n# Esse comando retorna o mesmo gráfico gerado acima\nage_pyramid(linelist, \"age_cat5\", \"gender\")\nage_pyramid(\n  linelist,                    # use a linelist de casos\n  \"age_cat5\",                  # coluna de faixa-etária\n  \"gender\",                    # divida por gênero\n  proportional = TRUE,         # porcentagem em vez de contagens\n  pal = c(\"orange\", \"purple\")  # cores\n  )"},{"path":"basics.html","id":"escrevendo-funções","chapter":"3 Introdução ao R","heading":"Escrevendo funções","text":"R é uma linguagem que é orientada em torno de funções, portanto você deve se sentir capacitado para escrever suas próprias funções. criação de funções traz várias vantagens:Para facilitar programação modular - separação código em peças independentes e gerenciáveisSubstituir o processo repetitivo de copia e cola, que pode ser propenso erros.Dar nomes memoráveis aos pedaços de códigoComo escrever uma função é abordado em profundidade na página Escrevendo funções.","code":""},{"path":"basics.html","id":"packages","chapter":"3 Introdução ao R","heading":"3.7 Pacotes","text":"Pacotes contém funções.Um pacote R é um pacote compartilhável de código e documentação que contém funções pré-definidas. Os usuários da comunidade R desenvolvem pacotes o tempo todo, atendendo problemas específicos, e é provável que alguém possa ajudar com seu trabalho inclusive! Você com certeza irá instalar e usar centenas de pacotes em seu uso de R.Na instalação, o R contém pacotes de “base” e funções que executam tarefas elementares e comuns. Mas muitos usuários R criam funções especializadas, que são verificadas pela comunidade R e que você pode baixar como um package (pacote) para seu próprio uso. Neste manual, os nomes dos pacotes estão escritos em negrito. Um dos aspectos mais desafiadores R é que muitas vezes há muitas funções ou pacotes serem escolhidos para complementar uma determinada tarefa.","code":""},{"path":"basics.html","id":"instalar-e-carregar","chapter":"3 Introdução ao R","heading":"Instalar e carregar","text":"funções estão contidas nos pacotes que podem ser baixados (“instalados”) para seu computador partir da Internet. Uma vez que um pacote é baixado, ele é armazenado em sua “biblioteca” (inglês, library). Você pode então acessar funções que ele contém durante sua sessão R atual “carregando” este pacote.Pense em R como sua biblioteca pessoal: Quando você baixa um pacote, sua biblioteca ganha um novo livro de funções, mas cada vez que você quiser usar uma função naquele livro, você deve pegar emprestado (“carregar”) aquele livro de sua biblioteca.Em resumo: para usar funções disponíveis em um pacote R, duas etapas devem ser implementadas:O pacote precisa ser instalado (uma vez), eO pacote precisa ser instalado (uma vez), eO pacote precisa ser carregado (cada sessão de R que abrir)O pacote precisa ser carregado (cada sessão de R que abrir)","code":""},{"path":"basics.html","id":"sua-biblioteca","chapter":"3 Introdução ao R","heading":"Sua biblioteca","text":"Sua “biblioteca” é na verdade uma pasta em seu computador, contendo uma subpasta para cada pacote que foi instalado. Descubra onde R está instalado em seu computador, e procure uma pasta chamada “win-library”. Por exemplo: R\\win-library\\4.0 (4.0 é versão R - você terá uma biblioteca diferente para cada versão R que você baixou).Você pode exibir (“printar”) o caminho arquivo para sua biblioteca digitando .libPaths() (parênteses vazios). Isto se torna especialmente importante se você trabalhar com R em unidades de rede.","code":""},{"path":"basics.html","id":"instalar-do-cran","chapter":"3 Introdução ao R","heading":"Instalar do CRAN","text":"Na maioria das vezes, os usuários R baixam pacotes da CRAN. CRAN (Comprehensive R Archive Network) é um repositório público -line de pacotes R que foram publicados por membros da comunidade R.Você está preocupado com vírus e segurança ao fazer o download de um pacote da CRAN? Leia este artigo sobre o assunto.","code":""},{"path":"basics.html","id":"como-instalar-e-carregar","chapter":"3 Introdução ao R","heading":"Como instalar e carregar","text":"Neste manual, sugerimos o uso pacote pacman (abreviação para “package manager” que significa “gerenciador de pacotes” em inglês). Ele oferece uma função conveniente p_load() que instalará um pacote se necessário e o carregará para utilização na sessão R atual.sintaxe é bastante simples. Basta listar os nomes dos pacotes dentro dos parênteses p_load(), separados por vírgulas. Este comando instalará os pacotes rio, tidyverse, e se ainda não estiverem instalados, e os carregará para utilização. Isto torna abordagem p_load() conveniente e concisa se compartilhar scripts com outros. Observe que os nomes dos pacotes são sensíveis maiúsculas e minúsculas.Note que utilizamos sintaxe pacman::p_load() que escreve explicitamente o nome pacote (pacman) antes nome da função (p_load()), conectado por duas colunas ::. Esta sintaxe é útil porque também carrega o pacote pacman (assumindo que já esteja instalado).Existem funções alternativas R base que você verá com freqüência. função R base para instalar um pacote é install.packages(). O nome pacote ser instalado deve ser fornecido entre parênteses em aspas. Se você quiser instalar vários pacotes em um comando, eles devem ser listados dentro de um vetor de caracteres c().Nota: este comando instala um pacote, mas não o carrega para utilização na sessão atual.instalação também pode ser feita clicando e apontando para o painel “Pacotes” RStudio e clicando em “Instalar” e procurando pelo nome pacote desejado.função R base para carregar um pacote para utilização (após ter sido instalado) é library(). Ela pode carregar apenas um pacote de cada vez (outro motivo para utilizar p_load()). Você pode fornecer o nome pacote com ou sem aspas.Para verificar se um pacote está instalado e/ou carregado, você pode visualizar o painel de Pacotes RStudio. Se o pacote estiver instalado, ele é mostrado lá com o número da versão. Se sua caixa marcada, ela é carregada para sessão atual.Instalar partir Github.Às vezes, você precisa instalar um pacote que ainda não está disponível na CRAN. Ou talvez o pacote esteja disponível na CRAN, mas você quer versão em desenvolvimento com novos recursos ainda não oferecidos na versão publicada mais estável da CRAN. Estes são frequentemente hospedados site github.com em um “repositório” de código gratuito e voltado para o público. Leia mais sobre Github na página manual Controle de versão e colaboração com Git e Github.Para baixar os pacotes R Github, você pode utilizar função p_load_gh() pacman, que instalará o pacote se necessário, e o carregará para utilização em sua sessão R atual. alternativas para instalar incluem utilização dos pacotes remotes ou devtools. Leia mais sobre todas funções pacman na documentação pacote.Para instalar partir Github, você precisa fornecer mais informações. Você tem que fornecer:identificação proprietário repositório GithubA identificação proprietário repositório GithubO nome repositório que contém o pacoteO nome repositório que contém o pacote(opcional) O nome “ramo” (o “branch” da versão de desenvolvimento específico) que você deseja baixar(opcional) O nome “ramo” (o “branch” da versão de desenvolvimento específico) que você deseja baixarNos exemplos abaixo, primeira palavra entre aspas representa ID Github proprietário repositório, após barra é o nome repositório (o nome pacote).Se você quiser instalar de um “branch” (versão) diferente da principal, adicione o nome “branch” após um “@”, após o nome repositório.Se não houver diferença entre versão Github e versão em seu computador, nenhuma ação será tomada. Você pode “forçar” uma reinstalação utilizando p_load_current_gh() com o argumento update = TRUE. Leia mais sobre pacman nesta vinheta onlineInstale partir de ZIP ou TARVocê poderia instalar um pacote de um endereço URL:Ou, faça o download dele para seu computador em um arquivo comprimido (“zipado”):Opção 1: usandoinstall_local() pacote remotesOpção 2: usando install.packages() R base, fornecendo o caminho arquivo comprimido e configurando os parâmetros type = \"source e repos = NULL.","code":"\n# Instala (se necessário) e os carrega para o uso\npacman::p_load(rio, tidyverse, here)\n# essa função disponível no R base instala um único pacote \ninstall.packages(\"tidyverse\")\n\n# install multiple packages with base R\ninstall.packages(c(\"tidyverse\", \"rio\", \"here\"))\n# com o R base, você pode carregar os pacotes dessa forma \nlibrary(tidyverse)\nlibrary(rio)\nlibrary(here)\n# instala/carrega o pacote epicontacts do seu repositório Github \np_load_gh(\"reconhub/epicontacts\")\n# instale o \"branch\"(ramo) \"timeline\" do pacte epicontacts do Github\np_load_gh(\"reconhub/epicontacts@timeline\")\npackageurl <- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\nremotes::install_local(\"~/Downloads/dplyr-master.zip\")\ninstall.packages(\"~/Downloads/dplyr-master.zip\", repos=NULL, type=\"source\")"},{"path":"basics.html","id":"sintaxe-do-código","chapter":"3 Introdução ao R","heading":"Sintaxe do código","text":"clarity handbook, functions sometimes preceded name package using :: symbol following way: package_name::function_name()package loaded session, explicit style necessary. One can just use function_name(). However writing package name useful function name common may exist multiple packages (e.g. plot()). Writing package name also load package already loaded.","code":"\n# Este comando usa o pacote \"rio\" e sua função   \"import()\" para importar uma base de dados.\nlinelist <- rio::import(\"linelist.xlsx\", which = \"Sheet1\")"},{"path":"basics.html","id":"auxílio-para-as-funções","chapter":"3 Introdução ao R","heading":"Auxílio para as funções","text":"Para maior clareza neste manual, funções são algumas vezes precedidas pelo nome de seu pacote utilizando o símbolo :: da seguinte forma: nome_do_pacote::nome_da_função()Uma vez carregado um pacote para uma sessão, este estilo explícito não é mais necessário. Pode-se simplesmente utilizar nome_da_função(). Entretanto, escrever o nome pacote é útil quando um nome de função é muito comum e pode existir em vários pacotes (por exemplo, plot()). Escrever o nome pacote também irá carregar o pacote se ele ainda não estiver carregado.","code":""},{"path":"basics.html","id":"atualizando-pacotes","chapter":"3 Introdução ao R","heading":"Atualizando pacotes","text":"Você pode atualizar os pacotes, reinstalando-os. Você também pode clicar botão verde “Atualizar” em seu painel de Pacotes RStudio para ver quais pacotes têm novas versões para instalar. Esteja ciente de que seu código antigo pode precisar ser atualizado se houver uma grande revisão de como uma função funciona!","code":""},{"path":"basics.html","id":"apagar-pacotes","chapter":"3 Introdução ao R","heading":"Apagar pacotes","text":"Utilize p_delete() de pacman, ou remove.packages() R base. Alternativamente, procure pasta que contém sua biblioteca e exclua manualmente pasta.","code":""},{"path":"basics.html","id":"dependências","chapter":"3 Introdução ao R","heading":"Dependências","text":"Os pacotes muitas vezes dependem de outros pacotes para funcionar. Estes são chamados de dependências. Se uma dependência falhar na instalação, então o pacote dependendo dela também pode falhar na instalação.Veja dependências de um pacote com p_depends(), e veja quais pacotes dependem dele com p_depends_reverse().","code":""},{"path":"basics.html","id":"funções-mascaradas","chapter":"3 Introdução ao R","heading":"Funções mascaradas","text":"Não é raro que dois ou mais pacotes contenham o mesmo nome de função. Por exemplo, o pacote dplyr tem uma função filter(), mas o pacote stats também. função padrão filter() depende da ordem em que estes pacotes são carregados primeiro na sessão R - última será o padrão para o comando filter().Você pode verificar ordem em seu painel Environment (Ambiente) R Studio - clique menu suspenso para Global Environment (“Ambiente Global”) e veja ordem dos pacotes. Funções de pacotes mais abaixo nessa lista suspensa mascararão funções com o mesmo nome em pacotes que aparecem mais altos na lista suspensa. Ao carregar um pacote pela primeira vez, R avisará console se estiver ocorrendo mascaramento, mas isto pode ser fácil de perder.Especifique o nome pacote comando. Por exemplo, utilize dplyr::filter()Reorganize ordem na qual os pacotes são carregados (por exemplo, dentro de p_load()), e inicie uma nova sessão R.","code":""},{"path":"basics.html","id":"desprender-descarregar","chapter":"3 Introdução ao R","heading":"Desprender / descarregar","text":"Para separar (descarregar) um pacote, use este comando, com o nome correto pacote e apenas um “dois pontos”. Note que isto pode não resolver o mascaramento.","code":"\ndetach(package:PACKAGE_NAME_HERE, unload=TRUE)"},{"path":"basics.html","id":"instalar-uma-versão-mais-antiga","chapter":"3 Introdução ao R","heading":"Instalar uma versão mais antiga","text":"Veja este guia para instalar uma versão mais antiga de um pacote em particular.","code":""},{"path":"basics.html","id":"pacotes-sugeridos","chapter":"3 Introdução ao R","heading":"Pacotes sugeridos","text":"Veja página em Pacotes sugeridos para uma listagem de pacotes que recomendamos para o dia--dia em epidemiologia.","code":""},{"path":"basics.html","id":"scripts","chapter":"3 Introdução ao R","heading":"3.8 Scripts","text":"Os scripts (que significa “roteiro” em inglês) são uma parte fundamental da programação. Eles são documentos que contêm seus comandos (por exemplo, funções para criar e modificar conjuntos de dados, visualizações de impressão, etc.). Você pode salvar um script e executá-lo novamente mais tarde. Há muitas vantagens em armazenar e executar seus comandos partir de um script (versus digitar comandos um um na “linha de comando” console R):Portabilidade - você pode compartilhar seu trabalho com outros enviando-lhes seus scriptsReprodutibilidade - para que você e outros saibam exatamente o que você fezControle de versão - para que você possa acompanhar mudanças feitas por você ou colegasComentando/anotando - para explicar seus colegas o que você tem feito","code":""},{"path":"basics.html","id":"comentando","chapter":"3 Introdução ao R","heading":"Comentando","text":"Em um script você também pode anotar (“fazer comentários”) ao longo seu código R. Comentar é útil para explicar si mesmo e aos outros leitores o que você está fazendo. Você pode adicionar um comentário digitando o símbolo “hashtag” (#) e escrevendo seu comentário depois dele. O texto comentado aparecerá em uma cor diferente da código R.Qualquer código escrito após o # não será executado. Portanto, colocar um # antes código também é uma maneira útil de bloquear temporariamente uma linha de código (“comentar fora”) se você não quiser apagá-lo). Você pode fazer isso em várias linhas ao mesmo tempo, selecionando-e pressionando Ctrl+Shift+c (Cmd+Shift+c Mac).Comente sobre o que você está fazendo e sobre por que você está fazendo.Divida seu código em seções lógicas…Acompanhe seu código com uma descrição passo passo em texto que você está fazendo (por exemplo, passos numerados)","code":"\n# Um comentário pode ser uma linha por si só\n# importar dados\nlinelist <- import(\"linelist_raw.xlsx\") %>%   # também pode ser após o código\n# filter(age > 50)                          # também pode ser usado para desativar uma linha de código\n  count()"},{"path":"basics.html","id":"estilo","chapter":"3 Introdução ao R","heading":"Estilo","text":"É importante estar consciente de seu estilo de codificação - especialmente se estiver trabalhando em equipe. Defendemos o uso tidyverse guia de estilo. Há também pacotes como styler e lintr que o ajudam se adequar este estilo.Alguns pontos muito básicos para tornar seu código legível para outros:* Ao nomear objetos, utilize apenas letras minúsculas, números e sublinhados _, por exemplo my_data.\n* Utilize espaços frequentes, inclusive ao redor dos operadores, por exemplo n = 1 e age_new <- age_old + 3","code":""},{"path":"basics.html","id":"exemplo-de-script","chapter":"3 Introdução ao R","heading":"Exemplo de Script","text":"Abaixo está um exemplo de um pequeno script R. Lembre-se, quanto melhor você explicar sucintamente seu código nos comentários, mais seus colegas vão gostar de você!","code":""},{"path":"basics.html","id":"r-markdown","chapter":"3 Introdução ao R","heading":"R markdown","text":"Um script R markdown é um tipo de script R qual o script em si resulta um documento de saída (PDF, Word, HTML, Powerpoint, etc.). Estas são ferramentas incrivelmente úteis e versáteis, freqüentemente usadas para criar relatórios dinâmicos e automatizados. Mesmo este website e manual são produzidos com um script R markdown!Vale pena notar que usuários iniciantes de R também podem usar R Markdown - não se intimidem! Para saber mais, consulte página manual nos documentos Relatórios com R Markdown.","code":""},{"path":"basics.html","id":"notebooks-r","chapter":"3 Introdução ao R","heading":"Notebooks R","text":"Não há diferença entre escrever em um Rmarkdown versus um caderno R. Entretanto, execução documento difere ligeiramente. Consulte este site para obter mais detalhes.","code":""},{"path":"basics.html","id":"shiny","chapter":"3 Introdução ao R","heading":"3.8.1 Shiny","text":"Os aplicativos/websites shiny estão contidas em um script, que deve ser chamado de app.R. Este arquivo tem três componentes:Uma interface de usuário (ui)Uma função de servidorUma chamada para função shinyApp.Veja página manual em Dashboards com Shiny, ou este tutorial online: Tutorial com shinyNos tempos mais antigos, o arquivo acima era dividido em dois arquivos (ui.R e server.R)","code":""},{"path":"basics.html","id":"código-dobrável","chapter":"3 Introdução ao R","heading":"Código dobrável","text":"Você pode colapsar/dobrar (inglês folding) porções de código para facilitar leitura de seu roteiro.Para isso, crie um cabeçalho de texto com #, escreva seu cabeçalho, e siga-o com pelo menos 4 traços (-), hashes (#) ou igual (=). Quando você tiver feito isto, uma pequena seta aparecerá na “sarjeta” à esquerda (pelo número da linha). Você pode clicar nesta seta e o código abaixo até o próximo cabeçalho cair e um ícone de seta dupla aparecerá em seu lugar.Para expandir o código, clique novamente na seta na sarjeta, ou ícone de duas fileiras. Há também atalhos de teclado como explicado na seção RStudio desta página.Ao criar cabeçalhos com #, você também ativará o Índice na parte inferior de seu script (veja abaixo) que você pode usar para navegar em seu script. Você pode criar subtítulos adicionando mais # símbolos, por exemplo, # para primário, # # para secundário e ### para terciário.Abaixo estão duas versões de um script de exemplo. À esquerda está o original com os cabeçalhos comentados. À direita, quatro traços foram escritos após cada cabeçalho, tornando-os colapsáveis. Dois deles foram colapsados, e você pode ver que Tabela de Conteúdos na parte inferior agora mostra cada seção.Outras áreas de código que são automaticamente elegíveis para fazer esse “dobramento” incluem regiões entre chaves { } tais como definições de funções ou blocos condicionais ( declarações “else”). Pode ler mais sobre dobramento de código RStudio site.","code":""},{"path":"basics.html","id":"diretório-de-trabalho","chapter":"3 Introdução ao R","heading":"3.9 Diretório de trabalho","text":"O diretório de trabalho é o local da pasta raiz usada por R para seu trabalho - onde R procura e salva arquivos por padrão. Por padrão, ele salvará novos arquivos e saídas para este local, e procurará por arquivos para importar (por exemplo, conjuntos de dados) também aqui.O diretório de trabalho aparece em texto cinza na parte superior painel RStudio Console. Você também pode imprimir o diretório de trabalho atual executando getwd() (deixe os parênteses vazios).","code":""},{"path":"basics.html","id":"abordagem-recomendada","chapter":"3 Introdução ao R","heading":"Abordagem recomendada","text":"Veja página sobre projetos R para obter detalhes sobre nossa abordagem recomendada para gerenciar seu diretório de trabalho.\nUma maneira comum, eficiente e sem problemas para gerenciar seu diretório de trabalho e caminhos de arquivos é combinar estes 3 elementos em um fluxo de trabalho orientado segundo projeto RUm projeto R para armazenar todos os seus arquivos (ver página em projetos R)O pacote para localização de arquivos (ver página em Importação e exportação)O pacote rio para arquivos de importação/exportação (ver página em Importação e exportação)","code":""},{"path":"basics.html","id":"definido-por-comando","chapter":"3 Introdução ao R","heading":"Definido por comando","text":"Até recentemente, muitas pessoas aprendendo R eram ensinadas começar seus roteiros com um comando setwd(). Em vez disso, considere utilização de um fluxo de trabalho orientados segundo projeto R e leia razões para não utilizar setwd(). Em resumo, seu trabalho torna-se específico para seu computador, os caminhos de arquivos utilizados para importar e exportar arquivos tornam-se ” frágeis”, e isso dificulta seriamente colaboração e utilização de seu código em qualquer outro computador. Existem alternativas fáceis!Como observado acima, embora não recomendamos esta abordagem na maioria das circunstâncias, você pode utilizar o comando setwd() com o caminho arquivo da pasta desejada escrito entre aspas, como exemplo abaixo:PERIGO: Definir um diretório de trabalho com setwd() pode ser “frágil” se o caminho arquivo específico para um computador. Em vez disso, use caminhos de arquivo relativos um diretório raiz R Project (com o pacote ).","code":"\nsetwd(\"C:/Documents/R Files/My analysis\")"},{"path":"basics.html","id":"definindo-manualmente","chapter":"3 Introdução ao R","heading":"Definindo manualmente","text":"Para definir o diretório de trabalho manualmente (que seria o equivalente de apontar e clicar de setwd()), clique menu suspenso Sessão (Session) e vá para “Definir diretório de trabalho” (Set Workig Directory) e depois “Escolher diretório” (Choose Directory). Isso definirá o diretório de trabalho para essa sessão específica R. Nota: se estiver usando esta abordagem, você terá que fazer isso manualmente toda vez que abrir o RStudio.","code":""},{"path":"basics.html","id":"dentro-de-um-projeto-r","chapter":"3 Introdução ao R","heading":"Dentro de um projeto R","text":"Se estiver usando um projeto R, o diretório de trabalho será padronizado para pasta raiz projeto R que contém o arquivo “.rproj”. Isso se aplicará se você abrir o RStudio clicando em abrir o Projeto R (o arquivo com extensão “.rproj”).","code":""},{"path":"basics.html","id":"diretório-de-trabalho-em-r-markdown","chapter":"3 Introdução ao R","heading":"Diretório de trabalho em R markdown","text":"Em um script R markdown, o diretório de trabalho padrão é pasta na qual o arquivo Rmarkdown (.Rmd) é salvo. Se estiver usando um projeto R e um pacote , isso não se aplica e o diretório de trabalho será () conforme explicado na página projetos R.Se você quiser alterar o diretório de trabalho de um R markdown autônomo (não em um projeto R), se você usar setwd(), isso se aplicará apenas esse trecho de código específico. Para fazer alteração para todos os trechos de código em um markdown R, edite o trecho de configuração para adicionar o parâmetro root.dir =, como abaixo:É muito mais fácil usar apenas o markdown R dentro de um projeto R e usar o pacote .","code":"\nknitr::opts_knit$set(root.dir = 'desired/directorypath')"},{"path":"basics.html","id":"fornecendo-o-caminho-dos-arquivos","chapter":"3 Introdução ao R","heading":"Fornecendo o caminho dos arquivos","text":"Talvez fonte mais comum de frustração para um iniciante em R (pelo menos em uma máquina Windows) seja digitar um caminho de arquivo para importar ou exportar dados. Há uma explicação completa de como melhor inserir caminhos de arquivo na página Importar e exportar, mas aqui estão alguns pontos-chave:Caminhos quebradosAbaixo está um exemplo de um caminho de arquivo “absoluto” ou “endereço completo”. Eles provavelmente quebrarão se forem usados por outro computador. Uma exceção é se você estiver usando uma unidade compartilhada/de rede.Direção da barraSe digitar um caminho de arquivo, observe direção das barras. Use barras normais (/) para separar os componentes (“data/provincial.csv”). Para usuários Windows, maneira padrão de exibição dos caminhos de arquivo é com barras invertidas (ou contra-barra) (\\) - portanto, você precisará alterar direção de cada barra. Se você usar o pacote conforme descrito na página projetos R, direção da barra não será um problema.Caminhos relativosGeralmente, recomendamos fornecer caminhos de arquivo “relativos” - ou seja, o caminho relativo à raiz seu projeto R. Você pode fazer isso usando o pacote conforme explicado na página projetos R. Um caminho de arquivo relativo pode ser assim:Mesmo usando caminhos de arquivo relativos em um projeto R, você ainda pode usar caminhos absolutos para importar/exportar dados fora seu projeto R.","code":"C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  \n# Import csv linelist from the data/linelist/clean/ sub-folders of an R project\nlinelist <- import(here(\"data\", \"clean\", \"linelists\", \"marin_country.csv\"))"},{"path":"basics.html","id":"objects","chapter":"3 Introdução ao R","heading":"3.10 Objetos","text":"Tudo em R é um objeto, e R é uma linguagem “orientada objetos”. Estas seções explicarão:Como criar objetos (<-)Tipos de objetos (por exemplo, quadros de dados, vetores..)Como acessar subpartes de objetos (por exemplo, variáveis em um conjunto de dados)Classes de objetos (por exemplo, numérico, lógico, inteiro, duplo, caractere, fator)","code":""},{"path":"basics.html","id":"tudo-é-um-objeto","chapter":"3 Introdução ao R","heading":"Tudo é um objeto","text":"Esta seção é adaptada projeto R4Epis.\nTudo o que você armazena R - conjuntos de dados, variáveis, uma lista de nomes de vilarejos, um número total da população, até saídas como gráficos - são objetos que recebem um nome e podem ser referenciados em comandos posteriores.Um objeto existe quando você atribui um valor ele (consulte seção de atribuição abaixo). Quando lhe é atribuído um valor, o objeto aparece Ambiente (Environment) (veja o painel superior direito RStudio). Ele pode então ser operado, manipulado, alterado e redefinido.","code":""},{"path":"basics.html","id":"definindo-objetos--","chapter":"3 Introdução ao R","heading":"Definindo objetos (<-)","text":"Crie objetos atribuindo-lhes um valor com o operador <-.\nVocê pode pensar operador de atribuição <- como palavras “é definido como”. Os comandos de atribuição geralmente seguem uma ordem padrão:nome_do_objeto <- valor (ou processo/cálculo que produz um valor)Por exemplo, você pode querer registrar semana relatório epidemiológico atual como um objeto para referência código posterior. Neste exemplo, o objeto semana_atual é criado quando é atribuído o valor \"2018-W10\" (aspas fazem disso um valor de caractere). O objeto semana_atual aparecerá painel RStudio Environment (canto superior direito) e poderá ser referenciado em comandos posteriores.Veja os comandos R e sua saída nas caixas abaixo.NOTA: Observe que o [1] na saída console R está simplesmente indicando que você está visualizando o primeiro item da saídaCUIDADO: O valor de um objeto pode ser sobrescrito qualquer momento executando um comando de atribuição para redefinir seu valor. Assim, ordem dos comandos executados é muito importante..O comando seguir irá redefinir o valor de semana_atual:Sinal de igual =Você também verá sinais de igual código R:Um sinal de igual duplo == entre dois objetos ou valores faz uma pergunta lógica: “isso é igual isso?”.Você também verá sinais de igual dentro de funções usadas para especificar valores de argumentos de função (leia sobre isso nas seções abaixo), por exemplo max(age, na.rm = TRUE).Você pode usar um único sinal de igual = lugar de <- para criar e definir objetos, mas isso é desencorajado. Você pode ler sobre por que isso é desencorajado aqui.Bases de dadosOs conjuntos de dados também são objetos (geralmente “dataframes”) e devem receber nomes quando são importados. código abaixo, o objeto linelist é criado e atribuído o valor de um arquivo CSV importado com o pacote rio e sua função import().Você pode ler mais sobre como importar e exportar conjuntos de dados na seção Importar e exportar(#importing.CUIDADO: Uma nota rápida sobre nomeação de objetos:Os nomes dos objetos não devem conter espaços, mas você deve usar sublinhado (_) ou um ponto (.) em vez de um espaço.Os nomes dos objetos diferenciam maiúsculas de minúsculas (o que significa que Dataset_A é diferente de dataset_A).Os nomes dos objetos devem começar com uma letra (não pode começar com um número como 1, 2 ou 3).Saídas (Outputs)Saídas como tabelas e gráficos fornecem um exemplo de como saídas podem ser salvas como objetos ou apenas exibidas (“printadas” console) sem serem salvas. Uma tabulação cruzada de gênero e resultado usando função R base table() pode ser exibida diretamente console R (sem ser salva).Mas mesma tabela pode ser salva como um objeto nomeado. Então, opcionalmente, pode ser printado.ColunasAs colunas em um conjunto de dados também são objetos e podem ser definidas, sobrescritas e criadas conforme descrito abaixo na seção Colunas.Você pode usar o operador de atribuição R base para criar uma nova coluna. Abaixo, nova coluna bmi (IMC - Índice de Massa Corporal, inglês Body Mass Index) é criada, e para cada linha o novo valor é resultado de uma operação matemática sobre o valor da linha nas colunas wt_kg e ht_cm.entanto, neste manual, enfatizamos uma abordagem diferente para definir colunas, que usa função mutate() pacote dplyr e piping com o operador pipe (%>%). sintaxe é mais fácil de ler e há outras vantagens explicadas na página em Limpeza de dados e principais funções. Você pode ler mais sobre tubulação na seção Tubulação abaixo.","code":"\nsemana_atual <- \"2018-W10\"   # esse comando cria o objeto semana_atual ao atribuir a ele um valor \nsemana_atual                # esse comento exibe (\"printa\") o valor atual do objeto semana_atual no Console ## [1] \"2018-W10\"\nsemana_atual <- \"2018-W51\"   # atribui um NOVO valor para o objeto semana_atual \nsemana_atual                # Exibe (\"printa\") o valor atual do objeto semana_atual no console ## [1] \"2018-W51\"\n# o objeto linelist é criado e a ele é atribuído o valor do arquivo CSV importado\nlinelist <- import(\"my_linelist.csv\")\n# exibe apenas no console R\ntable(linelist$gender, linelist$outcome)##    \n##     Death Recover\n##   f  1227     953\n##   m  1228     950\n# salvar\ngen_out_table <- table(linelist$gender, linelist$outcome)\n\n# printar\ngen_out_table##    \n##     Death Recover\n##   f  1227     953\n##   m  1228     950\n# criar uma nova colna bmi (que é o valor de IMC) usando a sintaxe do R base\nlinelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2\n# criar uma nova colna bmi (que é o valor de IMC) usando a sintaxe do dplyr\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)"},{"path":"basics.html","id":"estrutura-de-um-objeto","chapter":"3 Introdução ao R","heading":"Estrutura de um objeto","text":"Os objetos podem ser um único dado (por exemplo, meu_numero <- 24) ou podem consistir em dados estruturados.O gráfico abaixo é emprestado de este tutorial R online. Ele mostra algumas estruturas de dados comuns e seus nomes. Não estão incluídos nesta imagem os dados espaciais, que são discutidos na página Noções básicas de GIS.Em epidemiologia (e particularmente epidemiologia de campo), você encontrará mais comumente dataframes e vetores:Observe que para criar um vetor que “independente” (não faz parte de um data frame) função c() é usada para combinar os diferentes elementos. Por exemplo, se estiver criando um vetor de cores para uma paleta de cores de um gráfico: vector_de_cores <- c(\"blue\", \"red2\", \"orange\", \"grey\")","code":""},{"path":"basics.html","id":"classe-de-objetos","chapter":"3 Introdução ao R","heading":"Classe de objetos","text":"Todos os objetos armazenados em R possuem uma classe que informa ao R como lidar com o objeto. Existem muitas classes possíveis, mas mais comuns incluem:Você pode testar classe de um objeto fornecendo seu nome para função class(). Nota: você pode fazer referência uma coluna específica dentro de um conjunto de dados utilizando notação $ para separar o nome conjunto de dados e o nome da coluna.Às vezes, uma coluna será convertida automaticamente para uma classe diferente pelo R. Cuidado com isso! Por exemplo, se você tiver um vetor ou coluna de números, mas um valor de caractere inserido… coluna inteira mudará para caractere de classe.Um exemplo comum disso é quando se manipula um data frame para exibir uma tabela - se você fizer uma linha total e tentar colar/colar porcentagens na mesma célula dos números (por exemplo, 23 (40%)), toda coluna numérica acima será convertida em caractere e não poderá mais ser utilizada para cálculos matemáticos.** Algumas vezes, será necessário converter objetos ou colunas em outra classe.**Da mesma forma, existem funções R base para verificar se um objeto é de uma classe específica, como .numeric(), .character(), .double(), .factor(), .integer()Aqui está mais material -line sobre classes e estruturas de dados em R.","code":"\nclass(linelist)         # a classe deve ser uma data frame ou tibble## [1] \"data.frame\"\nclass(linelist$age)     # classe deve ser numérica ## [1] \"numeric\"\nclass(linelist$gender)  # classe deve ser caractere ## [1] \"character\"\nnum_vector <- c(1,2,3,4,5) # define um vetor só de números\nclass(num_vector)          # este vetor é da classe numérico## [1] \"numeric\"\nnum_vector[3] <- \"three\"   # converte o terceiro elemento para um caractere\nclass(num_vector)          # o vetor agora é classe caractere## [1] \"character\""},{"path":"basics.html","id":"colunasvariáveis","chapter":"3 Introdução ao R","heading":"Colunas/Variáveis ($)","text":"Uma coluna em um data frame é tecnicamente um “vetor” (ver tabela acima) - uma série de valores que devem ser todos da mesma classe (tanto caracter, numérico, lógico, etc.).Um vetor pode existir independentemente de um data frame, por exemplo, um vetor de nomes de colunas que você deseja incluir como variáveis explicativas em um modelo. Para criar um vetor independente, utilize função c() como abaixo:colunas em uma data frame também são vetores e podem ser chamadas, referenciadas, extraídas ou criadas utilizando o símbolo $. O símbolo $ liga o nome da coluna ao nome de sua moldura de dados. Neste manual, tentamos utilizar palavra “coluna” em vez de “variável”.Ao digitar o nome data frame seguido de $ você verá também um menu suspenso de todas colunas data frame. Você pode percorrê-las usando sua tecla de seta, selecionar uma com sua tecla Enter e evitar erros ortográficos!DICA AVANÇADA: Alguns objetos mais complexos (por exemplo, uma lista, ou um objeto ‘epicontacts’) podem ter múltiplos níveis que podem ser acessados através de múltiplos sinais de dólar. Por exemplo epicontacts$linelist$date_onset","code":"\n# define o vetor independente de entradas dp tipo caractere \nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n# printa os valores desse vetor nomeado  \nexplanatory_vars## [1] \"gender\" \"fever\"  \"chills\" \"cough\"  \"aches\"  \"vomit\"\n# Obter o comprimento do vetor age\nlength(linelist$age) # (age é uma coluna no data frame linelist)"},{"path":"basics.html","id":"accessarindexar-com-colchetes","chapter":"3 Introdução ao R","heading":"Accessar/indexar com colchetes ([ ])","text":"Talvez seja necessário visualizar partes de objetos, também chamadas de “indexação”, o que muitas vezes é feito utilizando os colchetes [ ]. Utilizar $ em um data frame para acessar uma coluna é também um tipo de indexação.Os colchetes também funcionam para retornar partes específicas de uma saída retornada, tais como saída de uma função summary():Os colchetes também trabalham em data frames para visualizar linhas e colunas específicas. Você pode fazer isso utilizando sintaxe dataframe[linhas, colunas]:Observe que você também pode alcançar indexação de linha/coluna acima em dataframes e tibbles utilizando dplyr sintaxe (funções filter() para linhas, e select() para colunas). Leia mais sobre estas funções centrais na página Dados de limpeza e principais funções.Para filtrar com base “número da linha”, você pode utilizar função dplyr row_number() com parênteses abertos como parte de uma instrução de filtragem lógica. Muitas vezes você utilizará o operador %% e uma faixa de números como parte dessa declaração lógica, como mostrado abaixo. Para ver primeiras N fileiras , você também pode utilizar função especial dplyr head().Ao indexar um objeto de classe lista, parênteses simples sempre retornam coma classe lista, mesmo que apenas um único objeto seja retornado. Entretanto, colchetes duplos podem ser usados para acessar um único elemento e retornar uma classe diferente da lista.\nOs parênteses também podem ser escritos um após o outro, como demonstrado abaixo.Esta explicação visual da indexação de listas, com pimenteiros é bem-humorada e útil.Veja como fica lista quando exibida console. Veja como há dois elementos nomeados:hospitals,, um vetor de caracteres.addresses, um quadro de dados de endereçosAgora nos extraímos usando vários métodos:","code":"\nmy_vector <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")  # define o vetor\nmy_vector[5]                                  # printa o quinto elemento## [1] \"e\"\n# Todo o resumo\nsummary(linelist$age)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.07   23.00   84.00      86\n# Apenas o segundo elemento,sem nome, usando colchetes simples\nsummary(linelist$age)[2]## 1st Qu. \n##       6\n# Apenas o segundo elemento,sem nome, usando colchetes duplos\n\n# Extrais um elemento pelo nome, sem mostrar o nome aparecer no console\nsummary(linelist$age)[[\"Median\"]]## [1] 13\n# Visualizar uma linha específica (2) de uma base de dados, com todas as colunas (não esqueça a vírgula!) \nlinelist[2,]\n\n# Vert todas as linhas, mas só uma coluna\nlinelist[, \"date_onset\"]\n\n# Ver valores da linha 2, e as colunas 5 a 10\nlinelist[2, 5:10] \n\n# VVer valores da linha 2, e as colunas 5 a 10 e a 18\nlinelist[2, c(5:10, 18)] \n\n# Ver valores da linha 2 a 20 , e colunas específicas\nlinelist[2:20, c(\"date_onset\", \"outcome\", \"age\")]\n\n#Ver linhas e colunas baseado em critérios\n# *** Noque que o dataframe precira ainda ser nomeado no critério!  \nlinelist[linelist$age > 25 , c(\"date_onset\", \"outcome\", \"age\")]\n\n# Use View() para ver as saídas no Painel Visualizador do RStudio Viewer (mais fácil de ler)\n# *** Note o  \"V\" maúsculo na função View() \nView(linelist[2:20, \"date_onset\"])\n\n# Salve como um novo objeto\nnew_table <- linelist[2:20, c(\"date_onset\")] \n# Visualizar as primeiras 100 linhas\nlinelist %>% head(100)\n\n# Show row 5 only\nlinelist %>% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns (note no quotes necessary on column names)\nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)\n# define uma lista demo\nmy_list <- list(\n  # Primeiro elemento na lista é um vetor do tipo caractere \n  hospitals = c(\"Central\", \"Empire\", \"Santa Anna\"),\n  \n  # segundo elemento na lista é um dataframe com endereços  \n  addresses   = data.frame(\n    street = c(\"145 Medical Way\", \"1048 Brown Ave\", \"999 El Camino\"),\n    city   = c(\"Andover\", \"Hamilton\", \"El Paso\")\n    )\n  )\nmy_list## $hospitals\n## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\n## \n## $addresses\n##            street     city\n## 1 145 Medical Way  Andover\n## 2  1048 Brown Ave Hamilton\n## 3   999 El Camino  El Paso\nmy_list[1] # esse retorna o elemanto da classe \"lista\" - o nome do elemento ainda é exibido ## $hospitals\n## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[1]] # este retorna apenas o vetor de caracter (sem nome) ## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[\"hospitals\"]] # você também pode indexar pelo nome do elemento da lista  ## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[1]][3] # Isto retorna o terceiro elemento do vetor de caracteres \"hospitals\" ## [1] \"Santa Anna\"\nmy_list[[2]][1] # Isto retorna a primeira coluna  (\"street\") da data frame de endereços##            street\n## 1 145 Medical Way\n## 2  1048 Brown Ave\n## 3   999 El Camino"},{"path":"basics.html","id":"remover-objetos","chapter":"3 Introdução ao R","heading":"Remover objetos","text":"Você pode remover objetos individuais de seu ambiente R colocando o nome na função rm() (sem aspas):Você pode reomver todos os objetos (limpar o ambiente de trabalho) ao executar:","code":"\nrm(object_name)\nrm(list = ls(all = TRUE))"},{"path":"basics.html","id":"piping-encadeamento","chapter":"3 Introdução ao R","heading":"3.11 Piping (Encadeamento, %>%)","text":"Duas abordagens gerais para trabalhar com objetos são:Pipes/tidyverse - pipes send object function function - emphasis action, objectDefinir objetos intermediários - um objeto é redefinido repetidamente - ênfase está objeto.","code":""},{"path":"basics.html","id":"pipes","chapter":"3 Introdução ao R","heading":"Pipes","text":"Explicado de forma simples, o operador pipe (%>%) passa uma saída intermediária de uma função para próxima.\nVocê pode pensar nisso como dizendo “então”. Muitas funções podem ser ligadas com %>%.Piping enfatiza uma seqüência de ações, não o objeto sobre o qual ações estão sendo realizadasPipes são melhores quando uma seqüência de ações deve ser executada em um único objeto.Os pipes vêm pacote magrittr, que é automaticamente incluído nos pacotes dplyr e tidyverseOs pipes podem tornar o código mais limpo e fácil de ler, mais intuitivoLeia mais sobre esta abordagem tidyverse guia de estiloAqui está um exemplo falso para comparação, usando funções fictícias para “assar um bolo”. Primeiro, o método pipe:Aqui está outro link descrevendo utilidade dos pipes.O pipe não é uma função R base. Para utilizar o pipe, o pacote magrittr deve ser instalado e carregado (isto é normalmente feito carregando os pacotes tidyverse ou dplyr que o inclui). Você pode ler mais sobre pipe na documentação magrittr.Observe que, assim como outros comandos R, os pipes podem ser utilizados apenas para exibir o resultado, ou para salvar/reservar um objeto, dependendo se o operador de atribuição <- está envolvido. Veja os dois abaixo:%<>%\nEste é um “tubo de atribuição” pacote magrittr, que encadeia um objeto para frente e também re-define o objeto. Deve ser o primeiro operador pipe da cadeia. É um “atalho”. Os dois comandos abaixo são equivalentes:","code":"\n# Um exemplo falso de como assar um bolo usando a sintaxe do pipe \n\ncake <- flour %>%       #para definir o bolo, comece com farinha, e então ...\n  add(eggs) %>%   # adicione ovos\n  add(oil) %>%    # adicione óleo\n  add(water) %>%  # adicione água\n  mix_together(         # misture\n    utensil = spoon,\n    minutes = 2) %>%    \n  bake(degrees = 350,   # asse\n       system = \"fahrenheit\",\n       minutes = 35) %>%  \n  let_cool()            # deixe esfriar\n# Criar ou sobrescrever um objeto, definindo como contagens agregadas por faixa-etária  (não \"printado\")\nlinelist_summary <- linelist %>% \n  count(age_cat)\n# Printa a tabela de contagens no console, mas nao a salva  \nlinelist %>% \n  count(age_cat)##   age_cat    n\n## 1     0-4 1095\n## 2     5-9 1095\n## 3   10-14  941\n## 4   15-19  743\n## 5   20-29 1073\n## 6   30-49  754\n## 7   50-69   95\n## 8     70+    6\n## 9    <NA>   86\nlinelist <- linelist %>%\n  filter(age > 50)\n\nlinelist %<>% filter(age > 50)"},{"path":"basics.html","id":"definir-objetos-intermediários","chapter":"3 Introdução ao R","heading":"Definir objetos intermediários","text":"Esta abordagem para mudar objetos/dataframes pode ser melhor se:Você precisa manipular vários objetos…Há etapas intermediárias que são significativas e merecem nomes de objetos separadosRiscos:Criar novos objetos para cada etapa significa criar muitos objetos. Se você usar o errado, talvez não se dê conta disso!Nomear todos os objetos pode ser confuso…Os erros podem não ser facilmente detectáveisOu nomear cada objeto intermediário, ou sobrescrever o original, ou combinar todas funções em conjunto. Todos vêm com seus próprios riscos.Abaixo está o mesmo exemplo falso de “bolo” como acima, mas usando este estilo:Combine todas funções em uma só - isso dificulta leitura):","code":"\n# um exemplo falso de como assar um bolo usado este método (definindo objetos intermediários) \nbatter_1 <- left_join(flour, eggs)\nbatter_2 <- left_join(batter_1, oil)\nbatter_3 <- left_join(batter_2, water)\n\nbatter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)\n\ncake <- bake(batter_4, degrees = 350, system = \"fahrenheit\", minutes = 35)\n\ncake <- let_cool(cake)\n# um exemplo de combinação/aninhamento de múltiplas funções  juntas - difícil de ler\ncake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = \"fahrenheit\", minutes = 35))"},{"path":"basics.html","id":"operadores","chapter":"3 Introdução ao R","heading":"3.12 Principais operadores e funções","text":"Esta seção detalha os operadores em R, como por exemplo:Operadores de definiçãoOperadores relacionais (menos que, igual …)Operadores lógicos (e, ou…)Lidando com valores faltantes…Operadores matemáticos e funções (+/-, >, sum(), median(), …)O operador %%","code":""},{"path":"basics.html","id":"operador-de-atribuição","chapter":"3 Introdução ao R","heading":"Operador de atribuição","text":"<-O operador de atribuição básica em R é <-. De tal forma que nome_objeto <- valor.\nEste operador de atribuição também pode ser escrito como =. Aconselhamos o uso de <- para uso geral em R.\nAconselhamos também o uso de <- para uso geral em R. Aconselhamos também o uso de espaços em torno de tais operadores, para facilitar leitura.<<-Se você estiver Escrevendo funções, ou utilizando R de forma interativa com scripts de origem, então você pode precisar utilizar este operador de atribuição <<- (R base). Este operador é utilizado para definir um objeto em um ambiente R ‘pai’ superior. Veja isto referência -line.%<>%Este é um “pipe de atribuição” pacote magrittr, que canaliza um objeto para frente e também re-define o objeto. Deve ser o primeiro operador pipe da cadeia. É abreviação, como mostrado abaixo em dois exemplos equivalentes:O código acima é equivalente ao abaixo:%<+%Isso é usado para adicionar dados árvores filogenéticas com o pacote ggtree. Veja página em Árvores Filogenéticas ou este livro de recursos online.","code":"\nlinelist <- linelist %>% \n  mutate(age_months = age_years * 12)\nlinelist %<>% mutate(age_months = age_years * 12)"},{"path":"basics.html","id":"operadores-relacionais-e-lógicos","chapter":"3 Introdução ao R","heading":"Operadores relacionais e lógicos","text":"Os operadores relacionais comparam valores e são freqüentemente utilizados na definição de novas variáveis e subconjuntos de conjuntos de dados. Aqui estão os operadores relacionais comuns em R:Operadores lógicos, como e , geralmente são usados para conectar operadores relacionais e criar critérios mais complicados. Instruções complexas podem exigir parênteses ( ) para agrupamento e ordem de aplicação.Por exemplo, abaixo, temos uma linelist com duas variáveis que queremos utilizar para criar nossa definição de caso, hep_e_rdt, um resultado de teste e other_cases_in_hh, que nos dirá se há outros casos na casa. O comando abaixo utiliza função case_when() para criar nova variável case_def de tal forma que:Note R case-sensitive, “Positive” different “positive”…","code":"\nlinelist_cleaned <- linelist %>%\n  mutate(case_def = case_when(\n    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,\n    rdt_result == \"Positive\"                                 ~ \"Confirmed\",\n    rdt_result != \"Positive\" & other_cases_in_home == \"Yes\"  ~ \"Probable\",\n    TRUE                                                     ~ \"Suspected\"\n  ))"},{"path":"basics.html","id":"valores-faltantes","chapter":"3 Introdução ao R","heading":"Valores faltantes","text":"Em R, os valores ausentes são representados pelo valor especial NA (um valor “reservado”) (letras maiúsculas N e - não entre aspas). Se você importar dados que registram dados ausentes de outra maneira (por exemplo, 99, “Missing” ou .), convém recodificar esses valores para NA. Como fazer isso é abordado na página Importação e exportação.Para testar se um valor é NA, use função especial .na(), que retorna TRUE ou FALSE.Leia mais sobre valores ausentes, infinitos, NULL e impossíveis na página em Campos em branco/faltantes. Saiba como converter valores ausentes ao importar dados na página em Importação e exportação.","code":"\nrdt_result <- c(\"Positive\", \"Suspected\", \"Positive\", NA)   # dois casos positivos, um suspeito e um desconhecido \nis.na(rdt_result)  # Testa se o valor de  rdt_result é NA## [1] FALSE FALSE FALSE  TRUE"},{"path":"basics.html","id":"matemática-e-estatística","chapter":"3 Introdução ao R","heading":"Matemática e estatística","text":"Todos os operadores e funções nesta página estão disponíveis automaticamente usando o pacote R base.","code":""},{"path":"basics.html","id":"operadores-mmatemáticos","chapter":"3 Introdução ao R","heading":"Operadores mmatemáticos","text":"Estes são frequentemente usados para realizar adição, divisão, para criar novas colunas, etc. Abaixo estão os operadores matemáticos comuns em R. Colocar ou não os espaços ao redor dos operadores não é importante.","code":""},{"path":"basics.html","id":"funções-matemáticas","chapter":"3 Introdução ao R","heading":"Funções matemáticas","text":"Nota: para round() o digits = especifica o número de casas decimais colocadas. Use signif() para arredondar para um número de algarismos significativos.","code":""},{"path":"basics.html","id":"notação-científica","chapter":"3 Introdução ao R","heading":"Notação científica","text":"probabilidade de notação científica ser usada depende valor da opção scipen.Da documentação de ?options: scipen é uma penalidade ser aplicada ao decidir imprimir valores numéricos em notação fixa ou exponencial. Os valores positivos tendem para notação fixa e os negativos para notação científica: notação fixa será preferida, menos que seja mais que os dígitos ‘scipen’ mais largos.Se estiver definido para um número baixo (por exemplo, 0), ele estará sempre “ligado”. Para “desativar” notação científica em sua sessão R, defina-como um número muito alto, por exemplo:","code":"\n# desligar a notação científica\noptions(scipen=999)"},{"path":"basics.html","id":"arredondando","chapter":"3 Introdução ao R","heading":"Arredondando","text":"PERIGO: função round() usa “arredondamento banqueiro” que arredonda de .5 somente se o número superior par. Use round_half_up() janitor para arredondar consistentemente metades para o número inteiro mais próximo. Veja esta explicação","code":"\n# use a função de arredondamento adequanda para o seu trabalho \nround(c(2.5, 3.5))## [1] 2 4\njanitor::round_half_up(c(2.5, 3.5))## [1] 3 4"},{"path":"basics.html","id":"funções-estatísticas","chapter":"3 Introdução ao R","heading":"Funções estatísticas","text":"CUIDADO: funções abaixo incluirão, por padrão, valores ausentes nos cálculos. Valores ausentes resultarão em uma saída de NA, menos que o argumento na.rm = TRUE seja especificado. Isso pode ser escrito de forma abreviada como na.rm = T.Notas:* quantile(): x é o vetor numérico ser examinado e probs = é um vetor numérico com probabilidades entre 0 e 1,0, por exemplo, c(0.5 , 0.8 , 0,.85)** summary(): fornece um resumo em um vetor numérico incluindo média, mediana e percentis comunsPERIGO: Ao fornecer um vetor de números para uma das funções acima, certifique-se de concatenar os números dentro de c() .","code":"\n# Se fornecer números brutos para uma função, concatene-os antes com c()\nmean(1, 6, 12, 10, 5, 0)    # !!! INCORRETO !!!  ## [1] 1\nmean(c(1, 6, 12, 10, 5, 0)) # CORRETO## [1] 5.666667"},{"path":"basics.html","id":"outras-funções-úteis","chapter":"3 Introdução ao R","heading":"Outras funções úteis","text":"","code":""},{"path":"basics.html","id":"in","chapter":"3 Introdução ao R","heading":"%in%","text":"Um operador muito útil para combinar valores e avaliar rapidamente se um valor está dentro de um vetor ou dataframe.Para perguntar se um valor não está em (%%) é um vetor, coloque um ponto de exclamação (!) na frente da instrução lógica:%% é muito útil ao usar função dplyr case_when(). Você pode definir um vetor anteriormente e depois referenciá-lo. Por exemplo:Note: want detect partial string, perhaps using str_detect() stringr, accept character vector like c(\"1\", \"Yes\", \"yes\", \"y\"). Instead, must given regular expression - one condensed string bars, “1|Yes|yes|y”. example, str_detect(hospitalized, \"1|Yes|yes|y\"). See page Caracteres e strings information.can convert character vector named regular expression command:","code":"\nmeu_vetor <- c(\"a\", \"b\", \"c\", \"d\")\n\"a\" %in% meu_vetor## [1] TRUE\n\"h\" %in% meu_vetor## [1] FALSE\n# para negar, coloque a exclamação na frente \n!\"a\" %in% meu_vetor## [1] FALSE\n!\"h\" %in% meu_vetor## [1] TRUE\naffirmative <- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\n\nlinelist <- linelist %>% \n  mutate(child_hospitaled = case_when(\n    hospitalized %in% affirmative & age < 18 ~ \"Hospitalized Child\",\n    TRUE                                      ~ \"Not\"))\naffirmative <- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\naffirmative## [1] \"1\"   \"Yes\" \"YES\" \"yes\" \"y\"   \"Y\"   \"oui\" \"Oui\" \"Si\"\n# condensar\naffirmative_str_search <- paste0(affirmative, collapse = \"|\")  # opção com R base\naffirmative_str_search <- str_c(affirmative, collapse = \"|\")   # opção co pacote stringr\n\naffirmative_str_search## [1] \"1|Yes|YES|yes|y|Y|oui|Oui|Si\""},{"path":"basics.html","id":"erros-avisos","chapter":"3 Introdução ao R","heading":"3.13 Erros & avisos","text":"Esta seção explica:diferença entre erros e avisosDicas gerais de sintaxe para escrever código RAjudas para o código.Erros e avisos comuns e dicas de solução de problemas podem ser encontrados na página em Erros e ajuda.","code":""},{"path":"basics.html","id":"erros-versus-avisos","chapter":"3 Introdução ao R","heading":"Erros versus Avisos","text":"Quando um comando é executado, o Console R pode mostrar mensagens de aviso ou erro em texto vermelho.Um aviso significa que o R concluiu seu comando, mas teve que executar etapas adicionais ou produziu uma saída incomum da qual você deve estar ciente.Um aviso significa que o R concluiu seu comando, mas teve que executar etapas adicionais ou produziu uma saída incomum da qual você deve estar ciente.Um erro significa que o R não conseguiu completar seu comando.Um erro significa que o R não conseguiu completar seu comando.Procurar pistas:mensagem de erro/aviso geralmente inclui um número de linha para o problema.mensagem de erro/aviso geralmente inclui um número de linha para o problema.Se um objeto “é desconhecido” ou “não encontrado”, talvez você o tenha escrito incorretamente, esquecido de chamar um pacote com library() ou esquecido de executar novamente seu script após fazer alterações.Se um objeto “é desconhecido” ou “não encontrado”, talvez você o tenha escrito incorretamente, esquecido de chamar um pacote com library() ou esquecido de executar novamente seu script após fazer alterações.Se tudo mais falhar, copie mensagem de erro Google junto com alguns termos-chave: é provável que alguém já tenha trabalhado com isso!","code":""},{"path":"basics.html","id":"dicas-gerais-de-sintaxe","chapter":"3 Introdução ao R","heading":"Dicas gerais de sintaxe","text":"Algumas coisas para lembrar ao escrever comandos em R, para evitar erros e avisos:Sempre feche os parênteses - dica: conte o número de abertura “(” e fechamento de parênteses “)” para cada pedaço de códigoEvite espaços em nomes de colunas e objetos. Use sublinhado ( _ ) ou pontos ( . )Acompanhe e lembre-se de separar os argumentos de uma função com vírgulasR diferencia maiúsculas de minúsculas, o que significa que Variable_A é diferente de variable_A","code":""},{"path":"basics.html","id":"ajudas-de-código","chapter":"3 Introdução ao R","heading":"Ajudas de código","text":"Qualquer script (RMarkdown ou outro) dará pistas quando você cometer um erro. Por exemplo, se você esqueceu de escrever uma vírgula onde necessário, ou de fechar um parêntese, o RStudio irá levantar uma bandeira nessa linha, lado direito script, para avisá-lo.","code":""},{"path":"transition-to-R.html","id":"transition-to-R","chapter":"4 Transição para o R","heading":"4 Transição para o R","text":"Abaixo, fornecemos alguns conselhos e recursos se você estiver fazendo transição para o R.O R foi lançado final dos anos 90 e desde então, seu escopo tem crescido dramaticamente. Suas capacidades são tão amplas que programas alternativos comerciais reagiram ao surgimento R para se manterem competitivas! (leia este artigo comparando R, SPSS, SAS, STATA, e Python).Além disso, o R é muito mais fácil de aprender que era há 10 anos. Anteriormente, o R tinha reputação de ser difícil para os iniciantes. Agora é muito mais fácil de aprender, com interfaces de usuário amigáveis como RStudio, código intuitivo como o tidyverse, e muitos recursos tutoriais.Não se sinta intimidado - venha descobrir o mundo R!","code":""},{"path":"transition-to-R.html","id":"partindo-do-excel","chapter":"4 Transição para o R","heading":"4.1 Partindo do Excel","text":"transição Excel diretamente para R é uma meta muito viável. Pode parecer assustador, mas você consegue fazer isso!É verdade que alguém com fortes habilidades Excel pode fazer atividades muito avançadas somente Excel - até mesmo usando ferramentas de programação em código como VBA. O Excel é usado em todo o mundo e é uma ferramenta essencial para um epidemiologista. Entretanto, complementá-lo com R pode melhorar drasticamente e expandir seus fluxos de trabalho.","code":""},{"path":"transition-to-R.html","id":"benefícios","chapter":"4 Transição para o R","heading":"Benefícios","text":"Você descobrirá que o uso de R oferece imensos benefícios, desde tempo economizado, análises mais consistentes e precisas, reprodutibilidade, compartilhabilidade e correção mais rápida de erros. Como qualquer software novo, há uma “curva” de aprendizado que reflete o tempo que você deve investir para se familiarizar em ele. Os dividendos serão significativos e um imenso escopo de novas possibilidades se abrirá para você com o R.Excel é um software bem conhecido que pode ser fácil para um iniciante usar para produzir análises e visualizações simples com o “apontar e clicar”. Em comparação, pode levar algumas semanas para se tornar confortável com funções e interface R. entanto, o R evoluiu nos últimos anos para se tornar muito mais amigável para iniciantes.Muitos fluxos de trabalho Excel dependem da memória e da repetição - portanto, há muitas oportunidades de erro. Além disso, geralmente limpeza de dados, metodologia de análise e equações utilizadas são ocultadas da vista. Pode ser necessário um tempo substancial para que um novo colega aprenda o que uma pasta de trabalho Excel está fazendo e como resolvê-la. Com R, todas etapas são explicitamente escritas script e podem ser facilmente visualizadas, editadas, corrigidas e aplicadas outros conjuntos de dados.Para iniciar sua transição Excel para o R, você deve ajustar sua mentalidade de algumas maneiras importantes:","code":""},{"path":"transition-to-R.html","id":"dados-bem-arrumados-tidy-data","chapter":"4 Transição para o R","heading":"Dados bem arrumados (tidy data)","text":"Use dados “arrumados” (tidy), isto é, que sejam legíveis para máquina em vez de dados bagunçados, que são apenas “legíveis para humanos”. Estes são os três principais requisitos para dados tipo “tidy”, como explicado neste tutorial sobre dados “tidy” em R:Cada variável deve ter sua própria colunaCada observação deve ter sua própria linhaCada valor deve ter sua própria célulaPara os usuários Excel - pense papel que “tabelas” Excel desempenham na padronização dos dados e na maior previsibilidade formato.Um exemplo de dados “tidy” seria lista (linelist) de casos utilizada ao longo deste manual - cada variável está contida dentro de uma coluna, cada observação (um caso) tem sua própria linha, e cada valor está em apenas uma célula. Abaixo você pode ver primeiras 50 linhas desta linelist:O principal motivo pelo qual entramos dados não-arrumados por aí (non-tidy) se deve ao fato de muitas planilhas Excel serem projetadas para priorizar leitura fácil por humanos, não leitura fácil por máquinas/software.Para ajudá-lo ver diferença, abaixo estão alguns exemplos fictícios de dados não-arrumados que priorizam leitura por humanos em vez de leitura por máquina:Problemas: Na planilha acima, há células mescladas que não são facilmente digeridas pelo R. Qual linha deve ser considerada o “cabeçalho” não está totalmente clara. Um dicionário baseado em cores está lado direito e os valores das células são representados por cores - o que também não é facilmente interpretado pelo R (nem por humanos daltônicos!). Além disso, diferentes pedaços de informação são combinados em uma célula (múltiplas organizações parceiras trabalhando em uma área, ou o status “TBC” na mesma célula que “Parceiro (partner) D”).Problemas: Na planilha acima, há numerosas linhas e colunas vazias extras dentro conjunto de dados - isto causará dores de cabeça para limpeza banco R. Além disso, coordenadas GPS estão espalhadas por duas linhas para um determinado centro de tratamento. Como nota lateral - coordenadas GPS estão em dois formatos diferentes!Os conjuntos de dados “tidy” podem não ser tão legíveis um olho humano, mas tornam limpeza e análise dos dados muito mais fácil! Dados “tidy” podem ser armazenados em vários formatos, por exemplo “longo/comprido” (long) ou “largo/amplo” (wide) (ver página em Pivotando dados), mas os princípios acima serão sempre observados.","code":""},{"path":"transition-to-R.html","id":"funções","chapter":"4 Transição para o R","heading":"Funções","text":"palavra “função” em R pode ser nova, mas o conceito também existe Excel como fórmulas. fórmulas Excel também requerem sintaxe precisa (por exemplo, colocação de ponto-e-vírgula e parênteses). Tudo o que você precisa fazer é aprender algumas novas funções e como elas funcionam juntas em R.","code":""},{"path":"transition-to-R.html","id":"scripts-1","chapter":"4 Transição para o R","heading":"Scripts","text":"Em vez de clicar nos botões e arrastar células, você estará escrevendo todos os passos e procedimentos em um “roteiro” (daqui em diante referido como script).\nOs usuários Excel podem estar familiarizados com “macros VBA” que também empregam uma abordagem de códigos de programação.O script R consiste de instruções passo passo. Isto permite que qualquer colega leia o script e veja facilmente os passos que você deu. Isto também ajuda eliminar erros ou cálculos imprecisos. Veja seção Introdução ao R sobre scripts para exemplos.Aqui está um exemplo de um script em R:","code":""},{"path":"transition-to-R.html","id":"do-excel-para-r-recursos","chapter":"4 Transição para o R","heading":"Do Excel-para-R: recursos","text":"R vs. Excelcurso RStudio em R para usuários Excel","code":""},{"path":"transition-to-R.html","id":"interação-r-excel","chapter":"4 Transição para o R","heading":"Interação R-Excel","text":"R tem formas robustas de importar pastas de trabalho Excel, trabalhar com os dados, exportar/guardar arquivos Excel e trabalhar com nuances das planilhas Excel.É verdade que algumas das formatações mais estéticas Excel podem se perder na tradução (por exemplo, itálico, texto lateral, etc.). Se seu fluxo de trabalho exigir passagem de documentos entre R e Excel enquanto mantém formatação original Excel, tente pacotes como openxlsx*.","code":""},{"path":"transition-to-R.html","id":"partindo-do-stata","chapter":"4 Transição para o R","heading":"4.2 Partindo do Stata","text":"Vindo Stata para R*Muitos epidemiologistas são ensinados primeiro usar Stata, e pode parecer assustador mudar para R. Entretanto, se você é um usuário confortável de Stata, então o salto para R é certamente mais manejável que você possa pensar. Embora existam algumas diferenças chave entre Stata e R em como os dados podem ser criados e modificados, bem como maneira que funções de análise são implementadas - após aprender estas diferenças chave você será capaz de adaptar suas habilidades.Abaixo estão algumas traduções chave entre Stata e R, que podem ser úteis como sua revisão deste guia.Notas geraisDiretório de trabalhoImportando e visualizando dadosManipulações básicas de dadosAnálise descritivaEmbora esta lista dê uma visão geral dos conceitos básicos na tradução dos comandos Stata em R, ela não é completa. Há muitos outros grandes recursos para os usuários da Stata em transição para R que poderiam ser de interesse:https://dss.princeton.edu/training/RStata.pdfhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.htmlhttp://r4stats.com/books/r4stata/","code":""},{"path":"transition-to-R.html","id":"partindo-do-sas","chapter":"4 Transição para o R","heading":"4.3 Partindo do SAS","text":"Vindo da SAS para R*O SAS é comumente usado em agências de saúde pública e campos de pesquisa acadêmica. Embora transição para um novo idioma raramente seja um processo simples, compreender diferenças-chave entre SAS e R pode ajudá-lo começar navegar novo idioma usando seu idioma nativo.\nseguir, descrevemos principais traduções gerenciamento de dados e análise descritiva entre SAS e o R.Notas geraisDiretório de trabalhoImportando e visualizando dadosManipulações básicas de dadosAnálise descritivaAlguns recursos úteis:R para usuários de SAS e SPSS (2011)SAS e R, Segunda Edição (2014)","code":""},{"path":"transition-to-R.html","id":"interoperabilidade-de-dados","chapter":"4 Transição para o R","heading":"4.4 Interoperabilidade de dados","text":"Veja página Importar e exportar para detalhes sobre como o pacote rio R pode importar e exportar arquivos como arquivos STATA .dta, arquivos SAS .xpt e.sas7bdat, arquivos SPSS .por e.sav, e muitos outros.","code":""},{"path":"packages-suggested.html","id":"packages-suggested","chapter":"5 Pacotes sugeridos","heading":"5 Pacotes sugeridos","text":"Abaixo está uma longa lista de pacotes sugeridos para trabalho epidemiológico comum em R. Você pode copiar este código, executá-lo, e todos estes pacotes serão instalados partir de CRAN e carregados para uso na sessão R atual. Se um pacote já estiver instalado, ele será carregado apenas para uso.Você pode modificar o código com símbolos # para excluir qualquer pacote que não queira.Nota:Instale primeiro o pacote pacman antes de executar o código abaixo. Você pode fazer isto com install.packages(\"pacman\"). Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para utilização na sessão R atual. Você também pode carregar pacotes que já estão instalados com library() partir R base.código abaixo, os pacotes que são incluídos ao instalar/carregar outro pacote são indicados por um travessão e hashtag. Por exemplo, como ggplot2 está listado em tidyverse.Se vários pacotes têm funções com o mesmo nome, o mascaramento (masking) das funções pode ocorrer entre os pacotes. Ou seja, quando função pacote mais recentemente carregado prevalece. Leia mais na página Introdução ao R. Considere o uso pacote conflicted para gerenciar tais conflitos.Consulte seção Introdução ao R sobre pacotes para mais informações sobre pacman e mascaramento.Para ver versões dos pacotes R, RStudio e R utilizados durante produção deste manual, veja página em Notas editoriais e técnicas.","code":""},{"path":"packages-suggested.html","id":"pacotes-do-cran","chapter":"5 Pacotes sugeridos","heading":"5.1 Pacotes do CRAN","text":"","code":"\n##########################################\n# Lista de pscotes úteis para uso em epidemiologia#\n##########################################\n\n# Este script usa a função p_load() do pacote R pacman , \n# que  instala se o pacote estiver ausente, e os carrega para uso, se já estiverem instalados\n\n\n# Garante que o pacman eestá instalado\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Pacotes disponíveis no CRAN\n##############################\npacman::p_load(\n     \n     # aprendendo R\n     ############\n     learnr,   # tutoriais interativos no RStudio \n     swirl,    # tutoriais interetivos no console\n        \n     # manuseio de projetos e arquivos \n     #############################\n     here,     # caminhos relativos de arquivos para a pasta raiz do projeto \n     rio,      # importar/exportar muitos formatos de arquivos\n     openxlsx, # importar/exportar planilhas de Excel com várias abas \n     \n     # manipulação e instalação de pacotes\n     ################################\n     pacman,   # instalação e carregamento de pacotes\n     renv,     # manipulando versões de pacotes quando trabalhando em grupos \n     remotes,  # instalar pacotes do github \n     \n     # Manipulação geral de dados\n     #########################\n     tidyverse,    # inlcui vários pacotes para arrumação,  manipulação e apresentação de dados. \n          #dplyr,      # manipulação de dados\n          #tidyr,      # manipulação de dados\n          #ggplot2,    # visualização de dados\n          #stringr,    # trabalhar com strings e caracteres\n          #forcats,    # trabalhar com fatores\n          #lubridate,  # trabalhar com datas\n          #purrr       # iteração e trabalhando com listas\n     linelist,     # limpando linelists\n     naniar,       # assessando valores ausentes\n     \n     # estatísticas\n     ############\n     janitor,      # tabelas e limpeza de dados\n     gtsummary,    # fazendo tabelas estatísticas e descritivas\n     rstatix,      #  fazer estatíticas e resumos rápidos \n     broom,        # arrumar resultados de regressões \n     lmtest,       # testes de razão de likelihood\n     easystats,\n          # parametros, # alternativa a limpar os resultados de regressões. \n          # see,        # alternativa para vizualizar gráfico de floresta. \n     \n     # modelagem de epidemias\n     ###################\n     epicontacts,  # Analisando rede de transmissão t\n     EpiNow2,      # Estimando Rt \n     EpiEstim,     # Estimando Rt \n     projections,  # Projeção de incidencia\n     incidence2,   # Fazer epicurvas e manipular dados de incidência. \n     i2extras,     # Funções extra para pacote incidence2 \n     epitrix,      # Funções epi úteis\n     distcrete,    # Distribuições discretas com delay (atraso)\n     \n     \n     # Gráficos - geral\n     #################\n     #ggplot2,         # incluso no tidyverse\n     cowplot,          # combinando gráficos\n     # patchwork,      #combinando gráficos (alternativa)     \n     RColorBrewer,     # escala de cores\n     ggnewscale,       # adicionar novos esquemas de cores\n\n     \n     # Gráficos - tipos específicos\n     ########################\n     DiagrammeR,       # diagramas utilizando linguagem DOT\n     incidence2,       # curvas epidêmicas\n     gghighlight,      # highlight um subset\n     ggrepel,          # rótulos inteligentes\n     plotly,           # gráficos interativos\n     gganimate,        # gráficos animados\n\n     \n     # gis\n     ######\n     sf,               # manusear dados espaciais usado o formato Simple Feature \n     tmap,             # produzir mapas simples, funciona tanto com mapas estáticos ou interativos\n     OpenStreetMap,    # adicionar base OSM num mapa ggplot\n     spdep,            # estatística espacial\n     \n     # relatórios de rotina\n     #################\n     rmarkdown,        # produz arquivos em  PDFs, Word, Powerpoint e HTML \n     reportfactory,    # auto-organização de outputs de R Markdown\n     officer,          # powerpoint\n     \n     # dashboards\n     ############\n     flexdashboard,    # converte um script R Markdown em um dashboard\n     shiny,            # web apps interativo\n     \n     # tabelas para apresentação\n     #########################\n     knitr,            # Geração de relatório R Markdown e tabelas html \n     flextable,        # Tabelas HTML \n     #DT,              # Tabelas HTML  (alternativa)\n     #gt,              # Tabelas HTML  (alternativa)\n     #huxtable,        # Tabelas HTML  (alternativa)\n     \n     # phylogenetics\n     ###############\n     ggtree,           # visualização e de árvores filogenéticas \n     ape,              # análise e de filogenenia e evolução\n     treeio            # visualizar arquivos de filogenia\n \n)"},{"path":"packages-suggested.html","id":"pacotes-do-github","chapter":"5 Pacotes sugeridos","heading":"5.2 Pacotes do Github","text":"Abaixo estão os comandos para instalar dois pacotes diretamente dos repositórios Github.versão de desenvolvimento de epicontacts contém capacidade de fazer árvores de transmissão com um eixo x temporal\nO pacote epirhandbook contém todos os dados de exemplo para este manual e pode ser usado para baixar versão offline manual.","code":"\n# Pacotes para baixar do github (não estão disponíveis no CRAN)\n##########################################################\n\n# Versão de desenvolvimento de epicontacts (para cadeias de transmissão com tempo no  eixo x)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# O pacote para este manual, que inclui todos os dados usados nos exemplos \npacman::p_install_gh(\"appliedepi/epirhandbook\")"},{"path":"r-projects.html","id":"r-projects","chapter":"6 R projects","heading":"6 R projects","text":"Um R project permite que seu trabalho seja agrupado em uma pasta portátil e independente. Dentro projeto, todos os scripts, arquivos de dados, figuras / saídas e histórico relevantes são armazenados em subpastas e, mais importante, - o diretório de trabalho é pasta raiz projeto.","code":""},{"path":"r-projects.html","id":"uso-sugerido","chapter":"6 R projects","heading":"6.1 Uso sugerido","text":"Uma maneira comum, eficiente e sem problemas de usar R é combinar esses 3 elementos. Um projeto de trabalho discreto é hospedado em um R project. Cada elemento é descrito nas seções abaixo.Um projeto R\nUm ambiente de trabalho independente com pastas para dados, scripts, saídas, etc.\nUm ambiente de trabalho independente com pastas para dados, scripts, saídas, etc.O pacote para caminhos de arquivo relativos\nOs caminhos de arquivo são gravados em relação à pasta raiz R project - consulte Importar e exportar para obter mais informações\nOs caminhos de arquivo são gravados em relação à pasta raiz R project - consulte Importar e exportar para obter mais informaçõesO pacote rio para importação / exportação\nimport() e export() manipulam qualquer tipo de arquivo por sua extensão (por exemplo, .csv, .xlsx, .png)\nimport() e export() manipulam qualquer tipo de arquivo por sua extensão (por exemplo, .csv, .xlsx, .png)","code":""},{"path":"r-projects.html","id":"criação-de-um-r-project","chapter":"6 R projects","heading":"6.2 Criação de um R project","text":"Para criar um R project, selecione “Novo Projeto” menu Arquivo.Se deseja criar uma nova pasta para o projeto, selecione “Novo diretório” e indique onde deseja que seja criado.Se deseja criar o projeto dentro de uma pasta existente, clique em “Diretório existente” e indique pasta.Se você deseja clonar um repositório Github, selecione terceira opção “Controle de Versão” e depois “Git”. Veja página em Controle de versão e colaboração com Git e Github para mais detalhes.O R project que você criar virá na forma de uma pasta contendo um arquivo .Rproj. Este arquivo é um atalho e provavelmente principal maneira de abrir seu projeto. Você também pode abrir um projeto selecionando “Abrir Projeto” menu Arquivo. Alternativamente, canto superior direito RStudio, você verá um ícone de R project e um menu suspenso de R projects disponíveis.Para sair de um R project, abra um novo projeto ou feche o projeto (Arquivo - Fechar Projeto).","code":""},{"path":"r-projects.html","id":"alternar-projetos","chapter":"6 R projects","heading":"Alternar projetos","text":"Para alternar entre os projetos, clique ícone R project e menu suspenso canto superior direito RStudio. Você verá opções para Fechar projeto, Abrir projeto e uma lista de projetos recentes.","code":""},{"path":"r-projects.html","id":"configurações","chapter":"6 R projects","heading":"Configurações","text":"Em geral, é aconselhável iniciar o RStudio cada vez com uma “lousa em branco” - ou seja, com sua área de trabalho não preservada da sessão anterior. Isso significa que seus objetos e resultados não persistirão de sessão para sessão (você deve recriá-los executando seus scripts). Isso é bom, porque o forçará escrever scripts melhores e evitará erros longo prazo.Para configurar o RStudio para ter uma “lista limpa” cada vez na inicialização:Selecione “Opções de projeto” menu Ferramentas.Na guia “Geral”, defina o RStudio para não restaurar .RData na área de trabalho na inicialização e para não salvar área de trabalho em .RData ao sair.","code":""},{"path":"r-projects.html","id":"organização","chapter":"6 R projects","heading":"Organização","text":"É comum ter subpastas em seu projeto. Considere ter pastas como “dados”, “scripts”, “figuras”, “apresentações”. Você pode adicionar pastas da maneira típica que faria com uma nova pasta para o seu computador. Como alternativa, consulte página em Interações de diretório para saber como criar novas pastas com comandos R.","code":""},{"path":"r-projects.html","id":"controle-de-versão","chapter":"6 R projects","heading":"Controle de versão","text":"Considere um sistema de controle de versão. Pode ser algo tão simples como ter datas nos nomes dos scripts (por exemplo, “transmission_analysis_2020-10-03.R”) e uma pasta de “arquivo”. Considere também ter um texto de cabeçalho comentado na parte superior de cada script com uma descrição, tags, autores e log de alterações.Um método mais complicado envolveria o uso Github ou uma plataforma semelhante para controle de versão. Veja página em Controle de versão e colaboração com Git e Github.Uma dica é que você pode pesquisar um projeto ou pasta inteira usando ferramenta “Localizar nos arquivos” (menu Editar). Ele pode pesquisar e até mesmo substituir strings em vários arquivos.","code":""},{"path":"r-projects.html","id":"exemplos","chapter":"6 R projects","heading":"6.3 Exemplos","text":"Abaixo estão alguns exemplos de importação / exportação / salvamento usando () de dentro de um R project. Leia mais sobre como usar o pacote na página Importar e exportar.Importando linelist_raw.xlsx da pasta” data “em seu R projectExportando o objeto R linelist como” my_linelist.rds “para pasta” clean “dentro da pasta” data “em seu R project.Salvar o gráfico impresso mais recentemente como “epicurve_2021-02-15.png” dentro da pasta “epicurves” na pasta “saídas” em seu R project.","code":"\nlinelist <- import(here(\"data\", \"linelist_raw.xlsx\"))\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))"},{"path":"r-projects.html","id":"recursos","chapter":"6 R projects","heading":"6.4 Recursos","text":"Página da web RStudio em usando R projects","code":""},{"path":"importing.html","id":"importing","chapter":"7 Importar e exportar","heading":"7 Importar e exportar","text":"Nesta página descrevemos formas de localizar, importar e exportar arquivos:Utilização pacote rio para flexivelmente import() e export() muitos tipos de arquivosUso pacote para localizar arquivos relativos uma raiz de projeto R - para evitar complicações de caminhos de arquivos que são específicos de um computadorCenários específicos de importação, como por exemplo:\nPlanilhas específicas Excel\nCabeçalhos confusos e linhas para pular\nPlanilhas Google\npartir de dados postados em websites\nCom APIs\nImportação arquivo mais recente\nPlanilhas específicas ExcelCabeçalhos confusos e linhas para pularPlanilhas GoogleA partir de dados postados em websitesCom APIsImportação arquivo mais recenteEntrada manual de dadosTipos de arquivos específicos de R, como RDS e RDataExportar / salvar arquivos e gráficos","code":""},{"path":"importing.html","id":"visão-geral","chapter":"7 Importar e exportar","heading":"7.1 Visão geral","text":"Quando você importa um “conjunto de dados” para o R, você geralmente está criando um novo objeto tipo data frame em seu ambiente R e definindo-o como um arquivo importado (por exemplo, Excel, CSV, TSV, RDS) que está localizado em suas pastas em um determinado caminho/endereço de arquivo.Você pode importar/exportar muitos tipos de arquivos, inclusive aqueles criados por outros programas estatísticos (SAS, STATA, SPSS). Você também pode se conectar bancos de dados relacionais.R tem até seus próprios formatos de dados:Um arquivo RDS (.rds) armazena um único objeto R, como um data frame. Estes são úteis para armazenar dados limpos, pois eles mantêm classes de colunas R. Leia mais em esta seção.Um arquivo RData (.Rdata) pode ser usado para armazenar vários objetos, ou mesmo um espaço de trabalho R completo. Leia mais em esta seção.","code":""},{"path":"importing.html","id":"o-pacote-rio","chapter":"7 Importar e exportar","heading":"7.2 O pacote rio","text":"O pacote R que recomendamos é: rio. O nome “rio” é uma abreviação de “R /O” (input/output ).Suas funções import() e export() podem lidar com muitos tipos diferentes de arquivos (por exemplo, .xlsx, .csv, .rds, .tsv). Quando você fornece um caminho de arquivo para qualquer uma destas funções (incluindo extensão arquivo como “.csv”), rio lerá extensão e utilizará ferramenta correta para importar ou exportar o arquivo.alternativa ao uso rio é usar funções de muitos outros pacotes, cada um dos quais é específico para um tipo de arquivo. Por exemplo, read.csv() (R base ), read.xlsx() (openxlsx pacote), e write_csv() (readr pacakge), etc. Estas alternativas podem ser difíceis de lembrar, enquanto que utilizar import() e export() de rio* é fácil.funções rio import() e export() utilizam o pacote e função apropriados para um determinado arquivo, com base em sua extensão. Veja final desta página uma tabela completa de quais pacotes/funções rio utilizam em segundo plano. Ele também pode ser utilizado para importar arquivos STATA, SAS e SPSS, entre dezenas de outros tipos de arquivos.importação/exportação de shapefiles (para mapas) requer outros pacotes, conforme detalhado na página sobre GIS básico.","code":""},{"path":"importing.html","id":"here","chapter":"7 Importar e exportar","heading":"7.3 O pacote here","text":"O pacote e sua função () tornam fácil dizer R onde encontrar e salvar seus arquivos - em essência, ele constrói os caminhos dos arquivos.Utilizado em conjunto com um projeto R, permite descrever localização dos arquivos em seu projeto R em relação ao diretório root projeto R (pasta de nível superior). Isto é útil quando o projeto R pode ser compartilhado ou acessado por várias pessoas/computadores. Ele evita complicações devido aos caminhos exclusivos dos arquivos em diferentes computadores (por exemplo, `“C:/Users/Laura/Documents…’’,”iniciando” o caminho arquivo em um lugar comum todos os usuários (raiz projeto R).É assim como () funciona dentro de um projeto R:Quando o pacote é carregado pela primeira vez dentro projeto R, ele coloca um pequeno arquivo chamado “.” na pasta raiz de seu projeto R como um “benchmark” ou “âncora”.Em seus scripts, para referenciar um arquivo nas subpastas projeto R, você utiliza função () para construir o caminho arquivo em relação essa âncora.Para construir o caminho arquivo, escreva os nomes das pastas além da raiz, entre aspas, separados por vírgulas, finalmente terminando com o nome arquivo e extensão arquivo, como mostrado abaixoCaminhos de arquivos com função ’()` podem ser utilizados tanto para importação quanto para exportaçãoPor exemplo, abaixo, função import() está sendo fornecida um caminho de arquivo construído com ().O comando (\"data\", \"linelists\", \"ebola_linelist.xlsx\") está na verdade fornecendo o caminho completo arquivo que é único para o computador usuário:beleza é que o comando R utilizando () pode ser executado com sucesso em qualquer computador que acesse o projeto R.DICA: Se você não tiver certeza de onde raiz “.” está definida, execute função () com parênteses vazios.Leia mais sobre o pacote neste link.","code":"\nlinelist <- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\""},{"path":"importing.html","id":"caminhos-dos-arquivos","chapter":"7 Importar e exportar","heading":"7.4 Caminhos dos arquivos","text":"Ao importar ou exportar dados, você deve fornecer um caminho para o arquivo. Você pode fazer isso de três maneiras:Recomendado: fornecer um caminho de arquivo “relativo” com o pacote hereFornecer o caminho “completo” / “absoluto” arquivoSeleção manual arquivo","code":""},{"path":"importing.html","id":"caminhos-relativo-dos-arquivos","chapter":"7 Importar e exportar","heading":"Caminhos ‘relativo’ dos arquivos","text":"R, os caminhos de arquivo “relativos” consistem caminho de arquivo relativo à raiz de um projeto R. Eles permitem caminhos de arquivo mais simples que podem funcionar em computadores diferentes (por exemplo, se o projeto R estiver em um drive compartilhado ou enviado por e-mail). Como descrito acima, os caminhos de arquivo relativos são facilitados pelo uso pacote .Um exemplo de um caminho de arquivo relativo construído com () está abaixo. Supomos que o trabalho esteja em um projeto R que contém uma subpasta “dados” e dentro dela uma subpasta “linelists”, na qual há o arquivo .xlsx de interesse.","code":"\nlinelist <- import(here(\"dados\", \"linelists\", \"ebola_linelist.xlsx\"))"},{"path":"importing.html","id":"caminhos-absoluto-dos-arquivos","chapter":"7 Importar e exportar","heading":"Caminhos ‘absoluto’ dos arquivos","text":"Caminhos de arquivo absolutos ou “completos” podem ser fornecidos para funções como import() mas são “frágeis”, pois são exclusivos para o computador específico usuário e portanto não são recomendados.Abaixo está um exemplo de um caminho de arquivo absoluto, onde computador de Laura há uma pasta “analises”, uma subpasta “dados” e dentro dela uma subpasta “linelists”, na qual há o arquivo .xlsx de interesse.Algumas coisas serem observadas sobre os caminhos absolutos dos arquivos:Evite o uso de caminhos de arquivo absolutos, pois eles quebrarão se o script executado em um computador diferente.Utilize barras normais (/), como exemplo acima (nota: este é NÃO o padrão para caminhos de arquivos Windows)Os caminhos de arquivos que começam com barras duplas (por exemplo, “//…”) provavelmente não serão reconhecidos por R e produzirão um erro. Considere mover seu trabalho para uma unidade “nomeado” ou ” com letras” que comece com uma letra (por exemplo, “J:” ou “C:”). Consulte página em Interações diretório para obter mais detalhes sobre este assunto.Um cenário onde caminhos de arquivo absolutos podem ser apropriados é quando você deseja importar um arquivo de um drive compartilhado que tenha o mesmo caminho de arquivo completo para todos os usuários.DICA: Para converter rapidemente todas barras invertidas \\ em barras normais /, destaque o código de interesse, use Ctrl+f (Windows), selecione caixa de opção “Em seleção” (selection), e depois usar funcionalidade de substituição para convertê-los.","code":"\nlinelist <- import(\"C:/Users/Laura/Documents/analises/dados/linelists/ebola_linelist.xlsx\")"},{"path":"importing.html","id":"selecionando-um-arquivo-manualmente","chapter":"7 Importar e exportar","heading":"Selecionando um arquivo manualmente","text":"Você pode importar dados manualmente por meio de um destes métodos:Painel Ambiente (Environment) RStudio, clique em “Importar Dados” (Import Dataset), e selecione o tipo de dadoClique em File / Import Dataset / (selecione o tipo de dados)Para seleção manual por código, utilize o comando R base file.choose() (deixando os parênteses vazios) para acionar aparência de uma janela pop-que permite ao usuário selecionar manualmente o arquivo de seu computador. Por exemplo:DICA: janela pop-window pode aparecer ATRÁS di seu RStudio.","code":"\n# Seleção manual de um arquivo. Quando este comando for executado, uma janela POP-UP aparecerá. \n# O caminho do arquivo selecionado será fornecido ao comando import().\n\nmy_data <- import(file.choose())"},{"path":"importing.html","id":"importar-dados","chapter":"7 Importar e exportar","heading":"7.5 Importar dados","text":"Utilizar import() para importar um conjunto de dados é bastante simples. Basta fornecer o caminho para o arquivo (incluindo o nome arquivo e extensão arquivo) entre aspas. Se utilizar () para construir o caminho arquivo, siga instruções acima. Abaixo estão alguns exemplos:Importar um arquivo csv que está localizado em seu “diretório de trabalho” ou na pasta raiz projeto R:Importação da primeira planilha de uma pasta de trabalho Excel que está localizada nas subpastas “dados” e “linelists” projeto R (o caminho arquivo construído utilizando ()):Importação de um “quadro de dados” ( referido nesse livro como data frame)(um arquivo .rds) usando um caminho de arquivo absoluto:","code":"\nlinelist <- import(\"linelist_cleaned.csv\")\nlinelist <- import(here(\"dados\", \"linelists\", \"linelist_cleaned.xlsx\"))\nlinelist <- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")"},{"path":"importing.html","id":"planilhas-específicas-do-excel","chapter":"7 Importar e exportar","heading":"Planilhas específicas do Excel","text":"Por padrão, se você fornecer uma pasta de trabalho Excel (.xlsx) para função import(), primeira planilha da pasta de trabalho será importada. Se você quiser importar uma aba (sheet) específica, inclua o nome da planilha ao = argument. Por exemplo:Se utilizar o método () para fornecer um caminho relativo para import(), você ainda pode indicar uma aba específica adicionando o = argumento depois dos parênteses de fechamento da função ().Para exportar um data frame R para uma planilha específica Excel e ter o resto da pasta de trabalho Excel inalterado, você terá que importar, editar e exportar com um pacote alternativo criado para este propósito, como openxlsx*. Veja mais informações na página em Interações diretório ou nesta página github.Se sua pasta de trabalho Excel .xlsb (pasta de trabalho Excel em formato binário) você talvez não consiga importá-la usando rio. Considere possibilidade de salvá-la como .xlsx, ou usando um pacote como readxlsb* que é construído para este propósito.","code":"\nmy_data <- import(\"my_excel_file.xlsx\", which = \"Sheetname\")# Demonstração: importação de uma planilha específica do Excel ao utilizar caminhos relativos com o pacote 'here'.  \n\nlinelist_raw <- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  "},{"path":"importing.html","id":"import_missing","chapter":"7 Importar e exportar","heading":"Valores faltantes","text":"Você pode querer designar que valor(es) em seu conjunto de dados que deve(m) ser considerado(s) como ausente(s)/faltante(s). Como explicado na página em Dados faltantes, o valor em R para dados ausentes é NA, mas talvez o conjunto de dados que você deseja importar utilize 99, “Ausente”, ou apenas espaço vazio de caracteres “” em vez disso.Utilize o na = argumento para import() e forneça o(s) valor(es) entre aspas (mesmo que sejam números). Você pode especificar múltiplos valores incluindo-os dentro de um vetor, utilizando c() como mostrado abaixo.Aqui, o valor “99” conjunto de dados importados é considerado ausente e convertido para NA em R.Qualquer um dos valores “Missing”, “” (célula vazia), ou “” (espaço único) conjunto de dados importados são convertidos para NA R.","code":"\nlinelist <- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\nlinelist <- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))"},{"path":"importing.html","id":"pular-linhas","chapter":"7 Importar e exportar","heading":"Pular linhas","text":"Às vezes, você pode querer evitar importação de uma linha específica de dados. Você pode fazer isso com o argumento skip = se utilizar import() de rio em um arquivo .xlsx ou .csv. Forneça o número de linhas que você deseja pular.Infelizmente ’skip = ’aceita apenas um valor inteiro, não um intervalo (por exemplo, “2:10” não funciona). Para pular importação de linhas específicas que não são consecutivas topo, considere importar várias vezes e utilizar bind_rows() partir de dplyr*. Veja o exemplo abaixo de pular apenas linha 2.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\", skip = 1)  # Não importa a linha de cabeçalho"},{"path":"importing.html","id":"como-lidar-com-uma-segunda-linha-de-cabeçalho","chapter":"7 Importar e exportar","heading":"Como lidar com uma segunda linha de cabeçalho","text":"Às vezes, seus dados podem ter uma segunda linha de cabeçalho, por exemplo, se uma linha de “dicionário de dados”, como mostrado abaixo. Esta situação pode ser problemática porque pode resultar na importação de todas colunas como classe “caractere”.Abaixo está um exemplo deste tipo de conjunto de dados (sendo primeira linha o dicionário de dados).","code":""},{"path":"importing.html","id":"remover-uma-segunda-linha-de-cabeçalho","chapter":"7 Importar e exportar","heading":"Remover uma segunda linha de cabeçalho","text":"Para ignorar segunda linha de cabeçalho, você provavelmente precisará importar os dados duas vezes.Importar os dados para armazenar os nomes corretos das colunasImportar os dados novamente, pulando primeiras duas fileiras (cabeçalho e segunda fileira)Ligar os nomes corretos campo de dados reduzidoO argumento exato usado para ligar os nomes corretos das colunas depende tipo de arquivo de dados (.csv, .tsv, .xlsx, etc.). Isto porque rio está usando uma função diferente para os diferentes tipos de arquivo (ver tabela acima).Para arquivos Excel: (col_names =)Para arquivos CSV: (col.names =)Opção de Backup  - atribuir/sobreescrever cabeçalhos usando função ‘colnames()’ base","code":"\n# importe a primeira vez; salve o nome das colunas\nlinelist_raw_names <- import(\"linelist_raw.xlsx\") %>% names()  # Salva o nome veradeiro das colunas\n\n# Importe uma segunda vez; pule a segunda linha e designe os nomes das colunas para o argumento col_names =\nlinelist_raw <- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n# importe a primeira vez; salve o nome das colunas\nlinelist_raw_names <- import(\"linelist_raw.csv\") %>% names() # salve o nome verdadeiro das colunas\n\n# note que o argumento para arquivos csv é 'col.names = '\nlinelist_raw <- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n# assign/overwrite headers using the base 'colnames()' function\ncolnames(linelist_raw) <- linelist_raw_names"},{"path":"importing.html","id":"fazendo-um-dicionário-de-dados","chapter":"7 Importar e exportar","heading":"Fazendo um dicionário de dados","text":"Bônus! Se você tiver uma segunda linha que seja um dicionário de dados, você pode facilmente criar um dicionário de dados adequado partir dele. Esta dica é adaptada partir deste post.","code":"\ndict <- linelist_2headers %>%             # começa: linelist com um dicionário como a primeira linha\n  head(1) %>%                             # mantenha apenas os nomes das colunas e a primeira linha com o dicionário               \n  pivot_longer(cols = everything(),       # faça o pivotamento de todas as coluna spara o formato \"longo\" \n               names_to = \"Column\",       # nomeie as colunas\n               values_to = \"Description\")"},{"path":"importing.html","id":"combinar-duas-linhas-de-cabeçalho","chapter":"7 Importar e exportar","heading":"Combinar duas linhas de cabeçalho","text":"Em alguns casos, quando seu conjunto de dados brutos tiver duas linhas de cabeçalho (ou mais especificamente, segunda linha de dados é um cabeçalho secundário), você pode querer “combiná-las” ou adicionar os valores da segunda linha de cabeçalho à primeira linha de cabeçalho.O comando abaixo definirá os nomes das colunas data frame como combinação (colando em conjunto) dos primeiros cabeçalhos (verdadeiros) com o valor imediatamente abaixo (na primeira linha).","code":"\nnames(my_data) <- paste(names(my_data), my_data[1, ], sep = \"_\")"},{"path":"importing.html","id":"planilhas-do-google","chapter":"7 Importar e exportar","heading":"Planilhas do Google","text":"Você pode importar dados de uma planilha -line Google com o pacote googlesheet4 e autenticando seu acesso à planilha.Abaixo, uma planilha de demonstração Google é importada e salva. Este comando pode solicitar confirmação da autenticação de sua conta Google. Siga instruções e pop-ups em seu navegador de internet para conceder permissões aos pacotes Tidyverse API para editar, criar e excluir suas planilhas Google Drive.planilha abaixo é “visualizável para qualquer pessoa com o link” e você pode tentar importá-la.planilha também pode ser importada usando apenas identificação da planilha, uma parte mais curta da URL:Outro pacote, googledrive oferece funções úteis para escrever, editar e excluir planilhas Google. Por exemplo, utilizando funções gs4_create() e sheet_write() encontradas neste pacote.Aqui estão alguns outros tutoriais -line úteis:tutorial básico de importação de planilhas Googletutorial mais detalhadointeração entre googlesheets4 e tidyverse","code":"\npacman::p_load(\"googlesheets4\")\nGsheets_demo <- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\nGsheets_demo <- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")"},{"path":"importing.html","id":"múltiplos-arquivos--importar-exportar-dividir-combinar","chapter":"7 Importar e exportar","heading":"7.6 Múltiplos arquivos- importar, exportar, dividir, combinar","text":"Veja página em Iteração, loops e listas para exemplos de como importar e combinar vários arquivos, ou vários arquivos de pastas de trabalho Excel. Essa página também tem exemplos de como dividir um data frame em partes e exportar cada uma separadamente, ou como planilhas nomeadas em uma pasta de trabalho Excel.","code":""},{"path":"importing.html","id":"import_github","chapter":"7 Importar e exportar","heading":"7.7 Importar do GitHub","text":"importação de dados diretamente Github para R pode ser muito fácil ou pode exigir alguns passos - dependendo tipo de arquivo. Abaixo estão algumas abordagens:","code":""},{"path":"importing.html","id":"arquivos-csv","chapter":"7 Importar e exportar","heading":"Arquivos CSV","text":"Pode ser fácil importar um arquivo .csv diretamente Github para R com um comando R.Vá até o repositório Github, localize o arquivo de interesse e clique sobre eleClique botão “Raw” (você verá então os dados “brutos” csv, como mostrado abaixo)Copiar URL (endereço web)Colocar URL entre aspas dentro comando import() R","code":""},{"path":"importing.html","id":"arquivo-xlsx","chapter":"7 Importar e exportar","heading":"Arquivo XLSX","text":"Talvez você não consiga visualizar os dados “Raw” de alguns arquivos (por exemplo, .xlsx, .rds, .nwk, .shp)Vá até o repositório Github, localize o arquivo de interesse e clique sobre eleClique botão “Download”, como mostrado abaixoSalve o arquivo em seu computador, e importe-o para o R","code":""},{"path":"importing.html","id":"shapefiles","chapter":"7 Importar e exportar","heading":"Shapefiles","text":"Os shapefiles têm muitos sub-componentes, cada um com uma extensão de arquivo diferente. Um arquivo terá extensão “.shp”, mas outros podem ter “.dbf”, “.prj”, etc. Para baixar um shapefile Github, você precisará baixar cada um dos arquivos de subcomponentes individualmente, e salvá-los na mesma pasta em seu computador. Github, clique em cada arquivo individualmente e faça o download deles clicando botão “Download”.Uma vez salvo em seu computador, você pode importar o shapefile como mostrado na página GIS básico utilizando st_read() pacote sf. Você só precisa fornecer o caminho arquivo e o nome arquivo “.shp” - desde que os outros arquivos relacionados estejam dentro da mesma pasta em seu computador.Abaixo, você pode ver como o shapefile “sle_adm3” consiste de muitos arquivos - cada um dos quais deve ser baixado Github.","code":""},{"path":"importing.html","id":"inserir-dados-munualmente","chapter":"7 Importar e exportar","heading":"7.8 Inserir dados munualmente","text":"","code":""},{"path":"importing.html","id":"inserção-por-linhas","chapter":"7 Importar e exportar","heading":"Inserção por linhas","text":"Utilize função tribble pacote tibble tidyverse (referência online tibble).Observe como os cabeçalhos das colunas começam com um til (~). Observe também que cada coluna deve conter apenas uma classe de dados (caractere, numérico, etc.). Você pode utilizar abas, espaçamento e novas linhas para tornar entrada de dados mais intuitiva e legível. Os espaços não importam entre os valores, mas cada linha é representada por uma nova linha de código. Por exemplo:agora nós exibimos o novo data frame::","code":"\n# Crie um conjunto de dados manualmente por linha\nmanual_entry_rows <- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )"},{"path":"importing.html","id":"inserção-por-colunas","chapter":"7 Importar e exportar","heading":"Inserção por colunas","text":"Como um data frame consiste em vetores (colunas verticais), abordagem base para criação manual de data frames R espera que você defina cada coluna e depois vincule juntas. Isto pode ser contra-intuitivo em epidemiologia, pois geralmente pensamos em nossos dados em linhas (como acima).CUIDADO: Todos os vetores devem ter o mesmo comprimento (mesmo número de valores).vectors can bound together using function data.frame():E agora vamos vizualizar o novo conjunto de dados:","code":"\n# definir cada vetor (coluna vertical) separadamente, cada um com seu próprio nome\nPatientID <- c(235, 452, 778, 111)\nTreatment <- c(\"Yes\", \"No\", \"Yes\", \"Yes\")\nDeath     <- c(1, 0, 1, 0)\n# combine as colunas em um *data frame*, referenciando os nomes dos vetores\nmanual_entry_cols <- data.frame(PatientID, Treatment, Death)"},{"path":"importing.html","id":"colando-a-partir-da-área-de-transferência","chapter":"7 Importar e exportar","heading":"Colando a partir da área de transferência","text":"Se você copiar dados de outro lugar e os tem na “área de transferência” (clipboard), você pode tentar uma das duas maneiras abaixo:pacote clipr*, você pode utilizar read_clip_tbl() para importar como um data frame, ou apenas read_clip() para importar como um vetor de caracteres. Em ambos os casos, deixe os parênteses vazios.Você também pode exportar facilmente para área de transferência seu sistema com clipr*. Veja seção abaixo sobre Exportação.Alternativamente, você pode utilizar função read.table() R base com file = \"clipboard\") para importar como um data frame:","code":"\nlinelist <- clipr::read_clip_tbl()  # importa a área de transferência atual como uma data frame\nlinelist <- clipr::read_clip()      # importa como um vetor de caracteres\ndf_from_clipboard <- read.table(\n  file = \"clipboard\",  # specify this as \"clipboard\"\n  sep = \"t\",           # separator could be tab, or commas, etc.\n  header=TRUE)         # if there is a header row"},{"path":"importing.html","id":"importar-o-arquivo-mais-recente","chapter":"7 Importar e exportar","heading":"7.9 Importar o arquivo mais recente","text":"Muitas vezes você pode receber atualizações diárias de seus conjuntos de dados. Neste caso, você vai querer escrever o código que importa o arquivo mais recente. seguir, apresentamos duas formas de abordar este assunto:Selecionando o arquivo com base na data nome arquivoSeleção arquivo com base nos metadados arquivo (última modificação)","code":""},{"path":"importing.html","id":"datas-no-nome-de-um-arquivo","chapter":"7 Importar e exportar","heading":"Datas no nome de um arquivo","text":"Esta abordagem depende de três premissas:Você confia nas datas nos nomes dos arquivosAs datas são numéricas e aparecem em geralmente mesmo formato (por exemplo, ano, mês e dia)Não há outros números nome arquivoExplicaremos cada passo e, final, mostraremos combinação deles.Primeiro, utilize dir() R base para extrair apenas os nomes dos arquivos para cada arquivo na pasta de interesse. Consulte página em Interações de diretório para obter mais detalhes sobre dir(). Neste exemplo, pasta de interesse é pasta “linelists” dentro da pasta “exemplo” dentro de “data” dentro projeto R.Uma vez que você tenha este vetor de nomes, você pode extrair datas partir deles aplicando str_extract() de stringr utilizando esta expressão regular. Ela extrai quaisquer números nome arquivo (incluindo quaisquer outros caracteres meio, tais como traços ou cortes). Você pode ler mais sobre stringr* na página Strings e caracteres.Assumindo que datas são escritas geralmente mesmo formato (por exemplo, Ano e depois Mês e depois Dia) e os anos têm 4 dígitos, você pode utilizar lubridate’s funções flexíveis de conversão (ymd(), dmy(), ou mdy()) para convertê-las em datas. Para estas funções, os traços, espaços ou cortes não importam, apenas ordem dos números. Leia mais na página Trabalhando com datas.função R base .max() pode então ser utilizada para retornar posição índice (por exemplo, 1º, 2º, 3º, …) valor máximo da data. O último arquivo é corretamente identificado como o 6º arquivo - “case_linelist_2020-10-08.xlsx”.Se nós condensarmos todos esses comandos, o cógico compelto deve parecer com o abaixo. Observe que o . na ultima linha é um marcador para o objeto pipe naquele ponta da sequência de pipes. Naquele ponto o valor é implesmente o número 6. Isso é colocado entre cochetes para extrair o sexto elemnto vetor de nomes arquivo produzido por dir().Você pode agora usar esse nome para finalizar o caminho relativo arquivo, com ():E agora você pode importar o arquivo mais recente:","code":"\nlinelist_filenames <- dir(here(\"data\", \"example\", \"linelists\")) # pega o nome dos arquivos da pasta\nlinelist_filenames                                              # exibe ## [1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\" \n## [3] \"case_linelist_2020-10-03.csv\"  \"case_linelist_2020-10-04.csv\" \n## [5] \"case_linelist_2020-10-05.csv\"  \"case_linelist_2020-10-08.xlsx\"\n## [7] \"case_linelist20201006.csv\"\nlinelist_dates_raw <- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # extrai números e quaisquer caracteres no meio\nlinelist_dates_raw  # print## [1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\" \"2020-10-08\"\n## [7] \"20201006\"\nlinelist_dates_clean <- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean## [1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\" \"2020-10-08\"\n## [7] \"2020-10-06\"\nindex_latest_file <- which.max(linelist_dates_clean)\nindex_latest_file## [1] 6\n# carrega os pacotes\npacman::p_load(\ntidyverse,           # manipulação  de dados\n  stringr,           # trabalha com strings/caravteres\n  lubridate,         # trabalha com datas\n  rio,               # importar / exportar\n  here,              # caminhos relativos dos arquivos\n  fs)                # interações entre diretórios\n\n# extrai o nome do arquivo mais recente\nlatest_file <- dir(here(\"data\", \"example\", \"linelists\")) %>%  # nomes dos aequivos da subpasta \"linelists\"         \n  str_extract(\"[0-9].*[0-9]\") %>%                  # extrai as datas (números)\n  ymd() %>%                                        # converte números pra datas (assumindo o formato ano-mês-dia)\n  which.max() %>%                                  # pega o índice da maior data (arquivo mais recente) \n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # retorna o nome do arquivo da linelist mais recente\n\nlatest_file  # mostra o nome do arquivo do artigo mais recente## [1] \"case_linelist_2020-10-08.xlsx\"\nhere(\"dados\", \"example\", \"linelists\", latest_file) \n# importar\nimport(here(\"dados\", \"example\", \"linelists\", latest_file)) # import "},{"path":"importing.html","id":"use-as-informações-do-arquivo","chapter":"7 Importar e exportar","heading":"Use as informações do arquivo","text":"Se seus arquivos não tiverem datas em seus nomes (ou se você não confiar nessas datas), você pode tentar extrair data da última modificação dos metadados arquivo. Use funções pacote fs para examinar informações dos metadados de cada arquivo, que incluem o tempo da última modificação e o caminho arquivo.Abaixo, fornecemos pasta de interesse para fs’s dir_info(). Neste caso, pasta de interesse está projeto R na pasta “dados”, na subpasta “exemplo” e em sua subpasta “linelists”. O resultado é um data frame com uma linha por arquivo e colunas para modification_time',path’, etc. Você pode ver um exemplo visual disto na página em interações de diretório.Podemos ordenar este data frame de arquivos pela coluna modification_time, e então manter apenas linha superior/última linha (arquivo) com função R base* head(). Então podemos extrair o caminho arquivo deste último arquivo somente com função dplyr* pull() na coluna path. Finalmente, podemos passar este caminho de arquivo para import(). O arquivo importado é salvo como latest_file.","code":"\nlatest_file <- dir_info(here(\"dados\", \"examplo\", \"linelists\")) %>%  # coleta dados sobre todos os arquivos no diretório\n  arrange(desc(modification_time)) %>%      # classifica por data da última modificação\n  head(1) %>%                               # mantém apenas o arquivo modificado por último\n  pull(path) %>%                            # extrai apenas o endereço do arquivo\n  import()                                  # importa o arquivo"},{"path":"importing.html","id":"import_api","chapter":"7 Importar e exportar","heading":"7.10 APIs","text":"Uma “Interface de Programação Automatizada” (API) pode ser usada para solicitar dados diretamente de um website. APIs são um conjunto de regras que permitem que uma aplicação de software interaja com outra. O cliente (você) envia uma “solicitação” e recebe uma “resposta” contendo o conteúdo. Os pacotes R httr e jsonlite* podem facilitar este processo.Cada website habilitado para API terá sua própria documentação e especificações para se familiarizar. Alguns sites estão disponíveis publicamente e podem ser acessados por qualquer pessoa. Outros, tais como plataformas com IDs de usuário e credenciais, requerem autenticação para acessar seus dados.Não é preciso dizer que é necessário ter uma conexão com Internet para importar dados via API. Daremos breves exemplos de uso de APIs para importar dados e conectá-lo outros recursos.Note: lembre-se que os dados podem ser postados* em um website sem API, o que pode ser mais fácil de ser recuperado. Por exemplo, um arquivo CSV postado pode ser acessível simplesmente fornecendo URL site para import() como descrito na seção sobre importação de Github.*","code":""},{"path":"importing.html","id":"requisição-http","chapter":"7 Importar e exportar","heading":"Requisição HTTP","text":"troca de API é mais comumente feita através de uma solicitação HTTP. HTTP é o Protocolo de Transferência de Hipertexto, e é o formato subjacente de uma solicitação/resposta entre um cliente e um servidor. entrada e saída exata pode variar dependendo tipo de API, mas o processo é o mesmo - uma “Solicitação” (geralmente Solicitação HTTP) usuário, muitas vezes contendo uma consulta, seguida por uma “Resposta”, contendo informações de status sobre solicitação e possivelmente o conteúdo solicitado.Aqui estão alguns componentes de uma solicitação HTTP:URL endpoint da APIO “Método” (ou “Verbo”)CabeçalhosCorpoO “método” de solicitação HTTP é ação que você deseja realizar. Os dois métodos HTTP mais comuns são GET e POST, mas outros poderiam incluir PUT, DELETE, PATCH, etc. Ao importar dados para R, é mais provável que você utilize GET.Após sua solicitação, seu computador receberá uma “resposta” em um formato similar ao que você enviou, incluindo URL, status HTTP (Status 200 é o que você quer!), tipo de arquivo, tamanho e o conteúdo desejado. Você precisará então analisar esta resposta e transformá-la em um data frame funcional dentro de seu ambiente R.","code":""},{"path":"importing.html","id":"pacotes","chapter":"7 Importar e exportar","heading":"Pacotes","text":"O pacote httr funciona bem para lidar com solicitações HTTP em R. Ele requer pouco conhecimento prévio de APIs Web e pode ser usado por pessoas menos familiarizadas com terminologia de desenvolvimento de software. Além disso, se resposta HTTP .json, você pode usar jsonlite para analisar resposta.","code":"\n# carrega pacotes\npacman::p_load(httr, jsonlite, tidyverse)"},{"path":"importing.html","id":"dados-públicos","chapter":"7 Importar e exportar","heading":"Dados públicos","text":"Abaixo é um exemplo de uma solicitação de HTTP, originalmente de um tutorial Trafford Data Lab. Esse site têm vários outros recursos para aprender esse tema e exercícios sobre API.Cenário: nós queremos importar uma lista de restaurantes fast food na cidade de Trafford, Reino Unido. Os dados podem ser acessados pela API da Food Standards Agency, que disponibiliza dados e classificações acerca de hiigiene alimentar Reino Unido.OAqui estão os parâmetros para nossa solicitação:HTTP verb: GETAPI endpoint URL: http://api.ratings.food.gov.uk/EstablishmentsParâmetros selecionados: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityIdCabeçalho: “x-api-version”, 2Formato(s) dos dados: JSON, XMLDocumentação: http://api.ratings.food.gov.uk/helpO código R seria como seguinte:Agora você pode limpar e utilizar o data frame resposta (response), que contém uma linha por estabelecimento de fast food.","code":"\n# prepare a solicitação\npath <- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest <- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# cheque para algum erro no servidor (\"200\" é bom!)\nrequest$status_code\n\n# submita a solicitação, separe a resposta, e converta para um data frame  \n\nresponse <- content(request, as = \"text\", encoding = \"UTF-8\") %>%\n  fromJSON(flatten = TRUE) %>%\n  pluck(\"establishments\") %>%\n  as_tibble()"},{"path":"importing.html","id":"autenticação-necessária","chapter":"7 Importar e exportar","heading":"Autenticação necessária","text":"Algumas APIs requerem autenticação - para que você possa provar quem você é, para que possa acessar dados restritos. Para importar estes dados, você pode precisar primeiro usar um método POST para fornecer um nome de usuário, senha, ou código. Isto retornará um token de acesso, que pode ser usado para solicitações posteriores método GET para recuperar os dados desejados.Abaixo está um exemplo de consulta de dados Go.Data, que é uma ferramenta de investigação de surtos. Go.Data usa uma API para todas interações entre o front-end da web e os aplicativos smartphone usados para coleta de dados. O Go.Data é usado em todo o mundo. Como os dados surto são sensíveis e você só deve ser capaz de acessar os dados para seu surto, autenticação é necessária.Abaixo estão alguns exemplos de código R usando httr e jsonlite para conexão com API Go.Data para importar dados sobre o acompanhamento de contato de seu surto.CUIDADO: Se você estiver importando grandes quantidades de dados de um API que requeira autenticação, poderá haver um intervalo de tempo. Para evitar isto, recupere o access_token novamente antes de cada solicitação GET API e tente usar filtros ou limites na consulta.DICA: função fromJSON() pacote jsonlite não desalinha totalmente na primeira vez em que é executada, então você provavelmente ainda terá itens de lista em seu tibble resultante. Você precisará des-nidificar ainda mais para certas variáveis; dependendo de como seu .json está aninhado. Para ver mais informações sobre isto, veja documentação pacote jsonlite, como função flatten(). Para mais detalhes, Veja documentação em LoopBack Explorer, página Rastreamento de Contatos ou dicas de API em Go.Data Github repositoryVocê pode ler mais sobre o pacote httr aquiEsta seção também foi informada por este tutorial e este tutorial.","code":"\n# configure as credenciais para a autorização \nurl <- \"https://godatasampleURL.int/\"           # instânica url Go.Data válida\nusername <- \"username\"                          # nome de usuário do Go.Data válido\npassword <- \"password\"                          # senha do Go.Data válida\noutbreak_id <- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # ID do surto do Go.Data outbreak válida\n\n# obtenha o token de acesso\nurl_request <- paste0(url,\"api/oauth/token?access_token=123\") # defina a solicitação da url base \n\n# prepare a solicitação\nresponse <- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # use o nome de usuario e senha salvos acima para autorizar \n    password = password),                                       \n    encode = \"json\")\n\n# execute a rolicitação e separe a resposta \ncontent <-\n  content(response, as = \"text\") %>%\n  fromJSON(flatten = TRUE) %>%          # flatten nested JSON\n  glimpse()\n\n# Salve o token de acesso da resposta \naccess_token <- content$access_token    #  salve o token de acesso para permitir as chamadas subsequentes abaixo \n\n# importat os contatos dos surtos \n# Use o token de access \nresponse_contacts <- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # OBTENHA (GET) a solicitação\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts <- content(response_contacts, as = \"text\")         # converta para texto JSON\n\ncontacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # \"achate\" o JSON para um tibble"},{"path":"importing.html","id":"exportar","chapter":"7 Importar e exportar","heading":"7.11 Exportar","text":"","code":""},{"path":"importing.html","id":"com-o-pacote-rio-.não-numerado","chapter":"7 Importar e exportar","heading":"7.11.1 Com o pacote rio {.não numerado}","text":"Com rio*, você pode utilizar função export() de uma forma muito semelhante à import(). Primeiro dê o nome objeto R que você deseja salvar (por exemplo, linelist) e depois, entre aspas, coloque o caminho arquivo onde você deseja salvar o arquivo, incluindo o nome arquivo desejado e extensão arquivo. Por exemplo, o nome objeto R:Isto salva o data frame linelist como uma pasta de trabalho Excel para pasta raiz diretório de trabalho/R projeto:Você poderia salvar o mesmo data frame que um arquivo csv, alterando extensão. Por exemplo, nós também o salvamos em um caminho de arquivo construído com aqui():","code":"\nexport(linelist, \"my_linelist.xlsx\") # will save to working directory\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.csv\"))"},{"path":"importing.html","id":"para-a-área-de-transferência","chapter":"7 Importar e exportar","heading":"Para a área de transferência","text":"Para exportar um data frame para “área de transferência” seu computador (para depois colar em outro software como Excel, Google Spreadsheets, etc.) você pode utilizar write_clip() pacote clipr*.","code":"\n# exporte a linelist para a área de transferência do seu sistema\nclipr::write_clip(linelist)"},{"path":"importing.html","id":"import_rds","chapter":"7 Importar e exportar","heading":"7.12 Arquivos RDS","text":"Junto com .csv, .xlsx, etc., você também pode exportar/vendar data frame R como arquivos .rds. Este é um formato de arquivo específico para R, e é muito útil se você souber que irá trabalhar com os dados exportados novamente em R.classes de colunas são armazenadas, de modo que você não terá que limpar novamente quando importado (com um arquivo Excel ou mesmo um arquivo CSV isto pode ser uma dor de cabeça!). É também um arquivo menor, que é útil para exportação e importação se seu conjunto de dados grande.Por exemplo, se você trabalha em uma equipe de Epidemiologia e precisa enviar arquivos para uma equipe GIS para mapeamento, e eles usam R também, basta enviar-lhes o arquivo .rds! Então todas classes de colunas são mantidas e têm menos trabalho fazer.","code":"\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.rds\"))"},{"path":"importing.html","id":"import_rdata","chapter":"7 Importar e exportar","heading":"7.13 Arquivos e listas Rdata","text":"Arquivos tipo .Rdata cpode armazenar múltiplos objetos R - por exemplo, múltiplos data frames, resultados de modelos, listas, etc. Isto pode ser muito útil para consolidar ou compartilhar muitos de seus dados para um determinado projeto.exemplo abaixo, múltiplos objetos R são armazenados dentro arquivo exportado “my_objects.Rdata”:Nota: se você estiver tentando importar uma lista, utilize import_list() de rio para importá-la com estrutura e o conteúdo original completo.","code":"\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\nrio::import_list(\"my_list.Rdata\")"},{"path":"importing.html","id":"salvando-gráficos","chapter":"7 Importar e exportar","heading":"7.14 Salvando gráficos","text":"Instruções em como salvar gráficos, incluindo os criados pelo pacote ggplot(), são discutidos com profundidado na página ggplot basics.Em resumo, execute o código ggsave(\"my_plot_filepath_and_name.png\") após exibir o seu gráfico. Você pode prover um objeto de gráfico para o argumento plot =, ou especificar o endereço de salvamento (com extensão de arquivo desejada) para salvar o último gráfico exibido. Você pode tamb[ém controlar o tamanho e qualidade por meio dos argumentos: width =, height =, units = e dpi =.Como salvar um gráfico de redes, como uma árvore de transmissão, é discutido na página Cadeias de Transmissão.","code":""},{"path":"importing.html","id":"recursos-1","chapter":"7 Importar e exportar","heading":"7.15 Recursos","text":"O Manual de Importação/Exportação de Dados RR 4 Capítulo de ciência dos dados sobre importação de dadosdocumentação ggsave()Abaixo está uma tabela, extraída rio online vinheta. Para cada tipo de dado ele mostra: extensão de arquivo esperada, o pacote rio* utilizado para importar ou exportar os dados, e se esta funcionalidade está incluída na versão instalada padrão rio.Formato | Extensão típica | Pacote de Importação | Pacote de exportação | Instalado por padrão\n—————————_|—————–|————————|———————-|———————\nDados separados por vírgulas | .csv | data.table fread() | data.table | Sim\nDados separados por Pipe | .psv | data.table fread() | data.table | Sim\nDados separados por Tab .tsv | data.table fread() | data.table | Sim\nSAS | .sas7bdat | haven | haven | Sim\nSPSS | .sav | haven | haven | Sim\nStata | .dta | haven | haven | Sim\nSAS | XPORT | .xpt | haven | haven | Sim\nSPSS Portable | .por | haven | | Sim\nExcel | .xls | readxl | | Sim\nExcel | .xlsx | readxl | openxlsx | Sim\nR syntax | .R | base | base | Sim\nObjetos R salvos | .RData, .rda | base | base | Sim\nObjetos R seriados | .rds | base | base | Sim\nEpiinfo | .rec | foreign | | Sim\nMinitab | .mtp | foreign | | Sim\nSystat | .syd | foreign | | Sim\n“XBASE” | database files | .dbf | foreign | foreign | Sim\nWeka Attribute-Relation File Format | .arff | foreign | foreign | Sim\nDados formato de intercâmbio| .dif | utils | | Sim\nDados Fortran da | recognized extension | utils | | Sim\nDados formato largura fixa | .fwf | utils | utils | Sim\ndados separados por vírgulas gzip | .csv.gz | utils | utils | v\nCSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | Não\nEViews | .wf1 |hexView | | Não\nFormato de intercâmbio Feather R/Python | .feather | feather | feather | Não\nFast Storage | .fst | fst | fst | Não\nJSON | .json | jsonlite | jsonlite | Não\nMatlab | .mat | rmatio | rmatio | Não\nPlanilhas OpenDocument | .ods | readODS | readODS | Não\nTabelas HTML | .html | xml2 | xml2 | Não\nDocumentos Shallow XML | .xml | xml2 | xml2 | Não\nYAML | .yml | yaml | yaml | Não\nPadrão da área de transferência é tsv | | clipr | clipr | Não","code":""},{"path":"cleaning.html","id":"cleaning","chapter":"8 Limpeza de dados e principais funções","heading":"8 Limpeza de dados e principais funções","text":"Esta página demonstra passos comuns usados processo de “limpeza” de um conjunto de dados, e também explica o uso de muitas funções essenciais de gerenciamento de dados.Para demonstrar limpeza de dados, esta página começa por importar um conjunto de dados brutos de uma lista de casos, e realiza passo--passo o processo de limpeza. código R, isto se manifesta com uma cadeia “pipe”, qual faz referência ao operador “pipe” %>%` que passa um conjunto de dados de uma operação para próxima.","code":""},{"path":"cleaning.html","id":"funções-essenciais","chapter":"8 Limpeza de dados e principais funções","heading":"Funções essenciais","text":"Este manual emfatiza utilização das funções da família de pacotes tidyversedo R. funções essenciais R demonstradas nesta página estão listadas abaixo.Muitas destas funções pertencem ao pacote R dplyr, que fornece funções “verbo” para resolver desafios de manipulação de dados (o nome é uma referência um “dataframe-plier (N.T.: plier significa alicate, fazendo uma analogia da funcionalidade dessa ferramenta sobre um dataframe). O pacote dplyr é parte da família de pacotes tidyverse R (os quais também incluem ggplot2, tidyr, stringr, tibble, purrr, magrittr, e forcats entre outros).Se quiser ver como estas funções se comparam aos comandos Stata ou SAS, consulte página em Transição para o R.Você poderá encontrar uma estrutura alternativa de gestão de dados partir pacote R data.table com operadores como := e utilização frequente de colchetes [ ]. Estas abordagem e sintaxe são brevemente explicadas na página Tabela de dados.","code":""},{"path":"cleaning.html","id":"nomenclatura-1","chapter":"8 Limpeza de dados e principais funções","heading":"Nomenclatura","text":"Neste manual, utilizamos os termos “colunas” e “linhas” em vez de “variáveis” e “observações”. Como explicado neste manual sobre “dados arrumados”, maioria dos conjuntos de dados estatísticos epidemiológicos consistem estruturalmente em linhas, colunas e valores.Variáveis contêm os valores que medem o mesmo atributo subjacente (como o faixa-etária, desfecho, ou data de início). Observações contêm todos os valores medidos na mesma unidade (por exemplo, uma pessoa, local, ou amostra de laboratório). Portanto, estes aspectos podem ser mais difíceis de definir de forma tangível.Em um conjunto de dados “arrumados”, cada coluna é uma variável, cada linha é uma observação, e cada célula é um único valor. Contudo, alguns conjuntos de dados que você encontra não se enquadrarão neste molde - um conjunto de dados de formato “amplo” (wide) pode ter uma variável dividida em várias colunas (ver um exemplo na página Pivotando Dados). Da mesma forma, observações podem ser divididas em várias linhas.maior parte deste manual trata da gestão e transformação de dados, referindo assim à estrutura concreta dos dados de linhas e colunas é mais relevante que utilizar os termos observações/variáveis, que são mais abstratos. exceções ocorrem principalmente em páginas sobre análise de dados, onde se verá mais referências variáveis e observações.","code":""},{"path":"cleaning.html","id":"conduta-de-limpeza","chapter":"8 Limpeza de dados e principais funções","heading":"8.1 Conduta de limpeza","text":"Esta página prossegue através das típicas etapas de limpeza, adicionando-sequencialmente uma cadeia de pipe de limpeza.Na análise epidemiológica e processamento de dados, etapas de limpeza são frequentemente executadas sequencialmente, ligadas entre si. R, isto manifesta-se frequentemente como um “pipeline” de limpeza, onde o conjunto de dados bruto é passado ou “canalizado” de uma etapa de limpeza para outra.Tais cadeias utilizam funções “verbo” dplyr e o operador pipe ‘%>%’ magrittr. Esta pipe começa com os dados “brutos” (“linelist_raw.xlsx”) e termina com um data frame de R “limpo” (linelist) que pode ser utilizada, guardada, exportada, etc.Em uma cadeia de limpeza, ordem das etapas é importante. etapas de limpeza podem incluir:Importação de dadosNomes de colunas limpos ou alteradosRemoção de duplicidadesCriação e transformação de colunas (por exemplo, re-codificação ou normalização de valores)Linhas filtradas ou adicionadas","code":""},{"path":"cleaning.html","id":"carregar-pacotes","chapter":"8 Limpeza de dados e principais funções","heading":"8.2 Carregar pacotes","text":"Este pedaço de código mostra o carregamento das pacotes necessários para análises. Neste manual, damos ênfase p_load() pacman, que instala o pacote se necessário e carrega-o para uso. Você pode também carregar pacotes instalados com library() R base. Veja página Introdução ao R para mais informações pacotes R.","code":"\npacman::p_load(\n  rio,        # importação de dados  \n  here,       # caminhos de arquicos relacionados\n  janitor,    # limpeza de dados e tabelas\n  lubridate,  # trabalhando com datas\n  matchmaker, # limpeza baseada no dicionário\n  epikit,     # funções de age_categories() \n  tidyverse,  # manejo e visualização de dados\n  skimr\n)"},{"path":"cleaning.html","id":"importação-de-dados","chapter":"8 Limpeza de dados e principais funções","heading":"8.3 Importação de dados","text":"","code":""},{"path":"cleaning.html","id":"importação","chapter":"8 Limpeza de dados e principais funções","heading":"Importação","text":"Aqui nós importamos o arquivo de Excel linelist de casos “brutos” usando função import() pacote rio. O pacote rio trata de forma flexível muitos tipos de arquivos (por ex. .xlsx, .csv, .tsv, .rds. Ver página em Importar e exportar para mais informações e dicas sobre situações não usuais (por exemplo, saltar linhas, definir valores em falta, importar Google sheets, etc.)Se quiser acompanhar, clique para descarregar linelist “bruta” (como arquivo .xlsx).Se o seu conjunto de dados grande e demorar muito tempo importar, pode ser útil que o comando de importação seja separado da cadeia pipe e que o “bruto” seja guardado como um arquivo distinto. Isto também permite uma comparação fácil entre versão original e versão limpa.Abaixo, importamos o arquivo bruto Excel e o salvamos como o dataframe linelist_raw. Presumimos que o arquivo esteja localizado diretório de trabalho ou na raiz projeto R e, portanto, nenhuma subpasta é especificada caminho arquivo.Você pode visualizar primeiras 50 linhas quadro de dados abaixo. Nota: função contida pacote R base head(n) permite que você visualize apenas primeiras n linhas console R.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\")"},{"path":"cleaning.html","id":"revisão","chapter":"8 Limpeza de dados e principais funções","heading":"Revisão","text":"Você pode usar função skim() pacote skimr para obter uma visão geral de todo o dataframe (ver página em Tabelas descritivas para mais informações). colunas são resumidas por classe/tipo, como caractere, numérico. Nota: “POSIXct” é um tipo de classe de data bruta (ver Trabalhando com datas).\nTable 8.1: Data summary\nVariable type: characterVariable type: numericVariable type: POSIXct","code":"\nskimr::skim(linelist_raw)"},{"path":"cleaning.html","id":"nomes-de-colunas","chapter":"8 Limpeza de dados e principais funções","heading":"8.4 Nomes de colunas","text":"R, os nomes das colunas são o “cabeçalho” ou valor “topo” de uma coluna. Eles são usados para referir colunas em código, e serve como um rotulo por omissão nas figuras.Outros softwares estatísticos como SAS e STATA utilizam “etiquetas” que coexistem como versões impressas mais longas dos nomes das colunas mais curtas. Embora o R ofereça possibilidade de adicionar etiquetas de coluna aos dados, isto não é enfatizado na maioria das práticas. Para que os nomes das colunas sejam “amigáveis para impressão” de figuras, normalmente se ajusta sua exibição dentro dos próprios comandos de criação dos gráficos e tabelas (por exemplo, títulos de eixos ou legendas de um gráfico, ou cabeçalhos de coluna em uma tabela impressa - veja seção de escalas da página de dicas ggplot e páginas de Tabelas para apresentação). Se você quiser atribuir etiquetas de coluna nos dados, leia mais online aqui e aqui.Como os nomes de colunas R são usados muito frequentemente, então eles devem ter uma sintaxe “limpa”. Nós sugerimos o seguinte:Nomes curtosSem espaços (substituir com sublinhados _ )Sem caracteres especiais (&, #, <, >, …)Nomenclatura de estilo similar (por exemplo, todas colunas de datas nomeadas como data_início, data_relato, data_morte…)Os nomes das colunas de linelist_raw são “printados” abaixo utilizando names() R base. Podemos ver isso inicialmente:Alguns nomes contêm espaços (por exemplo data de infeccção infecction date )Diferentes padrões de nomes são utilizados para datas (data de início vs data de infecção, date onset vs. infecction date)Deve ter havido um cabeçalho combinado nas duas últimas colunas .xlsx. Sabemos disso porque o nome de duas colunas combinadas (“merged_header”) foi atribuído pelo R à primeira coluna, e à segunda coluna foi atribuído um nome de espaço reservado “…28” (pois estava então vazia e é 28ª coluna).NOTA: Para referenciar um nome de coluna que inclua espaços, rodeie o nome com o acentro grave (N.T. chamado vulgarmente de “crase”), por exemplo: linelist$` '\\x60infection date\\x60'`. Note que seu teclado, o acento grave (`) é diferente das aspas simples/apóstrofe (’).","code":"\nnames(linelist_raw)##  [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"     \n##  [5] \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n##  [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n## [13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n## [17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n## [21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n## [25] \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\""},{"path":"cleaning.html","id":"limpeza-automática","chapter":"8 Limpeza de dados e principais funções","heading":"Limpeza automática","text":"função clean_names() pacote janitor padroniza os nomes das colunas e os torna únicos ao fazer o seguinte:Converte todos os nomes para consistir apenas em sublinhados, números e letrasOs caracteres acentuados são transliterados para ASCII (por exemplo, german o com umlaut torna-se “o”, “enye” espanhol torna-se “n”)preferência de capitalização para os nomes das novas colunas pode ser especificada utilizando o argumento case = argumento (“snake” é padrão, alternativas incluem “sentence”, “title”, “small_camel”…)Você pode especificar substituições específicas de nomes fornecendo um vetor para o argumento replace = argumento (por exemplo, replace = c(onset = \"date_of_onset\"))Aqui está uma vinheta online.seguir, linha de limpeza começa utilizando clean_names() na linelist bruta.NOTA: O nome da última coluna “…28” foi mudado para “x28”.","code":"\n# pipe do conjunto de dados brutos através da função clean_names(), atribuindo o resultado como \"linelist\"  \nlinelist <- linelist_raw %>% \n  janitor::clean_names()\n\n# Veja os novos nomes das colunas\nnames(linelist)##  [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"     \n##  [5] \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n##  [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n## [13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n## [17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n## [21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n## [25] \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\""},{"path":"cleaning.html","id":"limpeza-manual-de-nomes","chapter":"8 Limpeza de dados e principais funções","heading":"Limpeza manual de nomes","text":"renomeação manual das colunas é frequentemente necessária, mesmo após etapa de padronização acima. Abaixo, renomeação é realizada utilizando função rename() pacote dplyr, como parte de uma cadeia pipe. função rename() utiliza o estilo NOVO = VELHO - o novo nome da coluna é dado antes nome da coluna antiga.Abaixo, um comando de renomeação é adicionado linha de pipe limpa. Espaços foram adicionados estrategicamente para alinhar o código para facilitar leitura.Agora você pode ver que os nomes das colunas está sendo mudado:","code":"\n# CADEIA 'PIPE' DE LIMPEZA\n# (inicia com dados brutos e encadeia funções com o pipe até a limpeza dos dados)\n##################################################################################\nlinelist <- linelist_raw %>%\n    \n    # padronização da sintaxe do nome de coluna \n    janitor::clean_names() %>% \n    \n    # colunas renomeadas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)##  [1] \"case_id\"              \"generation\"           \"date_infection\"      \n##  [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n##  [7] \"outcome\"              \"gender\"               \"hospital\"            \n## [10] \"lon\"                  \"lat\"                  \"infector\"            \n## [13] \"source\"               \"age\"                  \"age_unit\"            \n## [16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n## [19] \"ct_blood\"             \"fever\"                \"chills\"              \n## [22] \"cough\"                \"aches\"                \"vomit\"               \n## [25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n## [28] \"x28\""},{"path":"cleaning.html","id":"renomear-a-posição-da-coluna","chapter":"8 Limpeza de dados e principais funções","heading":"Renomear a posição da coluna","text":"Você pode também renomear pela posição da coluna, ao invés nome da coluna, por exemplo:","code":"\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)"},{"path":"cleaning.html","id":"renomear-via-select-e-summarise","chapter":"8 Limpeza de dados e principais funções","heading":"Renomear via select() e summarise()","text":"Como um atalho, você também pode renomear colunas dentro das funções dplyr select() e summarise(). select() é utilizada para manter apenas certas colunas (e é abordada mais adiante nesta página). summarise() é coberta nas páginas Agrupamento de dados e Tabelas descritivas. Estas funções também utilizam o formato novo_nome = antigo_nome. Aqui está um exemplo:","code":"\nlinelist_raw %>% \n  select(# NOVO nome             # nome VELHO\n         date_infection       = `infection date`,    # renomear e MANTER APENAS estas colunas\n         date_hospitalisation = `hosp date`)"},{"path":"cleaning.html","id":"outros-desafios","chapter":"8 Limpeza de dados e principais funções","heading":"Outros desafios","text":"","code":""},{"path":"cleaning.html","id":"nomes-de-colunas-excel-vazias","chapter":"8 Limpeza de dados e principais funções","heading":"Nomes de colunas Excel vazias","text":"O R não pode ter colunas de conjuntos de dados que não tenham nomes de colunas (cabeçalhos). Portanto, se você importar um conjunto de dados Excel com dados mas sem cabeçalhos de colunas, o R preencherá os cabeçalhos com nomes como “…1” ou “…2”. O número representa o número da coluna (por exemplo, se 4ª coluna conjunto de dados não tiver cabeçalho, então R lhe dará o nome “…4”).Você pode limpar estes nomes manualmente referenciando o número de posição (ver exemplo acima), ou seu nome atribuído (linelist_raw$...1).","code":""},{"path":"cleaning.html","id":"nomes-de-colunas-e-células-de-excel-combinado","chapter":"8 Limpeza de dados e principais funções","heading":"Nomes de colunas e células de Excel combinado","text":"células combinadas em um arquivo Excel são uma ocorrência comum recebimento de dados. Como explicado em Transição para R, células combinadas podem ser agradáveis para leitura humana de dados, mas não são “dados arrumados” e causam muitos problemas para leitura de dados pela máquina. O R não pode acomodar células combinadas.Lembre pessoas que fazem entrada de dados que dados legíveis por humanos não é o mesmo que dados legíveis por máquinas. Esforce-se para treinar os usuários sobre os princípios de dados arrumados. Se possível, tente mudar os procedimentos para que os dados cheguem em um formato ordenado sem células combinadas.Cada variável deve ter sua própria coluna.Cada observação deve ter sua própria linha.Cada valor deve ter sua própria célula.Ao utilizar função import() rio, o valor em uma célula mesclada será atribuído à primeira célula e células subsequentes estarão vazias.Uma solução para lidar com células mescladas é importar os dados com função readWorkbook() pacote openxlsx. Defina o argumento fillMergedCells = TRUE. Isto dá o valor em uma célula mesclada todas células dentro da faixa mesclada.ATENÇÃO: Se os nomes das colunas forem mesclados com readWorkbook(), você terminará com nomes de colunas duplicadas, que você precisará corrigir manualmente - o R não funciona bem com nomes de colunas duplicadas! Você pode renomeá-los referenciando sua posição (por exemplo, coluna 5), como explicado na seção sobre limpeza manual de nomes de colunas","code":"\nlinelist_raw <- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)"},{"path":"cleaning.html","id":"selecionar-ou-reordenar-colunas","chapter":"8 Limpeza de dados e principais funções","heading":"8.5 Selecionar ou reordenar colunas","text":"Utilize select() dplyr para selecionar colunas que você deseja reter e especificar sua ordem quadro de dados,CUIDADO: Nos exemplos abaixo, o quadro de dados linelist é modificado com select() e exibido, mas não salvo. Isto é para fins de demonstração. Os nomes das colunas modificadas são exibidos ao fornecer banco de dados com o pipe para função names().Aqui estão TODOS os nomes que linelist tem até este ponto da cadeia de limpeza:","code":"\nnames(linelist)##  [1] \"case_id\"              \"generation\"           \"date_infection\"      \n##  [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n##  [7] \"outcome\"              \"gender\"               \"hospital\"            \n## [10] \"lon\"                  \"lat\"                  \"infector\"            \n## [13] \"source\"               \"age\"                  \"age_unit\"            \n## [16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n## [19] \"ct_blood\"             \"fever\"                \"chills\"              \n## [22] \"cough\"                \"aches\"                \"vomit\"               \n## [25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n## [28] \"x28\""},{"path":"cleaning.html","id":"manter-colunas","chapter":"8 Limpeza de dados e principais funções","heading":"Manter colunas","text":"Selecione apenas colunas que você quer manterColoque seus nomes comando select(), sem aspas. Eles aparecerão data frame na ordem que você fornecer. Observe que se você incluir uma coluna que não existe, o R retornará um erro (veja o uso de any_of() abaixo se você não quiser nenhum erro nesta situação).","code":"\n# O conjunto de dados linelist é canalisado através do comando select(), e names() \"printam\" apenas os nomes das colunas\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, fever) %>% \n  names()  # exibir os nomes das colunas## [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\n## [4] \"fever\""},{"path":"cleaning.html","id":"clean_tidyselect","chapter":"8 Limpeza de dados e principais funções","heading":"Funções auxiliares “tidyselect”","text":"Estas funções de ajuda existem para facilitar especificação de colunas para manter, descartar ou transformar. Elas são pacote tidyselect, que está incluído tidyverse e está subjacente à forma como colunas são selecionadas nas funções dplyr.Por exemplo, se você quiser reordenar colunas, everything() é uma função útil para significar “todas outras colunas ainda não mencionadas”. O comando abaixo move colunas date_onset e date_hospitalisation para o início (esquerda) conjunto de dados, mas mantém todas outras colunas depois. Note que everything() é escrito com parênteses vazios:Aqui estão outras funções auxiliares “tidyselect” que também trabalham dentro das funções dplyr como select(), across(), e summarise():everything() - todas outras colunas não mencionadaseverything() - todas outras colunas não mencionadaslast_col() - última colunalast_col() - última colunawhere() - aplica uma função todas colunas e seleciona aquelas para quais função retorna TRUE (verdadeiro)() - aplica uma função todas colunas e seleciona aquelas para quais função retorna TRUE (verdadeiro)contains() - colunas contendo uma cadeia de caracteres\nexemplo: select(contains(\"time\"))\ncontains() - colunas contendo uma cadeia de caracteresexemplo: select(contains(\"time\"))starts_with() - corresponde um prefixo especificado\nexemplo: select(starts_with(\"date_\"))\nstarts_with() - corresponde um prefixo especificadoexemplo: select(starts_with(\"date_\"))ends_with() - corresponde um sufixo especificado\nexemplo: select(ends_with(\"_post\"))\nends_with() - corresponde um sufixo especificadoexemplo: select(ends_with(\"_post\"))matches() - para aplicar uma expressão regular (regex)\nexemplo: select(matches(\"[pt]al\"))\nmatches() - para aplicar uma expressão regular (regex)exemplo: select(matches(\"[pt]al\"))num_range() - uma faixa numérica como x01, x02, x03num_range() - uma faixa numérica como x01, x02, x03any_of() - faz correspondência SE coluna existir, mas não retorna nenhum erro se não encontrada\nexemplo: select(any_of(date_onset, date_death, cardiac_arrest))\nany_of() - faz correspondência SE coluna existir, mas não retorna nenhum erro se não encontradaexemplo: select(any_of(date_onset, date_death, cardiac_arrest))Além disso, utilizar operadores normais como c() para listar várias colunas, : para colunas consecutivas, ! para o oposto, & para , e | para .Utilize () para especificar critérios lógicos para colunas. Se fornecer uma função dentro de (), não inclua os parênteses vazios da função. O comando abaixo seleciona colunas que são de classe Numérica.Utilize contains() para selecionar apenas colunas nas quais o nome da coluna contém uma cadeia de caracteres especificada. Os ends_with() e starts_with() fornecem mais nuances.função matches() funciona de forma semelhante contains() mas pode ser fornecida uma expressão regular (ver página em Caracteres e strings), tais como múltiplos strings separados por “barras de OU” dentro dos parênteses:CUIDADO: Se um nome de coluna que você fornecer especificamente não existir nos dados, ele pode retornar um erro e parar seu código. Considere utilizar any_of() para citar colunas que podem ou não existir, especialmente úteis em seleções negativas (remoção).Apenas uma destas colunas existe, mas nenhum erro é produzido e o código continua sem parar sua cadeia de limpeza.","code":"\n# mova date_onset e date_hospitalisation para o início\nlinelist %>% \n  select(date_onset, date_hospitalisation, everything()) %>% \n  names()##  [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"             \n##  [4] \"generation\"           \"date_infection\"       \"date_outcome\"        \n##  [7] \"outcome\"              \"gender\"               \"hospital\"            \n## [10] \"lon\"                  \"lat\"                  \"infector\"            \n## [13] \"source\"               \"age\"                  \"age_unit\"            \n## [16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n## [19] \"ct_blood\"             \"fever\"                \"chills\"              \n## [22] \"cough\"                \"aches\"                \"vomit\"               \n## [25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n## [28] \"x28\"\n# selecione colunas que são a classe numérica\nlinelist %>% \n  select(where(is.numeric)) %>% \n  names()## [1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"      \"ht_cm\"     \n## [7] \"ct_blood\"   \"temp\"\n# selecione colunas contendo certos caracteres\nlinelist %>% \n  select(contains(\"date\")) %>% \n  names()## [1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n## [4] \"date_outcome\"\n# procurado por combinações de caracteres múltiplos\nlinelist %>% \n  select(matches(\"onset|hosp|fev\")) %>%   # note o símbolo OR \"|\"\n  names()## [1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"            \n## [4] \"fever\"\nlinelist %>% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %>% \n  names()## [1] \"date_onset\""},{"path":"cleaning.html","id":"remova-colunas","chapter":"8 Limpeza de dados e principais funções","heading":"Remova colunas","text":"Indicar quais colunas devem ser removidas colocando um símbolo menos “-” na frente nome da coluna (por exemplo,select(-outcome)), ou um vetor de nomes de colunas (como abaixo). Todas outras colunas serão retidas.Você também pode remover uma coluna utilizando síntaxe R base, definindo-como NULL. Por exemplo:","code":"\nlinelist %>% \n  select(-c(date_onset, fever:vomit)) %>% # remova date_onset e todas as colunas de febre a vômito\n  names()##  [1] \"case_id\"              \"generation\"           \"date_infection\"      \n##  [4] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n##  [7] \"gender\"               \"hospital\"             \"lon\"                 \n## [10] \"lat\"                  \"infector\"             \"source\"              \n## [13] \"age\"                  \"age_unit\"             \"row_num\"             \n## [16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"            \n## [19] \"temp\"                 \"time_admission\"       \"merged_header\"       \n## [22] \"x28\"\nlinelist$date_onset <- NULL   # elimina a coluna com a síntaxe da base do R "},{"path":"cleaning.html","id":"autonomia","chapter":"8 Limpeza de dados e principais funções","heading":"Autonomia","text":"select() também pode ser utilizado como um comando independente (não em uma cadeia de pipe). Neste caso, o primeiro argumento é o dataframe original ser operado.","code":"\n# Criar uma nova linelist com colunas relacionadas a id e idade\nlinelist_age <- select(linelist, case_id, contains(\"age\"))\n\n# exiba os nomes das colunas\nnames(linelist_age)## [1] \"case_id\"  \"age\"      \"age_unit\""},{"path":"cleaning.html","id":"acrescente-à-cadeia-de-pipes","chapter":"8 Limpeza de dados e principais funções","heading":"Acrescente à cadeia de pipes","text":"Na linelist_raw, há algumas colunas que não precisamos: row_num, merged_header, e x28. Nós removemos com um comando select() na cadeia pipe limpa:","code":"\n# CADEIA 'PIPE' DE LIMPEZA \n#(inicia com dados brutos e encadeia funções com o pipe até a limpeza dos dados)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist <- linelist_raw %>%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %>% \n    \n    # renomeie manualmente colunas\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # ACIMA ESTÃO OS PASSOS DE LIMPEZA JÁ DISCUTIDOS\n    #####################################################\n\n    # remova coluna\n    select(-c(row_num, merged_header, x28))"},{"path":"cleaning.html","id":"eliminação-de-duplicidades","chapter":"8 Limpeza de dados e principais funções","heading":"8.6 Eliminação de duplicidades","text":"Consulte página manual de Eliminação de duplicidades para obter opções extensivas sobre como de-duplicar os dados. Apenas um exemplo muito simples de eliminação de duplicidades é apresentado aqui.O pacotedplyr oferece função distinct() function. Esta função examina cada linha e reduz o data frame para apenas linhas únicas. Isto é, ele remove linhas que são 100% duplicadas.Ao avaliar linhas duplicadas, ela leva em conta uma gama de colunas - por padrão ele considera todas colunas. Como mostrado na página de desduplicação, é possível ajustar este intervalo de colunas para que singularidade das linhas só seja avaliada em relação determinadas colunas.Neste exemplo simples, basta adicionar o comando vazio distinct() para cadeia de pipe. Isto garante que não haja linhas que sejam 100% duplicatas de outras linhas (avaliadas em todas colunas).Começamos com nrow(linelist) de linhas em linelist.Após eliminação de duplicidades, existem nrow(linelist) linhas. Qualquer linha removida teria sido 100% duplicada de outras linhas.Abaixo, o comando distinct() é adicionado à cadeia de pipe de limpeza:","code":"\nlinelist <- linelist %>% \n  distinct()\n# CADEIA 'PIPE' DE LIMPEZA \n#(inicia com dados brutos e encadeia funções com o pipe até a limpeza dos dados)\n##################################################################################\n\n# começa a limpeza da cadeia pipe\n###########################\nlinelist <- linelist_raw %>%\n    \n    # padronizar a sintaxe do nome da coluna\n    janitor::clean_names() %>% \n    \n    # re-nomear colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remova a coluna\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # ACIMA ESTÃO OS PASSOS DE LIMPEZA JÁ DISCUTIDOS\n    #####################################################\n    \n    # desduplicar\n    distinct()"},{"path":"cleaning.html","id":"criação-de-coluna-e-transformação","chapter":"8 Limpeza de dados e principais funções","heading":"8.7 Criação de coluna e transformação","text":"Nós recomendamos usar função dplyr mutate() para adicionar uma nova coluna, ou para modificar uma existente.Abaixo está um exemplo de criação de uma nova coluna com mutate(). sintaxe é: mutate(novo_nome_de_coluna = valor ou transformação)Stata, isto é similar ao comando generate, mas o mutate() R pode também ser usado para modificar uma coluna existente.","code":""},{"path":"cleaning.html","id":"novas-colunas","chapter":"8 Limpeza de dados e principais funções","heading":"Novas colunas","text":"O comando mutate() mais básico para criar uma nova coluna deve parecer como este. Ele cria uma nova coluna nova_coluna onde o valor em cada linha é 10.Você também pode referenciar valores em outras colunas, para realizar cálculos. Abaixo, uma nova coluna bmi é criada para manter o Índice de Massa Corporal (IMC, Body Mass Index em inglês) para cada caso - como calculado utilizando fórmula IMC = kg/m^2, utilizando coluna ht_cm e coluna wt_kg.Se forem criadas várias colunas novas, separe cada uma delas com uma vírgula e uma nova linha. Abaixo estão exemplos de novas colunas, incluindo aquelas que consistem de valores de outras colunas combinadas utilizando str_glue() pacote stringr (veja página em Caracteres e strings.Revise novas colunas. Para demonstrar os objetivos, apenas novas colunas e colunas usadas para criá-las são mostradas:DICA: Uma variação de mutate() é função transmute(). Esta função adiciona uma nova coluna apenas como mutate(), mas também remove todas outras colunas que você não menciona dentro destes parênteses.","code":"\nlinelist <- linelist %>% \n  mutate(nova_coluna = 10)\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2) #bmi = IMC em portugês\nnew_col_demo <- linelist %>%                       \n  mutate(\n    new_var_dup    = case_id,             # nova coluna = duplicata/copia outra coluna existente\n    new_var_static = 7,                   # nova coluna = todos os valores o mesmo\n    new_var_static = new_var_static + 5,  # você pode sobrescrever uma coluna, e ele pode ser um cálculo de outras variáveis\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # nova coluna = colando juntos valores de outras colunas\n    ) %>% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # mostra apenas nova coluna, para demonstrar objetivos\n# ESCONDIDO DO LEITOR\n# remove novas colunas de demonstração criadas acima\n# linelist <- linelist %>% \n#   select(-contains(\"new_var\"))"},{"path":"cleaning.html","id":"converter-a-classe-de-coluna","chapter":"8 Limpeza de dados e principais funções","heading":"Converter a classe de coluna","text":"Colunas contendo valores que são datas, números ou valores lógicos (TRUE/FALSE, ou seja, verdadeiro/falso) só se comportarão como esperado se forem corretamente classificadas. Há uma diferença entre “2” da classe caracteres e 2 da classe numérica!Há maneiras de definir classe da coluna durante os comandos de importação, mas isso é muitas vezes complicado. Veja seção Introdução ao R sobre classes de objetos para saber mais sobre conversão da classe de objetos e colunas.Primeiro, vamos fazer algumas verificações em colunas importantes para ver se são classe correta. Também vimos isso início, quando corremos skim().Atualmente, classe da coluna age é caractere. Para realizar análises quantitativas, precisamos que estes números sejam reconhecidos como numéricos!classe da coluna date_onset também é caractere! Para realizar análises, estas datas devem ser reconhecidas como datas!Para resolver isto, utilize capacidade de mutate() de redefinir uma coluna com uma transformação. Nós definimos coluna como ela mesma, mas convertida em uma classe diferente. Aqui está um exemplo básico, convertendo ou assegurando que coluna ‘age’ seja de classe numérica:Em um modo similar, você pode usar .character() e .logical(). Para converter para classe Fator, você pode usar factor() R base ou as_factor() forcats. Leia mais sobre isso na página Fatores.Você deve ter cuidado ao converter para classe Data. Vários métodos são explicados na página Trabalhando com datas. Normalmente, os valores de data bruta devem estar todos mesmo formato para que conversão funcione corretamente (por exemplo “MM/DD/YYYY”, ou “DD MM YYYY”). Após conversão para classe Data, verifique seus dados para confirmar que cada valor foi convertido corretamente.","code":"\nclass(linelist$age)## [1] \"character\"\nclass(linelist$date_onset)## [1] \"character\"\nlinelist <- linelist %>% \n  mutate(age = as.numeric(age))"},{"path":"cleaning.html","id":"dados-agrupados","chapter":"8 Limpeza de dados e principais funções","heading":"Dados agrupados","text":"Se o seu dataframe já estiver agrupado (veja página Dados agrupados), mutate() pode se comportar de forma diferente que se o dataframe não estiver agrupado. Qualquer função resumida, como mean(), median(), max(), etc. será calculada por grupo, não por todas linhas.Leia mais sobre utilização de mutate () em dataframes agrupados nesta documentaçao mutate tidyverse.","code":"\n# idade normalizada pela média de TODAS as linhas\nlinelist %>% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# idade normalizada pela média do grupo do hospital\nlinelist %>% \n  group_by(hospital) %>% \n  mutate(age_norm = age / mean(age, na.rm=T))"},{"path":"cleaning.html","id":"clean_across","chapter":"8 Limpeza de dados e principais funções","heading":"Transformar múltiplas colunas","text":"Muitas vezes para escrever um código conciso você quer aplicar mesma transformação várias colunas ao mesmo tempo. Uma transformação pode ser aplicada múltiplas colunas ao mesmo tempo utilizando função across() pacote dplyr (ambém contida pacote tidyverse). across() pode ser utilizada com qualquer função dplyr, mas é comumente utilizada dentro de select(), mutate(), filter(), ou summarise(). Veja como é aplicado summarise() na página de Tabelas Descritivas.Especifique colunas para o argumento .cols = e (s) função(ões) ser(em) aplicada(s) .fns =. Quaisquer argumentos adicionais serem fornecidos à função .fns' podem ser incluídos após uma vírgula, ainda dentro deacross()`.","code":""},{"path":"cleaning.html","id":"seleção-de-coluna-across","chapter":"8 Limpeza de dados e principais funções","heading":"Seleção de coluna across()","text":"Especifique colunas para o argumento .cols =. Você pode nomeá-las individualmente, ou usar funções helper “tidyselect”. Especifique função para .fns =`. Observe que utilizando o modo de função demonstrado abaixo, função é escrita sem seus parênteses ( ).Aqui transformação .character() é aplicada colunas específicas nomeadas dentro de across().funções auxiliares “tidyselect” estão disponíveis para ajudá-lo especificar colunas. Elas são detalhadas acima na seção sobre Seleção e reordenação de colunas, e eles incluem: everything(), last_col(), (), starts_with(), ends_with(), contains(), matches(), num_range() e any_of().Aqui está um exemplo de como se pode mudar todas colunas para classe de caracteres:Converter em caracteres todas colunas onde o nome contém string “data” (note colocação de vírgulas e parênteses):Abaixo, um exemplo de transformação de colunas que atualmente são da classe POSIXct (uma classe de data/hora bruta que mostra marcações de hora) - em outras palavras, onde função .POSIXct() avalia para TRUE. Em seguida, queremos aplicar função .Date() estas colunas para convertê-las em uma classe normal Date.Note que dentro de across() também utilizamos função () como .POSIXct está avaliando para TRUE ou FALSE.Note que .POSIXct() é pacote lubridate. Outras funções “” similares como .character(), .numeric(), e .logical() são R base.","code":"\nlinelist <- linelist %>% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n# para mudar todas as colunas para a classe caractere\nlinelist <- linelist %>% \n  mutate(across(.cols = everything(), .fns = as.character))\n# para mudar todas as colunas para classe de caracteres\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\nlinelist <- linelist %>% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))"},{"path":"cleaning.html","id":"funçõesacross","chapter":"8 Limpeza de dados e principais funções","heading":"Funçõesacross()","text":"Você pode ler documentação com ?across' para obter detalhes sobre como fornecer funções paraacross()`. Alguns pontos resumidos: há várias maneiras de especificar (s) função(ões) ser(em) executada(s) em uma coluna e você pode até mesmo definir suas próprias funções:Você pode fornecer apenas o nome da função (por ex., mean ou .character)Você pode fornecer apenas o nome da função (por ex., mean ou .character)Você pode fornecer função estilo purrr (por ex.,~ mean(.x, na.rm = TRUE)) (veja esta página de Iterações, Listas e Loops)Você pode fornecer função estilo purrr (por ex.,~ mean(.x, na.rm = TRUE)) (veja esta página de Iterações, Listas e Loops)Você pode especificar múltiplas funções fornecendo uma lista (por exemplo, list(mean = mean, n_miss = ~ sum(.na(.x))).Você pode especificar múltiplas funções fornecendo uma lista (por exemplo, list(mean = mean, n_miss = ~ sum(.na(.x))).Se você fornecer múltiplas funções, múltiplas colunas transformadas serão retornadas por coluna de entrada, com nomes únicos formato col_fn. Você pode ajustar como novas colunas são nomeadas com o argumento .names = usando sintaxe glue (veja página de Caracteres e strings) onde {.col} e {.fn} são abreviaturas para coluna de entrada e função.Se você fornecer múltiplas funções, múltiplas colunas transformadas serão retornadas por coluna de entrada, com nomes únicos formato col_fn. Você pode ajustar como novas colunas são nomeadas com o argumento .names = usando sintaxe glue (veja página de Caracteres e strings) onde {.col} e {.fn} são abreviaturas para coluna de entrada e função.Aqui estão alguns recursos -line sobre utilização de across(): creator Hadley Wickham’s thoughts/rationale","code":""},{"path":"cleaning.html","id":"coalesce","chapter":"8 Limpeza de dados e principais funções","heading":"coalesce()","text":"Esta função dplyr encontra o primeiro valor não-faltante em cada posição. Ela “preenche” os valores ausentes com o primeiro valor disponível em uma ordem especificada por você.Aqui está um exemplo fora contexto de um data frame: Digamos que você tem dois vetores, um contendo vila de detecção paciente e outro contendo vila de residência paciente. Você pode usar coalesce para escolher o primeiro valor não-faltante para cada índice:Isto funciona da mesma forma se você fornecer colunas de data frame: para cada linha, função atribuirá o novo valor de coluna com o primeiro valor não descartado nas colunas que você forneceu (na ordem fornecida).Este é um exemplo de uma operação “em linha”. Para cálculos mais complicados em linha, veja seção abaixo sobre cálculos em linha.","code":"\nvillage_detection <- c(\"a\", \"b\", NA,  NA)\nvillage_residence <- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage <- coalesce(village_detection, village_residence)\nvillage    # imprima## [1] \"a\" \"b\" \"a\" \"d\"\nlinelist <- linelist %>% \n  mutate(village = coalesce(village_detection, village_residence))"},{"path":"cleaning.html","id":"matemática-cumulativa","chapter":"8 Limpeza de dados e principais funções","heading":"Matemática cumulativa","text":"Se você quiser que uma coluna reflita soma cumulativa/média/mínimo/máximo etc para avaliar linhas em um dataframe até este ponto, usa seguintes funções:cumsum() retorna soma cumulativa, como mostrado abaixo:Isto pode ser usado em um dataframe ao fazer uma nova coluna. Por exemplo, para calcular o número cumulativo de casos por dia em um surto, considere um código como este:Abaixo estão primeiras 10 linhas:Veja página sobre Curvas epidêmicas para saber como plotar incidência acumulada com epicurva.Veja também:cumsum(), cummean(), cummin(), cummax(), cumany(), cumall()","code":"\nsum(c(2,4,15,10))     # retorna apenas um número## [1] 31\ncumsum(c(2,4,15,10))  # retorna a soma cumulativa em cada etapa## [1]  2  6 21 31\ncumulative_case_counts <- linelist %>%  # inicia com o caso linelist\n  count(date_onset) %>%                 # conta as linhas por dia, como coluna 'n'   \n  mutate(cumulative_cases = cumsum(n))  # nova coluna, da soma cumulativa em cada linha\nhead(cumulative_case_counts, 10)##    date_onset n cumulative_cases\n## 1  2012-04-15 1                1\n## 2  2012-05-05 1                2\n## 3  2012-05-08 1                3\n## 4  2012-05-31 1                4\n## 5  2012-06-02 1                5\n## 6  2012-06-07 1                6\n## 7  2012-06-14 1                7\n## 8  2012-06-21 1                8\n## 9  2012-06-24 1                9\n## 10 2012-06-25 1               10"},{"path":"cleaning.html","id":"usando-o-r-base","chapter":"8 Limpeza de dados e principais funções","heading":"Usando o R base","text":"Para definir uma nova coluna (ou redefinir uma coluna) utilizando o R base, escreva o nome data frame, conectado com $, para nova coluna (ou colunas ser modificada). Use o operador de atribuição <- para definir o(s) novo(s) valor(es). Relembre que quando usar o R base você deve especificar o nome data frame antes nome da coluna toda vez (por ex., dataframe$column). Aqui é um exemplo de criação da coluna bmi usando o R base:","code":"linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)"},{"path":"cleaning.html","id":"adicionar-a-cadeia-pipe","chapter":"8 Limpeza de dados e principais funções","heading":"Adicionar a cadeia pipe","text":"Abaixo, uma nova coluna é adicionada à cadeia pipe e algumas classes são convertidas.","code":"\n# CADEIA 'PIPE' DE LIMPEZA\n#(começa com dados brutos e faz pipes através das etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe limpa\n###########################\nlinelist <- linelist_raw %>%\n    \n    # padronizar a sintaxe do nome da coluna\n    janitor::clean_names() %>% \n    \n    # re-nomear colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # remova duplicidade\n    distinct() %>% \n  \n    # ACIMA SÃO PASSOS DE LIMPEZA A MONTANTE JÁ DISCUTIDOS\n    ###################################################\n    # adicione nova coluna\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% \n  \n    # converta a classe das colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) "},{"path":"cleaning.html","id":"re-codificar-valores","chapter":"8 Limpeza de dados e principais funções","heading":"8.8 Re-codificar valores","text":"Aqui estão alguns cenários onde você precisa recodificar (mudar) os valores:para editar um valor específico (por exemplo, uma data com um ano ou formato incorreto)para reconciliar valores não soletrados da mesma formapara criar uma nova coluna de valores categóricospara criar uma nova coluna de categorias numéricas (por exemplo, categorias de idade)","code":""},{"path":"cleaning.html","id":"valores-específicos","chapter":"8 Limpeza de dados e principais funções","heading":"Valores específicos","text":"Para alterar valores manualmente, você pode utilizar função recode() dentro da função mutate().Imagine que haja uma data sem sentido nos dados (por exemplo, “2014-14-15”): você poderia fixar data manualmente nos dados da fonte bruta, ou, você poderia escrever alteração pipe de limpeza via mutate() e recode(). Esta última é mais transparente e reprodutível para qualquer outra pessoa que procure entender ou repetir sua análise.linha mutate() acima pode ser lida como: “mude coluna date_onset para igualar coluna date_onset re-codificada para que o VALOR VELHO seja alterado para o NOVO VALOR”. Note que este padrão (VELHO = NOVO) para recode() é o oposto da maioria dos padrões de R (novo = velho). comunidade de desenvolvedores R está trabalhando na revisão deste padrão.Aqui está outro exemplo de recodificação de múltiplos valores dentro de uma coluna.Na linelist os valores dna coluna “hospital” devem ser limpos. Há várias grafias diferentes e muitos valores em falta.O comando recode() abaixo re-define coluna “hospital” como coluna atual “hospital”, mas com recodificação especificada muda. Não esqueça vírgulas depois de cada uma!Agora vemos que grafias na coluna ‘hospitalar’ foram corrigidas e consolidadas:[DICA: O número de espaços antes e depois de um sinal de igual não importa. Torne seu código mais fácil de ler, alinhando-o = para todas ou para maioria das linhas. Além disso, considere acrescentar uma linha de comentários em destaque para esclarecer aos futuros leitores qual lado é VELHO e qual lado é NOVO.] {style=“color: darkgreen;”}DICA: Às vezes existe um valor de caractere em branco em um conjunto de dados (não reconhecido como o valor de R por ausente - NA). Você pode referenciar este valor com duas aspas sem espaço intermediário","code":"\n# corrigir valores incorretos          # valor velho       # valor novo\nlinelist <- linelist %>% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\ntable(linelist$hospital, useNA = \"always\")  # imprimir tabela de todos os valores únicos, incluindo os que faltam## \n##                      Central Hopital                     Central Hospital \n##                                   11                                  457 \n##                           Hospital A                           Hospital B \n##                                  290                                  289 \n##                     Military Hopital                    Military Hospital \n##                                   32                                  798 \n##                     Mitylira Hopital                    Mitylira Hospital \n##                                    1                                   79 \n##                                Other                         Port Hopital \n##                                  907                                   48 \n##                        Port Hospital St. Mark's Maternity Hospital (SMMH) \n##                                 1756                                  417 \n##   St. Marks Maternity Hopital (SMMH)                                 <NA> \n##                                   11                                 1512\nlinelist <- linelist %>% \n  mutate(hospital = recode(hospital,\n                     # for reference: OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\ntable(linelist$hospital, useNA = \"always\")## \n##                     Central Hospital                           Hospital A \n##                                  468                                  290 \n##                           Hospital B                    Military Hospital \n##                                  289                                  910 \n##                                Other                        Port Hospital \n##                                  907                                 1804 \n## St. Mark's Maternity Hospital (SMMH)                                 <NA> \n##                                  428                                 1512"},{"path":"cleaning.html","id":"pela-lógica","chapter":"8 Limpeza de dados e principais funções","heading":"Pela lógica","text":"seguir demonstramos como recodificar valores em uma coluna usando lógica e condições:Utilizando replace(), ifelse() e if_else() para uma lógica simplesUtilizando case_when() para uma lógica mais complexa","code":""},{"path":"cleaning.html","id":"lógica-simples","chapter":"8 Limpeza de dados e principais funções","heading":"Lógica simples","text":"","code":""},{"path":"cleaning.html","id":"replace","chapter":"8 Limpeza de dados e principais funções","heading":"replace()","text":"Para re-codificar com critérios lógicos simples, você pode utilizar replace() dentro de mutate(). replace() é uma função R base. Utilize uma condição lógica para especificar linhas serem alteradas . sintaxe geral é:mutate(col_to_change = replace(col_to_change, critério para linhas, new value)).Uma situação comum para utilizar replace() é alterar apenas um valor em uma linha, utilizando um identificador único de linha. Abaixo, o gênero é alterado para “Female” (Feminino) na linha onde coluna case_id é “2195”.O comando equivalente utilizando síntaxe R base e colchetes indexadores [ ] está abaixo. Ele é lido como “Alterar o valor da coluna gender dataframe linelist (para linhas onde coluna case_id linelist tem o valor de ‘2195’) para ‘Female’”.","code":"\n#  Exemplo: mudar o gênero de uma observação específica para  \"Female\" (Feminino).  \nlinelist <- linelist %>% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\nlinelist$gender[linelist$case_id == \"2195\"] <- \"Female\""},{"path":"cleaning.html","id":"ifelse-e-if_else","chapter":"8 Limpeza de dados e principais funções","heading":"ifelse() e if_else()","text":"Outra ferramenta de lógica simples é ifelse() e seu parceiro if_else(). Entretanto, na maioria dos casos para re-codificação é mais claro utilizar case_when() (detalhado abaixo). Estes comandos “else” são versões simplificadas de uma declaração de programação e else. sintaxe geral é:ifelse(condição, valor para retornar se condição avlia se  TRUE, valor para retornar se condição avaliada é FALSE)Abaixo, coluna definida source_known é definida. Seu valor em uma determinada linha é definido como “conhecido” se o valor da linha na coluna source não estiver faltando. Se o valor em source está faltando, então o valor em source_known está definido como “desconhecido”.if_else() é uma versão especial de dplyr que manipula datas. Observe que se o valor ‘verdadeiro’ é uma data, o valor ‘falso’ também deve qualificar uma data, portanto, utilizando o valor especial NA_real_ em vez de apenas NA.Evitar junção de muitos comandos ifelse… use case_when() ao invés disso! case_when() é muito mais fácil de ler e você cometerá menos erros.Fora contexto de um data frame, se você quiser que um objeto utilizado em seu código mude seu valor, considere utilizar switch() R base.","code":"\nlinelist <- linelist %>% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n#  Criar uma coluna de data de morte, que é NA, se o paciente não tiver morrido.\nlinelist <- linelist %>% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))"},{"path":"cleaning.html","id":"clean_case_when","chapter":"8 Limpeza de dados e principais funções","heading":"Lógica complexa","text":"Use ocase_when() dplyr se você estiver recodificando em muitos grupos novos, ou se você precisar utilizar declarações lógicas complexas para recodificar valores. Esta função avalia cada linha data frame, avalia se linhas atendem aos critérios especificados e atribui o novo valor correto.Os comandos case_when() consistem de declarações que têm um Lado Direito (RHS, de Right-Hand Side em inglês) e um Lado Esquerdo (LHS, Left-Hand Side em inglês) separados por um “til” ~. Os critérios lógicos estão lado esquerdo e os valores de ajuste estão lado direito de cada afirmação. afirmações são separadas por vírgulas.Por exemplo, aqui utilizamos colunas age e age_unit para criar uma coluna age_years:Como cada linha dos dados é avaliado, os critérios são aplicados/avaliados na ordem em que declaraçõe case_when() são escritos - de cima para baixo. Se o critério de cima avaliar TRUE para uma dada linha, o valor RHS é atribuído, e os critérios restantes não são sequer testados para essa linha. Assim, é melhor escrever primeiro os critérios mais específicos, e por último os mais gerais.Nesta linha, em sua declaração final, coloque TRUE lado esquerdo, que captará qualquer linha que não atenda nenhum dos critérios anteriores. Ao lado direito desta declaração pode ser atribuído um valor como “checar!” ou perda.PERIGO: Valores lado direito devem ser todos na mesma classe - seja numérico, caractere, data, lógico, etc. Para atribuir valores em falta (NA), você talvez necessite usar variações especiais de NA como NA_character_, NA_real_ (para numérico ou POSIX), e .Date(NA). Leia mais em Trabalhando com datas.","code":"\nlinelist <- linelist %>% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # se a idade for dada em anos\n            age_unit == \"months\" ~ age/12,    # se a idade for dada em meses\n            is.na(age_unit)      ~ age))       # se falta a unidade de idade, suponha anos) \n                                             # qualquer outra circunstância, atribui NA (falta)"},{"path":"cleaning.html","id":"valores-faltantes-1","chapter":"8 Limpeza de dados e principais funções","heading":"Valores faltantes","text":"Abaixo estão funções especiais para manipular valores ausentes contexto da limpeza de dados.Veja página em Campos em branco/faltantes para dicas mais detahadas sobre como identificas e tratar os valores ausentes. Por exemplo, função .na()que logicamente testa falta de dados.replace_na()Para alterar valores ausentes (NA) para um valor específico, como “Ausente”, use função dplyr replace_na() dentro de mutate(). Observe que isto é utilizado da mesma forma que recode acima - o nome da variável deve ser repetida dentro de replace_na().fct_explicit_na()Esta é uma função pacote forcats. O pacote forcats manipula colunas de classe Fator. Fatores são forma R manipular valores ordenados tais como c(\"Primeiro\", \"Segundo\", \"Terceiro\") ou para definir ordem em que os valores (por exemplo, hospitais) aparecem em tabelas e gráficos. Veja página de Fatores.Se seus dados forem de classe Fator e você tentar converter NA para “Ausente” utilizando replace_na(), você receberá este erro: invalid factor level, NA generated. Você tentou adicionar “Ausente” como um valor, quando este não foi definido como um nível possível fator, e ele foi rejeitado.maneira mais fácil de resolver isto é utilizar função de forcats fct_explicit_na() que converte uma coluna para classe fator, e converte os valores NA para o caractere “(Missing)” (Ausente/Faltante).Uma alternativa mais lenta seria adicionar o nível fator utilizando fct_expand() e então converter os valores ausentes.na_if()Para converter um valor específico para NA, use na_if() dplyr. O comando abaixo executa operação oposta de replace_na(). exemplo abaixo, quaisquer valores de “Ausente” na coluna hospital são convertidas para NA.Observe: na_if() não pode ser usado para critérios lógicos (por ex., “todos os valores > 99”) - use replace() ou case_when() para isso:","code":"\nlinelist <- linelist %>% \n  mutate(hospital = replace_na(hospital, \"Ausente\"))\nlinelist %>% \n  mutate(hospital = fct_explicit_na(hospital))\nlinelist <- linelist %>% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n# Converta temperaturas acima de 40 para NA \nlinelist <- linelist %>% \n  mutate(temp = replace(temp, temp > 40, NA))\n\n# Converta as datas de início antes de 1 de janeiro de 2000 em ausente\nlinelist <- linelist %>% \n  mutate(date_onset = replace(date_onset, date_onset > as.Date(\"2000-01-01\"), NA))"},{"path":"cleaning.html","id":"dicionário-de-limpeza","chapter":"8 Limpeza de dados e principais funções","heading":"Dicionário de limpeza","text":"Utilize o pacote matchmaker R e sua função match_df() para limpar um data frame com um dicionário de limpeza.Criar um dicionário de limpeza com 3 colunas:\nUma coluna “de” (o valor incorreto)\nUma coluna “para” (o valor correto)\nUma coluna especificando coluna para mudanças serem aplicadas (ou “.global” para aplicar todas colunas)\nCriar um dicionário de limpeza com 3 colunas:Uma coluna “de” (o valor incorreto)Uma coluna “para” (o valor correto)Uma coluna especificando coluna para mudanças serem aplicadas (ou “.global” para aplicar todas colunas)Note: entradas dicionário .global serão substituídas por entradas de dicionário específicas de colunaImportar o arquivo dicionário para R. Este exemplo pode ser baixado através das instruções na página Baixar manual e dados.Passe linelist bruta para match_df(), especificando para dictionary = o data frame dicionário de limpeza. O argumento = deve ter o nome da coluna que ontem os valores “antigos”, o argumento = deve ser coluna dicionário que contem os valores “novos”, e o terceiro argumento lista coluna sobre qual fazer mudança.Leia mais sobre em package documentation digitando ?match_df console. Note que essa função pode demorar um tempo longo de execução em uma base de dados grande.Agora role para direita para ver como os valores mudaram - particularmente gender (de minúsculas para maiúsculas), e todas colunas de sintomas foram transformadas de sim/não para 1/0.Observe que os nomes das colunas dicionário de limpeza devem corresponder aos nomes neste ponto seu script de limpeza. Veja esta referência online para o pacote linelist para obter mais detalhes.","code":"\ncleaning_dict <- import(\"cleaning_dict.csv\")\nlinelist <- linelist %>%     # sua base de dados\n     matchmaker::match_df(\n          dictionary = cleaning_dict,  # nome do dicionário\n          from = \"from\",               # coluna com as variáveis a serem substituidas (o padrão é a col 1)\n          to = \"to\",                   # coluna ocm os valores finais (padrão é col 2)\n          by = \"col\"                   # coluna com nome de colunas (padrão é col 3)\n  )"},{"path":"cleaning.html","id":"adicione-a-cadeia-pipe","chapter":"8 Limpeza de dados e principais funções","heading":"Adicione a cadeia pipe","text":"Abaixo, algumas novas colunas e transformações de colunas são adicionadas à cadeia pipe.","code":"\n# CADEIA 'PIPE' DE LIMPEZA\n# inicia com dados brutos e canaliza-os através de etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist <- linelist_raw %>%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %>% \n    \n    # renomeie as colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # remova duplicidade\n    distinct() %>% \n  \n    # adicione colunas\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # converta classe de colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # adicione coluna: demora para internação\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n   # ACIMA ESTÃO AS ETAPAS DE LIMPEZA A MONTANTE JÁ DISCUTIDAS\n   ###################################################\n\n    # limpe valores da coluna do hospital\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # crie a coluna age_years (de age e age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))"},{"path":"cleaning.html","id":"num_cats","chapter":"8 Limpeza de dados e principais funções","heading":"8.9 Categorias numéricas","text":"Aqui descrevemos algumas abordagens especiais para criar categorias partir de colunas numéricas. Exemplos comuns incluem categorias de idade, grupos de valores de laboratório, etc. Aqui vamos discutir:age_categories(), pacote epikitcut(), R basecase_when()quebras de quantis com quantile() e ntile()","code":""},{"path":"cleaning.html","id":"distribuição-de-comentários","chapter":"8 Limpeza de dados e principais funções","heading":"Distribuição de comentários","text":"Para este exemplo, nós vamos criar uma coluna age_cat usando coluna age_years.Primeiro, examine distribuição de seus dados, para fazer os pontos de corte apropriados. Veja página sobre Básico ggplot.CUIDADO: Às vezes, variáveis numéricas serão importadas como classe “character”. Isso ocorre se houver caracteres não numéricos em alguns dos valores, por exemplo, uma entrada de “2 meses” para idade ou (dependendo das configurações locais R) se uma vírgula usada na casa decimal (por exemplo, “4,5” para significar quatro anos e meio)..","code":"\n# Verifique a classe da variável da linelist age\nclass(linelist$age_years)## [1] \"numeric\"\n# examine a distribuição\nhist(linelist$age_years)\nsummary(linelist$age_years, na.rm=T)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.04   23.00   84.00     107"},{"path":"cleaning.html","id":"age_categories","chapter":"8 Limpeza de dados e principais funções","heading":"age_categories()","text":"Com o pacote epikit, você pode usar função age_categories() fpara categorizar e rotular facilmente colunas numéricas (observação: esta função também pode ser aplicada variáveis numéricas que não sejam de idade). Como bônus, coluna de saída é automaticamente um fator ordenado.Aqui estão entradas necessárias:Um vetor numérico (coluna)O argumento breakers = - fornece um vetor numérico de pontos de interrupção para os novos gruposPrimeiro, o exemplo mais simples:Os valores de quebra que você especifica são, por padrão, os limites inferiores - ou seja, eles são incluídos grupo “superior” / os grupos são “abertos” lado inferior/esquerdo. Conforme mostrado abaixo, você pode adicionar 1 cada valor de quebra para obter grupos abertos na parte superior/direita.Você pode ajustar como os rótulos são exibidos com separator =. O padrão é “-”Você pode ajustar como os números superiores são tratados, com o argumento ceiling =. Para definir um limite superior, defina ceiling = TRUE. Neste uso, o valor de quebra mais alto fornecido é um “teto” e uma categoria “XX+” não é criada. Quaisquer valores acima valor de quebra mais alto (ou para upper =, se definido) são categorizados como NA. Abaixo está um exemplo com ceiling = TRUE, para que não haja categoria de XX+ e valores acima de 70 (o maior valor de quebra) sejam atribuídos como NA.Alternativamente, em vez de breakers =, você pode fornecer todos de lower =, upper =, e =:lower = O número mais baixo que você quer considerar - o padrão é 0upper = O número mais alto que você quer considerarby = O número de anos entre gruposVeja página de Ajuda da função para mais detalhes (digite ?age_categories console R).","code":"\n# Exemplo simples\n################\npacman::p_load(epikit)                    # carregue pacote\n\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(             # crie nova coluna\n      age_years,                            # coluna numérica para fazer grupos de\n      breakers = c(0, 5, 10, 15, 20,        # pontos de quebra\n                   30, 40, 50, 60, 70)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  <NA> \n##  1227  1223  1048   827  1216   597   251    78    27     7   107\n# Incluir extremidades superiores para as mesmas categorias\n############################################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# Mostre tabela\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  <NA> \n##  1469  1195  1040   770  1149   547   231    70    24     6   107\n# Com teto definido para TRUE\n##########################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 is ceiling, all above become NA\n\n# Mostre a tabela\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  <NA> \n##  1227  1223  1048   827  1216   597   251    78    28   113\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# Mostre a tabela\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  <NA> \n##  2450  1875  1216   597   251    78    27     6     1     0     0   107"},{"path":"cleaning.html","id":"cut","chapter":"8 Limpeza de dados e principais funções","heading":"cut()","text":"cut() é uma alternativa R base para age_categories(), mas eu acho que você verá porque age_categories() foi desenvolvida para simplificar este processo. Algumas diferenças notáveis da age_categories() são:Você não precisa instalar/carregar outro pacoteVocê pode especificar se os grupos estão abertos/fechados à direita/esquerdaVocê mesmo deve fornecer etiquetas precisasSe você quiser 0 incluído grupo mais baixo, você deve especificar issoA sintaxe básica dentro de cut() é fornecer primeiro coluna numérica ser cortada (age_years), e então o argumento breaks, que é um vetor numérico c() de pontos de quebra. Usando cut(), coluna resultante é um fator ordenado.Por padrão, categorização ocorre de forma que o lado direito/superior seja “aberto” e inclusivo (e o lado esquerdo/inferior seja “fechado” ou exclusivo). Este é o comportamento oposto da função age_categories(). Os rótulos padrão usam notação “(, B]”, o que significa que não está incluído, mas B sim. Inverta esse comportamento fornecendo o argumento right = TRUE.Assim, por padrão, os valores “0” são excluídos grupo mais baixo e categorizados como NA! Os valores “0” podem ser bebês codificados como 0, então tenha cuidado! Para alterar isso, adicione o argumento include.lowest = TRUE para que qualquer valor “0” seja incluído grupo mais baixo. O rótulo gerado automaticamente para categoria mais baixa será “[],B]”. Observe que se você incluir o argumento include.lowest = TRUE e right = TRUE, inclusão extrema agora será aplicada ao valor e categoria ponto de quebra mais alto, não ao mais baixo.Você pode fornecer um vetor de rótulos personalizados usando o argumento labels =. Como estes são escritos manualmente, tenha muito cuidado para garantir que eles sejam precisos! Verifique seu trabalho usando tabulação cruzada, conforme descrito abaixo.Um exemplo de cut() aplicado age_years para fazer nova variável age_cat está abaixo:Verifique seu trabalho!!! Verifique se cada valor de idade foi atribuído à categoria correta fazendo uma tabulação cruzada das colunas numéricas e de categoria. Examine atribuição de valores de limite (por exemplo, 15, se categorias vizinhas forem 10-15 e 16-20).Rotule novamente os valores NAVocê pode querer atribuir valores NA um rótulo tal como “Ausente”. Como nova coluna é de classe Fator (valores restritos), você não pode simplesmente mudá-la com replace_na(), pois este valor será rejeitado. Em vez disso, utilize fct_explicit_na() de forcats, como explicado na página Fatores.Fazer quebras e rótulos rapidamentePara uma maneira rápida de fazer quebras e rotular vetores, use algo como abaixo. Veja página Introdução R para referências em seq() e rep().Leia mais sobre cut() em sua página de Ajuda entrando em ?cut console R","code":"\n# Crie a nova variável, pelo corte da variável numérica age \n# quebra inferior é excluída, mas quebra superior é incluída em cada categoria\nlinelist <- linelist %>% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # inclua 0 no grupo mais baixo\n      ))\n\n# tabule o número de observaçõs por grupo\ntable(linelist$age_cat, useNA = \"always\")## \n##    [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100]     <NA> \n##     1469     1195     1040      770     1149      778       94        6      107\n# Tabulação cruzada das colunas numéricas e de categoria. \ntable(\"Numeric Values\" = linelist$age_years,   # nomes especificados na tabela para maior clareza.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # não esqueça de examinar os valores NA##                     Categories\n## Numeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] (70,100]\n##   0                    136      0       0       0       0       0       0        0\n##   0.0833333333333333     1      0       0       0       0       0       0        0\n##   0.25                   2      0       0       0       0       0       0        0\n##   0.333333333333333      6      0       0       0       0       0       0        0\n##   0.416666666666667      1      0       0       0       0       0       0        0\n##   0.5                    6      0       0       0       0       0       0        0\n##   0.583333333333333      3      0       0       0       0       0       0        0\n##   0.666666666666667      3      0       0       0       0       0       0        0\n##   0.75                   3      0       0       0       0       0       0        0\n##   0.833333333333333      1      0       0       0       0       0       0        0\n##   0.916666666666667      1      0       0       0       0       0       0        0\n##   1                    275      0       0       0       0       0       0        0\n##   1.5                    2      0       0       0       0       0       0        0\n##   2                    308      0       0       0       0       0       0        0\n##   3                    246      0       0       0       0       0       0        0\n##   4                    233      0       0       0       0       0       0        0\n##   5                    242      0       0       0       0       0       0        0\n##   6                      0    241       0       0       0       0       0        0\n##   7                      0    256       0       0       0       0       0        0\n##   8                      0    239       0       0       0       0       0        0\n##   9                      0    245       0       0       0       0       0        0\n##   10                     0    214       0       0       0       0       0        0\n##   11                     0      0     220       0       0       0       0        0\n##   12                     0      0     224       0       0       0       0        0\n##   13                     0      0     191       0       0       0       0        0\n##   14                     0      0     199       0       0       0       0        0\n##   15                     0      0     206       0       0       0       0        0\n##   16                     0      0       0     186       0       0       0        0\n##   17                     0      0       0     164       0       0       0        0\n##   18                     0      0       0     141       0       0       0        0\n##   19                     0      0       0     130       0       0       0        0\n##   20                     0      0       0     149       0       0       0        0\n##   21                     0      0       0       0     158       0       0        0\n##   22                     0      0       0       0     149       0       0        0\n##   23                     0      0       0       0     125       0       0        0\n##   24                     0      0       0       0     144       0       0        0\n##   25                     0      0       0       0     107       0       0        0\n##   26                     0      0       0       0     100       0       0        0\n##   27                     0      0       0       0     117       0       0        0\n##   28                     0      0       0       0      85       0       0        0\n##   29                     0      0       0       0      82       0       0        0\n##   30                     0      0       0       0      82       0       0        0\n##   31                     0      0       0       0       0      68       0        0\n##   32                     0      0       0       0       0      84       0        0\n##   33                     0      0       0       0       0      78       0        0\n##   34                     0      0       0       0       0      58       0        0\n##   35                     0      0       0       0       0      58       0        0\n##   36                     0      0       0       0       0      33       0        0\n##   37                     0      0       0       0       0      46       0        0\n##   38                     0      0       0       0       0      45       0        0\n##   39                     0      0       0       0       0      45       0        0\n##   40                     0      0       0       0       0      32       0        0\n##   41                     0      0       0       0       0      34       0        0\n##   42                     0      0       0       0       0      26       0        0\n##   43                     0      0       0       0       0      31       0        0\n##   44                     0      0       0       0       0      24       0        0\n##   45                     0      0       0       0       0      27       0        0\n##   46                     0      0       0       0       0      25       0        0\n##   47                     0      0       0       0       0      16       0        0\n##   48                     0      0       0       0       0      21       0        0\n##   49                     0      0       0       0       0      15       0        0\n##   50                     0      0       0       0       0      12       0        0\n##   51                     0      0       0       0       0       0      13        0\n##   52                     0      0       0       0       0       0       7        0\n##   53                     0      0       0       0       0       0       4        0\n##   54                     0      0       0       0       0       0       6        0\n##   55                     0      0       0       0       0       0       9        0\n##   56                     0      0       0       0       0       0       7        0\n##   57                     0      0       0       0       0       0       9        0\n##   58                     0      0       0       0       0       0       6        0\n##   59                     0      0       0       0       0       0       5        0\n##   60                     0      0       0       0       0       0       4        0\n##   61                     0      0       0       0       0       0       2        0\n##   62                     0      0       0       0       0       0       1        0\n##   63                     0      0       0       0       0       0       5        0\n##   64                     0      0       0       0       0       0       1        0\n##   65                     0      0       0       0       0       0       5        0\n##   66                     0      0       0       0       0       0       3        0\n##   67                     0      0       0       0       0       0       2        0\n##   68                     0      0       0       0       0       0       1        0\n##   69                     0      0       0       0       0       0       3        0\n##   70                     0      0       0       0       0       0       1        0\n##   72                     0      0       0       0       0       0       0        1\n##   73                     0      0       0       0       0       0       0        3\n##   76                     0      0       0       0       0       0       0        1\n##   84                     0      0       0       0       0       0       0        1\n##   <NA>                   0      0       0       0       0       0       0        0\n##                     Categories\n## Numeric Values       <NA>\n##   0                     0\n##   0.0833333333333333    0\n##   0.25                  0\n##   0.333333333333333     0\n##   0.416666666666667     0\n##   0.5                   0\n##   0.583333333333333     0\n##   0.666666666666667     0\n##   0.75                  0\n##   0.833333333333333     0\n##   0.916666666666667     0\n##   1                     0\n##   1.5                   0\n##   2                     0\n##   3                     0\n##   4                     0\n##   5                     0\n##   6                     0\n##   7                     0\n##   8                     0\n##   9                     0\n##   10                    0\n##   11                    0\n##   12                    0\n##   13                    0\n##   14                    0\n##   15                    0\n##   16                    0\n##   17                    0\n##   18                    0\n##   19                    0\n##   20                    0\n##   21                    0\n##   22                    0\n##   23                    0\n##   24                    0\n##   25                    0\n##   26                    0\n##   27                    0\n##   28                    0\n##   29                    0\n##   30                    0\n##   31                    0\n##   32                    0\n##   33                    0\n##   34                    0\n##   35                    0\n##   36                    0\n##   37                    0\n##   38                    0\n##   39                    0\n##   40                    0\n##   41                    0\n##   42                    0\n##   43                    0\n##   44                    0\n##   45                    0\n##   46                    0\n##   47                    0\n##   48                    0\n##   49                    0\n##   50                    0\n##   51                    0\n##   52                    0\n##   53                    0\n##   54                    0\n##   55                    0\n##   56                    0\n##   57                    0\n##   58                    0\n##   59                    0\n##   60                    0\n##   61                    0\n##   62                    0\n##   63                    0\n##   64                    0\n##   65                    0\n##   66                    0\n##   67                    0\n##   68                    0\n##   69                    0\n##   70                    0\n##   72                    0\n##   73                    0\n##   76                    0\n##   84                    0\n##   <NA>                107\nlinelist <- linelist %>% \n  \n  # cut() cria age_cat, automaticamente da classe Fator     \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # tornar explícitos os valores ausentes\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Idade Ausente\")  # você pode especificar o rótulo\n  )    \n\n# tabela para ver contagens\ntable(linelist$age_cat, useNA = \"always\")## \n##           0-4           5-9         10-14         15-19         20-29         30-49 \n##          1227          1223          1048           827          1216           848 \n##         50-69        70-100 Idade Ausente          <NA> \n##           105             7           107             0\n# Fazer pontos de quebra de 0 a 90 por 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Fazer etiquetas para as categorias acima, assumindo as configurações padrão de cut()\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n#  verificar se ambos os vetores têm o mesmo comprimento\nlength(age_seq) == length(age_labels)"},{"path":"cleaning.html","id":"quebrar-por-quantil","chapter":"8 Limpeza de dados e principais funções","heading":"Quebrar por quantil","text":"entendimento comum, “quantis” ou “percentis” normalmente se referem um valor abaixo qual uma proporção de valores está contida. Por exemplo, o 95º percentil de idades dessa linelist seria idade abaixo da qual estão 95% dos valores de idade.entanto, na fala comum, “quartis” e “decis” também podem se referir aos grupos de dados igualmente divididos em 4 ou 10 grupos (observe que haverá mais um ponto de quebra que grupo).Para obter pontos de quebra de quantil, você pode usar quantile() pacote stats R base. Você fornece um vetor numérico (por exemplo, uma coluna em um conjunto de dados) e um vetor de valores numéricos de probabilidade variando de 0 1,0. Os pontos de interrupção são retornados como um vetor numérico. Explore os detalhes das metodologias estatísticas inserindo ?quantile.Se o seu vetor numérico de entrada tiver algum valor ausente, é melhor definir na.rm = TRUEDefina names = FALSE para obter um vetor numérico sem nomeVocê pode usar os resultados de quantile() como pontos de quebra em age_categories() ou cut(). Abaixo nós criamos uma nova coluna deciles usando cut() onde quebras são definidas usando quantiles() em age_years. Abaixo, nós exibimos os resultados usando tabyl() janitor para que você possa ver porcentagens (consulte página Tabelas descritivas ). Observe como eles não são exatamente 10% em cada grupo.","code":"\nquantile(linelist$age_years,               # especifique o vetor numérico para trabalhar nele\n  probs = c(0, .25, .50, .75, .90, .95),   # especifique os percentis que você quer\n  na.rm = TRUE)                            # ignore os valores ausentes ##  0% 25% 50% 75% 90% 95% \n##   0   6  13  23  33  41\nlinelist %>%                                # inicie com linelist\n  mutate(deciles = cut(age_years,           # crie a nova coluna decile como cut() da coluna age_years\n    breaks = quantile(                      # defina as quebras usando quantile()\n      age_years,                               # opere em age_years\n      probs = seq(0, 1, by = 0.1),             # de 0.0 a 1.0 a cada 0.1\n      na.rm = TRUE),                           # ignore os valores ausentes\n    include.lowest = TRUE)) %>%             # para cut() incluir idade 0\n  janitor::tabyl(deciles)                   # pipe para a tabela ser exibida##  deciles   n    percent valid_percent\n##    [0,2] 748 0.11319613    0.11505922\n##    (2,5] 721 0.10911017    0.11090601\n##    (5,7] 497 0.07521186    0.07644978\n##   (7,10] 698 0.10562954    0.10736810\n##  (10,13] 635 0.09609564    0.09767728\n##  (13,17] 755 0.11425545    0.11613598\n##  (17,21] 578 0.08746973    0.08890940\n##  (21,26] 625 0.09458232    0.09613906\n##  (26,33] 596 0.09019370    0.09167820\n##  (33,84] 648 0.09806295    0.09967697\n##     <NA> 107 0.01619249            NA"},{"path":"cleaning.html","id":"grupos-de-tamanho-uniforme","chapter":"8 Limpeza de dados e principais funções","heading":"Grupos de tamanho uniforme","text":"Outra ferramenta para fazer grupos numéricos é função ntile() dplyr , que tenta dividir seus dados em n grupos de tamanho uniforme - mas esteja ciente de que diferente com quantile() o mesmo valor pode aparecer em mais de um grupo. Forneça o vetor numérico e, em seguida, o número de grupos. Os valores na nova coluna criada são apenas “números” grupo (por exemplo, 1 10), não o intervalo de valores em si, como ao usar cut().","code":"\n# faça grupos com ntile()\nntile_data <- linelist %>% \n  mutate(even_groups = ntile(age_years, 10))\n\n# faça uma tabela de contagem e proporções por grupo\nntile_table <- ntile_data %>% \n  janitor::tabyl(even_groups)\n  \n# fixe os valores mín/máx para demonstrar as faixas\nntile_ranges <- ntile_data %>% \n  group_by(even_groups) %>% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )## Warning: There were 2 warnings in `summarise()`.\n## The first warning was:\n## ℹ In argument: `min = min(age_years, na.rm = T)`.\n## ℹ In group 11: `even_groups = NA`.\n## Caused by warning in `min()`:\n## ! no non-missing arguments to min; returning Inf\n## ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n# combine e \"printe\" - note que valores estão presentes em múltiplos grupos\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")##  even_groups   n    percent valid_percent min  max\n##            1 651 0.09851695    0.10013844   0    2\n##            2 650 0.09836562    0.09998462   2    5\n##            3 650 0.09836562    0.09998462   5    7\n##            4 650 0.09836562    0.09998462   7   10\n##            5 650 0.09836562    0.09998462  10   13\n##            6 650 0.09836562    0.09998462  13   17\n##            7 650 0.09836562    0.09998462  17   21\n##            8 650 0.09836562    0.09998462  21   26\n##            9 650 0.09836562    0.09998462  26   33\n##           10 650 0.09836562    0.09998462  33   84\n##           NA 107 0.01619249            NA Inf -Inf"},{"path":"cleaning.html","id":"case_when","chapter":"8 Limpeza de dados e principais funções","heading":"case_when()","text":"É possível utilizar função case_when() dplyr para criar categorias partir de uma coluna numérica, mas é mais fácil utilizar age_categories() epikit ou cut() porque estas criarão automaticamente um fator ordenado.Se utilizar case_when(), por favor, revise o uso apropriado conforme descrito anteriormente na seção recodificar valores desta página. Esteja ciente também que todos os valores lado direito devem ser da mesma classe. Assim, se você quiser NA lado direito, você deve escrever “Ausente” ou utilizar o valor NA especial NA_character_.","code":""},{"path":"cleaning.html","id":"adicionar-à-cadeia-pipe","chapter":"8 Limpeza de dados e principais funções","heading":"Adicionar à cadeia pipe","text":"Abaixo, é adicionado o código para criar duas colunas de idade categóricas à cadeia pipe de limpeza:","code":"\n# CADEIA DE LIMPEZA 'PIPE' \n# (inicie com dados brutos e canalize-os através de etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist <- linelist_raw %>%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %>% \n    \n    # renomeie as colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # remova as duplicidades\n    distinct() %>% \n\n    # adicione coluna\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # converta classe de colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # adicione coluna: demora para internação\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # limpe valores da coluna do hospital\n    mutate(hospital = recode(hospital,\n                      # VELHO = NOVO\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Ausente\")) %>% \n\n    # crie a coluna age_years (de age e age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    # ACIMA ESTÃO AS ETAPAS DE LIMPEZA A MONTANTE JÁ DISCUTIDAS\n    ###################################################   \n    mutate(\n          # categorias de idade:personalizado\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # categorias etárias: 0 a 85 por 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))"},{"path":"cleaning.html","id":"adicionar-linhas","chapter":"8 Limpeza de dados e principais funções","heading":"8.10 Adicionar linhas","text":"","code":""},{"path":"cleaning.html","id":"uma-por-uma","chapter":"8 Limpeza de dados e principais funções","heading":"Uma-por-uma","text":"Adicionar linhas uma-por-uma manualmente é tediosa mas pode ser feito com add_row() dplyr. Relembre que cada coluna deve conter valores de apenas uma classe (seja caracter, numérico, lógico, etc.). Então adicionar uma linha reque detalhes para manter isso.Utilize .e .. para especificar colocação da linha que você deseja adicionar. .= 3colocará nova linha antes da 3ª linha atual. O comportamento padrão é adicionar linha ao final. colunas não especificadas serão deixadas vazias (NA).O novo número da linha pode parecer estranho (“…23”), mas os números das linhas preexistentes mudaram. Portanto, se utilizar o comando duas vezes, examine/teste inserção cuidadosamente.Se uma classe que você fornece estiver desligada, você verá um erro como este:(ao inserir uma linha com um valor de data, lembre-se de embrulhar data na função .Date() como .Date(\"2020-10-10\")).","code":"\nlinelist <- linelist %>% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)Erro: Não é possível combinar ..1$infection date <date> e ..2$infection date <character>. "},{"path":"cleaning.html","id":"colar-linhas","chapter":"8 Limpeza de dados e principais funções","heading":"Colar linhas","text":"Para combinar conjuntos de dados unindo linhas de um dataframe ao fundo de outro dataframe, pode-se utilizar bind_rows() dplyr. Isto é explicado com mais detalhes na página Juntando dados.","code":""},{"path":"cleaning.html","id":"filtrar-linhas","chapter":"8 Limpeza de dados e principais funções","heading":"8.11 Filtrar linhas","text":"Uma etapa típica de limpeza depois de limpar colunas e recodificar os valores é filtrar o dataframe para linhas específicas utilizando o verbo filter() dplyr.Dentro de filter(), especificar lógica que deve ser TRUE para que uma linha conjunto de dados seja mantida. Abaixo mostramos como filtrar linhas com base em condições lógicas simples e complexas.","code":""},{"path":"cleaning.html","id":"filtro-simples","chapter":"8 Limpeza de dados e principais funções","heading":"Filtro simples","text":"Este exemplo simples redefine o dataframe linelist como ela mesma, tendo filtrado linhas para atender uma condição lógica. Apenas linhas onde declaração lógica dentro dos parênteses avaliada comoTRUE são mantidas.Neste exemplo, afirmação lógica é gender == \"f\", que é perguntar se o valor na colunagender é igual “f” (sensível maiúsculas e minúsculas).Antes filtro ser aplicado, o número de linhas da linelist é nrow(linelist).Depois que o filtro é aplicado, o número de linhas da linelist é linelist %>% filter(gender == \"f\") %>% nrow().","code":"\nlinelist <- linelist %>% \n  filter(gender == \"f\")   # mantenha apenas as linhas onde o gênero é igual a  \"f\""},{"path":"cleaning.html","id":"filtrar-valores-faltantes","chapter":"8 Limpeza de dados e principais funções","heading":"Filtrar valores faltantes","text":"É bastante comum querer filtrar linhas que possuem valores ausentes. Resista à tentação de escrever filter(!.na(column) & !.na(column)) e ao invés disso use função tidyr que é customizada para este propósito: drop_na(). Se executado com parênteses vazios, ele remove linhas com qualquer valores ausentes. Alternativamente, você pode fornecer nomes de colunas específicas serem avaliadas quanto à ausência, ou usar funções auxiliares “tidyselect” descritas acima.Veja página sobre Campos em branco/faltantes para várias técnicas para analisar e manipular valores faltantes nos seus dados.","code":"\nlinelist %>% \n  drop_na(case_id, age_years)  # elimila as linhas com valores faltates nas colunas case_id ou age_years"},{"path":"cleaning.html","id":"filtrar-pelo-número-da-linha","chapter":"8 Limpeza de dados e principais funções","heading":"Filtrar pelo número da linha","text":"Em um quadro de dados ou tibble, cada linha terá geralmente um “número de linha” que (quando visto R Viewer) aparece à esquerda da primeira coluna. Não é em si uma coluna verdadeira nos dados, mas pode ser utilizada em uma declaração filter().Para filtrar com base “número de linha”, é possível utilizar função dplyr com o row_number() com parênteses abertos como parte de uma instrução de filtragem lógica. Muitas vezes você utilizará o operador %% e um range de números como parte dessa instrução lógica, como mostrado abaixo. Para ver primeiras N fileiras , você também pode utilizar função especial head()l pacote dplyr .Você também pode converter os números das linhas para uma coluna verdadeira, canalizando seu data Frame para função tibble rownames_to_column() (não coloque nada entre parênteses).","code":"\n# Veja as primeiras 100 linhas\nlinelist %>% head(100)     # ou use  tail() tvara ver as últimas n linhas\n\n# Mostre apenas 5 linhas\nlinelist %>% filter(row_number() == 5)\n\n# Veja linha 2 a 20 e especifique 3 colunas \nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)"},{"path":"cleaning.html","id":"filtro-complexo","chapter":"8 Limpeza de dados e principais funções","heading":"Filtro complexo","text":"Sentenças lógicas mais complexas podes ser contruídas usando parênteses ( ), OU os operadores |, !, %%, e &. Um exemplo pode ser visto abaixo:Nota: Você pode utilizar o ! operador em frente um critério lógico para negá-lo. Por exemplo, !.na(column) avalia para verdadeiro se o valor da coluna não é faltante. Da mesma forma, !column %% c(\"\", \"b\", \"c\") avalia se o valor da coluna não está contido vetor.","code":""},{"path":"cleaning.html","id":"examine-os-dados","chapter":"8 Limpeza de dados e principais funções","heading":"Examine os dados","text":"Abaixo está um simples comando de uma linha para criar um histograma de datas de início. Veja que um segundo surto menor de 2012-2013 também está incluído neste conjunto de dados brutos. Para nossas análises, queremos remover entradas deste surto anterior.","code":"\nhist(linelist$date_onset, breaks = 50)"},{"path":"cleaning.html","id":"como-os-filtros-lidam-com-valores-numericos-e-datas-faltantes","chapter":"8 Limpeza de dados e principais funções","heading":"Como os filtros lidam com valores numericos e datas faltantes","text":"Podemos simplesmente filtrar por ‘date_onset’ para linhas após junho de 2013? Cuidado! Aplicando o código filter(date_onset > .Date(\"2013-06-01\"))) removeria qualquer linha na última epidemia com uma data de início ausente!PERIGO: Filtrar para maior que (>) ou menor que (<) uma data ou número pode remover qualquer linha com valores ausentes (NA)! Isto porque NA é tratado como infinitamente grande e pequeno.(Veja página em Trabalhando com datas para mais informações sobre como trabalhar com datas e o pacote lubridate)","code":""},{"path":"cleaning.html","id":"desenhe-o-filtro","chapter":"8 Limpeza de dados e principais funções","heading":"Desenhe o filtro","text":"Examine tabulação cruzada para ter certeza que excluímos somente linhas corretas:Que outros critérios podemos filtrar para remover o primeiro surto (em 2012 e 2013) conjunto de dados? Vemos isso:primeira epidemia em 2012 & 2013 ocorreu Hospital , Hospital B, e que também houve 10 casos Port Hospital.Os Hospitais e B não tiveram casos na segunda epidemia, mas o Port Hospital teve.Queremos excluir:nrow(linelist %>% filter(hospital %% c(\"Hospital \", \"Hospital B\") | date_onset < .Date(\"2013-06-01\"))) filas com início em 2012 e 2013 hospital , B, ou Porto.\nExcluir nrow(linelist %>% filter(date_onset < .Date(\"2013-06-01\"))) filas com início em 2012 e 2013\nExcluir nrow(linelist %>% filter(hospital %em% c('Hospital ', 'Hospital B') & .na(date_onset)))linhas dos Hospitais & B com datas de início ausentes\nFazer não excluir nrow(linelist %>% filter(!hospital %% c('Hospital ', 'Hospital B') & .na(date_onset))) outras linhas com datas de início ausentes.\nExcluir nrow(linelist %>% filter(date_onset < .Date(\"2013-06-01\"))) filas com início em 2012 e 2013Excluir nrow(linelist %>% filter(hospital %em% c('Hospital ', 'Hospital B') & .na(date_onset)))linhas dos Hospitais & B com datas de início ausentesFazer não excluir nrow(linelist %>% filter(!hospital %% c('Hospital ', 'Hospital B') & .na(date_onset))) outras linhas com datas de início ausentes.Começamos com uma lineliste de nrow(linelist){\\i1}. Aqui está nossa declaração de filtro:Quando refazemos tabulação cruzada, vemos que os Hospitais e B são completamente removidos, e os 10 casos de hospitais portuários de 2012 e 2013 são removidos, e todos os outros valores são os mesmos - exatamente como queríamos.Declarações múltiplas podem ser incluídas dentro de um comando de filtro (separadas por vírgulas), ou você pode sempre encadear com um %>% para um comando filter() separado para maior clareza.Nota: alguns leitores podem notar que seria mais fácil filtrar apenas por date_hospitalisation porque é 100% completo sem valores ausentes. Isto é verdade. Mas o date_onset é utilizado com o propósito didático de demonstrar um filtro complexo.","code":"\ntable(Hospital  = linelist$hospital,                     # nome do hospital\n      YearOnset = lubridate::year(linelist$date_onset),  # ano de inicio dos sintomas (date_onset)\n      useNA     = \"always\")                              # mostrar valores faltantes##                                       YearOnset\n## Hospital                               2012 2013 2014 2015 <NA>\n##   Ausente                                 0    0 1117  318   77\n##   Central Hospital                        0    0  351   99   18\n##   Hospital A                            229   46    0    0   15\n##   Hospital B                            227   47    0    0   15\n##   Military Hospital                       0    0  676  200   34\n##   Other                                   0    0  684  177   46\n##   Port Hospital                           9    1 1372  347   75\n##   St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n##   <NA>                                    0    0    0    0    0\nlinelist <- linelist %>% \n  # mantém linhas onde o início é depois de 1 de Junho OU o início dos sintomas está faltante E o hospital é OUTRO que não A nem B \n  filter(date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)## [1] 6019\ntable(Hospital  = linelist$hospital,                     # nome do hospital\n      YearOnset = lubridate::year(linelist$date_onset),  # ano de início dos sintomas\n      useNA     = \"always\")                              # mostrar valores faltantes##                                       YearOnset\n## Hospital                               2014 2015 <NA>\n##   Ausente                              1117  318   77\n##   Central Hospital                      351   99   18\n##   Military Hospital                     676  200   34\n##   Other                                 684  177   46\n##   Port Hospital                        1372  347   75\n##   St. Mark's Maternity Hospital (SMMH)  322   93   13\n##   <NA>                                    0    0    0"},{"path":"cleaning.html","id":"autônomoindependente","chapter":"8 Limpeza de dados e principais funções","heading":"Autônomo/Independente","text":"Um filtro também pode ser feito como um comando autônomo (não parte de uma cadeia de pipes (%>%)). Como outros verbos dplyr, neste caso o primeiro argumento deve ser o próprio conjunto de dados.Você também pode usar o R base para criar um subconjunto dos dados, usando colchetes que refletem [linhas, colunas] que você deseja reter.","code":"\n# dataframe <- filter(dataframe, condition(s) for rows to keep)\n\nlinelist <- filter(linelist, !is.na(case_id))\n# dataframe <- dataframe[row conditions, column conditions] (se deixar a entrada em branco significa \"todas as linhas ou todas as colunas\")\n\nlinelist <- linelist[!is.na(case_id), ]"},{"path":"cleaning.html","id":"revisar-rapidamente-registros","chapter":"8 Limpeza de dados e principais funções","heading":"Revisar rapidamente registros","text":"Muitas vezes você quer rever rapidamente alguns registros, para apenas algumas colunas. função R base View() exibirá um dataframe para visualização em seu RStudio.Veja lineliste RStudio:Aqui estão dois exemplos de visualização de células específicas (linhas específicas, e colunas específicas):Com funções dplyr filter() e select():Dentro de View(), encadeie o conjunto de dados com o pipe (%>%) com função filter() para manter certas linhas, e depois com função select() para manter certas colunas. Por exemplo, para rever datas de início e hospitalização de 3 casos específicos:Você consegue os mesmos resultados com seguinte sintaxe R base , usando colchetes [ ] para subdividir o que você quer ver.","code":"\nView(linelist)\nView(linelist %>%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %>%\n       select(date_onset, date_hospitalisation))\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])"},{"path":"cleaning.html","id":"adiciotar-a-uma-cadeia-usando-o-pipe","chapter":"8 Limpeza de dados e principais funções","heading":"Adiciotar a uma cadeia usando o pipe (%>%)","text":"","code":"\n#  CADEIA DE LIMPEZA 'PIPE' (inicie com dados brutos e canalize-os através de etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist <- linelist_raw %>%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %>% \n    \n    # renomeie as colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # remova duplicidades\n    distinct() %>% \n\n    # adicione colunas\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # converta classe de colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # adicione coluna: demora para internação\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # limpe valores da coluna do hospital\n    mutate(hospital = recode(hospital,\n                      # VELHO = NOVO\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Ausente\")) %>% \n\n    # crie a coluna age_years (de age e age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    mutate(\n          # categorias de idade: personalizado\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # categorias de idade: 0 a 85 por 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% \n    \n    # ACIMA ESTÃO AS ETAPAS DE LIMPEZA A MONTANTE JÁ DISCUTIDAS\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))"},{"path":"cleaning.html","id":"cálculo-por-linha","chapter":"8 Limpeza de dados e principais funções","heading":"8.12 Cálculo por linha","text":"Se você quiser realizar um cálculo dentro de uma linha, você pode utilizar rowwise() partir de dplyr. Veja esta vinheta online em cálculos em linha.\nPor exemplo, este código se aplica rowwise() e então cria uma nova coluna que soma o número das colunas de sintomas especificados que têm o valor “yes” (sim), para cada linha da lista de linhas. colunas são especificadas dentro de sum() pelo nome dentro de um vetor c(). coluna rowwise() é essencialmente um tipo especial de group_by(), portanto é melhor utilizar ungroup() quando você terminar (página em Agrupar dados).Ao especificar coluna ser avaliada, talvez você queira utilizar funções de ajuda “tidyselect” descritas na seção select() desta página. Você só tem que fazer um ajuste (porque não está utilizando-dentro de uma função dplyr como select() ou summarise()).Coloque o critério de especificação de coluna dentro da função dplyr c_across(). Isto porque c_across (documentação) é projetado para trabalhar com rowwise() especificamente. Por exemplo, o seguinte código:Aplica-se rowwise() assim seguinte operação (sum()) é aplicada dentro de cada linha (não somando colunas inteiras)Cria nova coluna num_NA_dates, definida para cada linha como o número de colunas (com nome contendo “data”) para quais .na() avaliadas para VERDADEIRO (estão faltando dados).grupo()ungroup() para remover os efeitos de rowwise() para etapas subseqüentes.Você também poderia fornecer outras funções, tais como max() para obter data mais recente ou mais recente para cada linha:","code":"\nlinelist %>%\n  rowwise() %>%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %>% \n  ungroup() %>% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # para mostrar## # A tibble: 5,888 × 6\n##    fever chills cough aches vomit num_symptoms\n##    <chr> <chr>  <chr> <chr> <chr>        <int>\n##  1 no    no     yes   no    yes              2\n##  2 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  3 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  4 no    no     no    no    no               0\n##  5 no    no     yes   no    yes              2\n##  6 no    no     yes   no    yes              2\n##  7 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  8 no    no     yes   no    yes              2\n##  9 no    no     yes   no    yes              2\n## 10 no    no     yes   no    no               1\n## # ℹ 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %>% \n  ungroup() %>% \n  select(num_NA_dates, contains(\"date\")) # para mostrar## # A tibble: 5,888 × 5\n##    num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n##           <int> <date>         <date>     <date>               <date>      \n##  1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n##  2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n##  3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n##  4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n##  5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n## 10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n## # ℹ 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %>% \n  ungroup() %>% \n  select(latest_date, contains(\"date\"))  # para mostrar ## # A tibble: 5,888 × 5\n##    latest_date date_infection date_onset date_hospitalisation date_outcome\n##    <date>      <date>         <date>     <date>               <date>      \n##  1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n##  2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n##  3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n##  4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n##  5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n## 10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n## # ℹ 5,878 more rows"},{"path":"cleaning.html","id":"organizar-e-ordenar","chapter":"8 Limpeza de dados e principais funções","heading":"8.13 Organizar e ordenar","text":"Utilize função dplyr arrange() para ordenar ou ordenar linhas por valores de coluna.Simplesmente liste colunas na ordem em que elas devem ser ordenadas. Especifique .by_group = TRUE se você quiser que ordenação ocorra primeiro por quaisquer grupos aplicados aos dados (ver página em Agrupar dados).Por padrão, coluna será ordenada em ordem “ascendente” (que se aplica às colunas numéricas e também às colunas de caracteres). Você pode ordenar uma variável em ordem “decrescente”, envolvendo-com desc().ordenação de dados com arrange() é particularmente útil ao fazer Tabelas para apresentação, utilizando slice() para pegar linhas “top” por grupo, ou definir ordem de nível de fator por ordem de aparência.Por exemplo, para ordenar linhas de nossa linelist por hospital, depois por date_onset em ordem decrescente, nós utilizaríamos:","code":"\nlinelist %>% \n   arrange(hospital, desc(date_onset))"},{"path":"dates.html","id":"dates","chapter":"9 Trabalhando com datas","heading":"9 Trabalhando com datas","text":"Trabalhar com datas R requer mais atenção que trabalhar com outras classes de objetos. Abaixo, estão apresentadas algumas ferramentas e exemplos para tornar esse processo menos doloroso. Felizmente, datas podem ser alteradas facilmente com prática e com um conjunto de pacotes úteis, como lubridate.Na importação de dados brutos, o R frequentemente interpreta datas como objetos de caracteres - isso significa que elas não podem ser usados para operações gerais de data, como criar séries temporais e calcular intervalos de tempo. Para tornar coisas mais difíceis, existem muitas maneiras de formatar uma data e é preciso ajudar o R saber qual parte da data representa o quê (mês, dia, hora, etc.).datas R possuem sua própria classe de objeto - classe Date. Deve-se destacar que também existe uma classe que armazena objetos com data e hora. Objetos de data e hora são formalmente chamados de classes POSIXt, POSIXct, e/ou POSIXlt (diferença não é importante). Esses objetos são informalmente chamados de classes de data-e-hora (datetime).É importante fazer com que o R reconheça quando uma coluna contém datas.É importante fazer com que o R reconheça quando uma coluna contém datas.datas são uma classe de objeto própria e podem ser complicado de trabalhar com elas.datas são uma classe de objeto própria e podem ser complicado de trabalhar com elas.Aqui, são apresentadas várias maneiras de converter colunas com datas em classe de objeto Date.Aqui, são apresentadas várias maneiras de converter colunas com datas em classe de objeto Date.","code":""},{"path":"dates.html","id":"preparação","chapter":"9 Trabalhando com datas","heading":"9.1 Preparação","text":"","code":""},{"path":"dates.html","id":"carregar-os-pacotes","chapter":"9 Trabalhando com datas","heading":"Carregar os pacotes","text":"Esse trecho de código mostra o carregamento dos pacotes necessários para esta página. Neste manual enfatizamos função p_load() pacman, que instala o pacote se necessário e o carrega para utilização. Tamém é possível carregar os pacotes instalados com library() partir R base. Para mais informações, veja página em Introdução ao R sobre pacotes R.","code":"\n# Confere se o pacote está instalado, instala o pacote se necessário, e carrega-o para a sessão atual\n\npacman::p_load(\n  lubridate,  # pacote geral para manipulação e conversão de datas  \n  parsedate,   # possui a função de \"adivinhar\" datas desorganizadas\n  aweek,      # outra opção para conversão de datas em semanas, e de semanas em datas \n  zoo,        # funções adicionais de data/hora\n  tidyverse,  # gerenciamento e visualização dos dados  \n  rio)        # importação/exportação dos dados"},{"path":"dates.html","id":"importação-dos-dados","chapter":"9 Trabalhando com datas","heading":"Importação dos dados","text":"Importamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você deseja baixar os dados para acompanhar passo passo, consulte instruções na página Baixar manual e dados. Presumimos que o arquivo está diretório de trabalho, portanto, nenhuma subpasta é especificada neste caminho de arquivo.","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"dates.html","id":"data-atual","chapter":"9 Trabalhando com datas","heading":"9.2 Data atual","text":"Você pode obter data atual “sistema” ou data e hora sistema seu computador por meio da seguintes funções presentes R base.Com o pacote lubridate, essas informações também pode ser retornadas com today() e now(), respectivamente. date() retorna data e hora atual com os nomes dos dias da semana e dos meses.","code":"\n# obter a data do sistema - esta é uma classe DATE\nSys.Date()## [1] \"2023-10-22\"\n# obter a hora do sistema - esta é uma classe DATETIME\nSys.time()## [1] \"2023-10-22 12:31:33 CEST\""},{"path":"dates.html","id":"converter-para-data","chapter":"9 Trabalhando com datas","heading":"9.3 Converter para Data","text":"Depois de importar um conjunto de dados para o R, os valores da coluna com datas podem ser semelhantes “1989/12/30”, “05/06/2014”, ou “13 Janeiro 2020”. Nesses casos, é provável que o R ainda esteja lendo esses valores como caracteres. O R deve ser informado que esses valores são datas… e o que esse fomato de data representa (qual parte é referente ao dia, mês, ano, etc).Uma vez informado, o R converte esses valores para classe Date. Em segundo plano, o R armazenará datas como números (o número de dias partir de sua data de “origem” 1 de janeiro de 1970). Você não fará interface com o número da data com frequência, mas isso permite que R trate datas como variáveis contínuas e permita operações especiais, como calcular distância entre datas.Por padrão, os valores da classe Date em R são exibidos como AAAA-MM-DD. Posteriormente nesta seção, discutiremos como alterar exibição dos valores de data.seguir, apresentamos duas abordagens para converter uma coluna de valores de caracteres para classe Date.DICA: Você pode checar classe atual de uma coluna utilizando função class()presente na base R , como por exemplo class(linelist$date_onset).","code":""},{"path":"dates.html","id":"r-base","chapter":"9 Trabalhando com datas","heading":"R base","text":".Date() é função presente R base para conversão um objeto ou coluna para classe Data (observe capitalização de “D”).Para o uso da função .Date() é preciso que:Você especifique o formato existente da data como um caractere bruto ou então que especifique data de origem, caso forneça datas como números (consulte seção sobre datas Excel);Se foi usado em uma coluna de caracteres, todos os valores de data devem ter o mesmo formato exato (se este não o caso, tente parse_date() pacote parsedate).Primeiro, verifique classe de sua coluna com class() R base. Se você não tem certeza ou está confuso sobre classe de seus dados (por exemplo, você vê “POSIXct”, etc.) pode ser mais fácil primeiro converter coluna para classe Character com função .character(), e depois converter para classe Date.Segundo, dentro da função .Date(), use o argumento format = para informar ao R o formato atual dos componentes da data como caractere - quais caracteres se referem ao mês, dia e ano, e como eles são separados. Se seus valores já estiverem em um dos formatos de data padrão R (“AAAA-MM-DD” ou “AAAA/MM/DD”), o argumento format = não é necessário.Para format =, forneça uma sequência de caracteres (entre aspas) que representa o formato de data atual usando abreviações especiais “strptime” abaixo. Por exemplo, se datas dos caracteres estão atualmente formato “DD/MM/AAAA”, como “24/04/1968”, você usaria format = \"%d/%m/%Y\" para converter os valores em datas. É necessário colocar o formato entre aspas. E não se esqueça de quaisquer barras ou travessões!maioria das abreviações de strptime estão listadas abaixo. Você pode ver lista completa executando ?strptime.%d = Número dia mês (5, 17, 28, etc.)\n%j = Número dia ano (dia Juliano 001-366)\n%= Dia da semana abreviado (Seg, Ter, Quarta,etc. ou Mon, Tue, Wed, etc.)\n%= Dia da semana completo (segunda, terça, etc.)%w = Número dia da semana (0-6, sendo que domingo é 0)\n%u = Número dia da semana (1-7, sendo que segunda é 1)\n%W = Número da semana (00-53, segunda é início da semana)\n%U = Número da semana (01-53, domingo é o início da semana)\n%m = Número mês (por exemplo, 01, 02, 03, 04)\n%b = Mês abreviado (Jan, Fev, etc.)\n%B = Mês completo (Janeiro, Fevereiro, etc.)  %y = Ano em 2 dígitos (por exemplo, 89)\n%Y = Ano em 4 dígitos (por exemplo, 1989)\n%h = horas (relógio de 24 horas)\n%M = minutos\n%s = segundos%z = deslocamento GMT\n%Z = fuso horário (caractere)DICA: argumento format = da função .Date() não está informando ao R o formato que deseja que datas tenham, mas sim como identificar partes da data da forma como elas estão, antes de rodar o comando.DICA: Certifique-se de que argumento format = você usa o separador de data (por exemplo, /, -, ou espaço) que está presente em suas datas.Uma vez que os valores estão na classe Date, o R os exibirá formato padrão, que é AAAA-MM-DD.","code":"\n# Converter para classe data\nlinelist <- linelist %>% \n  mutate(date_onset = as.Date(date_of_onset, format = \"%d/%m/%Y\"))"},{"path":"dates.html","id":"lubridate","chapter":"9 Trabalhando com datas","heading":"lubridate","text":"conversão de objetos de caracteres em datas pode ser facilitada com o uso pacote lubridate. Este é um pacote tidyverse projetado para tornar o trabalho com datas e horários mais simples e consistente que R base. Por essas razões, lubridate é frequentemente considerado o pacote padrão ouro para datas e horários, e é recomendado sempre que trabalhar com eles.O pacote lubridate fornece diferentes funções auxiliares projetadas para converter objetos de caracteres em datas de uma forma intuitiva e mais branda que especificar o formato em .Date(). Essas funções são específicas para o formato de data aproximada, mas permitem uma variedade de separadores e sinônimos para datas (como, 01 vs Jan vs Janeiro) - eles são nomeados após abreviações de formatos de data.função ymd() converte de forma flexível os valores de data fornecidos como ano, seguido de mês, e depois dia.função mdy() converte de forma flexível os valores de data fornecidos como mês, seguido de dia, e ano.função dmy() converte de forma flexível os valores de data fornecidos como dia, seguida de mês, e ano.Se estiver usando o pipe %>%, conversão de uma coluna de caracteres para datas com lubridate pode ser feita assim:Depois de concluído, você pode executar class() para verificar classe da colunaUma vez que os valores estão na classe Date, o R os exibirá por padrão formato AAAA-MM-DD.Observe que funções acima funcionam melhor com anos de 4 dígitos. Anos de 2 dígitos podem produzir resultados inesperados, à medida que lubridate tenta adivinhar o século.Para converter um ano de 2 dígitos em um ano de 4 dígitos (todos mesmo século) você pode converter datas para caractere e então combinar os dígitos existentes com uma pré-correção usando str_glue() pacote stringr (veja Caracteres e strings). Em seguida, converta para data.","code":"\n# instale/carregue lubridate \npacman::p_load(lubridate)\n# Leia a data no formato ano-mês-dia\nymd(\"2020-10-11\")## [1] \"2020-10-11\"\nymd(\"20201011\")## [1] \"2020-10-11\"\n# Leia a data no formato mês-dia-ano\nmdy(\"10/11/2020\")## [1] \"2020-10-11\"\nmdy(\"Oct 11 20\")## [1] \"2020-10-11\"\n# Leia a data no formato dia-mês-ano\ndmy(\"11 10 2020\")## [1] \"2020-10-11\"\ndmy(\"11 October 2020\")## [1] \"2020-10-11\"\nlinelist <- linelist %>%\n  mutate(date_onset = lubridate::dmy(date_onset))\n# Confira a classe da coluna \nclass(linelist$date_onset)  \nano_dois_digitos <- c(\"15\", \"15\", \"16\", \"17\")\nstr_glue(\"20{ano_dois_digitos}\")## 2015\n## 2015\n## 2016\n## 2017"},{"path":"dates.html","id":"combine-colunas","chapter":"9 Trabalhando com datas","heading":"Combine colunas","text":"Você pode usar funções lubridate make_date() e make_datetime() para combinar múltiplas colunas numéricas em uma coluna de data. Por exemplo, se você tiver colunas numéricas onset_day, onset_month, e onset_year na tabela de dados linelist:","code":"\nlinelist <- linelist %>% \n  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))"},{"path":"dates.html","id":"datas-do-excel","chapter":"9 Trabalhando com datas","heading":"9.4 Datas do Excel","text":"Em segundo plano, maioria dos softwares armazena datas como números. O R armazena datas de uma origem de 1º Janeiro, 1970. Portanto, se você executar .numeric(.Date(\"1970-01-01)) você obterá 0.O Microsoft Excel armazena datas com um origem em 30 de dezembro de 1899 (Windows) ou 1 de janeiro de 1904 (Mac), dependendo seu sistema operacional. Consulte em Microsoft guidance para obter mais informações.datas Excel geralmente são importadas para o R como esses valores numéricos, em vez de caracteres. Se o conjunto de dados que você importou Excel mostra datas como números ou caracteres como “41369” … use .Date() (ou função lubridate as_date()) para converter, mas lugar de fornecer um “formato” como acima, forneça data de origem Excel argumento origin =.Isso não irá funcionar se datas Excel contidas R estiverem como caracteres, assim, confirme se os números estão classificados como Numérico!NOTA: Você deve fornecer data de origem formato de data padrão R (“AAAA-MM-DD”).","code":"\n# Um exemplo de fornecimento da 'data de origem' do Excel ao converter datas numéricas do Excel\ndata_cleaned <- data %>% \n  mutate(date_onset = as.numeric(date_onset)) %>%   # garantir que a classe seja numérica\n  mutate(date_onset = as.Date(date_onset, origin = \"1899-12-30\")) # converter para data usando a origem do Excel"},{"path":"dates.html","id":"datas-bagunçadas","chapter":"9 Trabalhando com datas","heading":"9.5 Datas bagunçadas","text":"função parse_date() pacote parsedate tenta ler uma coluna de data “bagunçada” contendo datas em muitos formatos diferentes e converte datas para um formato padrão. Você pode ler mais online sobre parse_date().Por exemplo, o parse_date() vê um vetor dos seguintes caracteres de datas “03 Jan 2018”, “07/03/1982”, e “08/20/85” e os converteria para classe Date como: 2018-01-03, 1982-03-07, e 1985-08-20.","code":"\nparsedate::parse_date(c(\"03 Jan 2018\",\n                        \"07/03/1982\",\n                        \"08/20/85\"))## [1] \"2018-01-03 UTC\" \"1982-07-03 UTC\" \"1985-08-20 UTC\"\n# Um exemplo usando parse_date() na coluna `date_onset` (data de início de sintomas)\nlinelist <- linelist %>%      \n  mutate(date_onset = parse_date(date_onset))"},{"path":"dates.html","id":"trabalhando-com-classe-de-data-hora","chapter":"9 Trabalhando com datas","heading":"9.6 Trabalhando com classe de data-hora","text":"Conforme mencionado anteriormente, o R também oferece suporte para dados de classe datetime - uma coluna que contém informações de data e hora. Assim como classe Date, eles geralmente precisam ser convertidos de objetos de character para objetos datetime.","code":""},{"path":"dates.html","id":"converter-datas-com-horas","chapter":"9 Trabalhando com datas","heading":"Converter datas com horas","text":"Um objeto datetime padrão é formatado com data primeiro, que é seguida por um componente de hora - por exemplo, 01 de janeiro de 2020, 16:30. Assim como acontece com datas, isso pode ser formatado de muitas maneiras e vários níveis de precisão (horas, minutos, segundos) que podem ser fornecidos.Felizmente, funções auxiliares lubridate também existem para ajudar converter essas junções para objetos datetime. Essas funções são extensões das funções auxiliares de data, com _h (apenas horas fornecidas), _hm (horas e minutos fornecidos), ou _hms (horas, minutos e segundos fornecidos) anexado ao final (por exemplo, dmy_hms()). Eles podem ser usados conforme mostrado abaixo:Converte “data e hora” contendo apenas horas para o objeto tipo datetimeConverte “data e hora” com horas e minutos para o objeto tipo datetimeConverte “data e hora” com horas, minutos e segundos para o objeto tipo datetimeVocê pode fornecer o fuso horário, mas ele será ignorado. Consulte seção mais adiante nesta página sobre fusos horários.Ao trabalhar com uma tabela de dados, colunas de hora e data podem ser combinadas para criar uma coluna data-e-hora (datetime) usando str_glue() pacote stringr e uma função apropriada lubridate. Consulte página em Caracteres e strings para obter detalhes sobre o stringr.Neste exemplo, tabela de dados linelist possui uma coluna formato “horas:minutos”. Para converter isso para data-e-hora, seguem-se algumas etapas:Crie uma coluna de tempo de admissão “limpa” na qual os valores ausentes são preenchidos pela mediana da coluna. Isso é realizado, pois lubridate não funciona com valores ausentes. Combine-o com coluna date_hospitalisation, e então use função ymd_hm() para converter.","code":"\nymd_h(\"2020-01-01 16hrs\")## [1] \"2020-01-01 16:00:00 UTC\"\ndmy_hm(\"01 January 2020 16:20\")## [1] \"2020-01-01 16:20:00 UTC\"\nmdy_hms(\"01 January 2020, 16:20:40\")## [1] \"2020-01-20 16:20:40 UTC\"\nmdy_hms(\"01 January 2020, 16:20:40 PST\")## [1] \"2020-01-20 16:20:40 UTC\"\n# pacotes\npacman::p_load(tidyverse, lubridate, stringr)\n\n# time_admission é a coluna em horas:minutos\nlinelist <- linelist %>%\n  \n  # quando o horário de admissão não é fornecido, atribua o horário médio de admissão\n  mutate(\n    time_admission_clean = ifelse(\n      is.na(time_admission),   # se horário estiver faltando\n      median(time_admission),  # atribua a mediana\n      time_admission           # se não estiver faltando, mantenha como está\n  )) %>%\n  \n    # use str_glue() para combinar as colunas de data-e-horas em uma coluna de caracteres\n    # em seguida, use ymd_hm() para converter em formato datetime\n  mutate(\n    date_time_of_admission = str_glue(\"{date_hospitalisation}{time_admission_clean}\") %>% \n      ymd_hm()\n  )"},{"path":"dates.html","id":"converta-horários-isolados","chapter":"9 Trabalhando com datas","heading":"Converta horários isolados","text":"Se seus dados contém apenas caracteres referente um horário (horas e minutos), você pode convertê-los e manipulá-los como tempos usando strptime() partir R base. Por exemplo, para obter diferença entre dois desses tempos:Observe, entretanto, que sem um valor de data fornecido, ele assume que data é hoje. , Veja como usar stringr na seção acima para combinar uma data string e um tempo string. Leia mais sobre strptime() aqui.Para converter números de um dígito em dois dígitos (por exemplo, para “preencher” horas ou minutos com zeros à esquerda para atingir 2 dígitos), consulte seção “Pad length” da página Caracteres e junções.","code":"\n# horário como caracteres brutos\ntime1 <- \"13:45\" \ntime2 <- \"15:20\"\n\n# horário convertidos para classe datetime \ntime1_clean <- strptime(time1, format = \"%H:%M\")\ntime2_clean <- strptime(time2, format = \"%H:%M\")\n\n# Por padrão, a diferença é da classe \"difftime\", aqui convertida em horas numéricas \nas.numeric(time2_clean - time1_clean)   # diferença em horas## [1] 1.583333"},{"path":"dates.html","id":"extrair-o-tempo","chapter":"9 Trabalhando com datas","heading":"Extrair o tempo","text":"Você pode extrair elementos de um tempo com hour(), minute(), ou second() lubridate.Aqui está um exemplo de extração da hora e em seguida, sua classificação por período dia. Começamos com coluna time_admission, qual está na classe Caractere formato “HH:MM”. Primeiro, strptime() é usado conforme descrito acima para converter os caracteres para classe datetime. Em seguida, hora é extraída com hour(), retornando um número de 0-24. Finalmente, uma coluna time_period usando lógica com função case_when() para classificar linhas em Manhã / Tarde / Início da noite / Noite com base na hora de admissão.Para saber mais sobre case_when() , consulte página Limpeza dos daos e principais funções.","code":"\nlinelist <- linelist %>%\n  mutate(hour_admit = hour(strptime(time_admission, format = \"%H:%M\"))) %>%\n  mutate(time_period = case_when(\n    hour_admit > 06 & hour_admit < 12 ~ \"Manhã\",\n    hour_admit >= 12 & hour_admit < 17 ~ \"Tarde\",\n    hour_admit >= 17 & hour_admit < 21 ~ \"Início da noite\",\n    hour_admit >=21 | hour_admit <= 6 ~ \"Noite\"))"},{"path":"dates.html","id":"trabalhando-com-datas","chapter":"9 Trabalhando com datas","heading":"9.7 Trabalhando com datas","text":"lubridate também pode ser usado para uma variedade de outras funções, como extrair aspectos de uma data / data e hora, realizar cálculos aritiméticos de data ou calcular intervalos de data.Aqui, definimos uma data que será usada para os exemplos:","code":"\n# criar um objeto de classe Date\nexample_date <- ymd(\"2020-03-01\")"},{"path":"dates.html","id":"extrair-os-componentes-de-datas","chapter":"9 Trabalhando com datas","heading":"Extrair os componentes de datas","text":"Você pode extrair aspectos comuns, como mês, dia, dia da semana:Você também pode extrair componentes de tempo de um objeto ou coluna datetime. Isso pode ser útil se você quiser ver distribuição dos horários de admissão.Existem várias opções para recuperar semanas. Veja seção sobre semanas epidemiológicas abaixo.Observe que se você deseja exibir uma data de uma determinada maneira (por exemplo, “janeiro de 2020” ou “Quinta-feira, 20 de março” ou “Semana 20 de 1977”), pode fazer isso de forma mais flexível, conforme descrito na seção Exibição de data.","code":"\nmonth(example_date)  # número do mês## [1] 3\nday(example_date)    # dia do mês (número)## [1] 1\nwday(example_date)   # número do dia da semana (1-7)## [1] 1\nexample_datetime <- ymd_hm(\"2020-03-01 14:45\")\n\nhour(example_datetime)     # extrair hora\nminute(example_datetime)   # extrair minuto\nsecond(example_datetime)   # extrair segundo"},{"path":"dates.html","id":"cálculos-com-datas","chapter":"9 Trabalhando com datas","heading":"Cálculos com datas","text":"Você pode adicionar determinados números de dias ou semanas usando suas respectivas funções lubridate.","code":"\n# adicione 3 dias à essa data \nexample_date + days(3)## [1] \"2020-03-04\"\n# adicione 7 semanas e subtraia dois dias dessa data\nexample_date + weeks(7) - days(2)## [1] \"2020-04-17\""},{"path":"dates.html","id":"intervalos-entre-datas","chapter":"9 Trabalhando com datas","heading":"Intervalos entre datas","text":"diferença entre datas pode ser calculada por:Certifique-se de que ambas datas estejam como classe dataUse subtração para retornar diferença “difftime” entre duas datasSe necessário, converta o resultado em classe numérica para realizar cálculos matemáticos subsequentesAbaixo, o intervalo entre duas datas é calculado e exibido. Você pode encontrar intervalos usando o símbolo de subtração “menos” em valores que estão como classe Data. Contudo, observe que classe valor retornado é “difftime” conforme exibido abaixo e deve ser convertida para numérico.Para fazer operações subsequentes em um “difftime”, converta-o para numérico com .numeric().Tudo isso pode ser reunido para trabalhar com dados - por exemplo:contexto de uma tabela de dados (data frame), se uma das datas acima estiver faltando, operação falhará para essa linha. Isso resultará em um NA em vez de um valor numérico. Ao usar esta coluna para cálculos, certifique-se de definir o argumento na.rm = como TRUE. Por exemplo:","code":"\n# encontre o intervalo entre essa data e 20 de fevereiro de 2020\noutput <- example_date - ymd(\"2020-02-20\")\noutput    # print## Time difference of 10 days\nclass(output)## [1] \"difftime\"\npacman::p_load(lubridate, tidyverse)   # carregue os pacotes\n\nlinelist <- linelist %>%\n  \n  # converter a data de início (date_onset) de caracteres em objetos de data, especificando o formato dmy\n  mutate(date_onset = dmy(date_onset),\n         date_hospitalisation = dmy(date_hospitalisation)) %>%\n  \n  # filtrar todos os casos sem início em março\n  filter(month(date_onset) == 3) %>%\n    \n  # encontrar a diferença, em dias, entre a data de ínicio e o início da hospitalização\n  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)\n# calcule o número médio de dias até a hospitalização para todos os casos em que os dados estão disponíveis\nmedian(linelist_delay$days_onset_to_hosp, na.rm = T)"},{"path":"dates.html","id":"exibição-das-datas","chapter":"9 Trabalhando com datas","heading":"9.8 Exibição das datas","text":"Uma vez que datas essão na classe correta, você geralmente deseja que elas sejam exibidas de forma diferente, por exemplo, como “Segunda-feira, 5 de janeiro” em vez de “05/01/2018”. Você também pode ajustar exibição para agrupar linhas pelos elementos de data exibidos - por exemplo, agrupar por mês-ano.","code":""},{"path":"dates.html","id":"format","chapter":"9 Trabalhando com datas","heading":"format()","text":"Ajuste exibição de data com função format()R base. Esta função aceita uma cadeia de caracteres entre aspas (string) especificando o formato de saída desejado nas abreviações de strptime “%” (mesma sintaxe usada em .Date()). Abaixo estão relacionadas maioria das abreviações comuns.Observação: o uso de format() converterá os valores para classe Caractere, então geralmente é usado final de uma análise ou apenas para fins de exibição! Você pode ver lista completa executando ?strptime.%d = Número dia mês (5, 17, 28, etc.)\n%j = Número dia ano (Julho dia 001-366)\n%= Dia da semana abreviado (Mon, Tue, Wed, etc.)\n%= Dia da semana completo (Monday, Tuesday, etc.)\n%w = Número dia da semana (0-6, Domingo é 0)\n%u = Número dia da semana (1-7, Segunda-feira é 1)\n%W = Número da semana (00-53, Segunda-feira é o início da semana)\n%U = Número da semana (01-53, Domingo é o início da semana)\n%m = Número mês (exemplo, 01, 02, 03, 04)\n%b = Mês abreviado (Jan, Fev, etc.)\n%B = Mês completo (Janeiro, Fevereiro, etc.)\n%y = Ano em 2 dígitos (por exemplo, 89)\n%Y = Ano em 7 dígitos (por exemplo, 1989)\n%h = horas (relógio de 24 horas)\n%M = minutos\n%s = segundos\n%z = deslocamento GMT\n%Z = Fuso horário (caractere)Um exemplo de formatação da data de hoje:Observe que se estiver usando str_glue(), esteja ciente de que dentro das aspas duplas esperadas “, você deve usar apenas aspas simples (como acima).","code":"\n# data de hoje com formatação\nformat(Sys.Date(), format = \"%d %B %Y\")## [1] \"22 October 2023\"\n# maneira fácil de obter data e hora completas (formatação padrão)\ndate()## [1] \"Sun Oct 22 12:31:34 2023\"\n# data, hora e fuso horário combinados e formatados usando a função str_glue()\nstr_glue(\"{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}\")## Sunday, October 22 2023, +0000  UTC, 12:31:34\n# Usando a função format para exibir as semanas\nformat(Sys.Date(), \"%Y Week %W\")## [1] \"2023 Week 42\""},{"path":"dates.html","id":"mês-ano","chapter":"9 Trabalhando com datas","heading":"Mês-ano","text":"Para converter uma coluna de Data para o formato mês-ano, sugerimos que você use função .yearmon() pacote zoo. Isso converte data para classe “yearmon” e mantém ordem adequada. Em contraste, o uso de format(column, \"%Y %B\") irá converter para classe Caractere e irá ordenar os valores alfabeticamente (incorretamente).Abaixo, uma nova coluna yearmonth é criada partir da coluna date_onset, usando função .yearmon(). ordem padrão (correta) dos valores resultantes é mostrada na tabela.Em contraste, você pode ver como usando apenas format() é possível atingir ao formato de exibição desejado, mas não na ordem correta.Observação: se você estiver trabalhando em um ggplot() e quiser ajustar apenas forma como datas são exibidas, pode ser suficiente fornecer um formato strptime para o argumento date_labels = na função scale_x_date() - você pode usar \"%b %Y\" ou \"%Y %b\". Veja página Dicas para ggplot.zoo também oferece função .yearqtr(), e você pode usar scale_x_yearmon() ao usar ggplot().","code":"\n# criando uma nova tabela \ntest_zoo <- linelist %>% \n     mutate(yearmonth = zoo::as.yearmon(date_onset))\n\n# mostrar tabela\ntable(test_zoo$yearmon)## \n## Apr 2014 May 2014 Jun 2014 Jul 2014 Aug 2014 Sep 2014 Oct 2014 Nov 2014 Dec 2014 \n##        7       64      100      226      528     1070     1112      763      562 \n## Jan 2015 Feb 2015 Mar 2015 Apr 2015 \n##      431      306      277      186\n# criar uma nova coluna\ntest_format <- linelist %>% \n     mutate(yearmonth = format(date_onset, \"%b %Y\"))\n\n# mostrar tabela\ntable(test_format$yearmon)## \n## Apr 2014 Apr 2015 Aug 2014 Dec 2014 Feb 2015 Jan 2015 Jul 2014 Jun 2014 Mar 2015 \n##        7      186      528      562      306      431      226      100      277 \n## May 2014 Nov 2014 Oct 2014 Sep 2014 \n##       64      763     1112     1070"},{"path":"dates.html","id":"dates_epi_wks","chapter":"9 Trabalhando com datas","heading":"9.9 Semanas epidemiológicas","text":"","code":""},{"path":"dates.html","id":"lubridate-1","chapter":"9 Trabalhando com datas","heading":"lubridate","text":"Consulte página em Agrupando dados para exemplos mais abrangentes de dados de agrupamento por data. Abaixo, descrevemos resumidamente os dados de agrupamento por semanas.Geralmente recomendamos usar função floor_date() lubridate, com o argumento unit = \"week\". Isso arredonda data para o “início” da semana, conforme definido pelo argumento week_start =. O início da semana padrão é 1 (para segundas-feiras), mas você pode especificar qualquer dia da semana como o início (por exemplo, 7 para domingos). floor_date() é versátil e pode ser usado para arredondar outras unidades de tempo definindo unit = para “segundo”, “minuto”, “hora”, “dia”, “mês” ou “ano”.O valor retornado é data de início da semana, na classe Date. classe de data é útil ao plotar os dados, pois serão facilmente reconhecidos e ordenados corretamente por ggplot().Se você estiver interessado apenas em ajustar datas para exibição por semana em um gráfico, consulte seção nesta página sobre Exibição de data. Por exemplo, ao plotar uma curva epidemiológica, você pode formatar exibição da data fornecendo nomenclatura “%” strptime desejada. Por exemplo, use “%Y-%W” ou “%Y-%U” para retornar o ano e o número da semana (dado o início da semana na segunda-feira ou domingo, respectivamente).","code":""},{"path":"dates.html","id":"contagens-semanais","chapter":"9 Trabalhando com datas","heading":"Contagens semanais","text":"Veja página em Agrupando dados para uma explicação completa de dados de agrupamento com count(), group_by(), e summarise(). Um breve exemplo está mostrado abaixo.Crie uma nova coluna ‘semana’ com mutate(), usando floor_date() com unit = \"week\";Obtenha contagens de linhas (casos) por semana com count(); remova quaisquer casos com data ausente;Conclua com complete() tidyr para garantir que todas semanas apareçam nos dados - mesmo aquelas sem linhas/casos. Por padrão, os valores de contagem para quaisquer “novas” linhas são NA, mas você pode torná-los 0 com o argumento fill =, que espera uma lista nomeada (abaixo, n é o nome da coluna de contagens).Aqui estão primeiras linhas da tabela de dados resultante:","code":"\n# Faça um conjunto de dados agregado de contagens de casos semanais\nweekly_counts <- linelist %>% \n  drop_na(date_onset) %>%             # remover casos sem data de início onset date\n  mutate(weekly_cases = floor_date(   # fazer nova coluna, semana de início\n    date_onset,\n    unit = \"week\")) %>%            \n  count(weekly_cases) %>%           # agrupar dados por semana e contar linhas por grupo (cria a coluna 'n')\n  tidyr::complete(                  # garantir que todas as semanas estejam presentes, mesmo aquelas sem casos relatados\n    weekly_cases = seq.Date(          # redefina a coluna \"weekly_cases\" como uma sequência completa,\n      from = min(weekly_cases),       # a partir da data mínima\n      to = max(weekly_cases),         # para a data máxima\n      by = \"week\"),                   # por semanas\n    fill = list(n = 0))             # preencha NAs na coluna de n contagens com 0"},{"path":"dates.html","id":"alternativas-do-epiweek","chapter":"9 Trabalhando com datas","heading":"Alternativas do Epiweek","text":"Note que lubridate também tem funções week(), epiweek(), e isoweek(), cada uma com datas de início ligeiramente diferentes e outras nuances. De modo geral, porém, floor_date() deve ser tudo o que você precisa. Leia os detalhes dessas funções inserindo ?week console ou lendo documentação aqui.Você pode considerar usar o pacote aweek para definir semanas epidemiológicas. Você pode ler mais sobre isso site RECON. Possui funções date2week()e week2date() nas quais você pode definir o dia de início da semana com week_start = \"Monday\". Este pacote é mais fácil se você quiser saídas estilo “semana” (por exemplo, “2020-W12”, sendo W = semana). Outra vantagem de aweek é que quando date2week() é aplicado uma coluna de data, coluna retornada (formato de semana) é automaticamente da classe Fator e e inclui níveis para todas semanas intervalo de tempo (isso evita etapa extra de complete() descrito acima). Porém, aweek não tem funcionalidade de arredondar datas para outras unidades de tempo, como meses, anos, etc..Outra alternativa para séries temporais que também funciona bem para mostrar um formato de “semana” (“2020 W12”) é yearweek() pacote tsibble, como demonstrado na página Séries temporais e detecção de surto.","code":""},{"path":"dates.html","id":"conversão-de-datas-fusos-horários","chapter":"9 Trabalhando com datas","heading":"9.10 Conversão de datas / fusos horários","text":"Quando os dados estão presentes em fusos horários diferentes, muitas vezes pode ser importante padronizar esses dados em um fuso horário unificado. Isso pode representar um desafio adicional, pois o componente de fuso horário dos dados deve ser codificado manualmente na maioria dos casos.R, cada objeto datetime possui um componente de fuso horário. Por padrão, todos os objetos datetime levarão o fuso horário local computador que está sendo usado - isso geralmente é específico para um local em vez de um nome fuso horário, pois os fusos horários geralmente mudam nos locais devido ao horário de verão. Não é possível compensar com precisão os fusos horários sem um componente de tempo de uma data, pois o evento que uma coluna de data representa não pode ser atribuído um tempo específico e, portanto, mudanças de tempo medidas em horas não podem ser razoavelmente contabilizadas.Para lidar com fusos horários, há várias funções auxiliares lubridate que podem ser usadas para alterar o fuso horário de um objeto datetime seu fuso horário local para um fuso horário diferente. Os fusos horários são definidos atribuindo um fuso horário banco de dados tz válido ao objeto datetime. Uma lista deles pode ser encontrada aqui - se o local qual você está usando os dados não estiver nessa lista, grandes cidades próximas fuso horário estão disponíveis e têm mesma finalidade.https://en.wikipedia.org/wiki/List_of_tz_database_time_zonesIsso pode parecer muito abstrato e geralmente não é necessário se o usuário não estiver trabalhando em outros fusos horários.","code":"\n# atribuir a hora atual a uma coluna\ntime_now <- Sys.time()\ntime_now## [1] \"2023-10-22 12:31:34 CEST\"\n# use with_tz() para atribuir um novo fuso horário à coluna, enquanto ALTERA a hora do relógio\ntime_london_real <- with_tz(time_now, \"Europe/London\")\n\n# use force_tz() para atribuir um novo fuso horário para a coluna, enquanto MANTÉM a hora do relógio\ntime_london_local <- force_tz(time_now, \"Europe/London\")\n\n\n# observe que, desde que o computador usado para executar este código NÃO esteja definido para o horário de Londres,\n# haverá uma diferença nos horários\n# (o número de horas de diferença do fuso horário do computador para Londres)\ntime_london_real - time_london_local## Time difference of -1 hours"},{"path":"dates.html","id":"cálculos-com-valores-anteriores-ou-posteriores","chapter":"9 Trabalhando com datas","heading":"9.11 Cálculos com valores anteriores ou posteriores","text":"lead() lag() são funções pacote dplyr que ajudam encontrar valores anteriores (lag) ou subsequentes (lead) em um vetor - normalmente um vetor numérico ou de data. Isso é útil ao fazer cálculos de mudança / diferença entre unidades de tempo.Digamos que você queira calcular diferença de casos entre uma semana atual e anterior. Os dados são fornecidos inicialmente em contagens semanais, conforme mostrado abaixo.Ao usar lag() ou lead(), ordem das linhas seus dados é muito importante! - preste atenção se suas datas / números estão de forma crescentes ou decrescentesPrimeiro, crie uma nova coluna contendo o valor da semana anterior (defasada).Controle o número de unidades para trás / para frente com n = (deve ser um número inteiro não negativo)Use default = para definir o valor colocado em linhas não existentes (por exemplo, primeira linha para qual não há valor defasado). Por padrão, isso é NA.Use order_by = TRUE se suas linhas não estiverem ordenadas por sua coluna de referênciaA seguir, crie uma nova coluna que é diferença entre duas colunas de casos:Você pode ler mais sobre lead() e lag() documento aqui ou inserindo ?lag seu console.","code":"\ncounts <- counts %>% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1))\ncounts <- counts %>% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1),\n         case_diff = cases_wk - cases_prev_wk)"},{"path":"dates.html","id":"recursos-2","chapter":"9 Trabalhando com datas","heading":"9.12 Recursos","text":"lubridate página tidyverselubridate RStudio cheatsheet\nR para Ciência dos Dados na página datas e horasTutorial Online de Formatos de datas","code":""},{"path":"characters-strings.html","id":"characters-strings","chapter":"10 Caracteres e strings","heading":"10 Caracteres e strings","text":"Essa página mostra o uso pacote stringr para avaliar e lidar com cadeias de caracteres (“strings”).Combinar, ordenar, dividir, organizar - str_c(), str_glue(), str_order(), str_split()Combinar, ordenar, dividir, organizar - str_c(), str_glue(), str_order(), str_split()Limpar e padronizar\nAjuste o comprimento - str_pad(), str_trunc(), str_wrap()\nAlterar maiúsculas e minúsculas - str_to_upper(), str_to_title(), str_to_lower(), str_to_sentence()\nLimpar e padronizarAjuste o comprimento - str_pad(), str_trunc(), str_wrap()Alterar maiúsculas e minúsculas - str_to_upper(), str_to_title(), str_to_lower(), str_to_sentence()Avaliar e extrair por posição - str_length(), str_sub(), word()Avaliar e extrair por posição - str_length(), str_sub(), word()Padrões\nDetectar e localizar - str_detect(), str_subset(), str_match(), str_extract()\nModificar e substituir - str_sub(), str_replace_all()\nPadrõesDetectar e localizar - str_detect(), str_subset(), str_match(), str_extract()Modificar e substituir - str_sub(), str_replace_all()Expressões regulares (“regex”)Expressões regulares (“regex”)Para facilitar exibição, maioria dos exemplos são mostrados agindo em um vetor curto tipo caractere, entanto, eles podem ser facilmente adaptados uma coluna dentro de um quadro de dados (data frame).Esse manual das funções stringr forneceu grande parte da inspiração para esta página.","code":""},{"path":"characters-strings.html","id":"preparação-1","chapter":"10 Caracteres e strings","heading":"10.1 Preparação","text":"","code":""},{"path":"characters-strings.html","id":"carregue-os-pacotes","chapter":"10 Caracteres e strings","heading":"Carregue os pacotes","text":"Instale ou carregue o stringr e outros pacotes tidyverse.","code":"\n# instalar/carregar pacotes\npacman::p_load(\n  stringr,    # muitas funções para lidar com strings\n  tidyverse,  # para manipulação opicional de dados\n  tools)      # alternativa para converter para maiúsculas"},{"path":"characters-strings.html","id":"importar-os-dados","chapter":"10 Caracteres e strings","heading":"Importar os dados","text":"Nesta página, faremos referência ocasional à linelist, uma lista de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para realizar o download “clean linelist” (como arquivo .rds). Importe dados com função import() pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja página Importar e exportar para detalhes).primeiras 50 linhas da lista estão exibidas abaixo.","code":"\n# Exemplo de importação \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"characters-strings.html","id":"unir-dividir-e-organizar","chapter":"10 Caracteres e strings","heading":"10.2 Unir, dividir e organizar","text":"Essa seção aborda:O uso das funções str_c(), str_glue(), e unite() para combinar strings (caracteres ou descrições)O uso da função str_order() para organizar stringsO uso das funções str_split() e separate() para dividir strings","code":""},{"path":"characters-strings.html","id":"combinar-strings","chapter":"10 Caracteres e strings","heading":"Combinar strings","text":"Para combinar ou concatenar múltiplos strings em um único string, sugerimos usar str_c stringr. Se você tiver distintos valores de caracteres para combinar, basta fornecê-los como argumentos exclusivos, separados por vírgulas.O argumento sep = insere um valor de caractere entre cada um dos argumentos fornecidos (por exemplo, inserir uma vírgula, espaço ou nova linha \"\\n\")O argumento collapse = é relevante se você estiver inserindo múltiplos vetores como argumentos para função str_c(). Ele é usado para separar os elementos que seria um vetor de saída, de forma que o vetor de saída tenha apenas um longo elemento de caractere.O exemplo abaixo mostra combinação de dois vetores em um (nomes e sobrenomes). Outro exemplo semelhante pode ser sobre jurisdições e suas contagens de casos. Neste exemplo:O valor sep = aparece entre cada nome e sobrenomeO valor collapse = aparece entre cada pessoaNota: Dependendo contexto de exibição desejado, ao imprimir/exibir uma string combinada com novas linhas, você pode precisar inserir frase inteira em cat() para que novas linhas sejam impressas/exibidas corretamente:","code":"\nstr_c(\"String1\", \"String2\", \"String3\")## [1] \"String1String2String3\"\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")## [1] \"String1, String2, String3\"\nfirst_names <- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  <- c(\"hussein\", \"akinleye\", \"okeke\")\n\n# sep é exibido entre as respectivas strings de entrada, enquanto collapse é exibido entre os elementos produzidos\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")## [1] \"abdul hussein;  fahruk akinleye;  janice okeke\"\n# Para que as novas linhas sejam impressas corretamente, a frase pode precisar estar inserida na função cat()\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))## abdul hussein;\n## fahruk akinleye;\n## janice okeke"},{"path":"characters-strings.html","id":"strings-dinâmicas","chapter":"10 Caracteres e strings","heading":"Strings dinâmicas","text":"Use str_glue() para inserir um código R dinâmico em um string. Esta é uma função muito útil para criar legendas dinâmicas de gráficos, conforme demonstrado abaixo.Todo o conteúdo fica entre aspas duplas str_glue(\"\")Qualquer código dinâmico ou referências aos valores predefinidos são colocados entre chaves {} com aspas duplas. Pode haver muitas chaves mesmo comando str_glue().Para exibir aspas como caracter ’’, use aspas simples entre aspas duplas (por exemplo, ao fornecer o formato de data - veja o exemplo abaixo)Dica: você pode usar \\n para forçar uma nova linhaDica: você usa format() para ajustar exibição da data e usa Sys.Date() para exibir data atualUm simples exemplo da gráfico com legenda dinâmica:Um formato alternativo é usar espaços reservados dentro dos colchetes e definir o código em argumentos separados final da função str_glue(), conforme abaixo. Isso pode melhorar legibilidade código se o texto longo.Extraindo de uma tabela de dadosÀs vezes, é útil extrair dados de um data frame e colá-los juntos na sequência. Abaixo está um exemplo de data frame. Vamos usá-lo para fazer uma declaração resumida sobre jurisdições e contagens de casos novos e totais.Use str_glue_data(), que é feito especialmente para obter dados de linhas data frame:Combine strings em linhasSe você estiver tentando “acumular” valores em uma coluna de um data frame, por exemplo, combinar valores de várias linhas em apenas uma linha, colando-os juntos com um separador, consulte seção da página Eliminação de duplicidades em “acumulando” valores.Data frame para uma linhaVocê pode fazer frase aparecer em uma linha usando str_c() (especificando o data frame e os nomes das colunas) e fornecendo os argumentos sep = e collapse =.Você poderia adicionar o texto “Novos Casos:” ao início da instrução envolvendo função com str_c() (se “Novos Casos:” estivesse dentro str_c() original, ele apareceria várias vezes).","code":"\nstr_glue(\"Os dados incluem {nrow(linelist)} casos e são atuais para {format(Sys.Date(), '%d %b %Y')}.\")## Os dados incluem 5888 casos e são atuais para 22 Oct 2023.\nstr_glue(\"Lista  em {current_date}.\\n dos último casos hospitalizados no {last_hospital}.\\n{n_missing_onset} casos sem data de início e não mostrados\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))\n         )## Lista  em 22 Oct 2023.\n##  dos último casos hospitalizados no 30 Apr 2015.\n## 256 casos sem data de início e não mostrados\n# fazer um data frame de casos\ncaso_tabela <- data.frame(\n  zone        = c(\"Zone 1\", \"Zone 2\", \"Zone 3\", \"Zone 4\", \"Zone 5\"),\n  novos_casos   = c(3, 0, 7, 0, 15),\n  total_casos = c(40, 4, 25, 10, 103)\n  )\ncaso_tabela %>% \n  str_glue_data(\"{zone}: {novos_casos} ({total_casos} total casos)\")## Zone 1: 3 (40 total casos)\n## Zone 2: 0 (4 total casos)\n## Zone 3: 7 (25 total casos)\n## Zone 4: 0 (10 total casos)\n## Zone 5: 15 (103 total casos)\nstr_c(caso_tabela$zone, caso_tabela$novos_casos, sep = \" = \", collapse = \";  \")## [1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\nstr_c(\"Novos Casos: \", str_c(caso_tabela$zone, caso_tabela$novos_casos, sep = \" = \", collapse = \";  \"))## [1] \"Novos Casos: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\""},{"path":"characters-strings.html","id":"str_unite","chapter":"10 Caracteres e strings","heading":"Unir colunas","text":"Dentro de uma tabela de dados, reunir valores de caracteres de várias colunas pode ser obtido com unite() pacote tidyr. Isso é o oposto de separate().Forneça o nome da nova coluna unida. Em seguida, forneça os nomes das colunas que deseja unir.Por padrão, o separador usado na coluna unida é o underline _, mas isso pode ser alterado com o argumento sep =.remove = rremove colunas de entrada da tabela de dados (TRUE por padrão)na.rm = remove os valores ausentes durante união (FALSE por padrão)Abaixo, definimos uma mini-tabela de dados para demonstrar:Aqui está o exemplo da tabela de dados:Abaixo, unimos três colunas de sintomas:","code":"\ndf <- data.frame(\n  case_ID = c(1:6),\n  symptoms  = c(\"jaundice, fever, chills\",     # paciente 1\n                \"chills, aches, pains\",        # paciente 2 \n                \"fever\",                       # paciente 3\n                \"vomiting, diarrhoea\",         # paciente 4\n                \"bleeding from gums, fever\",   # paciente 5\n                \"rapid pulse, headache\"),      # paciente 6\n  outcome = c(\"Recover\", \"Death\", \"Death\", \"Recover\", \"Recover\", \"Recover\"))\ndf_split <- separate(df, symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), extra = \"merge\")## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [3, 4].\ndf_split %>% \n  unite(\n    col = \"all_symptoms\",         # nome da nova coluna unida\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # colunas para unir\n    sep = \", \",                   # separador para usar na coluna unida\n    remove = TRUE,                # se TRUE (verdadeiro), remove colunas de entrada da tabela de dados\n    na.rm = TRUE                  # se TRUE, os valores ausentes são removidos antes da união\n  )##   case_ID                all_symptoms outcome\n## 1       1     jaundice, fever, chills Recover\n## 2       2        chills, aches, pains   Death\n## 3       3                       fever   Death\n## 4       4         vomiting, diarrhoea Recover\n## 5       5 bleeding, from, gums, fever Recover\n## 6       6      rapid, pulse, headache Recover"},{"path":"characters-strings.html","id":"dividir","chapter":"10 Caracteres e strings","heading":"Dividir","text":"Para dividir um objeto de texto (string) com base em um padrão, use str_split(). Ele avalia o(s) string(s) e retorna uma list de vetores de caracteres que consistem nos valores recém-divididos.O exemplo simples abaixo avalia uma string e divide em três. Por padrão, ele retorna um objeto da list de classes com um elemento (um vetor de caracteres) para cada string fornecida inicialmente. Se simplify = TRUE, ele retorna uma matriz de caracteres.Neste exemplo, uma string é fornecida e função retorna uma lista com um elemento - um vetor de caracteres com três valores.Se o resultado de saída salvo, você poderá acessar o enésimo valor de divisão com sintaxe de colchetes. Para acessar um valor específico, você pode usar uma sintaxe como esta: the_returned_object[[1]][2], que acessaria o segundo valor da primeira string avaliada (“febre”). Consulte página Introdução ao R para obter mais detalhes sobre como acessar os elementos.Se múltiplos strings forem fornecidas por str_split(), haverá mais de um elemento na lista retornada.Para retornar uma “matriz de caracteres”, que pode ser útil ao criar colunas de tabela de dados, defina o argumento simplify = TRUE como mostrado abaixo:Você também pode ajustar o número de divisões serem criadas com o argumento n =. Por exemplo, isso restringe o número de divisões 2. Quaisquer outras vírgulas permanecem dentro dos segundos valores.Oservação - mesmas saídas podem ser obtidas com str_split_fixed(), em que você não fornece o argumento simplify, mas deve designar o número de colunas (n).","code":"\nstr_split(string = \"jaundice, fever, chills\",\n          pattern = \",\")## [[1]]\n## [1] \"jaundice\" \" fever\"   \" chills\"\npt1_symptoms <- str_split(\"jaundice, fever, chills\", \",\")\n\npt1_symptoms[[1]][2]  # extrai o segundo valor do primeiro (e único) elemento da lista## [1] \" fever\"\nsymptoms <- c(\"jaundice, fever, chills\",     # paciente 1\n              \"chills, aches, pains\",        # paciente 2 \n              \"fever\",                       # paciente 3\n              \"vomiting, diarrhoea\",         # paciente 4\n              \"bleeding from gums, fever\",   # paciente 5\n              \"rapid pulse, headache\")       # paciente 6\n\nstr_split(symptoms, \",\")                     # dividir os sintomas de cada paciente## [[1]]\n## [1] \"jaundice\" \" fever\"   \" chills\" \n## \n## [[2]]\n## [1] \"chills\" \" aches\" \" pains\"\n## \n## [[3]]\n## [1] \"fever\"\n## \n## [[4]]\n## [1] \"vomiting\"   \" diarrhoea\"\n## \n## [[5]]\n## [1] \"bleeding from gums\" \" fever\"            \n## \n## [[6]]\n## [1] \"rapid pulse\" \" headache\"\nstr_split(symptoms, \",\", simplify = TRUE)##      [,1]                 [,2]         [,3]     \n## [1,] \"jaundice\"           \" fever\"     \" chills\"\n## [2,] \"chills\"             \" aches\"     \" pains\" \n## [3,] \"fever\"              \"\"           \"\"       \n## [4,] \"vomiting\"           \" diarrhoea\" \"\"       \n## [5,] \"bleeding from gums\" \" fever\"     \"\"       \n## [6,] \"rapid pulse\"        \" headache\"  \"\"\nstr_split(symptoms, \",\", simplify = TRUE, n = 2)##      [,1]                 [,2]            \n## [1,] \"jaundice\"           \" fever, chills\"\n## [2,] \"chills\"             \" aches, pains\" \n## [3,] \"fever\"              \"\"              \n## [4,] \"vomiting\"           \" diarrhoea\"    \n## [5,] \"bleeding from gums\" \" fever\"        \n## [6,] \"rapid pulse\"        \" headache\"\nstr_split_fixed(symptoms, \",\", n = 2)"},{"path":"characters-strings.html","id":"dividir-colunas","chapter":"10 Caracteres e strings","heading":"Dividir colunas","text":"Se você está tentando dividir coluna da tabela de dados, é melhor usar função separate() dplyr. É usado para dividir uma coluna de caracteres em outras colunas.Digamos que temos uma simples tabela de dados df (definida e unida na seção Unir) contendo uma coluna case_ID, uma coluna de caractere com muitos sintomas e uma coluna de resultado. Nosso objetivo é separar coluna de symptoms em várias colunas - cada uma contendo um sintoma.Assumindo que os dados sejam divididos por meio separate(), primeiro forneça coluna ser separada. Em seguida, forneça = como um vetor c( ) contendo os novos nomes das colunas, conforme mostrado abaixo.sep = o separador, pode ser um caractere ou um número (interpretado como posição caractere para dividir)sep = o separador, pode ser um caractere ou um número (interpretado como posição caractere para dividir)remove = FALSE por padrão, remove coluna de entradaremove = FALSE por padrão, remove coluna de entradaconvert = FALSE por padrão, fará com que string “NA” se torne NAconvert = FALSE por padrão, fará com que string “NA” se torne NAextra = isso controla o que acontece se houver mais valores criados pela separação que novas colunas nomeadas.extra = isso controla o que acontece se houver mais valores criados pela separação que novas colunas nomeadas.extra = \"warn\" significa que você verá um aviso, mas os valores em excesso serão descartados (o padrão)extra = \"warn\" significa que você verá um aviso, mas os valores em excesso serão descartados (o padrão)extra = \"drop\" significa que os valores em excesso serão descartados sem avisoextra = \"drop\" significa que os valores em excesso serão descartados sem aviso**extra = \"merge\" somente será dividido para o número de novas colunas listadas em - *esta configuração preservará todos os seus dados****extra = \"merge\" somente será dividido para o número de novas colunas listadas em - *esta configuração preservará todos os seus dados**Um exemplo com extra = \"merge\" está abaixo - nenhum dado é perdido. Duas novas colunas são definidas, mas quaisquer terceiros sintomas são combinados na segunda coluna nova:Quando o padrão extra = \"drop\" é usado abaixo, um aviso é dado, mas os terceiros sintomas são perdidos:CUIDADO: Se você não fornecer valores suficientes para novas colunas, seus dados podem ser truncados.","code":"\n# terceiros sintomas combinados na segunda nova coluna\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].##   case_ID              sym_1          sym_2 outcome\n## 1       1           jaundice  fever, chills Recover\n## 2       2             chills   aches, pains   Death\n## 3       3              fever           <NA>   Death\n## 4       4           vomiting      diarrhoea Recover\n## 5       5 bleeding from gums          fever Recover\n## 6       6        rapid pulse       headache Recover\n# terceiros sintomas são perdidos\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\")## Warning: Expected 2 pieces. Additional pieces discarded in 2 rows [1, 2].## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].##   case_ID              sym_1      sym_2 outcome\n## 1       1           jaundice      fever Recover\n## 2       2             chills      aches   Death\n## 3       3              fever       <NA>   Death\n## 4       4           vomiting  diarrhoea Recover\n## 5       5 bleeding from gums      fever Recover\n## 6       6        rapid pulse   headache Recover"},{"path":"characters-strings.html","id":"organizar-em-ordem-alfabética","chapter":"10 Caracteres e strings","heading":"Organizar em ordem alfabética","text":"Várias strings podem ser classificadas em ordem alfabética. str_order() retorna ordem, enquanto str_sort() retorna strings nessa ordem.Para usar um alfabeto diferente, adicione o argumento locale =. Veja lista completa de localidades digitando stringi::stri_locale_list() R console.","code":"\n# strings\nhealth_zones <- c(\"Alba\", \"Takota\", \"Delta\")\n\n# retornar a ordem alfabética\nstr_order(health_zones)## [1] 1 3 2\n# retornar as strings em ordem alfabética\nstr_sort(health_zones)## [1] \"Alba\"   \"Delta\"  \"Takota\""},{"path":"characters-strings.html","id":"funções-do-r-base","chapter":"10 Caracteres e strings","heading":"Funções do R base","text":"É comum ver funções R base paste() e paste0(), que concatenam vetores após converter todas partes em caracteres. Eles agem de forma semelhante str_c() , mas sintaxe é indiscutivelmente mais complicada - entre parênteses cada parte é separada por uma vírgula. partes são textos de caracteres (entre aspas) ou objetos de código predefinidos (sem aspas). Por exemplo:Os argumentos sep = e collapse = podem ser especificados. paste() é simplesmente paste0() com um sep = \" \" padrão (um espaço).","code":"\nn_beds <- 10\nn_masks <- 20\n\npaste0(\"Hospital regional precisa \", n_beds, \" camas e \", n_masks, \" máscaras.\")## [1] \"Hospital regional precisa 10 camas e 20 máscaras.\""},{"path":"characters-strings.html","id":"limpe-e-padronize","chapter":"10 Caracteres e strings","heading":"10.3 Limpe e padronize","text":"","code":""},{"path":"characters-strings.html","id":"mudar-maiúsculas-e-minúsculas","chapter":"10 Caracteres e strings","heading":"Mudar maiúsculas e minúsculas","text":"Frequentemente, é necessário alterar capitalização / maiúsculas de um valor de string, por exemplo, nomes de jursidições. Use str_to_upper(), str_to_lower(), e str_to_title(), de stringr, como mostrado abaixo:Usando R base, o acima também pode ser obtido com toupper(), tolower().Capitalização de títuloTransformar o string para que cada palavra inicie com maiúscula pode ser conseguido com str_to_title():Use toTitleCase() pacote tools para obter uma capitalização mais sutil (palavras como “para”, “o” e “de” não são capitalizadas).Você também pode usar str_to_sentence(), que coloca em maiúscula apenas primeira letra string.","code":"\nstr_to_upper(\"California\")## [1] \"CALIFORNIA\"\nstr_to_lower(\"California\")## [1] \"california\"\nstr_to_title(\"go to the US state of california \")## [1] \"Go To The Us State Of California \"\ntools::toTitleCase(\"Este é o estado da califórnia dos EUA\")## [1] \"Este é o Estado Da Califórnia Dos EUA\"\nstr_to_sentence(\"o paciente precisa ser transportado\")## [1] \"O paciente precisa ser transportado\""},{"path":"characters-strings.html","id":"str_pad","chapter":"10 Caracteres e strings","heading":"Comprimento do código","text":"Use str_pad() para adicionar caracteres uma string, com um comprimento mínimo. Por padrão, espaços são adicionados, mas você também pode preencher com outros caracteres usando o argumento pad =.Por exemplo, para preencher números com zeros à esquerda (como para horas ou minutos), você pode preencher o número com o comprimento mínimo de 2 com pad = \"0\".","code":"\n# Códigos ICD de comprimento diferente\nICD_codes <- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# Códigos ICD preenchidos com 7 caracteres no lado direito\nstr_pad(ICD_codes, 7, \"right\")## [1] \"R10.13 \" \"R10.819\" \"R17    \"\n# Pad com pontos em vez de espaços\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")## [1] \"R10.13.\" \"R10.819\" \"R17....\"\n# Adicione zeros à esquerda de dois dígitos (por exemplo, para tempos minutos / horas)\nstr_pad(\"4\", 2, pad = \"0\") ## [1] \"04\"\n# exemplo usando uma coluna numérica chamada \"horas\"\n# hours <- str_pad(hours, 2, pad = \"0\")"},{"path":"characters-strings.html","id":"truncar","chapter":"10 Caracteres e strings","heading":"Truncar","text":"str_trunc() define um comprimento máximo para cada string. Se uma string exceder esse comprimento, ela será truncada (encurtada) e uma reticência (…) será incluída para indicar que string era anteriormente mais longa. Observe que reticências são counted contadas comprimento. Os caracteres de reticências podem ser alterados com o argumento ellipsis =. O argumento opcional side = especifica onde reticências aparecerão dentro da string truncada (“esquerda”, “direita” ou “centro”).","code":"\noriginal <- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")## [1] \"Symp...ing\""},{"path":"characters-strings.html","id":"padronizar-comprimento","chapter":"10 Caracteres e strings","heading":"Padronizar comprimento","text":"Use str_trunc() para definir um comprimento máximo, e então use str_pad() para expandir strings muito curtas para aquele comprimento truncado. exemplo abaixo, 6 é definido como o comprimento máximo (um valor é truncado) e, em seguida, um valor muito curto é preenchido para atingir o comprimento de 6.","code":"\n# Códigos ICD de comprimento diferente\nICD_codes   <- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# truncar com comprimento máximo de 6\nICD_codes_2 <- str_trunc(ICD_codes, 6)\nICD_codes_2## [1] \"R10.13\" \"R10...\" \"R17\"\n# expandir para comprimento mínimo de 6\nICD_codes_3 <- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3## [1] \"R10.13\" \"R10...\" \"R17   \""},{"path":"characters-strings.html","id":"remova-os-espaços-em-branco-à-esquerda-à-direita","chapter":"10 Caracteres e strings","heading":"Remova os espaços em branco à esquerda / à direita","text":"Use str_trim() para remover espaços, \\n para novas linhas ou tabulações (\\t) nos lados de uma entrada de string. Adicione \"right\" \"left\", ou \"\" ao comando para especificar qual lado cortar (por exemplo, str_trim(x, \"right\").","code":"\n# Números ID com espaços em excesso à direita\nIDs <- c(\"provA_1852  \", # dois espaços excedentes\n         \"provA_2345\",   # zero espaço excedente\n         \"provA_9460 \")  # um espaço excedente\n\n# IDs cortados para remover espaços em excesso apenas no lado direito\nstr_trim(IDs)## [1] \"provA_1852\" \"provA_2345\" \"provA_9460\""},{"path":"characters-strings.html","id":"remova-os-espaços-em-branco-repetidos-dentro-do-texto","chapter":"10 Caracteres e strings","heading":"Remova os espaços em branco repetidos dentro do texto","text":"Use str_squish() para remover espaços repetidos que aparecem dentro de uma string. Por exemplo, para converter espaços duplos em espaços simples. Ele também remove espaços, novas linhas ou tabulações lado de fora da string como str_trim().Digite ?str_trim, ?str_pad em seu console R para ver mais detalhes.","code":"\n# o original contém espaços em excesso dentro da string\nstr_squish(\"  Pt requires   IV saline\\n\") ## [1] \"Pt requires IV saline\""},{"path":"characters-strings.html","id":"quebrar-em-parágrafos","chapter":"10 Caracteres e strings","heading":"Quebrar em parágrafos","text":"Use str_wrap() para quebrar um texto longo e não estruturado em um parágrafo estruturado com comprimento de linha fixo. Fornece o comprimento de caractere ideal para cada linha e aplica um algoritmo para inserir novas linhas (\\n) dentro parágrafo, conforme mostrado exemplo abaixo.função base cat() pode ser envolvida comando acima para mostrar o resultado, exibindo novas linhas adicionadas.","code":"\npt_course <- \"início dos sintomas 04/01/2020 vômito febre calafrios. Pt viu um curandeiro tradicional na aldeia natal em 04/02/2020. Em 04/05/2020 os sintomas de pt se agravaram e foi internado na clínica de Lumta. A amostra foi coletada e o pt foi transportado para o hospital regional em 04/06/2020. Pt morreu no hospital regional em 04/07/2020.\"\n\nstr_wrap(pt_course, 40)## [1] \"início dos sintomas 04/01/2020 vômito\\nfebre calafrios. Pt viu um curandeiro\\ntradicional na aldeia natal em\\n04/02/2020. Em 04/05/2020 os sintomas\\nde pt se agravaram e foi internado na\\nclínica de Lumta. A amostra foi coletada\\ne o pt foi transportado para o hospital\\nregional em 04/06/2020. Pt morreu no\\nhospital regional em 04/07/2020.\"\ncat(str_wrap(pt_course, 40))## início dos sintomas 04/01/2020 vômito\n## febre calafrios. Pt viu um curandeiro\n## tradicional na aldeia natal em\n## 04/02/2020. Em 04/05/2020 os sintomas\n## de pt se agravaram e foi internado na\n## clínica de Lumta. A amostra foi coletada\n## e o pt foi transportado para o hospital\n## regional em 04/06/2020. Pt morreu no\n## hospital regional em 04/07/2020."},{"path":"characters-strings.html","id":"manipular-por-posição","chapter":"10 Caracteres e strings","heading":"10.4 Manipular por posição","text":"","code":""},{"path":"characters-strings.html","id":"extrair-pela-posição-dos-caracteres","chapter":"10 Caracteres e strings","heading":"Extrair pela posição dos caracteres","text":"Use str_sub() para retornar apenas uma parte de uma string. função tem três argumentos principais:o(s) vetor(es) de caracteresposição inicialposição finalAlgumas notas sobre os números de posição:Se um número de posição positivo, posição é contada partir da extremidade esquerda da string.Se um número de posição negativo, ele é contado partir da extremidade direita da string.Os números das posições são inclusivos.posições que se estendem além da string serão truncadas (removidas).Abaixo estão alguns exemplos aplicados à string “pneumonia”:","code":"\n# começar e terminar em terceiro da esquerda (3ª letra da esquerda)\nstr_sub(\"pneumonia\", 3, 3)## [1] \"e\"\n# 0 não está presente\nstr_sub(\"pneumonia\", 0, 0)## [1] \"\"\n# 6º da esquerda, para o 1º da direita\nstr_sub(\"pneumonia\", 6, -1)## [1] \"onia\"\n# 5º da direita, para o 2º da direita\nstr_sub(\"pneumonia\", -5, -2)## [1] \"moni\"\n# 4º da esquerda para uma posição fora da string\nstr_sub(\"pneumonia\", 4, 15)## [1] \"umonia\""},{"path":"characters-strings.html","id":"extrair-por-posição-de-palavra","chapter":"10 Caracteres e strings","heading":"Extrair por posição de palavra","text":"Para extrair enésima ‘palavra’, use word(), também pacote stringr. Forneça strings (descriçoes), posição da primeira palavra extrair e posição da última palavra extrair.Por padrão, o separador entre ‘palavras’ é considerado um espaço, menos que indicado de outra forma com sep = (por exemplo, sep = \"_\" quando palavras são separadas por underlines).","code":"\n# strings para avaliar\nchief_complaints <- c(\"Acabei de sair do hospital há 2 dias, mas ainda mal consigo respirar.\",\n                      \"Meu estômago dói\",\n                      \"Dor de ouvido severa\")\n\n# extraia a 1ª a 3ª palavras de cada string (descrição)\nword(chief_complaints, start = 1, end = 3, sep = \" \")## [1] \"Acabei de sair\"   \"Meu estômago dói\" \"Dor de ouvido\""},{"path":"characters-strings.html","id":"substituir-pela-posição-do-caractere","chapter":"10 Caracteres e strings","heading":"Substituir pela posição do caractere","text":"str_sub() emparelhado com o operador de atribuição (<-) pode ser usado para modificar uma parte de uma string:Um exemplo aplicado várias strings (por exemplo, uma coluna). Observe expansão comprimento de “HIV”.","code":"\nword <- \"pneumonia\"\n\n# converter o terceiro e o quarto caracteres em X \nstr_sub(word, 3, 4) <- \"XX\"\n\n# exibe\nword## [1] \"pnXXmonia\"\nwords <- c(\"pneumonia\", \"tubercolose\", \"HIV\")\n\n# converter o terceiro e o quarto caracteres em X \nstr_sub(words, 3, 4) <- \"XX\"\n\nwords## [1] \"pnXXmonia\"   \"tuXXrcolose\" \"HIXX\""},{"path":"characters-strings.html","id":"avalie-o-comprimento","chapter":"10 Caracteres e strings","heading":"Avalie o comprimento","text":"Alternativamente, use nchar() R base","code":"\nstr_length(\"abc\")## [1] 3"},{"path":"characters-strings.html","id":"padrões","chapter":"10 Caracteres e strings","heading":"10.5 Padrões","text":"Muitas funções stringr trabalham para detectar, localizar, extrair, combinar, substituir e dividir com base em um padrão especificado.","code":""},{"path":"characters-strings.html","id":"detectar-um-padrão","chapter":"10 Caracteres e strings","heading":"Detectar um padrão","text":"Use str_detect() como abaixo para detectar presença / ausência de um padrão dentro de uma string. Primeiro forneça string ou vetor ser pesquisado (string =) e, em seguida, o padrão ser procurado (pattern =). Observe que, por padrão, pesquisa diferencia maiúsculas de minúsculas!O argumento negate = pode ser incluído e definido como TRUE se você quiser saber se o padrão NÃO está presente.Para ignorar maiúsculas e minúsculas, envolva o padrão em regex(), e em regex() adicione o argumento ignore_case = TRUE (ou T como abreviação).Quando str_detect() é aplicado um vetor de caracteres ou uma coluna da tabela de dados, ele retornará TRUE ou FALSE para cada um dos valores.Se você precisar contar os TRUEs, simplesmente os resultados por meio da função sum(). Essa função conta o número de TRUE.Para pesquisar incluindo vários termos, inclua-os separados por barras (|) dentro argumento pattern =, conforme mostrado abaixo:Se precisar construir uma longa lista de termos de pesquisa, você pode combiná-los usando str_c() e sep = |, em seguida defina que este é um objeto de caractere e referencie o vetor posteriormente de forma mais sucinta. O exemplo abaixo inclui possíveis termos de pesquisa de ocupação para provedores médicos de linha de frente.Este comando retorna o número de ocupações que contêm qualquer um dos termos de pesquisa para provedores médicos de linha de frente (occupation_med_frontline):Funções de pesquisa de string R baseA função base grepl() funciona de forma similar à função str_detect(), sentido de que procura por correspondências com um padrão e retorna um vetor lógico. sintaxe básica é grepl(pattern, strings_to_search, ignore.case = FALSE, ...). Uma vantagem é que o argumento ignore.case é mais fácil de escrever (não há necessidade de envolver função regex()).Da mesma forma, funções de base sub() e gsub() agem de forma semelhante str_replace(). Sua sintaxe básica é: gsub(pattern, replacement, strings_to_search, ignore.case = FALSE). sub() substituirá primeira instância padrão, enquanto gsub() substituirá todas instâncias padrão.","code":"\nstr_detect(string = \"professor de escola primária\", pattern = \"prof\")## [1] TRUE\nstr_detect(string = \"professor de escola primária\", pattern = \"prof\", negate = TRUE)## [1] FALSE\nstr_detect(string = \"Professor\", pattern = regex(\"prof\", ignore_case = T))## [1] TRUE\n# um vetor / coluna de ocupações\noccupations <- c(\"trabalhador do campo\",\n                 \"professor universitário\",\n                 \"educador de escola primária\",\n                 \"tutor\",\n                 \"enfermeira em hospital regional\",\n                 \"eletricita da Fábrica em Amberdeen\",\n                 \"médico\",\n                 \"cardiologista\",\n                 \"trabalhador de escritório\",\n                 \"trabalhador de serviço de alimentação\")\n\n# Detecta a presença do padrão \"prof\" em cada string - a saída é um vetor TRUE / FALSE\nstr_detect(occupations, \"prof\")##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\nsum(str_detect(occupations, \"prof\"))## [1] 1\nsum(str_detect(string = occupations, pattern = \"prof|educador|tutor\"))## [1] 3\n# termos de busca\noccupation_med_frontline <- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline## [1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\nsum(str_detect(string = occupations, pattern = occupation_med_frontline))## [1] 2"},{"path":"characters-strings.html","id":"converta-vírgulas-em-pontos","chapter":"10 Caracteres e strings","heading":"Converta vírgulas em pontos","text":"Aqui está um exemplo de uso de gsub() para converter vírgulas em pontos em um vetor de números. Isso pode ser útil se seus dados vierem de outras partes mundo que não os Estados Unidos ou Grã-Bretanha.O gsub() interno que atua primeiro em lengths convertendo quaisquer pontos em nenhum espaço ““. O caractere de ponto final”.” deve ser “escapado” com duas barras para realmente significar um ponto, porque “.” em regex significa “qualquer caractere”. Em seguida, o resultado (apenas com vírgulas) é passado para o gsub() , qual vírgulas são substituídas por pontos.","code":"\nlengths <- c(\"2.454,56\", \"1,2\", \"6.096,5\")\n\nas.numeric(gsub(pattern = \",\",                # encontra vírgulas   \n                replacement = \".\",            # substitui por pontos\n                x = gsub(\"\\\\.\", \"\", lengths)  # vetor com outros pontos removidos (deve-se \"escapar\" os pontos)\n                )\n           )                                  # converter resultado em numérico"},{"path":"characters-strings.html","id":"substituir-tudo","chapter":"10 Caracteres e strings","heading":"Substituir tudo","text":"Use str_replace_all() omo uma ferramenta de “localizar e substituir”. Primeiro, forneça strings serem avaliadas para string =, depois o padrão ser substituído por pattern = e, seguir, o valor de substituição para replacement =. O exemplo abaixo substitui todas ocorrências de “morto” por “falecido”. Observe que isso É sensível maiúsculas e minúsculas.Notas:Para substituir um padrão por NA, use str_replace_na().função str_replace() substitui apenas primeira instância padrão em cada string avaliada.","code":"\noutcome <- c(\"Karl: morto\",\n            \"Samantha: morto\",\n            \"Marco: não morto\")\n\nstr_replace_all(string = outcome, pattern = \"morto\", replacement = \"óbito\")## [1] \"Karl: óbito\"      \"Samantha: óbito\"  \"Marco: não óbito\""},{"path":"characters-strings.html","id":"detectar-dentro-da-lógica","chapter":"10 Caracteres e strings","heading":"Detectar dentro da lógica","text":"Dentro de case_when()str_detect() é frequentemente usado em case_when() (de dplyr). Digamos que occupations é uma coluna na lista. função mutate() abaixo cria uma nova coluna chamada is_educator usando lógica condicional via case_when(). Veja página sobre limpeza de dados para aprender mais sobre case_when().Como um lembrete, pode ser importante adicionar critérios de exclusão à lógica condicional (negate = F):","code":"\ndf <- df %>% \n  mutate(is_educator = case_when(\n    # pesquisa de termo dentro da ocupação, sem distinção entre maiúsculas e minúsculas\n    str_detect(occupations,\n               regex(\"educador|prof|tutor|universidade\",\n                     ignore_case = TRUE))              ~ \"Educador\",\n    # todos os outros\n    TRUE                                               ~ \"Não é educador\"))df <- df %>% \n  # valor na nova coluna is_educator é baseado na lógica condicional\n  mutate(is_educator = case_when(\n    \n    # a coluna de ocupação deve atender a 2 critérios para ser atribuído \"Educador\":\n    # deve ter um termo de pesquisa E NÃO qualquer termo de exclusão\n    \n    # Deve conter um termo de pesquisa\n    str_detect(occupations,\n               regex(\"educador|prof|tutor|universidade\", ignore_case = T)) &              \n    \n    # E NÃO deve ter um termo de exclusão\n    str_detect(occupations,\n               regex(\"admin\", ignore_case = T),\n               negate = TRUE                        ~ \"Educador\"\n    \n    # Todas as linhas que não atendem aos critérios acima\n    TRUE                                            ~ \"Não é educador\"))"},{"path":"characters-strings.html","id":"localize-a-posição-do-padrão","chapter":"10 Caracteres e strings","heading":"Localize a posição do padrão","text":"Para localizar primeira posição de um padrão, use str_locate(). Ele produz uma posição inicial e final.Como outras funções str, há uma versão “_all” (str_locate_all()) que retornará posições de todas instâncias padrão dentro de cada string. Isso resulta em uma list.","code":"\nstr_locate(\"I wish\", \"sh\")##      start end\n## [1,]     5   6\nphrases <- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # posição da *primeira* instância do padrão##      start end\n## [1,]     6   6\n## [2,]     3   3\n## [3,]     1   1\n## [4,]     4   4\nstr_locate_all(phrases, \"h\" ) # posição de *cada* instância do padrão## [[1]]\n##      start end\n## [1,]     6   6\n## \n## [[2]]\n##      start end\n## [1,]     3   3\n## \n## [[3]]\n##      start end\n## [1,]     1   1\n## [2,]     4   4\n## \n## [[4]]\n##      start end\n## [1,]     4   4"},{"path":"characters-strings.html","id":"extraia-uma-combinação","chapter":"10 Caracteres e strings","heading":"Extraia uma combinação","text":"str_extract_all() retorna os próprios padrões de correspondência, o que é mais útil quando você oferece vários padrões por meio de condições “OU”. Por exemplo, procurando vetor string de ocupações (consulte aba anterior) “educador”, “prof” ou “tutor”.str_extract_all() retorna uma list que contém todas correspondências para cada string avaliada. Veja abaixo como ocupação 3 tem duas correspondências de padrão dentro dela.str_extract() extrai apenas primeira combinação (match) em cada string avaliada, produzindo um vetor de caracteres com um elemento para cada string avaliada. Retorna NA onde não há uma combinação. Os NAs pode ser removido envolvendo o vetor retornado com na.exclude(). Observe como o segundo dos acertos da ocupação 3 não é mostrado.","code":"\nstr_extract_all(occupations, \"educador|prof|tutor\")## [[1]]\n## character(0)\n## \n## [[2]]\n## [1] \"prof\"\n## \n## [[3]]\n## [1] \"educador\"\n## \n## [[4]]\n## [1] \"tutor\"\n## \n## [[5]]\n## character(0)\n## \n## [[6]]\n## character(0)\n## \n## [[7]]\n## character(0)\n## \n## [[8]]\n## character(0)\n## \n## [[9]]\n## character(0)\n## \n## [[10]]\n## character(0)\nstr_extract(occupations, \"educador|prof|tutor\")##  [1] NA         \"prof\"     \"educador\" \"tutor\"    NA         NA         NA        \n##  [8] NA         NA         NA"},{"path":"characters-strings.html","id":"subconjunto-e-contagem","chapter":"10 Caracteres e strings","heading":"Subconjunto e contagem","text":"funções alinhadas incluem str_subset() e str_count().str_subset() retorna os valores reais que continham o padrão:str_count() retorna um vetor de números: o número de vezes que um termo de pesquisa aparece em cada valor avaliado.","code":"\nstr_subset(occupations, \"educador|prof|tutor\")## [1] \"professor universitário\"     \"educador de escola primária\"\n## [3] \"tutor\"\nstr_count(occupations, regex(\"educador|prof|tutor\", ignore_case = TRUE))##  [1] 0 1 1 1 0 0 0 0 0 0"},{"path":"characters-strings.html","id":"grupos-regex","chapter":"10 Caracteres e strings","heading":"Grupos Regex","text":"CONSTRUCTION","code":""},{"path":"characters-strings.html","id":"caracteres-especiais","chapter":"10 Caracteres e strings","heading":"10.6 Caracteres especiais","text":"Barra invertida \\ como escapeA barra invertida \\ é usada para “escapar” significado próximo caractere. Desta forma, uma barra invertida pode ser usada para exibir uma aspa dentro de outras aspas (\\\") - aspa meio não “quebrará” aspas circundantes.Observação - portanto, se você deseja exibir uma barra invertida, deve-se escapar de seu significado com outra barra invertida. Portanto, você deve escrever duas barras invertidas \\\\ para mostrar uma.Caracteres especiaisExecute ?\"'\" console R para exibir uma lista completa desses caracteres especiais (ela aparecerá painel Ajuda RStudio).","code":""},{"path":"characters-strings.html","id":"regular-expressões-regex","chapter":"10 Caracteres e strings","heading":"10.7 Regular expressões (regex)","text":"","code":""},{"path":"characters-strings.html","id":"regex-e-caracteres-especiais","chapter":"10 Caracteres e strings","heading":"10.8 Regex e caracteres especiais","text":"Expressões regulares, ou “regex”, é uma linguagem concisa para descrever padrões em strings. Se você não estiver familiarizado com ela, uma expressão regular pode parecer uma linguagem alienígena. Aqui tentamos desmistificar um pouco essa linguagem.Grande parte desta seção foi adaptada desse tutorial e desta página de referência. Nós adaptamos seletivamente aqui sabendo que este manual pode ser visto por pessoas sem acesso à Internet para ver os outros tutoriais.Uma expressão regular é frequentemente aplicada para extrair padrões específicos de texto “não estruturado” - por exemplo, notas médicas, queixas principais, histórico paciente ou outras colunas de texto livre em uma tabela de dados.Existem quatro ferramentas básicas que podem ser usadas para criar uma expressão regular básica:Conjuntos de caracteresMeta caracteresQuantificadoresGruposConjunto de caracteresOs conjuntos de caracteres são uma forma de expressar opções de listagem para uma correspondência de caracteres, entre colchetes. Portanto, qualquer correspondência será acionada se qualquer um dos caracteres entre colchetes encontrado na string. Por exemplo, para procurar vogais, pode-se usar este conjunto de caracteres: “\\[aeiou\\]”. Alguns outros conjuntos de caracteres comuns são:Os conjuntos de caracteres podem ser combinados dentro de um colchete (sem espaços!), como \"[-Za-z]\" (qualquer letra maiúscula ou minúscula), ou outro exemplo \"[t-z0-5]\" (t minúsculo até z OU número de 0 5).MetacaracteresMetacaracteres são abreviações para conjuntos de caracteres. Alguns dos mais importantes estão listados abaixo:QuantificadoresNormalmente, você não deseja pesquisar uma correspondência em apenas um caractere. Os quantificadores permitem que você designe o comprimento das letras/números para permitir correspondência.Quantificadores são números escritos entre chaves { } após o caractere que estão quantificando, por exemplo,\"{2}\" retornará instâncias de duas letras maiúsculas.\"{2,4}\" retornará instâncias entre duas e quatro letras maiúsculas (não coloque espaços!).\"{2,}\" retornará correspondências de duas ou mais letras maiúsculas.\"+\" retornará instâncias de uma ou mais letras maiúsculas (grupo estendido até que um caractere diferente seja encontrado).Preceda com um * asterisco para retornar zero ou mais correspondências (útil se você não tiver certeza de que o padrão está presente)Usando o símbolo mais + como quantificador, correspondência ocorrerá até que um caractere diferente seja encontrado. Por exemplo, esta expressão retornará todas palavras (caracteres alfabéticos: \"[-Za-z]+\"Quando um quantificador de {2} é usado, apenas pares de ’s consecutivos são retornados. Dois pares são identificados dentro AAAA.Quando um quantificador de {2,4} é usado, grupos de ’s consecutivos com comprimento de dois quatro são retornados.Com o quantificador +, grupos de um ou mais são retornados:Posição relativaEsses requisitos expressam o que precede ou segue um padrão. Por exemplo, para extrair frases, “dois números seguidos de um ponto” (\"\"). (?<=\\.)\\s(?=\\[-Z\\])GruposCapturar grupos em sua expressão regular é uma maneira de ter um resultado mais organizado na extração.Exemplos de RegexAbaixo está um texto livre para os exemplos. Tentaremos extrair informações úteis dele usando um termo de pesquisa de expressão regular.Esta expressão corresponde todas palavras (qualquer caractere até atingir um objeto não caractere, como um espaço):expressão \"[0-9]{1,2}\" corresponde números consecutivos com 1 ou 2 dígitos de comprimento. Também pode ser escrito \"\\\\d{1,2}\", ou \"[:digit:]{1,2}\".Você pode ver uma lista útil de expressões regex e dicas na página 2 deste cheatsheetTambém veja o tutorial.","code":"\n# teste string para quantificadores\ntest <- \"A-AA-AAA-AAAA\"\nstr_extract_all(test, \"A{2}\")## [[1]]\n## [1] \"AA\" \"AA\" \"AA\" \"AA\"\nstr_extract_all(test, \"A{2,4}\")## [[1]]\n## [1] \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"A+\")## [[1]]\n## [1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"\")## [[1]]\n##  [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\npt_note <- \"O paciente chegou ao pronto-socorro do Broward Hospital às 18h do dia 12/06/2005. O paciente apresentou dor abdominal irradiada no quadrante LR. A pele do paciente estava pálida, fria e úmida. A temperatura do paciente era de 99,8 graus Fahrenheit. A pulsação do paciente era de 100 bpm e intermitente. A frequência respiratória era de 29 por minuto.\"\nstr_extract_all(pt_note, \"[A-Za-z]+\")## [[1]]\n##  [1] \"O\"            \"paciente\"     \"chegou\"       \"ao\"           \"pronto\"      \n##  [6] \"socorro\"      \"do\"           \"Broward\"      \"Hospital\"     \"s\"           \n## [11] \"h\"            \"do\"           \"dia\"          \"O\"            \"paciente\"    \n## [16] \"apresentou\"   \"dor\"          \"abdominal\"    \"irradiada\"    \"no\"          \n## [21] \"quadrante\"    \"LR\"           \"A\"            \"pele\"         \"do\"          \n## [26] \"paciente\"     \"estava\"       \"p\"            \"lida\"         \"fria\"        \n## [31] \"e\"            \"mida\"         \"A\"            \"temperatura\"  \"do\"          \n## [36] \"paciente\"     \"era\"          \"de\"           \"graus\"        \"Fahrenheit\"  \n## [41] \"A\"            \"pulsa\"        \"o\"            \"do\"           \"paciente\"    \n## [46] \"era\"          \"de\"           \"bpm\"          \"e\"            \"intermitente\"\n## [51] \"A\"            \"frequ\"        \"ncia\"         \"respirat\"     \"ria\"         \n## [56] \"era\"          \"de\"           \"por\"          \"minuto\"\nstr_extract_all(pt_note, \"[0-9]{1,2}\")## [[1]]\n##  [1] \"18\" \"12\" \"06\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\""},{"path":"characters-strings.html","id":"recursos-3","chapter":"10 Caracteres e strings","heading":"10.9 Recursos","text":"Uma planilha de referencia para funções de stringr pode ser encontrada aquiUma vinheta sobre stringr pode ser encontrada aqui","code":""},{"path":"factors.html","id":"factors","chapter":"11 Fatores","heading":"11 Fatores","text":"R, os fatores são uma classe de dados que permitem categorias ordenadas com um conjunto fixo de valores possíveis.Normalmente, você converteria uma coluna de caractere ou classe numérica em um fator se quiser definir uma ordem intrínseca para os valores (“níveis”) para que eles possam ser exibidos de forma não alfabética em gráficos e tabelas. Outro uso comum de fatores é padronizar legendas dos gráficos para que não flutuem se certos valores estiverem temporariamente ausentes dos dados.Esta página demonstra o uso de funções pacote forcats (um nome curto para “categorical variables” - “para variáveis categóricas”) e algumas funções R base. Também abordamos o uso de lubridate e aweek para casos de fatores especiais relacionados semanas epidemiológicas (epiweeks).Uma lista completa das funções forcats pode ser encontrada online aqui. Abaixo, demonstramos alguns dos mais comuns.","code":""},{"path":"factors.html","id":"preparação-2","chapter":"11 Fatores","heading":"11.1 Preparação","text":"","code":""},{"path":"factors.html","id":"carregar-pacotes-1","chapter":"11 Fatores","heading":"Carregar pacotes","text":"Este trecho de código mostra o carregamento de pacotes necessários para análises. Neste manual, enfatizamos o p_load() pacman, o qual instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() R base. Veja pagina em Introdução ao R para mais informações sobre pacotes R.","code":"\npacman::p_load(\n  rio,           # importar/exportar\n  here,          # diretório\n  lubridate,     # trabalhando com datas\n  forcats,       # fatores\n  aweek,         # criar epiweeks com níveis de fatores automático\n  janitor,       # tabelas\n  tidyverse      # dados mgmt e viz\n  )"},{"path":"factors.html","id":"importe-os-dados","chapter":"11 Fatores","heading":"Importe os dados","text":"Importamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para baixar o “clean” linelist (.rds file). Importe seus dados com função import() pacote rio package (o pacote aceita muitos tipos de arquivo como .xlsx, .rds, .csv - veja página Importar e exportar para detalhes).","code":"\n# importar seu conjunto de dados\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"factors.html","id":"fct_newcat","chapter":"11 Fatores","heading":"Nova variável categórica","text":"Para demonstração nesta página, usaremos um cenário comum - criação de uma nova variável categórica.Observe que se você converter uma coluna numérica em fator, não será capaz de calcular estatísticas numéricas sobre ela.","code":""},{"path":"factors.html","id":"criar-coluna","chapter":"11 Fatores","heading":"Criar coluna","text":"Usamos coluna existente days_onset_hosp (dias desde o início dos sintomas até admissão hospitalar) e criamos uma nova coluna delay_cat classificando cada linha em uma das várias categorias. Nós fazemos isso com função dplyr case_when(), que aplica critérios lógicos sequencialmente (lado direito) cada linha e retorna o valor lado esquerdo correspondente para nova coluna delay_cat. Leia mais sobre case_when() em Limpeza de dados e principais funções.","code":"\nlinelist <- linelist %>% \n  mutate(delay_cat = case_when(\n    # critério                                  # novo valor se TRUE\n    days_onset_hosp < 2                        ~ \"<2 dias\",\n    days_onset_hosp >= 2 & days_onset_hosp < 5 ~ \"2-5 dias\",\n    days_onset_hosp >= 5                       ~ \">5 dias\",\n    is.na(days_onset_hosp)                     ~ NA_character_,\n    TRUE                                       ~ \"Verifique\"))  "},{"path":"factors.html","id":"padrão-da-ordem-dos-valores","chapter":"11 Fatores","heading":"Padrão da ordem dos valores","text":"Conforme criado com case_when(), nova coluna delay_cat é uma coluna categórica da classe Caractere - ainda não é um fator. Assim, em uma tabela de frequência, vemos que os valores exclusivos aparecem por padrão em uma ordem alfanumérica - uma ordem que não faz muito sentido intuitivo:Da mesma forma, se fizermos um gráfico de barra, os valores também aparecem nesta ordem eixo x (consulte página O básico o ggplot para mais informações sobre o ggplot2 - o pacote de visualização mais comum R).","code":"\ntable(linelist$delay_cat, useNA = \"always\")## \n##  <2 dias  >5 dias 2-5 dias     <NA> \n##     2990      602     2040      256\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))"},{"path":"factors.html","id":"converter-para-fator","chapter":"11 Fatores","heading":"11.2 Converter para fator","text":"Para converter um caractere ou coluna numérica para classe fator, você pode usar qualquer função pacote forcats (muitos são detalhados abaixo). Eles serão convertidos para fator e, em seguida, também realizarão ou permitirão certa ordenação dos níveis - por exemplo, usar fct_relevel() permite que você especifique manualmente ordem dos níveis. função as_factor() simplesmente converte classe sem quaisquer recursos adicionais.função R base factor() converte uma coluna em fator e permite que você especifique manualmente ordem dos níveis, como um vetor de caracteres para seu argumento levels =.Abaixo usamos mutate() e fct_relevel() para converter coluna delay_cat de classe caractere para classe fator. coluna delay_cat é criada na seção Preparação acima.Os “valores” únicos nesta coluna são agora considerados “níveis” fator. Os níveis têm uma ordem, que pode ser exibida com função R base levels(), ou, alternativamente, visualizada em uma tabela de contagem via table() R base ou tabyl() janitor. Por padrão, ordem dos níveis será alfanumérica, como antes. Observe que NA não é um nível de fator.função fct_relevel() tem utilidade adicional de permitir que você especifique manualmente ordem dos níveis. Basta escrever os valores dos níveis em ordem, entre aspas, separados por vírgulas, conforme mostrado abaixo. Observe que grafia deve corresponder exatamente aos valores. Se você quiser criar níveis que não existem nos dados, use fct_expand() ao invés).Agora podemos ver que os níveis estão ordenados, conforme especificado comando anterior, em uma ordem sensata.Agora, ordem gráfico também faz um sentido mais intuitivo.","code":"\nlinelist <- linelist %>%\n  mutate(delay_cat = fct_relevel(delay_cat))\nlevels(linelist$delay_cat)## [1] \"<2 dias\"  \">5 dias\"  \"2-5 dias\"\nlinelist <- linelist %>%\n  mutate(delay_cat = fct_relevel(delay_cat, \"<2 days\", \"2-5 days\", \">5 days\"))## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `delay_cat = fct_relevel(delay_cat, \"<2 days\", \"2-5 days\", \">5\n##   days\")`.\n## Caused by warning:\n## ! 3 unknown levels in `f`: <2 days, 2-5 days, and >5 days\nlevels(linelist$delay_cat)## [1] \"<2 dias\"  \">5 dias\"  \"2-5 dias\"\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))"},{"path":"factors.html","id":"adicionar-ou-remover-níveis","chapter":"11 Fatores","heading":"11.3 Adicionar ou remover níveis","text":"","code":""},{"path":"factors.html","id":"fct_add","chapter":"11 Fatores","heading":"Adicionar","text":"Se você precisar adicionar níveis um fator, você pode fazer isso com fct_expand(). Basta escrever o nome da coluna seguido pelos novos níveis (separados por vírgulas). Tabulando os valores, podemos ver os novos níveis e contagens zero. Você pode usar table() R base, ou tabyl() janitor:Nota: há uma função especial forcats para adicionar facilmente valores ausentes (NA) como um nível. Consulte seção abaixo sobre Valores ausentes.","code":"\nlinelist %>% \n  mutate(delay_cat = fct_expand(delay_cat, \"Not admitted to hospital\", \"Transfer to other jurisdiction\")) %>% \n  tabyl(delay_cat)   # print table##                       delay_cat    n    percent valid_percent\n##                         <2 dias 2990 0.50781250     0.5308949\n##                         >5 dias  602 0.10224185     0.1068892\n##                        2-5 dias 2040 0.34646739     0.3622159\n##        Not admitted to hospital    0 0.00000000     0.0000000\n##  Transfer to other jurisdiction    0 0.00000000     0.0000000\n##                            <NA>  256 0.04347826            NA"},{"path":"factors.html","id":"remover","chapter":"11 Fatores","heading":"Remover","text":"Se você usar fct_drop(), os níveis “não usados” com contagem zero serão retirados conjunto de níveis. Os níveis que adicionamos acima (“admitted hospital” - Não admitido em um hospital) existem como um nível, mas nenhuma linha realmente possui esses valores. Portanto, eles serão eliminados aplicando fct_drop() na nossa coluna de fator:","code":"\nlinelist %>% \n  mutate(delay_cat = fct_drop(delay_cat)) %>% \n  tabyl(delay_cat)##  delay_cat    n    percent valid_percent\n##    <2 dias 2990 0.50781250     0.5308949\n##    >5 dias  602 0.10224185     0.1068892\n##   2-5 dias 2040 0.34646739     0.3622159\n##       <NA>  256 0.04347826            NA"},{"path":"factors.html","id":"fct_adjust","chapter":"11 Fatores","heading":"11.4 Ajuste a ordem dos níveis","text":"O pacote forcats oferece funções úteis para ajustar facilmente ordem dos níveis de um fator (após uma coluna ser definida como classe fator):Essas funções podem ser aplicadas uma coluna de fator em dois contextos:Para coluna data frame, como de costume, para que transformação esteja disponível para qualquer uso subsequente dos dadosDentro de um gráfico, de modo que alteração seja aplicada apenas dentro gráfico","code":""},{"path":"factors.html","id":"manualmente","chapter":"11 Fatores","heading":"Manualmente","text":"Esta função é usada para ordenar manualmente os níveis dos fatores. Se usada em uma coluna sem fator, coluna será primeiro convertida para classe fator.Entre parênteses, primeiro forneça o nome da coluna fator e, em seguida, forneça:Todos os níveis na ordem desejada (como um vetor de caracteres c()), ouUm nível e seu posicionamento corrigido usando o argumento =Aqui está um exemplo de redefinição da coluna delay_cat (que já é da classe Factor) e especificando toda ordem de níveis desejada.Se você quiser mover apenas um nível, você pode especificá-lo sozinha para fct_relevel() e dar um número ao argumento = para indicar onde na ordem ele deveria estar. Por exemplo, o comando abaixo muda “<2 dias” para segunda posição:","code":"\n# redefine a ordem dos níveis dos fatores\nlinelist <- linelist %>% \n  mutate(delay_cat = fct_relevel(delay_cat, c(\"<2 days\", \"2-5 days\", \">5 days\")))## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `delay_cat = fct_relevel(delay_cat, c(\"<2 days\", \"2-5 days\", \">5\n##   days\"))`.\n## Caused by warning:\n## ! 3 unknown levels in `f`: <2 days, 2-5 days, and >5 days\n# redefinir a ordem dos níveis\nlinelist %>% \n  mutate(delay_cat = fct_relevel(delay_cat, \"<2 days\", after = 1)) %>% \n  tabyl(delay_cat)"},{"path":"factors.html","id":"dentro-de-um-gráfico","chapter":"11 Fatores","heading":"Dentro de um gráfico","text":"Os comandos forcats podem ser usados para definir ordem dos níveis data frame ou apenas dentro de um gráfico. Usando o comando para “envolver” o nome da coluna dentro comando de plotagem ggplot() você pode reverter / reordenar / etc, assim, transformação só se aplicará esse gráfico.Abaixo, dois gráficos são criados com ggplot() (consulte página O básico o ggplot). primeiro, coluna delay_cat é mapeada para o eixo x gráfico, com sua ordem de nível padrão como nos dados da linelist. segundo exemplo, ele é inserido em fct_relevel() e ordem é alterada gráfico.Observe que o título padrão eixo x agora é bastante complicado - você pode reescrever este título com o argumento labs() ggplot2.","code":"## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `delay_cat = fct_relevel(delay_cat, c(\"2-5 days\", \"<2 days\", \">5\n##   days\"))`.\n## Caused by warning:\n## ! 3 unknown levels in `f`: 2-5 days, <2 days, and >5 days\n# Ordem alfanumérica padrão - sem ajuste no ggplot\nggplot(data = linelist)+\n    geom_bar(mapping = aes(x = delay_cat))\n\n# Ordem dos níveis dos fatores ajustada dentro do ggplot\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c(\"<2 days\", \"2-5 days\", \">5 days\"))))"},{"path":"factors.html","id":"inverter","chapter":"11 Fatores","heading":"Inverter","text":"É bastante comum que você queira inverter ordem dos níveis. Simplesmente envolva o fator com fct_rev().Observe que se você deseja reverter apenas uma legenda gráfico, mas não os níveis reais dos fatores, pode fazer isso com guides() (consulte Dicas para o ggplot).","code":""},{"path":"factors.html","id":"por-frequência","chapter":"11 Fatores","heading":"Por frequência","text":"Para ordenar pela frequência com que o valor aparece nos dados, use fct_infreq(). Quaisquer valores ausentes (NA) serão incluídos automaticamente final, menos que sejam convertidos para um nível explícito (veja essa seção). Você pode inverter ordem envolvendo em seguida com fct_rev().Esta função pode ser usada em um ggplot(), conforme mostrado abaixo.","code":"\n# ordenando por frequência\nggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by frequency\")\n\n# inverter frequência\nggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Reverse of order by frequency\")"},{"path":"factors.html","id":"pela-aparência","chapter":"11 Fatores","heading":"Pela aparência","text":"Use fct_inorder() para definir ordem dos níveis para corresponder à ordem de aparecimento nos dados, começando da primeira linha. Isso pode ser útil se você primeiro organizar os dados cuidadosamente por meio arrange() data frame e, em seguida, usar isso para definir ordem dos fatores.","code":""},{"path":"factors.html","id":"pela-estatística-de-resumo-de-outra-coluna","chapter":"11 Fatores","heading":"Pela estatística de resumo de outra coluna","text":"Você pode usar fct_reorder() para ordenar os níveis de uma coluna por uma estatística de resumo de outra coluna. Visualmente, isso pode resultar em gráficos agradáveis, onde barras / pontos sobem ou descem de forma constante gráfico.Nos exemplos abaixo, o eixo x é delay_cat, e o eixo y é coluna numérica ct_blood (valor limite ciclo). Os gráficos de caixa mostram distribuição valor CT por grupo delay_cat. Queremos ordenar os gráficos de caixa em ordem crescente pelo valor de CT mediano grupo.primeiro exemplo abaixo, ordem padrão de nível alfanumérico é usada. Você pode ver que alturas box plot estão confusas e não em uma ordem específica. segundo exemplo, coluna delay_cat (mapeada para o eixo x) foi agrupada em fct_reorder(), coluna ct_blood é fornecida como o segundo argumento e “median” (mediana) é fornecido como o terceiro argumento (você também pode usar “max”, “mean”, “min”, etc). Portanto, ordem dos níveis de delay_cat agora refletirá os valores médios de CT crescentes de cada valor de CT médio dos grupos presentes em delay_cat. Isso se reflete segundo gráfico - os gráficos de caixa foram reorganizados para ascender. Observe como NA (ausente) aparecerá final, menos que seja convertido para um nível explícito.Observe que neste exemplo acima não há etapas necessárias antes da função ggplot() - o agrupamento e os cálculos são todos feitos dentro comando ggplot.","code":"\n# boxplots ordenados para os níveis originais dos fatores\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = delay_cat,\n        y = ct_blood, \n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by original alpha-numeric levels\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n# boxplots ordenados pelo valor médio de CT\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = fct_reorder(delay_cat, ct_blood, \"median\"),\n        y = ct_blood,\n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by median CT value in group\")+\n  theme_classic()+\n  theme(legend.position = \"none\")"},{"path":"factors.html","id":"por-valor-final","chapter":"11 Fatores","heading":"Por valor “final”","text":"Use fct_reorder2() para gráficos de linha agrupados. Ele ordena os níveis (e, portanto, legenda) para alinhar com ordem vertical das linhas “final” gráfico. Tecnicamente falando, ele “ordena pelos valores y associados aos maiores valores x”.Por exemplo, se você tiver linhas mostrando contagens de casos por hospital ao longo tempo, você pode aplicar fct_reorder2() ao argumento color = dentro aes(), de modo que ordem vertical dos hospitais que aparecem na legenda se alinhe com ordem das linhas extremidade final gráfico. Leia mais na documentação online.","code":"\nepidemic_data <- linelist %>%         # comece com a linelist   \n    filter(date_onset < as.Date(\"2014-09-21\")) %>%    # limite a data para clareza visual\n    count(                                            # obter a contagem dos casos por semana e por hospital\n      epiweek = lubridate::floor_date(date_onset, \"week\"),  \n      hospital                                            \n    ) \n  \nggplot(data = epidemic_data)+                       # inicie o gráfico\n  geom_line(                                        # faça as linhas \n    aes(\n      x = epiweek,                                  # eixo-x epiweek\n      y = n,                                        # altura é o número de casos por semana\n      color = fct_reorder2(hospital, epiweek, n)))+ # dados agrupados e coloridos por hospital, com fator de ordem por altura no final do gráfico\n  labs(title = \"Factor levels (and legend display) by line height at end of plot\",\n       color = \"Hospital\")                          # change legend title"},{"path":"factors.html","id":"fct_missing","chapter":"11 Fatores","heading":"11.5 Valores ausentes","text":"Se você tiver valores NA em sua coluna de fatores, poderá convertê-los facilmente em um nível nomeado, como “Missing” (ausentes) com fct_explicit_na(). Por padrão, os valores NA são convertidos para “(Missing)” final da ordenação dos nível. Você pode ajustar o nome nível com o argumento na_level =.seguir, esta operação é realizada na delay_cat e uma tabela é exibida com tabyl() contendo NA convertido para “Missing delay”.","code":"\nlinelist %>% \n  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing delay\")) %>% \n  tabyl(delay_cat)##      delay_cat    n    percent\n##        <2 dias 2990 0.50781250\n##        >5 dias  602 0.10224185\n##       2-5 dias 2040 0.34646739\n##  Missing delay  256 0.04347826"},{"path":"factors.html","id":"combine-os-níveis","chapter":"11 Fatores","heading":"11.6 Combine os níveis","text":"","code":""},{"path":"factors.html","id":"manualmente-1","chapter":"11 Fatores","heading":"Manualmente","text":"Você pode ajustar exibibição dos níveis manualmente com fct_recode(). Essa função é similar função recode() dplyr (veja Limpeza de dados e principais funções), mas permite criação de novos níveis de fator. Se você usar simplesmente o recode() em um fator, novos valores recodificados serão rejeitados, menos que já tenham sido definidos como níveis permitidos.Essa ferramenta também pode ser usada para “combinar” níveis, atribuindo vários níveis ao mesmo valor recodificado. Só tome cuidado para não perder informações! Considere fazer essas etapas de combinação em uma nova coluna (não sobrescrever coluna existente).fct_recode() tem uma sintaxe diferente de recode(). recode() usa OLD = NEW, enquanto fct_recode() usa NEW = OLD.Os níveis atuais de delay_cat são:Os novos níveis são criados usando sintaxe fct_recode(column, \"new\" = \"old\", \"new\" = \"old\", \"new\" = \"old\") e exibidos:Aqui, eles são combinados manualmente com fct_recode(). Observe que nenhum erro foi gerado na criação de um novo nível “Less 5 days” (Menos de 5 dias) .","code":"## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `delay_cat = fct_relevel(delay_cat, \"<2 days\", after = 0)`.\n## Caused by warning:\n## ! 1 unknown level in `f`: <2 days\nlevels(linelist$delay_cat)## [1] \"<2 dias\"  \">5 dias\"  \"2-5 dias\"\nlinelist %>% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 2 days\" = \"<2 days\",\n    \"2 to 5 days\"      = \"2-5 days\",\n    \"More than 5 days\" = \">5 days\")) %>% \n  tabyl(delay_cat)## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `delay_cat = fct_recode(...)`.\n## Caused by warning:\n## ! Unknown levels in `f`: <2 days, 2-5 days, >5 days##  delay_cat    n    percent valid_percent\n##    <2 dias 2990 0.50781250     0.5308949\n##    >5 dias  602 0.10224185     0.1068892\n##   2-5 dias 2040 0.34646739     0.3622159\n##       <NA>  256 0.04347826            NA\nlinelist %>% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 5 days\" = \"<2 days\",\n    \"Less than 5 days\" = \"2-5 days\",\n    \"More than 5 days\" = \">5 days\")) %>% \n  tabyl(delay_cat)##  delay_cat    n    percent valid_percent\n##    <2 dias 2990 0.50781250     0.5308949\n##    >5 dias  602 0.10224185     0.1068892\n##   2-5 dias 2040 0.34646739     0.3622159\n##       <NA>  256 0.04347826            NA"},{"path":"factors.html","id":"reduzir-para-outro","chapter":"11 Fatores","heading":"Reduzir para “Outro”","text":"Você pode usar fct_other() para atribuir manualmente níveis de fator um nível chamado “Outros”. Abaixo, todos os níveis da coluna hospital, aside “Port Hospital” “Central Hospital”, combined “”. exceto “Port Hospital” e “Central Hospital”, são combinados em “”. Você pode fornecer um vetor para keep =, ou drop =. Você pode alterar exibição nível “Outro” com other_level =.","code":"\nlinelist %>%    \n  mutate(hospital = fct_other(                      # ajustar níveis\n    hospital,\n    keep = c(\"Port Hospital\", \"Central Hospital\"),  # manter esses separados\n    other_level = \"Other Hospital\")) %>%            # Todos os outros como \"Other Hospital\"\n  tabyl(hospital)                                   # exiba a tabela##          hospital    n    percent\n##  Central Hospital  454 0.07710598\n##     Port Hospital 1762 0.29925272\n##    Other Hospital 3672 0.62364130"},{"path":"factors.html","id":"reduzir-por-frequência","chapter":"11 Fatores","heading":"Reduzir por frequência","text":"Você pode combinar os níveis fator menos frequentes automaticamente usando fct_lump().Para “agrupar” muitos níveis de baixa frequência em um grupo “Outro”, siga um destes procedimentos:Defina n = como o número de grupos que deseja manter. Os n níveis mais frequentes serão mantidos e todos os outros serão combinados em “Outros”.Defina prop = como proporção de frequência limite para os níveis acima dos quais você deseja manter. Todos os outros valores serão combinados em “Outro”.Você pode alterar exibição nível “Outro” com other_level =. Abaixo, todos, exceto os dois hospitais mais frequentes, são combinados em “Hospital” (Outro hospital).","code":"\nlinelist %>%    \n  mutate(hospital = fct_lump(                      # ajuste os níveis\n    hospital,\n    n = 2,                                          # mantenha os 2 níveis superiores\n    other_level = \"Other Hospital\")) %>%            # todos os outros como \"Other Hospital\"\n  tabyl(hospital)                                   # exiba a tabela##        hospital    n   percent\n##         Ausente 1469 0.2494905\n##   Port Hospital 1762 0.2992527\n##  Other Hospital 2657 0.4512568"},{"path":"factors.html","id":"mostrar-todos-os-níveis","chapter":"11 Fatores","heading":"11.7 Mostrar todos os níveis","text":"Um benefício de usar fatores é padronizar aparência das legendas e tabelas gráfico, independentemente de quais valores estão realmente presentes em um conjunto de dados.Se você estiver preparando muitas figuras (por exemplo, para várias jurisdições), você desejará que legendas e tabelas apareçam de forma idêntica, mesmo com variação nos níveis de conclusão ou composição de dados.","code":""},{"path":"factors.html","id":"em-gráficos","chapter":"11 Fatores","heading":"Em gráficos","text":"Em uma figura ggplot(), simplesmente adicione o argumento drop = FALSE na função de escala relevante scale_xxxx(). Todos os níveis de fator serão exibidos, independentemente de estarem presentes nos dados. Se seus níveis de coluna de fator são exibidos usando fill =, então em scale_fill_discrete() você inclui drop = FALSE, conforme mostrado abaixo. Se seus níveis são exibidos com x = (para o eixo x), você deve fornecer color = ou size = para função scale_color_discrete() ou para scale_size_discrete(), respectivamente.Este exemplo é um gráfico de barras empilhadas das categorias por idade e por hospital. Adicionar scale_fill_discrete(drop = FALSE) garante que todas faixas etárias apareçam na legenda, mesmo se não estiverem presentes nos dados.","code":"\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +\n  scale_fill_discrete(drop = FALSE)+                        # mostra todos os grupos de idade na legenda, mesmo aqueles não presentes\n  labs(\n    title = \"Todas as faixas etárias aparecerão na legenda, mesmo se não estiverem presentes nos dados\")"},{"path":"factors.html","id":"em-tabelas","chapter":"11 Fatores","heading":"Em tabelas","text":"Ambas funções table() R base e tabyl() janitor mostrarão todos os níveis de fator (mesmo os níveis não utilizados).Se você usar count() ou summarise() dplyr para fazer uma tabela, adicione o argumento .drop = FALSE para incluir contagens para todos os níveis fator, mesmo aqueles não usados.Leia mais na página Tabelas descritivas, ou documento scale_discrete, ou na documentação count(). Você pode ver outro exemplo na página Rastreamento de contatos.","code":""},{"path":"factors.html","id":"epiweeks-semanas-epidemiológicas","chapter":"11 Fatores","heading":"11.8 Epiweeks (semanas epidemiológicas)","text":"Consulte ampla discussão sobre como criar semanas epidemiológicas na página Agrupamento de dados.Consulte também página Trabalhando com datas para obter dicas sobre como criar e formatar semanas epidemiológicas.","code":""},{"path":"factors.html","id":"epiweeks-em-um-gráfico","chapter":"11 Fatores","heading":"Epiweeks em um gráfico","text":"Se seu objetivo é criar epiweeks para exibir em um gráfico, você pode fazer isso simplesmente com o pacote lubridate e função floor_date(), conforme explicado na página Agrupamento de dados. Os valores retornados serão da classe Data com formato AAAA-MM-DD. Se você usar esta coluna em um gráfico, datas irão naturalmente ordenar corretamente, e você não precisa se preocupar com os níveis ou com conversão para classe Fator. Veja o histograma ggplot() das datas de início abaixo.Nesta abordagem, você pode ajustar exibição das datas em um eixo com scale_x_date(). Consulte página em Curvas epidêmicas para obter mais informações. Você pode especificar um formato de exibição “strptime” para o argumento date_labels = da função scale_x_date(). Esses formatos usam marcadores “%” e são abordados na página Trabalhando com datas. Use “% Y” para representar um ano de 4 dígitos e “% W” ou “% U” para representar o número da semana (semanas de segunda ou domingo, respectivamente).","code":"\nlinelist %>% \n  mutate(epiweek_date = floor_date(date_onset, \"week\")) %>%  # criando uma coluna de semanas\n  ggplot()+                                                  # iniciando o ggplot\n  geom_histogram(mapping = aes(x = epiweek_date))+           # histograma da data de início\n  scale_x_date(date_labels = \"%Y-W%W\")                       # ajustar a exibição das datas para YYYY-WWw"},{"path":"factors.html","id":"epiweeks-nos-dados","chapter":"11 Fatores","heading":"Epiweeks nos dados","text":"entanto, se o seu objetivo na transformação para fator não é gerar um gráfico, você pode abordar isso de duas maneiras:Para um controle preciso sobre exibição, converta lubridate coluna epiweek (YYYY-MM-DD) para o formato de exibição desejado (YYYY-WWw) dentro próprio data frame e, em seguida, converta-o para classe Fator.Primeiro, use format() R base para converter exibição de data de YYYY-MM-DD para YYYY-Www (consulte página Trabalhando com datas). Neste processo, classe será convertida em caractere. Em seguida, converta de caractere para classe Fator com factor().PERIGO: Se você colocar semanas à frente dos anos (“Www-YYYY”) (“% W-% Y”), ordem de nível alfanumérico padrão estará incorreta (por exemplo, 01-2015 estará antes de 35-2014) . Pode ser necessário ajustar manualmente ordem, o que seria um processo longo e doloroso.Para uma exibição padrão rápida, use o pacote aweek e sua função date2week(). Você pode definir o dia início da semana por week_start = e, se definir factor = TRUE coluna de saída é um fator ordenado. Como bônus, o fator inclui níveis para todas semanas possíveis intervalo - mesmo se não houver casos naquela semana.Veja página Trabalhando com datas para mais informações sobre aweek. O pacote também oferece função reversa week2date().","code":"\nlinelist <- linelist %>% \n  mutate(epiweek_date = floor_date(date_onset, \"week\"),       # cria semanas epidemiológicas - epiweeks (YYYY-MM-DD)\n         epiweek_formatted = format(epiweek_date, \"%Y-W%W\"),  # Converter para mostrar (YYYY-WWW)\n         epiweek_formatted = factor(epiweek_formatted))       # Converter para fator\n\n# Mostrar níveis\nlevels(linelist$epiweek_formatted)##  [1] \"2014-W13\" \"2014-W14\" \"2014-W15\" \"2014-W16\" \"2014-W17\" \"2014-W18\" \"2014-W19\"\n##  [8] \"2014-W20\" \"2014-W21\" \"2014-W22\" \"2014-W23\" \"2014-W24\" \"2014-W25\" \"2014-W26\"\n## [15] \"2014-W27\" \"2014-W28\" \"2014-W29\" \"2014-W30\" \"2014-W31\" \"2014-W32\" \"2014-W33\"\n## [22] \"2014-W34\" \"2014-W35\" \"2014-W36\" \"2014-W37\" \"2014-W38\" \"2014-W39\" \"2014-W40\"\n## [29] \"2014-W41\" \"2014-W42\" \"2014-W43\" \"2014-W44\" \"2014-W45\" \"2014-W46\" \"2014-W47\"\n## [36] \"2014-W48\" \"2014-W49\" \"2014-W50\" \"2014-W51\" \"2015-W00\" \"2015-W01\" \"2015-W02\"\n## [43] \"2015-W03\" \"2015-W04\" \"2015-W05\" \"2015-W06\" \"2015-W07\" \"2015-W08\" \"2015-W09\"\n## [50] \"2015-W10\" \"2015-W11\" \"2015-W12\" \"2015-W13\" \"2015-W14\" \"2015-W15\" \"2015-W16\"\ndf <- linelist %>% \n  mutate(epiweek = date2week(date_onset, week_start = \"Monday\", factor = TRUE))\n\nlevels(df$epiweek)"},{"path":"factors.html","id":"recursos-4","chapter":"11 Fatores","heading":"11.9 Recursos","text":"R para página de Ciência de Dados em factorsvinheta pacote aweek","code":""},{"path":"pivoting.html","id":"pivoting","chapter":"12 Pivoteando dados","heading":"12 Pivoteando dados","text":"Ao lidar com dados, pivotar (pivoting) pode ser entendido como um dos dois processos abaixo:criação de tabelas dinâmicas (pivot tables), que são tabelas com estatísticas que resumem os dados de um tabela maior.conversão de uma tabela formato longo (long) para o formato largo (wide), ou vice-versa.Nessa página, iremos nos focar na segunda definição. primeira é um passo crucial em análise de dados que está coberto em outras partes livro, nos capítulos de Agrupamento de Dados e Tabelas Descritivas.Essa página discute os formatos dos dados. É importante estar atento à ideia de “dados tidy” (tidy data), na qual cada varíavel tem sua própria coluna, cada observação tem sua própria linha e cada valor tem sua própria célula. Você pode ler mais sobre esse tópico online em seu capítulo livro R para Ciência de Dados (em inglês).","code":""},{"path":"pivoting.html","id":"preparação-3","chapter":"12 Pivoteando dados","heading":"12.1 Preparação","text":"","code":""},{"path":"pivoting.html","id":"carregue-os-pacotes-r","chapter":"12 Pivoteando dados","heading":"Carregue os pacotes R","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  kableExtra,   # Build and manipulate complex tables\n  tidyverse)    # data management + ggplot2 graphics"},{"path":"pivoting.html","id":"importe-os-dados-1","chapter":"12 Pivoteando dados","heading":"Importe os dados","text":"","code":""},{"path":"pivoting.html","id":"dados-de-malária","chapter":"12 Pivoteando dados","heading":"Dados de Malária","text":"Nesta página, iremos utilizar um banco fictício de casos diários de malária, divididos por local e grupos de idade. Se você quiser acompanhar análise, clique aqui para baixar (como arquivo .rds ). Importe os dados com função import() pacote rio (função suporta vários tipos de arquivo como .xlsx, .csv, .rds - cheque página Importar e exportar para mais detalhes).primeras 50 linhas são mostradas abaixo.","code":"\n# Import data\ncount_data <- import(\"malaria_facility_count_data.rds\")"},{"path":"pivoting.html","id":"casos-da-linelist","chapter":"12 Pivoteando dados","heading":"Casos da Linelist","text":"Nas seções finais dessa página também iremos utilizar dados de uma epidemia simulada de Ebola. Se você quiser acompanhar, clique para baixar linelist “limpa” (como um arquivo .rds). Importe os dados com função import() pacote rio (função suporta vários tipos de arquivo como .xlsx, .csv, .rds - cheque página Importar e exportar para mais detalhes).","code":"\n# import your dataset\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"pivoting.html","id":"largo-para-longo","chapter":"12 Pivoteando dados","heading":"12.2 Largo-para-longo","text":"","code":""},{"path":"pivoting.html","id":"formato-largo-wide","chapter":"12 Pivoteando dados","heading":"Formato “Largo” (wide)","text":"Os dados são normalmente inseridos e armazenados formato “largo” (wide) - em que características ou respostas dos sujeitos são acondicionadas em apenas uma linha. Embora possa ser útil para apresentação, esse formato não é ideal para alguns tipos de análises.Vamos pegar como exemplo o banco count_data importado na seção de Preparação acima. Você pode ver que cada linha representa um “dia-local” (facility-day). contagens propriamente ditas dos casos (colunas mais à direita) estão armazenadas em um formato “largo”, de forma que informações para todos os grupos de idade em cada “dia-local” estão armazenadas em apenas uma coluna.Cada observação nesse banco refere-se às contagens dos casos de malária em um dos 65 locais, em uma referida data, que vai desde count_data$data_date %>% min() até count_data$data_date %>% max(). Esse locais estão divididos em uma Província - Province (North) e quatro Distritos - District (Spring, Bolo, Dingo, e Barnard). O banco disponibiliza contagens gerais de malária, bem como contagens específicas por idade em cada um dos quatro grupos = <4 anos, 5-14 anos, e 15 anos ou mais.Dados em formato “largo” (wide) como esse não aderem aos padrões de dados “tidy”, pois os cabeçalhos das colunas não representam, de fato, “variáveis” - eles representam valores de uma varíavel hipotética “grupo de idade” (age group).Esse formato pode ser útil para apresentar informações em uma tabela, ou para inserção de dados provenientes de formulários (Excel, por exemplo). entanto, na fase de análise, os dados devem ser transformados para um formato mais “longo”, alinhado com os padrões de dados “tidy”. O pacote de gráficos ggplot2, inclusive, funciona melhor quando os dados estão formato “longo”.formato atual, não há dificuldade alguma em visualizar o total de casos versus tempo:entanto, e se quiséssemos mostrar contribuições relativas de cada grupo de idade esse total? Neste caso, precisaríamos nos assegurar de que varíaveis de interesse (grupos de idade - age group) aparecessem banco em apenas uma coluna que possa ser passada ao ggplot2 através argumento aes().","code":"\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)"},{"path":"pivoting.html","id":"pivot_longer","chapter":"12 Pivoteando dados","heading":"pivot_longer()","text":"função pivot_longer() tidyr torna os dados mais “longos” (“longer”). O pacote tidyr faz parte dos pacotes da família tidyverse.Essa função recebe como argumento um intervalo de colunas que serão transformadas (especificado argumento cols =). Assim, ela pode operar em apenas um parte banco. Isso é útil para os dados de malária, pois queremos pivotar apenas colunas com contagem dos casos.Executando esse processo, você vai obter duas “novas” colunas - uma com categorias (que antes eram os nomes das colunas), e uma outra com os valores correspondentes (os números de casos). Você pode aceitar os nomes padrão para essas novas colunas ou você pode especificar seus próprios nomes através dos argumentos names_to = e values_to = respectivamente.vamos ver pivot_longer() em ação…","code":""},{"path":"pivoting.html","id":"pivot-padrão","chapter":"12 Pivoteando dados","heading":"Pivot padrão","text":"Queremos usar função pivot_longer() tidyr para converter os dados formato “largo” (wide) para o formato “longo” (long). Especificamente, converter quatro colunas numéricas com contagens dos casos de malária em duas novas colunas: uma com os grupos de idade (age groups) e uma com os valores correspondentes.perceba que o data frame recém criado (df_long) possui mais linhas (12,152 vs 3,038); ele tornou-se mais longo - longer. De fato, ele está precisamente quatro vezes mais longo, pois cada linha banco original agora representa quatro linhas em df_long, uma para cada contagem das observações (<4 anos, 5-14 anos, 15 anos+ e total).Além de mais longo, o novo banco também tem menos colunas (8 vs 10), uma vez que os dados que estavam armazenados nas quatro colunas (aquelas que começavam com o prefixo malaria_) passaram ser armazenados em apenas duas.Uma vez que os nomes de todas essas quatro colunas começam com o prefixo malaria_, poderíamos ter utilizado uma função muito útil para fazer “tidyselect” - com starts_with() poderíamos chegar mesmo resultado (veja página Limpeza de dados e principais funções para conhecer mais dessas funções de auxílio).ou por posição:ou por intervalo nomeado:novas colunas recebem os nomes padrão de name e value, mas podemos sobrescrever esses padrões para fornecer nomes mais semânticos, que vão ajudar lembrar o que representam, utilizando os argumentos names_to e values_to. Vamos utilizar os nomes age_group e counts:Agora podemos passar essa nova base para o ggplot2, e mapear nova coluna count para o eixo y e nova coluna age_group para o argumento fill = (cor de preenchimento da barra). Isso vai mostrar contagens em um gráfico de barras empilhadas, por grupo de idade:Veja esse novo gráfico, e compare com o gráfico criado anteriormento - o que deu errado?Encontramos um problema comum ao manipular dados de vigilância - acabamos incluindo também o número total de casos da coluna malaria_tot, o que fez com que altura de cada barra gráfico fosse o dobro que deveria.Podemos lidar com isso de algumas formas. Podemos simplesmente filtrar esses totais da base antes de passá-la para o ggplot():Ou então, poderíamos ter excluído essa variável quando rodamos pivot_longer(), mantendo-na assim como uma variável separada na base de dados. Veja como os valores dela se “expandem” para preencher novas linhas.","code":"\ndf_long <- count_data %>% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n# provide column with a tidyselect helper function\ncount_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )## # A tibble: 12,152 × 8\n##    location_name data_date  submitted_date Province District newid name          value\n##    <chr>         <date>     <date>         <chr>    <chr>    <int> <chr>         <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…    11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…    12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…    23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot      46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…    11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…    10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…     5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot      26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…     8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…     5\n## # ℹ 12,142 more rows\n# provide columns by position\ncount_data %>% \n  pivot_longer(\n    cols = 6:9\n  )\n# provide range of consecutive columns\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\ndf_long <- \n  count_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long## # A tibble: 12,152 × 8\n##    location_name data_date  submitted_date Province District newid age_group    counts\n##    <chr>         <date>     <date>         <chr>    <chr>    <int> <chr>         <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt…     11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt…     12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt…     23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot      46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt…     11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt…     10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt…      5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot      26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt…      8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt…      5\n## # ℹ 12,142 more rows\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\ndf_long %>% \n  filter(age_group != \"malaria_tot\") %>% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )## # A tibble: 9,114 × 9\n##    location_name data_date  submitted_date Province District malaria_tot newid\n##    <chr>         <date>     <date>         <chr>    <chr>          <int> <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n##  4 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n##  7 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n##  8 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n## 10 Facility 4    2020-08-11 2020-08-12     North    Bolo              49     4\n## # ℹ 9,104 more rows\n## # ℹ 2 more variables: age_group <chr>, counts <int>"},{"path":"pivoting.html","id":"pivoteando-dados-de-múltiplas-classes","chapter":"12 Pivoteando dados","heading":"Pivoteando dados de múltiplas classes","text":"O exemplo acima funciona bem em situações em que todas colunas que você quer pivotar para o formato “longo” são da mesma classe (caracter, numérico, lógico, etc…)Porém, haverá muitos casos em que, como epidemiologista de campo, você estará trabalhando com dados que foram preparados por não-especialistas e que seguem suas próprias lógicas não padronizadas - como Hadley Wickham citou (em referência Tolstoy) em seu artigo seminal sobre os princípios de Tidy Data: “Like families, tidy datasets alike every messy dataset messy way.” (Como famílias, bases de dados tidy são todas parecidas mas todas bases bagunçadas são bagunçadas à sua maneira.)Um problema particularmente comum que você vai encontrar será necessidade de pivotar colunas que possuem diferentes classes de dados. Essa pivotagem vai resultar armazenamento desses diferentes tipos em uma única coluna, o que não é uma situação ideal. Existem várias abordagens possíveis para separar bagunça que isso gera, mas existe um passo importante que você pode dar utilizando pivot_longer() para evitar cair nessa situação.Vamos analisar situação em que há uma série de observações em diferentes intervalos de tempo para cada um dos itens , B e C. Exemplos desses itens podem ser indivíduos (ex: contatos de caso de Ebola sendo monitorados por 21 dias) ou postos de saúde de vilarejos remotos sendo monitorados uma vez por ano para assegurar que ainda funcionam. Vamos utilizar o exemplo contato com o caso de Ebola. Imagine os dados armazenados da seguinte forma:Como pode ser observado, os dados são um pouco complicados. Cada linha armazena informação sobre um item, mas com série temporal avançando mais e mais para direita à medida que o tempo passa. Além disso, classe das colunas alternam entre valores de data e caracteres.Um exemplo particularmente ruim encontrado por este autor envolvia dados de vigilância cólera, qual 8 novas colunas de observação eram adicionadas à base por dia ao longo de 4 anos. Só para abrir o arquivo de Excel em que esses dados estavam levava mais de 10 minutos meu laptop!Para trabalhar com esses dados, precisamos transformar o data frame para o formato longo, mas mantendo separação entre colunas formato date e character (status), para cada observação e cada item. Se não o fizermos, podemos acabar com uma mistura de tipos de variáveis na mesma coluna (um “sacrilégio” quando se trata de gerenciamento de dados e dados “tidy”):Acima, nosso pivot mesclou datas e caracteres em apenas uma coluna value. R reagirá convertendo coluna inteira para classe de caracteres e assim, utilidade das datas será perdida.Para evitar essa situação, podemos aproveitar sintaxe da estrutura original nome das colunas. Existe uma estrutura comum nos nomes, com o número da observação, um underline e depois palavra “status” ou “date”. Podemos utilizar essa sintaxe para manter esses dois tipos de dados em colunas separadas após o pivot.Fazemos isso através de:Fornecimento de um vetor de caracteres para o argumento names_to =, com o segundo item sendo (\".value\" ). Esse termo especial indica que colunas pivotadas vão ser divididas baseadas em um caracter presente em seus nomes…Você também precisa fornecer o caracter “separador” para o argumento names_sep =. Nesse caso, é o underline “_“.Assim, o nome e separação das novas colunas são baseados nos termos “em volta” underline nos nomes das variáveis existentes.Toques finais:Note que coluna date está atualmente com classe caractere - nós podemos convertê-la facilmente em sua classe apropriada utilizando funções mutate() e as_date() descritas na página Trabalhando com datas.Também podemos converter coluna observation para o formato numeric removendo o prefixo “obs” e convertendo para numérico. Podemos fazer isso com função str_remove_all() pacote stringr (veja página Caracteres strings).E agora, podemos começar trabalhar com os dados nesse formato. Ex: criando um de mapa de calor descritivo:","code":"\ndf %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )## # A tibble: 18 × 3\n##    id    observation value     \n##    <chr> <chr>       <chr>     \n##  1 A     obs1_date   2021-04-23\n##  2 A     obs1_status Healthy   \n##  3 A     obs2_date   2021-04-24\n##  4 A     obs2_status Healthy   \n##  5 A     obs3_date   2021-04-25\n##  6 A     obs3_status Unwell    \n##  7 B     obs1_date   2021-04-23\n##  8 B     obs1_status Healthy   \n##  9 B     obs2_date   2021-04-24\n## 10 B     obs2_status Healthy   \n## 11 B     obs3_date   2021-04-25\n## 12 B     obs3_status Healthy   \n## 13 C     obs1_date   2021-04-23\n## 14 C     obs1_status Missing   \n## 15 C     obs2_date   2021-04-24\n## 16 C     obs2_status Healthy   \n## 17 C     obs3_date   2021-04-25\n## 18 C     obs3_status Healthy\ndf_long <- df %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long## # A tibble: 9 × 4\n##   id    observation date       status \n##   <chr> <chr>       <chr>      <chr>  \n## 1 A     obs1        2021-04-23 Healthy\n## 2 A     obs2        2021-04-24 Healthy\n## 3 A     obs3        2021-04-25 Unwell \n## 4 B     obs1        2021-04-23 Healthy\n## 5 B     obs2        2021-04-24 Healthy\n## 6 B     obs3        2021-04-25 Healthy\n## 7 C     obs1        2021-04-23 Missing\n## 8 C     obs2        2021-04-24 Healthy\n## 9 C     obs3        2021-04-25 Healthy\ndf_long <- df_long %>% \n  mutate(\n    date = date %>% lubridate::as_date(),\n    observation = \n      observation %>% \n      str_remove_all(\"obs\") %>% \n      as.numeric()\n  )\n\ndf_long## # A tibble: 9 × 4\n##   id    observation date       status \n##   <chr>       <dbl> <date>     <chr>  \n## 1 A               1 2021-04-23 Healthy\n## 2 A               2 2021-04-24 Healthy\n## 3 A               3 2021-04-25 Unwell \n## 4 B               1 2021-04-23 Healthy\n## 5 B               2 2021-04-24 Healthy\n## 6 B               3 2021-04-25 Healthy\n## 7 C               1 2021-04-23 Missing\n## 8 C               2 2021-04-24 Healthy\n## 9 C               3 2021-04-25 Healthy\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )"},{"path":"pivoting.html","id":"longo-para-largo","chapter":"12 Pivoteando dados","heading":"12.3 Longo-para-largo","text":"Em algumas instâncias, pode ser necessário converter uma base para o formato mais largo (wide) utilizando função pivot_wider().Um caso de uso típico é quando queremos transformar o resultado de uma análise em um formato mais “palatável” ao leitor (tal como em Tabelas para apresentação). Normalmente, isso envolve transformar uma base em que informação para um sujeito está espalhada em múltiplas linhas em um formato em que aquela informação esteja armazenada em apenas uma.","code":""},{"path":"pivoting.html","id":"dados","chapter":"12 Pivoteando dados","heading":"Dados","text":"Para essa seção da página, vamos utilizar o caso da linelist (veja seção de Preparação), que contém uma linha por caso.Aqui estão primeiras 50 linhas:Suponha que gente queira saber contagem dos indivíduos nos diferentes grupos de idade, por gênero:Isso vai produzir uma base longa que é ótima para fazer visualizações ggplot2, mas não é ideal para apresentar em uma tabela:","code":"\ndf_wide <- \n  linelist %>% \n  count(age_cat, gender)\n\ndf_wide##    age_cat gender   n\n## 1      0-4      f 640\n## 2      0-4      m 416\n## 3      0-4   <NA>  39\n## 4      5-9      f 641\n## 5      5-9      m 412\n## 6      5-9   <NA>  42\n## 7    10-14      f 518\n## 8    10-14      m 383\n## 9    10-14   <NA>  40\n## 10   15-19      f 359\n## 11   15-19      m 364\n## 12   15-19   <NA>  20\n## 13   20-29      f 468\n## 14   20-29      m 575\n## 15   20-29   <NA>  30\n## 16   30-49      f 179\n## 17   30-49      m 557\n## 18   30-49   <NA>  18\n## 19   50-69      f   2\n## 20   50-69      m  91\n## 21   50-69   <NA>   2\n## 22     70+      m   5\n## 23     70+   <NA>   1\n## 24    <NA>   <NA>  86\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))"},{"path":"pivoting.html","id":"pivot-wider","chapter":"12 Pivoteando dados","heading":"Pivot wider","text":"Desta forma, podemos utilizar pivot_wider() para transformar os dados em um formato melhor para inclusão nas tabelas de nossos relatórios.O argumento names_from especifica coluna partir da qual serão gerados os nomes da nova coluna names, enquanto o argumento values_from especifica coluna partir da qual serão retirados os valores da coluna values que vão popular células. O argumento id_cols = é opcional, mas pode ser utilizado passando um vetor de nomes de colunas que não deverão ser pivotadas, e assim irá identificar cada linha.Essa tabela é muito mais legível e assim, melhor para utilização em relatórios. Você pode convertê-la em tabelas elegantes e bonitas utilizando vários pacotes, incluindo flextable e knitr. Esse processo é elaborado na página Tabelas para apresentação.","code":"\ntable_wide <- \n  df_wide %>% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide## # A tibble: 9 × 4\n##   age_cat     f     m  `NA`\n##   <fct>   <int> <int> <int>\n## 1 0-4       640   416    39\n## 2 5-9       641   412    42\n## 3 10-14     518   383    40\n## 4 15-19     359   364    20\n## 5 20-29     468   575    30\n## 6 30-49     179   557    18\n## 7 50-69       2    91     2\n## 8 70+        NA     5     1\n## 9 <NA>       NA    NA    86\ntable_wide %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% # adds row and column totals\n  knitr::kable() %>% \n  kableExtra::row_spec(row = 10, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) "},{"path":"pivoting.html","id":"preenchimento","chapter":"12 Pivoteando dados","heading":"12.4 Preenchimento","text":"Em algumas situações após um pivot, e mais frequentemente após um bind, acabamos ficando com algumas células vazias que gostaríamos de preencher.","code":""},{"path":"pivoting.html","id":"dados-1","chapter":"12 Pivoteando dados","heading":"Dados","text":"Por exemplo, pegue duas bases, cada uma com observações para o número da medição, o nome local e contagem de casos naquele momento. entanto, segunda base também possui variável Year.Quando fazemos um bind_rows() para mesclar bases, variável Year será preenchida com NA para aquelas linhas em que não existia nenhuma informação prévia (ex: na primeira base):","code":"\ndf1 <- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 ## # A tibble: 9 × 3\n##   Measurement Facility Cases\n##         <dbl> <chr>    <dbl>\n## 1           1 Hosp 1      66\n## 2           2 Hosp 1      26\n## 3           3 Hosp 1       8\n## 4           1 Hosp 2      71\n## 5           2 Hosp 2      62\n## 6           3 Hosp 2      70\n## 7           1 Hosp 3      47\n## 8           2 Hosp 3      70\n## 9           3 Hosp 3      38\ndf2 <- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2## # A tibble: 3 × 4\n##    Year Measurement Facility Cases\n##   <dbl>       <dbl> <chr>    <dbl>\n## 1  2000           1 Hosp 4      82\n## 2  2001           2 Hosp 4      87\n## 3  2002           3 Hosp 4      46\ndf_combined <- \n  bind_rows(df1, df2) %>% \n  arrange(Measurement, Facility)\n\ndf_combined## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 1      66    NA\n##  2           1 Hosp 2      71    NA\n##  3           1 Hosp 3      47    NA\n##  4           1 Hosp 4      82  2000\n##  5           2 Hosp 1      26    NA\n##  6           2 Hosp 2      62    NA\n##  7           2 Hosp 3      70    NA\n##  8           2 Hosp 4      87  2001\n##  9           3 Hosp 1       8    NA\n## 10           3 Hosp 2      70    NA\n## 11           3 Hosp 3      38    NA\n## 12           3 Hosp 4      46  2002"},{"path":"pivoting.html","id":"fill","chapter":"12 Pivoteando dados","heading":"fill()","text":"Nesse caso, Year é uma variável útil para ser incluída, particularmente se quisermos explorar tendências ao longo tempo. Por isso, utilizamos fill() para preencher células vazias, especificando coluna ser preenchida e direção (nesse caso, acima):Ou então, podemos rearranjar os dados para que possamos preencher na direção descendente:Agora temos uma base útil para fazer um gráfico:Mas menos útil para apresentar em uma tabela, então vamos praticar e converter esse dataframe longo e não “tidy” em um dataframe largo (wide) e “tidy”:Obs: Nesse caso, foi necessário especificar para incluir apenas três variáveis Facility, Year, e Cases pois outra variável Measurement iria interferir com criação da tabela:","code":"\ndf_combined %>% \n  fill(Year, .direction = \"up\")## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 1      66  2000\n##  2           1 Hosp 2      71  2000\n##  3           1 Hosp 3      47  2000\n##  4           1 Hosp 4      82  2000\n##  5           2 Hosp 1      26  2001\n##  6           2 Hosp 2      62  2001\n##  7           2 Hosp 3      70  2001\n##  8           2 Hosp 4      87  2001\n##  9           3 Hosp 1       8  2002\n## 10           3 Hosp 2      70  2002\n## 11           3 Hosp 3      38  2002\n## 12           3 Hosp 4      46  2002\ndf_combined <- \n  df_combined %>% \n  arrange(Measurement, desc(Facility))\n\ndf_combined## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 4      82  2000\n##  2           1 Hosp 3      47    NA\n##  3           1 Hosp 2      71    NA\n##  4           1 Hosp 1      66    NA\n##  5           2 Hosp 4      87  2001\n##  6           2 Hosp 3      70    NA\n##  7           2 Hosp 2      62    NA\n##  8           2 Hosp 1      26    NA\n##  9           3 Hosp 4      46  2002\n## 10           3 Hosp 3      38    NA\n## 11           3 Hosp 2      70    NA\n## 12           3 Hosp 1       8    NA\ndf_combined <- \n  df_combined %>% \n  fill(Year, .direction = \"down\")\n\ndf_combined## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 4      82  2000\n##  2           1 Hosp 3      47  2000\n##  3           1 Hosp 2      71  2000\n##  4           1 Hosp 1      66  2000\n##  5           2 Hosp 4      87  2001\n##  6           2 Hosp 3      70  2001\n##  7           2 Hosp 2      62  2001\n##  8           2 Hosp 1      26  2001\n##  9           3 Hosp 4      46  2002\n## 10           3 Hosp 3      38  2002\n## 11           3 Hosp 2      70  2002\n## 12           3 Hosp 1       8  2002\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\ndf_combined %>% \n  pivot_wider(\n    id_cols = c(Measurement, Facility),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  arrange(Facility) %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% \n  knitr::kable() %>% \n  kableExtra::row_spec(row = 5, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) \ndf_combined %>% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  knitr::kable()"},{"path":"pivoting.html","id":"recursos-5","chapter":"12 Pivoteando dados","heading":"12.5 Recursos","text":"Aqui tem um tutorial útil.","code":""},{"path":"grouping.html","id":"grouping","chapter":"13 Agrupando dados","heading":"13 Agrupando dados","text":"Esta página cobre como agrupar e agregar dados para análise descritiva. Ela faz uso da família de pacotes tidyverse que tem funções comuns e fáceis de usar.O agrupamento de dados é um componente central gerenciamento e análise de dados. Os dados agrupados estatisticamente resumidos por grupo e que podem ser traçados por grupo em um gráfico. funções pacote dplyr (parte tidyverse) tornam o agrupamento e operações subseqüentes bastante fáceis.Esta página abordará os seguintes tópicos:Agrupar dados com função group_by().Dados desagrupadossummarise()dados agrupados com estatísticasA diferença entre count() e tally()’arrange()`aplicado dados agrupadosfilter() aplicado aos dados agrupadosmutate()`aplicado dados agrupadosselect()aplicado aos dados agrupados   O comando R **base**aggregate()` como alternativa","code":""},{"path":"grouping.html","id":"preparação-4","chapter":"13 Agrupando dados","heading":"13.1 Preparação","text":"","code":""},{"path":"grouping.html","id":"carregar-pacotes-2","chapter":"13 Agrupando dados","heading":"Carregar pacotes","text":"Este trecho de código mostra o carregamento dos pacotes necessários para análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para utilização. Você também pode carregar os pacotes instalados com library() R base. Veja página em Introdução ao R para mais informações sobre os pacotes R.","code":"\npacman::p_load(\n  rio,       # para importar os dados\n  here,      # localizar pacotes\n  tidyverse, # limpar, manipular, e visualizar os dados (inlcui dplyr)\n  janitor)   # adicionar totais às linhas e colunas "},{"path":"grouping.html","id":"importar-datos","chapter":"13 Agrupando dados","heading":"Importar datos","text":"Nós importamos os dados de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar,  clique para baixar o linelist “limpo”  (.rds file). O conjunto de dados é importado utilizando função import() pacote rio. Veja página em Importar e exportar para várias formas de importação de dados.primeiras 50 linhas da linelist:","code":"\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"grouping.html","id":"agrupando-os-dados","chapter":"13 Agrupando dados","heading":"13.2 Agrupando os dados","text":"função group_by() de dplyr agrupa linhas pelos valores únicos na coluna especificada para ela. Se várias colunas forem especificadas, linhas são agrupadas pelas combinações únicas de valores através das colunas. Cada valor único (ou combinação de valores) constitui um grupo. Alterações subseqüentes conjunto de dados ou cálculos podem então ser realizadas dentro contexto de cada grupo.Por exemplo, o comando abaixo toma “linelist” e agrupa linhas por valores únicos na coluna “outcome”, salvando saída como uma nova tabela de dados (dataframe) chamada “ll_by_outcome”. (s) coluna(s) de agrupamento são colocadas dentro dos parênteses da função group_by()Note que não há nenhuma mudança perceptível conjunto de dados após executar group_by(), até outra função dplyr tal como mutate(), summarise(), ou arrange() ser aplicada dataframe “grouped”.Você pode, entanto, “ver” os agrupamentos imprimindo o quadro de dados. Ao imprimir um quadro de dados agrupados, você verá que ele foi transformado em um objeto de classe [tibble (https://tibble.tidyverse.org/) que, quando impresso, mostra quais agrupamentos foram aplicados e quantos grupos existem - escritos logo acima da linha cabeçalho.","code":"\nll_by_outcome <- linelist %>% \n  group_by(outcome)\n# visualizar quais grupos estão ativvos\nll_by_outcome## # A tibble: 5,888 × 30\n## # Groups:   outcome [3]\n##    case_id generation date_infection date_onset date_hospitalisation date_outcome\n##    <chr>        <dbl> <date>         <date>     <date>               <date>      \n##  1 5fe599           4 2014-05-08     2014-05-13 2014-05-15           NA          \n##  2 8689b7           4 NA             2014-05-13 2014-05-14           2014-05-18  \n##  3 11f8ea           2 NA             2014-05-16 2014-05-18           2014-05-30  \n##  4 b8812a           3 2014-05-04     2014-05-18 2014-05-20           NA          \n##  5 893f25           3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6 be99c8           3 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7 07e3e8           4 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8 369449           4 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9 f393b4           4 NA             2014-06-05 2014-06-06           2014-06-18  \n## 10 1389ca           4 NA             2014-06-05 2014-06-07           2014-06-09  \n## # ℹ 5,878 more rows\n## # ℹ 24 more variables: outcome <chr>, gender <chr>, age <dbl>, age_unit <chr>,\n## #   age_years <dbl>, age_cat <fct>, age_cat5 <fct>, hospital <chr>, lon <dbl>,\n## #   lat <dbl>, infector <chr>, source <chr>, wt_kg <dbl>, ht_cm <dbl>,\n## #   ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>"},{"path":"grouping.html","id":"grupos-únicos","chapter":"13 Agrupando dados","heading":"Grupos únicos","text":"Os grupos criados refletem cada combinação única de valores através das colunas de agrupamento.Para ver os grupos e o número de linhas em cada grupo, passe os dados agrupados para tally(). Para ver apenas os grupos únicos sem conta, você pode passar para group_keys().Veja abaixo que existem três valores únicos na coluna de agrupamento outcome (desfecho, em português): “Death” (óbito), “Recover” (Recuperado), e NA. Veja que existem nrow(linelist %>% filter(outcome == \"Death\")) óbitos, nrow(linelist %>% filter(outcome == \"Recover\")) recuperações, e nrow(linelist %>% filter(.na(outcome))) sem nenhum resultado registrado.Você pode agrupar por mais de uma coluna. Abaixo, o dataframe é agrupado por ‘outcome’ e ‘gender’, e depois contada. Observe como cada combinação única de “outcome” e “gender” é registrada como seu próprio grupo - incluindo valores ausentes para cada coluna.","code":"\nlinelist %>% \n  group_by(outcome) %>% \n  tally()## # A tibble: 3 × 2\n##   outcome     n\n##   <chr>   <int>\n## 1 Death    2582\n## 2 Recover  1983\n## 3 <NA>     1323\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally()## # A tibble: 9 × 3\n## # Groups:   outcome [3]\n##   outcome gender     n\n##   <chr>   <chr>  <int>\n## 1 Death   f       1227\n## 2 Death   m       1228\n## 3 Death   <NA>     127\n## 4 Recover f        953\n## 5 Recover m        950\n## 6 Recover <NA>      80\n## 7 <NA>    f        627\n## 8 <NA>    m        625\n## 9 <NA>    <NA>      71"},{"path":"grouping.html","id":"novas-colunas-1","chapter":"13 Agrupando dados","heading":"Novas colunas","text":"Você também pode criar uma nova coluna de agrupamento dentro da função group_by(). Isto equivale chamar funçãomutate() antes da instrução group_by(). Para uma tabulação rápida, este estilo pode ser útil, mas para maior clareza em seu código, considere criar esta coluna em seu próprio passo mutate() e depois encadear (usando o “pipe” %>%) com o group_by().","code":"\n# agrupar dados baseado em uma coluna biária criada dentro do próprio comando group_by  \nlinelist %>% \n  group_by(\n    age_class = ifelse(age >= 18, \"adult\", \"child\")) %>% \n  tally(sort = T)## # A tibble: 3 × 2\n##   age_class     n\n##   <chr>     <int>\n## 1 child      3618\n## 2 adult      2184\n## 3 <NA>         86"},{"path":"grouping.html","id":"adicionareliminar-colunas-de-agrupamento","chapter":"13 Agrupando dados","heading":"Adicionar/Eliminar colunas de agrupamento","text":"Por padrão, se você executar group_by() em dados que já estão agrupados, os grupos antigos serão removidos e o(s) novo(s) grupo(s) será(ão) aplicado(s). Se você quiser adicionar novos grupos aos já existentes, inclua o argumento `.add = TRUE’.Manter todos os gruposSe você agrupar em uma coluna tipo fator, pode haver níveis fator que não estão presentes atualmente nos dados. Se você agrupar nesta coluna, por padrão esses níveis não presentes são descartados e não incluídos como grupos. Para alterar isso para que todos os níveis apareçam como grupos (mesmo que não estejam presentes nos dados), defina .drop = FALSE' em seu comandogroup_by()`.","code":"\n# Agrupado por 'outcome' (desfecho)\nby_outcome <- linelist %>% \n  group_by(outcome)\n\n# Adicionar um agrupamento por 'gender' (sexo) \nby_outcome_gender <- by_outcome %>% \n  group_by(gender, .add = TRUE)"},{"path":"grouping.html","id":"desagrupar","chapter":"13 Agrupando dados","heading":"13.3 Desagrupar","text":"Os dados que foram agrupados permanecerão agrupados até que especificamente não sejam agrupados através ungroup(). Se você se esquecer de desagradar, isso pode levar cálculos incorretos! Abaixo está um exemplo de remoção de todos os agrupamentos:Você também pode remover o agrupamento apenas para colunas específicas, colocando o nome da coluna dentro de ungroup().NOTA: O verbo count() desagrupa os dados automaticamente após contagem.","code":"\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally() %>% \n  ungroup()\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally() %>% \n  ungroup(gender) # remove o agrupamento por `gender` (sexo), mantendo o agrupamento por `outcome` (desfecho) "},{"path":"grouping.html","id":"group_summarise","chapter":"13 Agrupando dados","heading":"13.4 Resumir os dados (Summarise)","text":"Consulte seção dplyr da página Tabelas descritivas para obter uma descrição detalhada de como produzir tabelas resumidas com summarise(). Aqui abordamos brevemente como seu comportamento muda quando aplicado dados agrupados.função dplyr summarise() (ou summarize()) pega um dataframe e o converte em um novo dataframe resumido, com colunas contendo estatísticas resumidas que você definiu. Em dataframe não agrupados, estatísticas resumidas serão calculadas partir de todas linhas. aplicação de summarise() aos dados agrupados produz estas estatísticas resumidas para cada grupo.sintaxe de summarise() é tal que você fornece o(s) nome(s) da(s) nova(s) coluna(s) resumo, um sinal de igual, e então uma função estatística ser aplicada aos dados, como mostrado abaixo. Por exemplo, min(), max(), median(), ou sd(). Dentro da função estatística, liste coluna ser operada e qualquer argumento relevante (por exemplo, na.rm = TRUE). Você pode utilizar sum() para contar o número de linhas que satisfazem um critério lógico (com duplo igual `==``).Abaixo está um exemplo de summarise() aplicado em dados não-agrupados. estatísticas resultantes são produzidas partir de todo o conjunto de dados.Em contraste, abaixo está mesma declaração summarise() aplicada aos dados agrupados. estatísticas são calculadas para cada grupo de “outcome” (desfecho). Observe como colunas de agrupamento serão transportadas para o dataframe.DICA: função summarise funciona com ortografia britânica e americana - summarise() e summarize() chamam mesma função.","code":"\n# estatísticas resumo na linelist desagrupada \nlinelist %>% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males  = sum(gender == \"m\", na.rm=T))##   n_cases mean_age max_age min_age n_males\n## 1    5888 16.01831      84       0    2803\n# statísticas resumo na linelist agrupada \nlinelist %>% \n  group_by(outcome) %>% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males    = sum(gender == \"m\", na.rm=T))## # A tibble: 3 × 6\n##   outcome n_cases mean_age max_age min_age n_males\n##   <chr>     <int>    <dbl>   <dbl>   <dbl>   <int>\n## 1 Death      2582     15.9      76       0    1228\n## 2 Recover    1983     16.1      84       0     950\n## 3 <NA>       1323     16.2      69       0     625"},{"path":"grouping.html","id":"contagens","chapter":"13 Agrupando dados","heading":"13.5 Contagens","text":"funções count() e tally() tem funcionalidade semelhante mas são diferentes. Leia mais sobre distinção entre tally() e count() ","code":""},{"path":"grouping.html","id":"tally","chapter":"13 Agrupando dados","heading":"tally()","text":"tally() é um atalho para summarise(n = n()), e não agrupa os dados. Assim, para ter tallys (contagens) agrupadas, esta função deve ser precedida de um comando group_by(). Você pode adicionar sort = TRUE para ver os grupos maiores primeiro.","code":"\nlinelist %>% \n  tally()##      n\n## 1 5888\nlinelist %>% \n  group_by(outcome) %>% \n  tally(sort = TRUE)## # A tibble: 3 × 2\n##   outcome     n\n##   <chr>   <int>\n## 1 Death    2582\n## 2 Recover  1983\n## 3 <NA>     1323"},{"path":"grouping.html","id":"count","chapter":"13 Agrupando dados","heading":"count()","text":"Por outro lado, count() faz o seguinte:aplica group_by() nas colunas especificadasaplica summarise() e retorna coluna n com o número de linhas por grupoaplica ungroup()Assim como em group_by() você pode adicionar uma nova coluna dentro comando count():O comandocount() pode ser chamado várias vezes, com funcionalidade “rolling-” (rolando para cima). Por exemplo, para resumir o número de hospitais presentes para cada sexo, execute o seguinte. Nota, o nome da coluna final é alterado padrão “n” para maior clareza (com name =).","code":"\nlinelist %>% \n  count(outcome)##   outcome    n\n## 1   Death 2582\n## 2 Recover 1983\n## 3    <NA> 1323\nlinelist %>% \n  count(age_class = ifelse(age >= 18, \"adult\", \"child\"), sort = T)##   age_class    n\n## 1     child 3618\n## 2     adult 2184\n## 3      <NA>   86\nlinelist %>% \n  # produz contagens para grupos únicos de  \"outcome-gender\" groups\n  count(gender, hospital) %>% \n  # junta lingas por `gender` (3) e conta a quantidade de hospitais por gênero (6)\n  count(gender, name = \"hospitals per gender\" ) ##   gender hospitals per gender\n## 1      f                    6\n## 2      m                    6\n## 3   <NA>                    6"},{"path":"grouping.html","id":"adicionar-contagens","chapter":"13 Agrupando dados","heading":"Adicionar contagens","text":"Em contraste com count() e summarise(), você pode utilizar add_count() para adicionar uma nova coluna n com contagem de linhas por grupo enquanto mantém todas outras colunas dataframe.Isto significa que o número de contagem de um grupo, na nova coluna n, será impresso em cada linha grupo. Para fins de demonstração, adicionamos esta coluna e depois reorganizamos colunas para facilitar visualização. Veja seção abaixo em filtro tamanho grupo para outro exemplo.","code":"\nlinelist %>% \n  as_tibble() %>%                   # converte para \"tibble\" para melhro vizualização\n  add_count(hospital) %>%           # adiciona coluna n com as contages por hospital \n  select(hospital, n, everything()) # re-organiza para o propósito desta demostração## # A tibble: 5,888 × 31\n##    hospital        n case_id generation date_infection date_onset date_hospitalisation\n##    <chr>       <int> <chr>        <dbl> <date>         <date>     <date>              \n##  1 Other         885 5fe599           4 2014-05-08     2014-05-13 2014-05-15          \n##  2 Ausente      1469 8689b7           4 NA             2014-05-13 2014-05-14          \n##  3 St. Mark's…   422 11f8ea           2 NA             2014-05-16 2014-05-18          \n##  4 Port Hospi…  1762 b8812a           3 2014-05-04     2014-05-18 2014-05-20          \n##  5 Military H…   896 893f25           3 2014-05-18     2014-05-21 2014-05-22          \n##  6 Port Hospi…  1762 be99c8           3 2014-05-03     2014-05-22 2014-05-23          \n##  7 Ausente      1469 07e3e8           4 2014-05-22     2014-05-27 2014-05-29          \n##  8 Ausente      1469 369449           4 2014-05-28     2014-06-02 2014-06-03          \n##  9 Ausente      1469 f393b4           4 NA             2014-06-05 2014-06-06          \n## 10 Ausente      1469 1389ca           4 NA             2014-06-05 2014-06-07          \n## # ℹ 5,878 more rows\n## # ℹ 24 more variables: date_outcome <date>, outcome <chr>, gender <chr>, age <dbl>,\n## #   age_unit <chr>, age_years <dbl>, age_cat <fct>, age_cat5 <fct>, lon <dbl>,\n## #   lat <dbl>, infector <chr>, source <chr>, wt_kg <dbl>, ht_cm <dbl>,\n## #   ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>"},{"path":"grouping.html","id":"adicionar-totais","chapter":"13 Agrupando dados","heading":"Adicionar totais","text":"Para adicionar facilmente uma linhas ou colunas com os total ou colunas após utilizar tally() ou count(), veja seção janitor da página Tabelas descritivas. Este pacote oferece funções como adorn_totals() e adorn_percentagens() para adicionar totais e converter para mostrar porcentagens. Abaixo está um breve exemplo:Para adicionar linhas de totais mais complexas que envolvam estatísticas resumidas diferentes de somas, ver esta seção da página Tabelas Descritivas.","code":"\nlinelist %>%                                  # caso linelist\n  tabyl(age_cat, gender) %>%                  # tabela cruzada para duas colinas\n  adorn_totals(where = \"row\") %>%             # adiciona uma linha de totais\n  adorn_percentages(denominator = \"col\") %>%  # converte para proporções com a coluna `denominator`\n  adorn_pct_formatting() %>%                  # converte proporções para porcentagens\n  adorn_ns(position = \"front\") %>%            # mostrar como: \"count (percent)\"\n  adorn_title(                                # ajustar título\n    row_name = \"Age Category\",\n    col_name = \"Gender\")##                       Gender                            \n##  Age Category              f              m          NA_\n##           0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n##           5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n##         10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n##         15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n##         20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n##         30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n##         50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n##           70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n##          <NA>     0   (0.0%)     0   (0.0%)  86  (30.9%)\n##         Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)"},{"path":"grouping.html","id":"agrupoando-por-data","chapter":"13 Agrupando dados","heading":"13.6 Agrupoando por data","text":"Ao agrupar os dados por data, você deve ter (ou criar) uma coluna para unidade de data de interesse - por exemplo “dia”, “epiweek”, “mês”, etc. Você pode fazer esta coluna utilizando floor_date() lubridate, como explicado na seção Semanas Epidemiológicas da página Trabalhando com datas. Uma vez que você tenha esta coluna, você pode utilizar count() dplyr* para agrupar linhas por esses valores de data únicos e obter contagens agregadas.Uma etapa adicional comum para situações de datas, é “preencher” quaisquer datas na seqüência que não estejam presentes nos dados. Utilize complete() tidyr* para que série de datas agregadas seja completa incluindo todas unidades de data possíveis dentro intervalo. Sem esta etapa, uma semana sem casos reportados pode não aparecer em seus dados!Dentro de complete() você define sua coluna de datas como uma seqüência de datas seq.Date() mínimo para o máximo - assim, datas são expandidas. Por padrão, os valores de contagem de casos em qualquer nova linha “expandida” serão NA. Você pode defini-los como 0 utilizando o fill = argumento de complete(), que espera uma lista nomeada (se sua coluna de contagem chamada n, forneça fill = lista(n = 0). Veja `?complete’ para detalhes e página Trabalhando com datas para um exemplo.","code":""},{"path":"grouping.html","id":"os-casos-da-linelist-em-dias","chapter":"13 Agrupando dados","heading":"Os casos da Linelist em dias","text":"Aqui está um exemplo de agrupamento de casos em dias sem utilizar função complete(). Observe que primeiras linhas saltam datas sem casos.Abaixo nós adicionamos o comando complete() para assegurar que todos os dias estão representados.","code":"\ndaily_counts <- linelist %>% \n  drop_na(date_onset) %>%        # remove casos que faltam date_onset\n  count(date_onset)              # conta o número de linhas poro data única \ndaily_counts <- linelist %>% \n  drop_na(date_onset) %>%                 # remove casos em que faltam date_onset\n  count(date_onset) %>%                   # conta o número de linhas poro data única\n  complete(                               # assegura que todos os dias aparecem \n    date_onset = seq.Date(                # re-define a coluna data como uma sequencia diária\n      from = min(date_onset, na.rm=T), \n      to = max(date_onset, na.rm=T),\n      by = \"day\"),\n    fill = list(n = 0))                   # configura as linhas adicionadas para apresentar 0 e na coluna n  (não NAcomo no padrão) "},{"path":"grouping.html","id":"casos-linelist-em-semanas","chapter":"13 Agrupando dados","heading":"Casos Linelist em semanas","text":"O mesmo princípio pode ser aplicado durante semanas. Primeiro cria-se uma nova coluna que é semana caso utilizando floor_date() com unit = \"semana\". Em seguida, utilize count() como acima para obter contagens semanais de casos. Termine com complete() para garantir que todas semanas sejam representadas, mesmo que não contenham casos.Aqui estão 50 primeiras linhas dataframe resultante:","code":"\n# Mostrar dados por contagens semanais\nweekly_counts <- linelist %>% \n  drop_na(date_onset) %>%                 # remove casos em que está faltando date_onset\n  mutate(week = lubridate::floor_date(date_onset, unit = \"week\")) %>%  # nova coluna com a data \n  count(week) %>%                         #  agrupa dados por semana e conta \n  complete(                               # assegura que todos as semanas aparencem \n    week = seq.Date(                      # redefine a coluna data como uma sequência completa\n      from = min(week, na.rm=T), \n      to = max(week, na.rm=T),\n      by = \"week\"),\n    fill = list(n = 0))                   # configura as linhas adicionadas para apresentar 0 e na coluna n  (não NAcomo no padrão) "},{"path":"grouping.html","id":"casos-da-linelist-em-meses","chapter":"13 Agrupando dados","heading":"Casos da Linelist em meses","text":"Para agregar os casos em meses, novamente utilize floor_date() pacote lubridate, mas com o argumento unit = \"meses\". Isto arredonda cada data até o dia 1 de seu mês. saída será classe Data. Observe que passo complete() também utilizamos = \"meses\".","code":"\n# Mostrar dados para contagens mensais\nmonthly_counts <- linelist %>% \n  drop_na(date_onset) %>% \n  mutate(month = lubridate::floor_date(date_onset, unit = \"months\")) %>%  # nova colua com o 1 mês do `onset` \n  count(month) %>%                          # conta casos por mês\n  complete(\n    month = seq.Date(\n      min(month, na.rm=T),     # inclui todos os meses mesmo os sem casos reportados \n      max(month, na.rm=T),\n      by=\"month\"),\n    fill = list(n = 0))"},{"path":"grouping.html","id":"contagens-diárias-em-semanas","chapter":"13 Agrupando dados","heading":"Contagens diárias em semanas","text":"Para agregar contagens diárias em contagens semanais, utilize floor_date() como acima. Entretanto, utilize group_by() e summarize() em vez de count() porque você precisa sum() contar casos diários em vez de apenas contar o número de filas por semana.","code":""},{"path":"grouping.html","id":"contagens-diárias-em-meses","chapter":"13 Agrupando dados","heading":"Contagens diárias em meses","text":"Para agregar contagens diárias em contagens de meses, utilize floor_date() com unit = \"month\" (mês) como acima. Entretanto, utilize group_by() e summarize() em vez de count() porque você precisa sum() contar casos diários em vez de apenas contar o número de filas por mês.","code":""},{"path":"grouping.html","id":"organizando-dados-agrupados","chapter":"13 Agrupando dados","heading":"13.7 Organizando dados agrupados","text":"Utilizando o verbo arrange()dplyr para ordenar linhas em um quadro de dados se comporta da mesma forma quando os dados são agrupados, menos que você defina o argumento .by_group =TRUE. Neste caso, linhas são ordenadas primeiro pelas colunas de agrupamento e depois por quaisquer outras colunas que você especificar para arrange().","code":""},{"path":"grouping.html","id":"filtrando-dados-agrupados","chapter":"13 Agrupando dados","heading":"13.8 Filtrando dados agrupados","text":"","code":""},{"path":"grouping.html","id":"filter","chapter":"13 Agrupando dados","heading":"filter()","text":"Quando aplicadas em conjunto com funções que avaliam o dataframe (como max(), min(), mean()), estas funções serão agora aplicadas aos grupos. Por exemplo, se você quiser filtrar e manter linhas onde os pacientes estão acima da mediana de idade, isto agora será aplicado por grupo - filtrando para manter linhas acima da mediana de idade grupo.","code":""},{"path":"grouping.html","id":"linhas-de-corte-por-grupo","chapter":"13 Agrupando dados","heading":"Linhas de corte por grupo","text":"função slice() (literalmente: fatiar) pacote dplyr , que filtra linhas com base em sua posição nos dados, também pode ser aplicada por grupo. Lembre-se de levar em conta ordenação dos dados dentro de cada grupo para obter “fatia” desejada.Por exemplo, para recuperar apenas últimas 5 admissões de cada hospital:Agrupar lineliste por coluna “hospital”.Organizar os registros da mais recente à mais antiga date_hospitalisation (data de hospitalização) em cada grupo hospitalar.Divide para recuperar 5 primeiras fileiras de cada hospitalslice_head() - selecciona n linhas toposlice_tail() - selecciona n linhas final\nslice_sample() - seleciona aleatoriamente n linhas\nslice_min() - seleciona n linhas com os valores mais altos da coluna order_by =, use with_ties = TRUE para manter os vínculos\nslice_max() - seleciona os menores valores da coluna order_by = column, , use with_ties = TRUE para manter os vínculosVeja página Eliminando duplicidades para meis exemplos e detalhes de slice().","code":"\nlinelist %>%\n  group_by(hospital) %>%\n  arrange(hospital, date_hospitalisation) %>%\n  slice_head(n = 5) %>% \n  arrange(hospital) %>%                            # para visualizar\n  select(case_id, hospital, date_hospitalisation)  # para visualizar## # A tibble: 30 × 3\n## # Groups:   hospital [6]\n##    case_id hospital         date_hospitalisation\n##    <chr>   <chr>            <date>              \n##  1 6c286a  Ausente          2014-04-27          \n##  2 49731d  Ausente          2014-05-02          \n##  3 f1f60f  Ausente          2014-05-09          \n##  4 8689b7  Ausente          2014-05-14          \n##  5 6285c9  Ausente          2014-05-14          \n##  6 20b688  Central Hospital 2014-05-06          \n##  7 d58402  Central Hospital 2014-05-10          \n##  8 b8f2fd  Central Hospital 2014-05-13          \n##  9 acf422  Central Hospital 2014-05-28          \n## 10 275cc7  Central Hospital 2014-05-28          \n## # ℹ 20 more rows"},{"path":"grouping.html","id":"group_filter_grp_size","chapter":"13 Agrupando dados","heading":"Filtrar por tamanho do grupo","text":"função add_count() adiciona uma coluna n aos dados originais dando o número de linhas grupo daquela linha.Mostrado abaixo, add_count() é aplicado à coluna hospital, assim os valores na nova coluna n refletem o número de linhas grupo hospitalar. Observe como os valores na coluna n são repetidos. exemplo abaixo, o nome da coluna n poderia ser alterado utilizando name = dentro de add_count(). Para fins de demonstração, reorganizamos colunas com select().Torna-se então fácil filtrar para linhas de casos que foram hospitalizados em um hospital “pequeno”, digamos, um hospital que admitiu menos de 500 pacientes:","code":"\nlinelist %>% \n  as_tibble() %>% \n  add_count(hospital) %>%          # adiciona \"número de linhas adimitidas no mesmo hospital que o dessa linha\" \n  select(hospital, n, everything())## # A tibble: 5,888 × 31\n##    hospital        n case_id generation date_infection date_onset date_hospitalisation\n##    <chr>       <int> <chr>        <dbl> <date>         <date>     <date>              \n##  1 Other         885 5fe599           4 2014-05-08     2014-05-13 2014-05-15          \n##  2 Ausente      1469 8689b7           4 NA             2014-05-13 2014-05-14          \n##  3 St. Mark's…   422 11f8ea           2 NA             2014-05-16 2014-05-18          \n##  4 Port Hospi…  1762 b8812a           3 2014-05-04     2014-05-18 2014-05-20          \n##  5 Military H…   896 893f25           3 2014-05-18     2014-05-21 2014-05-22          \n##  6 Port Hospi…  1762 be99c8           3 2014-05-03     2014-05-22 2014-05-23          \n##  7 Ausente      1469 07e3e8           4 2014-05-22     2014-05-27 2014-05-29          \n##  8 Ausente      1469 369449           4 2014-05-28     2014-06-02 2014-06-03          \n##  9 Ausente      1469 f393b4           4 NA             2014-06-05 2014-06-06          \n## 10 Ausente      1469 1389ca           4 NA             2014-06-05 2014-06-07          \n## # ℹ 5,878 more rows\n## # ℹ 24 more variables: date_outcome <date>, outcome <chr>, gender <chr>, age <dbl>,\n## #   age_unit <chr>, age_years <dbl>, age_cat <fct>, age_cat5 <fct>, lon <dbl>,\n## #   lat <dbl>, infector <chr>, source <chr>, wt_kg <dbl>, ht_cm <dbl>,\n## #   ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\nlinelist %>% \n  add_count(hospital) %>% \n  filter(n < 500)"},{"path":"grouping.html","id":"criando-novas-variáveis-mutate-em-dados-agrupados","chapter":"13 Agrupando dados","heading":"13.9 Criando novas variáveis (mutate) em dados agrupados","text":"Para manter todas colunas e linhas (não resumir) e adicionar uma nova coluna contendo estatísticas de grupo, utilizar mutate() após group_by() em vez de summarise().Isto é útil se você quiser estatísticas de grupo conjunto de dados original * com todas outras colunas presentes* - por exemplo, para cálculos que comparam uma linha com seu grupo.Por exemplo, este código abaixo calcula diferença entre o atraso de para admissão de uma observação e o atraso mediano para seu hospital. etapas são:Agrupar os dados por hospitalUtilize coluna days_onset_hosp (atraso à hospitalização) para criar uma nova coluna contendo o atraso médio hospital para aquela linha.Calcular diferença entre duas colunasNós usamos função select() para selecionar apenas certas colunas serem exibidas, para fins de demonstração.","code":"\nlinelist %>% \n  # agrupando dados por hospital (sem mudanças na linelist ainda)\n  group_by(hospital) %>% \n  \n  # novas colunas\n  mutate(\n    # quantidades de dias média para admissão por hospital (arredondado para 1 decimal)\n    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),\n    \n    # diferença entre o atraso daquela observação e o atraso medio do hospital (arredondado para 1 decimal)\n    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%\n  \n  # seleciona alguma linhas apenas - para fim de demostração/visualização  \n  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)## # A tibble: 5,888 × 5\n## # Groups:   hospital [6]\n##    case_id hospital                    days_onset_hosp group_delay_admit diff_to_group\n##    <chr>   <chr>                                 <dbl>             <dbl>         <dbl>\n##  1 5fe599  Other                                     2               2             0  \n##  2 8689b7  Ausente                                   1               2.1          -1.1\n##  3 11f8ea  St. Mark's Maternity Hospi…               2               2.1          -0.1\n##  4 b8812a  Port Hospital                             2               2.1          -0.1\n##  5 893f25  Military Hospital                         1               2.1          -1.1\n##  6 be99c8  Port Hospital                             1               2.1          -1.1\n##  7 07e3e8  Ausente                                   2               2.1          -0.1\n##  8 369449  Ausente                                   1               2.1          -1.1\n##  9 f393b4  Ausente                                   1               2.1          -1.1\n## 10 1389ca  Ausente                                   2               2.1          -0.1\n## # ℹ 5,878 more rows"},{"path":"grouping.html","id":"selecionar-em-dados-agrupados","chapter":"13 Agrupando dados","heading":"13.10 Selecionar em dados agrupados","text":"O verbo select() funciona em dados agrupados, mas colunas de agrupamento são sempre incluídas (mesmo se não mecionadas explicitamente em select()). Se você não quiser essas colunas, precisa usarprimeiro função ungroup() para desagrupá-los.","code":""},{"path":"grouping.html","id":"recursos-6","chapter":"13 Agrupando dados","heading":"13.11 Recursos","text":"Aqui estão alguns recursos úteis para mais informações.Você pode aplicar funções de resumo em dados agrupados; ver “cheat sheet” (cola) de transformação de dados RStudio.página Data Carpentry dplyr\npáginas de referência tidyverse em group_by() groupingEsta página em Manipulação de dadosResumindo com condicionamento dplyr","code":""},{"path":"joining-matching.html","id":"joining-matching","chapter":"14 Juntando dados (Joins)","heading":"14 Juntando dados (Joins)","text":"Acima: um exemplo animado de uma operação de left join (image source)Essa página descreve maneiras de combinar diferentes data frames com operações tipo “join”, “match”, “link” e “bind”.Raramente nosso fluxo de análise epidemiológica não envolverá múltiplas fontes de dados e relações entre múltiplas bases. Talvez você precise conectar dados laboratoriais com desfechos clínicos dos pacientes, ou dados de mobilidade Google às tendências de doenças infecciosas, ou ainda, uma base de dados em um estágio da análise com uma versão transormada dessa mesma base.Nessa página vamos demonstrar como escrever código para:Conduzir joins de dois dataframes de forma que linhas sejam combinadas com base nos valores comuns das colunas de identificadoresJuntar dois dataframes baseados na combinação probabilística (verossímil) entre valoresExpandir um dataframe através da ligação/anexação direta (binding ou “appending”) de linhas ou colunas de outro dataframe","code":""},{"path":"joining-matching.html","id":"preparação-5","chapter":"14 Juntando dados (Joins)","heading":"14.1 Preparação","text":"","code":""},{"path":"joining-matching.html","id":"carregue-os-pacotes-r-1","chapter":"14 Juntando dados (Joins)","heading":"Carregue os pacotes R","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  rio, # importar and exportar\n  here, # localizar arquivos\n  tidyverse, # gerenciamento e visualização de dados\n  RecordLinkage, # combinações probabilisticas\n  fastLink # combinações probabilisticas\n)"},{"path":"joining-matching.html","id":"importe-dados","chapter":"14 Juntando dados (Joins)","heading":"Importe dados","text":"Para iniciar, importaremos versão limpa da linelist de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar, clique para baixar linelist “limpa” (com um arquivo .rds). Importe os dados com função import() pacote rio (ela manipula vários tipos de arquivo, tais como .xlsx, .csv, .rds - veja na página Importando exportando para detalhes).primeiras 50 linhas da linelist são mostradas abaixo.","code":"\n# importa a linelist de casos\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"joining-matching.html","id":"base-de-dados-de-exemplo","chapter":"14 Juntando dados (Joins)","heading":"Base de dados de exemplo","text":"Para demonstrar um join na seção abaixo, utilizaremos seguintes bases de dados:Uma versão “miniatura” da linelist de casos, contendo apenas colunas case_id, date_onset, e hospital, e apenas primeiras 10 linhasUm dataframe separado chamado hosp_info, que contém mais detalhes sobre cada hospitalNa seção de combinação probabilística, utilizaremos outras duas bases diferentes. O código para criar essas bases serão mostradas naquela seção.","code":""},{"path":"joining-matching.html","id":"joins_llmini","chapter":"14 Juntando dados (Joins)","heading":"Linelist de casos “miniatura”","text":"Abaixo está miniatura da linelist de casos, que contém apenas 10 linhas e só colunas case_id, date_onset, e hospital.","code":"\nlinelist_mini <- linelist %>% # começa com a linelist original\n  select(case_id, date_onset, hospital) %>% # seleciona colunas\n  head(10) # seleciona apenas 10 primeira linhas"},{"path":"joining-matching.html","id":"joins_hosp_info","chapter":"14 Juntando dados (Joins)","heading":"Dataframe com informações dos hospitais","text":"Abaixo está o código para criar um dataframe separado com informações adicionais sobre sete hospitais (abrangência populacional e o nível de atenção disponível). Note que o nome “Military Hospital” pertence dois hospitais diferentes - um primeiro nível servindo 10000 residentes e outro nível secundário servindo 50280 residentes.Aqui está esse dataframe:","code":"\n# Cria o dataframe de informação dos hospitais\nhosp_info <- data.frame(\n  hosp_name     = c(\"central hospital\", \"military\", \"military\", \"port\", \"St. Mark's\", \"ignace\", \"sisters\"),\n  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),\n  level         = c(\"Tertiary\", \"Secondary\", \"Primary\", \"Secondary\", \"Secondary\", \"Primary\", \"Primary\")\n)"},{"path":"joining-matching.html","id":"pré-limpeza","chapter":"14 Juntando dados (Joins)","heading":"Pré-limpeza","text":"Joins tradicionais (não-probabilísticos) são sensíveis ao caso (maiúsculos/minúsculos) e necessitam que os caracteres combinem de forma exata (exact match) entre os valores nos dois dataframes. Para demonstrar alguns dos passos de limpeza que você possa precisar executar antes de iniciar um join, vamos limpar e alinhar bases linelist_mini e hosp_info agora.Identifique diferençasPrecisamos que os valores da coluna hosp_name dataframe hosp_info combinem com os valores da coluna hospital dataframe linelist_mini.Aqui estão os valores dataframe linelist_mini, impressos com função unique() R base:e aqui estão os valores dataframe hosp_info:Você pode ver que apesar de alguns dos hospitais existirem em ambos dataframes, existem muitas diferenças na forma como os nomes estão escritos.Alinhando valoresVamos começar limpando os valores dataframe hosp_info. Como explicado na página Limpando dados e funções principais, podemos recodificar valores com critérios lógicos utilizando função case_when() pacote dplyr. Para os quatro hospitais que existem em ambos os dataframes, vamos mudar os valores para alinhar com os valores da linelist_mini. Para os outros hospitais, deixaremos os valores como estão (TRUE ~ hosp_name).CUIDADO: Tipicamente, quando estamos limpando dataframes devemos criar uma nova coluna (ex: hosp_name_clean), mas para facilitar demonstração vamos mostrar diretamente modificação da antiga colunaOs nomes dos hospitais que aparecem em ambos os dataframes estão alinhados. Existem dois hospitais em hosp_info que não estão presentes em linelist_mini - vamos lidar com estes depois, join.Antes de fazer um join, geralmente o mais fácil é converter uma coluna completamente para letras minúsculas (lowercase) ou letras maiúsculas (uppercase). Se você precisar converter todos os valores de uma coluna para MAIÚSCULO ou minúsculo, utilize função mutate() e envolva coluna com alguma dessas funções pacote stringr, como mostrado na página Caracteres e strings.str_to_upper()str_to_upper()str_to_title()","code":"\nunique(linelist_mini$hospital)## [1] \"Other\"                                \"Ausente\"                             \n## [3] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [5] \"Military Hospital\"\nunique(hosp_info$hosp_name)## [1] \"central hospital\" \"military\"         \"port\"             \"St. Mark's\"      \n## [5] \"ignace\"           \"sisters\"\nhosp_info <- hosp_info %>%\n  mutate(\n    hosp_name = case_when(\n      # critério                         # novo valor\n      hosp_name == \"military\" ~ \"Military Hospital\",\n      hosp_name == \"port\" ~ \"Port Hospital\",\n      hosp_name == \"St. Mark's\" ~ \"St. Mark's Maternity Hospital (SMMH)\",\n      hosp_name == \"central hospital\" ~ \"Central Hospital\",\n      TRUE ~ hosp_name\n    )\n  )\nunique(hosp_info$hosp_name)## [1] \"Central Hospital\"                     \"Military Hospital\"                   \n## [3] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\n## [5] \"ignace\"                               \"sisters\""},{"path":"joining-matching.html","id":"joins-com-dplyr","chapter":"14 Juntando dados (Joins)","heading":"14.2 Joins com dplyr","text":"O pacote dplyr oferece várias funções diferentes de join. dplyr está incluso pacote tidyverse. Essas funções de join são descritas abaixo, com casos de uso simples.Agradecimentos https://github.com/gadenbuie pelos gifs informativos!","code":""},{"path":"joining-matching.html","id":"sintaxe-geral","chapter":"14 Juntando dados (Joins)","heading":"Sintaxe geral","text":"Os comandos de join podem ser executados individualmente para juntar dois dataframes em um novo objeto, ou podem ser usados em uma cadeia de comandos com pipe (%>%) para mesclar um dataframe em outro à medida que ele vai sendo limpo ou modificado de alguma outra forma.exemplo abaixo, função left_join() é utilizada como um comando individual para criar um novo dataframe chamado joined_data. entradas (inputs) são os dataframes 1 e 2 (df1 e df2). O primeiro dataframe listado é o dataframe de base e o segundo é o dataframe que será mesclado (joined ) ele.O terceiro argumento = é onde você especifica colunas em cada dataframe que serão utilizadas para alinhar linhas dos dois dataframes. Se os nomes dessas colunas forem diferentes, insira o nome delas com um vetor c() como mostrado abaixo, onde linhas são combinadas com base nos valores comuns entre coluna ID em df1 e coluna identifier em df2.Se colunas utilizadas parâmetro tiverem exatamente o mesmo nome em ambos os dataframes, você pode inserir apenas esse nome, entre aspas.Se você estiver juntando dataframes baseado em valores comuns ao longo de múltiplos campos, liste esses campos em um vetor c(). Esse exemplo junta linhas se os valores em três colunas em cada base de dado se alinham de forma exata.Os comandos de join também podem ser rodados em uma cadeia de comandos com pipe. Isso irá modificar o dataframe que está sendo passado pelo pipe.exemplo abaixo, df1 está sendo pessado pelos pipes, df2 será juntado ele e df1 então será modificado e redefinido.CUIDADO: Joins são caso-específicos (maiúsculas e minúsculas)! Então, é útil converter todos os valores para minúsculo ou maiúsculo antes de fazer o join. Veja página sobre caracteres/strings.","code":"\n# Faz o join baseado nos valores comuns entre a coluna \"ID\" (primeiro dataframe) e coluna \"identifier\" (segundo dataframe)\njoined_data <- left_join(df1, df2, by = c(\"ID\" = \"identifier\"))\n# Join baseado nos valores comuns da coluna \"ID\" em ambos os dataframes\njoined_data <- left_join(df1, df2, by = \"ID\")\n# join baseado nos mesmos primeiro nome, último nome e idade\njoined_data <- left_join(df1, df2, by = c(\"name\" = \"firstname\", \"surname\" = \"lastname\", \"Age\" = \"age\"))\ndf1 <- df1 %>%\n  filter(date_onset < as.Date(\"2020-03-05\")) %>% # miscellaneous cleaning\n  left_join(df2, by = c(\"ID\" = \"identifier\")) # join df2 to df1"},{"path":"joining-matching.html","id":"left-joins-e-right-joins","chapter":"14 Juntando dados (Joins)","heading":"Left joins e right joins","text":"Um left join ou right join é normalmente utilizado para adicionar informação um dataframe - novas informações são adicionadas apenas linhas que já existem data frame base. Esses são tipos de joins comuns em trabalhos epidemiológicos pois eles são utilizados para adicionar informações de uma base de dado em outra.Para utilizar esses joins, ordem em que os dataframes estão escritos nos comandos é importante*.Em um left join, o primeiro dataframe escrito é o de baseEm um right join, o segundo dataframe escrito é o de baseTodas linhas dataframe base são mantidas. informações outro dataframe (secundário) será juntada ao dataframe de base apenas se houver combinação via colunas dos identificadores. E ainda:Linhas dataframe secundário que não combinam são removidas.Se houver muitas linhas dataframe base que combinam com uma linha secundário (muitos-para-um), informação secundário é adicionada cada linha base que combina.Se uma linha base combina com múltiplas linhas secundário (um-para-muitos), todas combinações são dadas, o que significa que novas linhas podem ser adicionadas ao dataframe resultante!Exemplos animados de left e right joins (fonte da imagem)ExemploAbaixo está saída de um left_join() hosp_info (dataframe secundário, veja aqui) em linelist_mini (dataframe base, veja aqui). O linelist_mini tem nrow(linelist_mini) linhas. O linelist_mini modificado é mostrado. Note o seguinte:Duas novas colunas, catchment_pop e level foram adicionadas ao lado esquerdo da linelist_miniTodas linhas originais dataframe base linelist_mini são mantidasQuaisquer linhas originais linelist_mini para “Military Hospital” foram duplicadas porque combinaram com duas linhas dataframe secundário, então ambas combinações são retornadasA coluna de identificador join na base secundária (hosp_name) desapareceu pois está em redundância com coluna de identificador da base primária (hospital)Quando linha da base não combina com nenhuma linha da base secundária (ex: quando hospital é “” ou “Missing”), colunas dataframe secundário serão preenchidas com NA (em branco)Linhas dataframe secundário sem nenhuma combinação dataframe base (hospitais “sisters” e “ignace”) foram removidas","code":"\nlinelist_mini %>%\n  left_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))## Warning in left_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\n## ℹ Row 5 of `x` matches multiple rows in `y`.\n## ℹ Row 4 of `y` matches multiple rows in `x`.\n## ℹ If a many-to-many relationship is expected, set `relationship = \"many-to-many\"` to\n##   silence this warning."},{"path":"joining-matching.html","id":"devo-fazer-um-right-join-ou-um-left-join","chapter":"14 Juntando dados (Joins)","heading":"“Devo fazer um right join, ou um left join?”","text":"Para responder à pergunta acima, pergunte-se “qual dataframe deve manter todas suas linhas?” - utilize esse como o base. Um left join manterá todas linhas primeiro dataframe escrito comando, enquanto um right join manterá todas linhas segundo dataframe.Os dois comandos abaixo geram mesma saída - um join de 10 linhas hosp_info em linelist_mini (base), mas eles usam joins diferentes. O resultado é que ordem das colunas vai diferir se hosp_info aparecer na direita (em um left join) ou na esquerda (em um right join). ordem das linhas também pode mudar de posição da mesma forma. entanto, ambas essas consequências podem ser resolvidas depois utilizando select() para reordenar colunas, ou arrange() para ordenar (sort) linhas.Aqui está o resultado join de hosp_info em linelist_mini por meio de um left join (novas colunas vindas da direita)Aqui, o resultado join de hosp_info em linelist_mini por meio de um right join (novas colunas vindas da esquerda)Considere também se seu caso de uso está em meio uma cadeia de comandos com pipe (%>%). Se os dados passando através dos pipes o dataframe base, você irá preferivelmente utilizar um left join para adicionar mais dados ele.","code":"\n# Os dois comandos abaixo geram os memso dados, mas com linhas e colunas em ordem diferentes\nleft_join(linelist_mini, hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nright_join(hosp_info, linelist_mini, by = c(\"hosp_name\" = \"hospital\"))## Warning in left_join(linelist_mini, hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\n## ℹ Row 5 of `x` matches multiple rows in `y`.\n## ℹ Row 4 of `y` matches multiple rows in `x`.\n## ℹ If a many-to-many relationship is expected, set `relationship = \"many-to-many\"` to\n##   silence this warning.## Warning in right_join(hosp_info, linelist_mini, by = c(hosp_name = \"hospital\")): Detected an unexpected many-to-many relationship between `x` and `y`.\n## ℹ Row 4 of `x` matches multiple rows in `y`.\n## ℹ Row 5 of `y` matches multiple rows in `x`.\n## ℹ If a many-to-many relationship is expected, set `relationship = \"many-to-many\"` to\n##   silence this warning."},{"path":"joining-matching.html","id":"full-join","chapter":"14 Juntando dados (Joins)","heading":"Full join","text":"Um full join é o mais inclusivo dos joins - ele retorna todas linhas de ambos os dataframes.Se houver alguma linha presente em um mas não em outro (onde não foi encontrada nenhuma combinação entre os dados), o dataframe vai incluir essa linha e tornar-se mais longo. Os valores NA para representar valores ausentes serão utilizados para preencher os espaços vazios criados. À medida que você executando o join, monitore cuidadosamente o número de colunas e linhas para resolver problemas de sensitividade de caso (maiúsculo/minúsculo) ou combinação exata de caracteres.O dataframe base será aquele escrito primeiro comando. Mudar essa posição não vai impactar em quais registros serão retornados pelo join, mas pode impactar na ordem das colunas e linhas resultantes e também em quais colunas de identificadores serão mantidos.Exemplo animado de um full join (fonte da imagem)ExemploAbaixo está uma saída de um full_join() hosp_info (originalmente nrow(hosp_info), veja aqui) em linelist_mini (originalmente nrow(linelist_mini), veja aqui). Note o seguinte:Todas linhas dataframe base são mantidas (linelist_mini)Linhas dataframe secundário que não combinam com o dataframe base são mantidas (“ignace” e “sisters”), com valores nas colunas correspondentes base (case_id e onset) preenchidas com os valores ausentes NADa mesma forma, linhas dataframe base que não combinam com o secundário (“” e “Missing”) são mantidas, com colunas catchment_pop e level secundário preenchidas com NANos casos das combinações um-para-muitos ou muitos-para-um (ex: linhas para “Military Hospital”), todas combinações possíveis são retornadas (aumentando o tamanho dataframe final)Apenas coluna identificador dataframe base foi mantida (hospital)","code":"\nlinelist_mini %>%\n  full_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))## Warning in full_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\n## ℹ Row 5 of `x` matches multiple rows in `y`.\n## ℹ Row 4 of `y` matches multiple rows in `x`.\n## ℹ If a many-to-many relationship is expected, set `relationship = \"many-to-many\"` to\n##   silence this warning."},{"path":"joining-matching.html","id":"inner-join","chapter":"14 Juntando dados (Joins)","heading":"Inner join","text":"Um inner join é o mais restritivo dos joins - ele retona apenas linhas que combinam em ambos os dataframes.\nIsso significa que o número linhas dataframe base pode, de fato, reduzir. Ajustes em relação qual dataframe será o base (escrito primeiro na função) não irá impactar quais linhas serão retornadas, mas vai impactar na ordem das colunas e linhas, e quais colunas de identificadores serão mantidas.Exemplo animado de um inner join (fonte da imagem)ExemploAbaixo está saída de um inner_join() de linelist_mini (base) com hosp_info (secundário). Note o seguinte:linhas dataframe base que não combinam com secundário são removidas (linhas onde hospital é “Missing” ou “”)De forma análoga, linhas secundário que não combinam com o base são removidas (linhas onde hosp_name é “sisters” ou “ignace”)Apenas coluna de identificador base foi mantida (hospital)","code":"\nlinelist_mini %>%\n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))## Warning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\n## ℹ Row 5 of `x` matches multiple rows in `y`.\n## ℹ Row 4 of `y` matches multiple rows in `x`.\n## ℹ If a many-to-many relationship is expected, set `relationship = \"many-to-many\"` to\n##   silence this warning."},{"path":"joining-matching.html","id":"semi-join","chapter":"14 Juntando dados (Joins)","heading":"Semi join","text":"Um semi join é “join filtro” que utiliza outra base de dados não para adicionar linhas ou colunas, mas para fazer uma filtragem.Um semi-join mantém todas observações dataframe base que combinam com algum valor dataframe secundário (mas não adiciona novas colunas nem duplica nenhuma linha para o caso de múltiplas combinações). Leia mais sobre esses joins “filtros” aqui.Exemplo de um semi join animado (fonte da imagem)Como um exemplo, o código abaixo retorna linhas dataframe hosp_info que tem combinações em linelist_mini baseados nome hospital.","code":"\nhosp_info %>%\n  semi_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))##                              hosp_name catchment_pop     level\n## 1                    Military Hospital         40500 Secondary\n## 2                    Military Hospital         10000   Primary\n## 3                        Port Hospital         50280 Secondary\n## 4 St. Mark's Maternity Hospital (SMMH)         12000 Secondary"},{"path":"joining-matching.html","id":"anti-join","chapter":"14 Juntando dados (Joins)","heading":"Anti join","text":"O anti join é um outro tipo de “join filtro” que retorna linhas dataframe base que não possuem uma combinação dataframe secundário.Leia mais sobre esses joins “filtros” aqui.Cenários comuns para anti-join incluem identificar registros que não estão presentes em outro data frame, checar erros de grafia em um join (revisão de registros que deveriam ter combinado) e examinar registros que foram excluídos depois de outro join.Assim como com right_join() e left_join(), o dataframe base (listado primeiro) é importante. linhas retornadas serão apenas dataframe base. Veja gif abaixo qu e linha dataframe secundário (linha roxa 4) não é retornada mesmo que ela não tenha combinado com o base.Exemplo animado de um anti join (fonte da imagem)","code":""},{"path":"joining-matching.html","id":"um-exemplo-simples-de-anti_join","chapter":"14 Juntando dados (Joins)","heading":"Um exemplo simples de anti_join()","text":"Para um exemplo simples, vamos achar os hospitais de hosp_info que não possuem nenhum caso presente em linelist_mini. Nós listamos hosp_info primeiro, como o dataframe base. Os hospitais que não estão presentes em linelist_mini são retornados.","code":"\nhosp_info %>%\n  anti_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))"},{"path":"joining-matching.html","id":"exemplo-complexo-de-anti_join","chapter":"14 Juntando dados (Joins)","heading":"Exemplo complexo de anti_join()","text":"Para outro exemplo, vamos supor que rodamos um inner_join() entre linelist_mini e hosp_info. Será retornado apenas um subconjunto dos registros originais de linelist_mini, visto que alguns não estão presentes em hosp_info.Para revisar os registros de linelist_mini que foram excluídos inner join, podemos rodar um anti-join com mesmas configurações (linelist_mini como o dataframe base).Para ver os registros de hosp_info que foram excluídos inner join, também podemos rodar um anti-join com hosp_info como o dataframe base.","code":"\nlinelist_mini %>%\n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))## Warning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\n## ℹ Row 5 of `x` matches multiple rows in `y`.\n## ℹ Row 4 of `y` matches multiple rows in `x`.\n## ℹ If a many-to-many relationship is expected, set `relationship = \"many-to-many\"` to\n##   silence this warning.\nlinelist_mini %>%\n  anti_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"joining-matching.html","id":"combinação-probabilística","chapter":"14 Juntando dados (Joins)","heading":"14.3 Combinação probabilística","text":"Se você não tiver um único identificador comum entre bases de dados para fazer o join, considere utilizar um algoritmo de combinação probabilística. Ele acharia combinações entre os registros baseados em similaridade (ex: distância de strings de Jaro–Winkler, ou distância numérica). Abaixo temos um exemplo simples utilizando o pacote fastLink .Carregue o pacoteAque estão duas pequenas bases de dados que nós iremos utilizar para demonstrar combinação probabilística (cases e test_results):Aqui está o código utilizado para construir bases de dados:base de dados cases possui 9 registros de pacientes que estão esperando para testar resultados.base de dados test_results possui 14 registros e contém coluna result, que nós queremos adicionar aos registros cases baseados nas combinações probabilísticas dos registros.","code":"\npacman::p_load(\n  tidyverse, # manipulação e visualização de dados\n  fastLink # combinação dos registros\n)\n# cria as bases de dados\n\ncases <- tribble(\n  ~gender, ~first, ~middle, ~last, ~yr, ~mon, ~day, ~district,\n  \"M\", \"Amir\", NA, \"Khan\", 1989, 11, 22, \"River\",\n  \"M\", \"Anthony\", \"B.\", \"Smith\", 1970, 09, 19, \"River\",\n  \"F\", \"Marialisa\", \"Contreras\", \"Rodrigues\", 1972, 04, 15, \"River\",\n  \"F\", \"Elizabeth\", \"Casteel\", \"Chase\", 1954, 03, 03, \"City\",\n  \"M\", \"Jose\", \"Sanchez\", \"Lopez\", 1996, 01, 06, \"City\",\n  \"F\", \"Cassidy\", \"Jones\", \"Davis\", 1980, 07, 20, \"City\",\n  \"M\", \"Michael\", \"Murphy\", \"O'Calaghan\", 1969, 04, 12, \"Rural\",\n  \"M\", \"Oliver\", \"Laurent\", \"De Bordow\", 1971, 02, 04, \"River\",\n  \"F\", \"Blessing\", NA, \"Adebayo\", 1955, 02, 14, \"Rural\"\n)\n\nresults <- tribble(\n  ~gender, ~first, ~middle, ~last, ~yr, ~mon, ~day, ~district, ~result,\n  \"M\", \"Amir\", NA, \"Khan\", 1989, 11, 22, \"River\", \"positive\",\n  \"M\", \"Tony\", \"B\", \"Smith\", 1970, 09, 19, \"River\", \"positive\",\n  \"F\", \"Maria\", \"Contreras\", \"Rodriguez\", 1972, 04, 15, \"Cty\", \"negative\",\n  \"F\", \"Betty\", \"Castel\", \"Chase\", 1954, 03, 30, \"City\", \"positive\",\n  \"F\", \"Andrea\", NA, \"Kumaraswamy\", 2001, 01, 05, \"Rural\", \"positive\",\n  \"F\", \"Caroline\", NA, \"Wang\", 1988, 12, 11, \"Rural\", \"negative\",\n  \"F\", \"Trang\", NA, \"Nguyen\", 1981, 06, 10, \"Rural\", \"positive\",\n  \"M\", \"Olivier\", \"Laurent\", \"De Bordeaux\", NA, NA, NA, \"River\", \"positive\",\n  \"M\", \"Mike\", \"Murphy\", \"O'Callaghan\", 1969, 04, 12, \"Rural\", \"negative\",\n  \"F\", \"Cassidy\", \"Jones\", \"Davis\", 1980, 07, 02, \"City\", \"positive\",\n  \"M\", \"Mohammad\", NA, \"Ali\", 1942, 01, 17, \"City\", \"negative\",\n  NA, \"Jose\", \"Sanchez\", \"Lopez\", 1995, 01, 06, \"City\", \"negative\",\n  \"M\", \"Abubakar\", NA, \"Abullahi\", 1960, 01, 01, \"River\", \"positive\",\n  \"F\", \"Maria\", \"Salinas\", \"Contreras\", 1955, 03, 03, \"River\", \"positive\"\n)"},{"path":"joining-matching.html","id":"combinação-probabilística-probabilistic-matching","chapter":"14 Juntando dados (Joins)","heading":"Combinação Probabilística (probabilistic matching)","text":"função fastlink() pacote fastlink pode ser utilizada para aplicar um algoritmo que busca combinações entre os valores. Aqui estão informações básicas. Você pode ler mais detalhes digitando ?fastlink seu console.Defina os dois dataframes que serão comparados nos argumentos dfA = e dfB =Em varnames = defina todos os nomes de colunas que serão utilizadas para testar combinação. Todas devem existir tanto em dfA quanto em dfB.Em stringdist.match = defina o nome das colunas que estão em varnames que serão avaliadas pela “distancia” entre strings.Em numeric.match = defina o nome das colunas que estão em varnames que serão avaliadas pela distância numérica.Valores ausentes serão ignoradosPor padrão, cada linha em qualquer dos dataframes será combinada com máximo uma linha outro dataframe. Se você quiser ver todas combinações que foram avaliadas defina o parâmetro dedupe.matches = FALSE. deduplicação é feita utilizando solução de Winkler para atribuição linear.Dica: divida uma coluna única de data em 3 colunas numéricas separadas utilizadando day(), month(), e year() pacote lubridateO limiar padrão para combinações é 0.94 (threshold.match =) mas você pode ajustar para maior ou menor. Se você ajustar manualmente o limiar, considere que com limiares mais altos você pode gerar mais falsos negativos (linhas que não combinam quando na verdade deveriam combinar) e, da mesma forma, um limiar mais baixo pode gerar falsos positivos.Abaixo, os dados estão sendo combinados pela distância de strings nas colunas de nome e distrito, e na distância numérica para ano, mês e dia nascimento. Um limiar para combinação de 95% de probabilidade foi configurado.Revisando combinaçõesNós definimos o objeto retornado da função fastLink() como fl_output. Ele é da classe list, e de fato contém vários dataframes internamente que detalham os resultados da combinação. Um desses dataframes é matches, que vai conter combinações mais prováveis entre cases e results. Você pode acessar esse dataframe de combinações com fl_output$matches. Abaixo, ele está sendo salvo como my_matches para facilitar o acesso depois.Quando my_matches é impresso console, você vê duas colunas de vetores: os pares de número de linhas/índices (também chamados “rownames”) em cases (“inds.”) e em results (“inds.b”) representando melhores combinações. Se o número da linha de um dataframe estiver ausente, então nenhuma combinação foi achada outro dataframe limiar de combinação especificado.Algumas coisas para se ter em mente:combinações ocorrem apesar de algumas diferenças sutis na grafia dos nomes ou nas datas de nascimento:\n“Tony B. Smith” combinou com “Anthony B Smith”\n“Maria Rodriguez” combinou com “Marialisa Rodrigues”\n“Betty Chase” combinou com “Elizabeth Chase”\n“Olivier Laurent De Bordeaux” combinou com “Oliver Laurent De Bordow” (data de nascimneto ausente foi ignorada)\n“Tony B. Smith” combinou com “Anthony B Smith”“Maria Rodriguez” combinou com “Marialisa Rodrigues”“Betty Chase” combinou com “Elizabeth Chase”“Olivier Laurent De Bordeaux” combinou com “Oliver Laurent De Bordow” (data de nascimneto ausente foi ignorada)Uma linha de cases (para “Blessing Adebayo”, linha 9) não teve nenhuma boa combinação em results, por isso não está prente em my_matches.Join baseado em combinações probabilísticasPara utilizar essas combinações para fazer um join de results e cases, uma estratégia seria:Utilizar left_join() para fazer o join de my_matches em cases (combinando os nomes das colunas em cases com “inds.” em my_matches)Depois, utilizar outro left_join() para fazer o join de results em cases (combinando o recém adquirido “inds.b” em cases com os nomes das linhas em results)Antes dos joins, devemos limpar os três dataframes:Ambos dfA e dfB devem ter seus números de linhas (“rowname”) convertidos para uma coluna propriamente dita.Ambas colunas de my_matches devem ser convertidas para classe character, para que o join possa ser feito com os nomes de coluna que são caracteresComo feito código acima, o dataframe complete, resultado dos joins, vai conter todas colunas de cases e results. Muitas delas estarão com sufixos “.x” e “.y”, por que, caso contrário, o nome das colunas seriam duplicados.Como opção, para ter apenas os 9 registros “originais” em cases com novaas colunas de results, utilize select() em results antes dos joins, de forma que ela contenha apenas os nomes de linhas e colunas que você queira adicionar cases (ex: coluna result).Se você quiser um subconjunto de qualquer um dos dataframes contendo apenas linhas que combinaram, você pode utilizar o código abaixo:Ou, para ver apenas linhas que não combinaram:","code":"\nfl_output <- fastLink::fastLink(\n  dfA = cases,\n  dfB = results,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\"),\n  stringdist.match = c(\"first\", \"middle\", \"last\", \"district\"),\n  numeric.match = c(\"yr\", \"mon\", \"day\"),\n  threshold.match = 0.95\n)## \n## ==================== \n## fastLink(): Fast Probabilistic Record Linkage\n## ==================== \n## \n## If you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\n## Calculating matches for each variable.\n## Getting counts for parameter estimation.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Running the EM algorithm.\n## Getting the indices of estimated matches.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Deduping the estimated matches.\n## Getting the match patterns for each estimated match.\n# print matches\nmy_matches <- fl_output$matches\nmy_matches##   inds.a inds.b\n## 1      1      1\n## 2      2      2\n## 3      3      3\n## 4      4      4\n## 5      8      8\n## 6      7      9\n## 7      6     10\n## 8      5     12\n# Limpeza dos dados antes do join\n#############################\n\n# converte os nomes das linhas de cases em coluna\ncases_clean <- cases %>% rownames_to_column()\n\n# converte os nomes das linhas de test_results em coluna\nresults_clean <- results %>% rownames_to_column()\n\n# converte todas as colunas no dataframe de combinações (my_matches) para character, para que o join possa ser feito com os nomes das linhas\nmatches_clean <- my_matches %>%\n  mutate(across(everything(), as.character))\n\n\n\n# Faça o join das combinações com dfA, e depois adicione dfB\n###################################\n# a coluna \"inds.b\" é adicionada ao dfA\ncomplete <- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\n\n# colunas do dfB são adicionadas\ncomplete <- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\ncases_clean <- cases %>% rownames_to_column()\n\nresults_clean <- results %>%\n  rownames_to_column() %>%\n  select(rowname, result) # selecion apenas algumas colunas\n\nmatches_clean <- my_matches %>%\n  mutate(across(everything(), as.character))\n\n# joins\ncomplete <- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\ncomplete <- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\ncases_matched <- cases[my_matches$inds.a, ] # Linhas em cases que combinaram com uma linha em results\nresults_matched <- results[my_matches$inds.b, ] # Linhas em results que combinaram com uma linha em cases\ncases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a, ] # Linhas em cases que NÃO combinaram com uma linha em results\nresults_not_matched <- results[!rownames(results) %in% my_matches$inds.b, ] # Linhas em results que NÃO combinaram com uma linha em cases"},{"path":"joining-matching.html","id":"remoção-de-duplicidades-probabilística","chapter":"14 Juntando dados (Joins)","heading":"Remoção de duplicidades probabilística","text":"combinação probabilística também pode ser utilizada para remover duplicidades uma base de dados. Veja página de remoção de duplicidades para outros métodos de deduplicação.Aqui, vamos começar com base cases, mas partir daqui chamaremos ela de cases_dup, pois ela tem 2 linhas adicionais que podem ser duplicidades de linhas anteriores:\nVeja “Tony” com “Anthony”, e “Marialisa Rodrigues” com “Maria Rodriguez”.Execute fastLink() como anteriormente, mas compare o dataframe cases_dup com ele mesmo. Quando os dois dataframes passados para função são idênticos, ela assume que você quer fazer remoção de duplicidades. Note que nós não especificamos stringdist.match = ou numeric.match = como havíamos feito anteriormente.Agora, você pode revisar duplicidades em potencial com getMatches(). Passe o dataframe tanto como dfA = como dfB =, e passa saída da função fastLink() como fl.=. fl.deve ser da classe fastLink.dedupe, ou em outras palavras, o resultado de fastLink().Veja coluna da extrema direita, que indica os IDs das duplicatas - duas últimas linhas estão identificadas como sendo potenciais duplicatadas das linhas 2 e 3.Para retornar o número de linhas que são potenciais duplicidades, você pode contar o número de linhas por valores únicos na coluna dedupe.ids, e aí filtrar para manter apenas aquelas com mais de uma linha. Nesse caso, isso deixaria linhas 2 e 3.Para investigar totalidade das linhas que poderiam ser duplicidades, coloque o número da linha nesse comando:","code":"\n## Execute fastLink na mesma base de dados\ndedupe_output <- fastLink(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\")\n)## \n## ==================== \n## fastLink(): Fast Probabilistic Record Linkage\n## ==================== \n## \n## If you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\n## dfA and dfB are identical, assuming deduplication of a single data set.\n## Setting return.all to FALSE.\n## \n## Calculating matches for each variable.\n## Getting counts for parameter estimation.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Running the EM algorithm.\n## Getting the indices of estimated matches.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Calculating the posterior for each pair of matched observations.\n## Getting the match patterns for each estimated match.\n## Execute getMatches()\ncases_dedupe <- getMatches(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  fl.out = dedupe_output\n)\ncases_dedupe %>%\n  count(dedupe.ids) %>%\n  filter(n > 1)##   dedupe.ids n\n## 1          2 2\n## 2          3 2\n# mostra a linha 2 e todas as possíveis duplicidades dela\ncases_dedupe[cases_dedupe$dedupe.ids == 2, ]##    gender   first middle  last   yr mon day district dedupe.ids\n## 2       M Anthony     B. Smith 1970   9  19    River          2\n## 10      M    Tony     B. Smith 1970   9  19    River          2"},{"path":"joining-matching.html","id":"anexando-binding-e-alinhando","chapter":"14 Juntando dados (Joins)","heading":"14.4 Anexando (binding) e alinhando","text":"Um outro método de combinar dois dataframes é anexando (“binding”) um ao outro. Você também pode pensar nisso como incluir (“appending”) ou adicionar (“adding”) linhas ou colunas.Essa seção também vai discutir como “alinhar” ordem das linhas de um dataframe à ordem de outro dataframe. Esse tópico é discutido abaixo na seção de Anexar colunas.","code":""},{"path":"joining-matching.html","id":"anexar-linhas-bind-rows","chapter":"14 Juntando dados (Joins)","heading":"Anexar linhas (bind rows)","text":"Para anexar linhas de um dataframe final de outro dataframe, utilize função bind_rows() pacote dplyr. Essa é uma função bastante inclusiva, então, todas colunas presentes em cada dataframe será incluída na saída. Algumas notas:Diferente da versão row.bind() R base, bind_rows() dplyr não exige que ordem das colunas seja mesma em ambos os dataframes. Contanto que os nomes das colunas estejam grafados de forma idêntica, função vai alinhá-las corretamente.Você poder, opcionalmente, especificar o argumento .id =. Passe um nome de coluna para o argumento. Isso vai produzir uma nova coluna que serve para identificar de qual dataframe cada linha veio originalmente.Você pode usar bind_rows() em uma lista de dataframes que tenham estrutura semelhante para combiná-los em um só. Veja um exemplo na página Iteração, loops e listas que envolve importação de múltimplas linelists com purrr.Um exemplo comum de anexação de linhas é anexar uma linha de “total” final de uma tabela descritiva feita utilizando função summarise() dplyr. Abaixo nós criamos uma tabela de contagem de casos e medianas dos valores de CT por hospital com uma linha total.função summarise() é utilizada em dados agrupados por hospital para retornar um dataframe sumárizado por hospital. Porém, função summarise() não gera colunas de “totais” automaticamente, então, nós criamos uma sumarizando os dados novamente, mas com os dados não agrupados por hospital. Isso produz um segundo dataframe de apenas uma linha. Nós podemos anexar (bind) esses dataframes um ao outro para chegar na tabela final.Veja outros exemplos práticos como esse nas páginas Tabelas descritivas e Tabelas para apresentação.Aqui está o dataframe hosp_summary:Cria um dataframe com estatísticas de “total” (sem o agrupamento por hospital). Isso vai retornar apenas uma linha.E abaixo está o dataframe totals. Note como tem apenas duas colunas. Essas colunas também está em hosp_summary, mas tem uma coluna em hosp_summary que não está em totals (hospital).Agora podemos anexar linhas com bind_rows().Agora podemos visualizar o resultado. Veja como na última linha, um valor vazio, NA, preenche coluna hospital que não estava em hosp_summary. Como explicado na página Tabelas para apresentação, você pode preencher essa célula com “Total” utilizando replace_na().","code":"\n# Cria a tabela principal\n###################\nhosp_summary <- linelist %>%\n  group_by(hospital) %>% # Agrupa os dados por hospital\n  summarise( # Cria colunas sumário dos indicadores de interesse\n    cases = n(), # Número de linhas por grupo hospital-desfecho\n    ct_value_med = median(ct_blood, na.rm = T)\n  ) # valores medianos de CT por grupo\n# cria totais\n###############\ntotals <- linelist %>%\n  summarise(\n    cases = n(), # Número de linhas da base de dados inteira\n    ct_value_med = median(ct_blood, na.rm = T)\n  ) # CT Mediano para toda a base de dados\n# Bind data frames together\ncombined <- bind_rows(hosp_summary, totals)"},{"path":"joining-matching.html","id":"anexar-colunas","chapter":"14 Juntando dados (Joins)","heading":"Anexar colunas","text":"Existe uma função similar dplyr, bind_cols() que você pode utilizar para combinar dois dataframes “lateralmente”. Note que linhas são combinadas umas com outras por posição (não como join acima) - por exemplo, 12ª linha de cada dataframe estarão alinhadas.Para demonstrar, vamos anexar várias tabelas de sumário juntas. Para fazer isso, também demonstraremos como rearranjar ordem das linhas de um dataframe para combinar com ordem outro, com match().Aqui nós definimos case_info como um dataframe de sumário dos casos da linelist, por hospital, com o número de casos e o número de mortes.Então, digamos que haja um dataframe diferente, contact_fu (fu -> follow ), contendo informação acerca da porcentagem de contatos expostos que foram investigados e “acompanhados” (follow-), novamente por hospital.Note que os hospitais são os mesmos, mas estão em ordens diferentes em cada dataframe. solução mais fácil seria utilizar left_join() na coluna hospital, mas você poderia também utilizar bind_cols() com um passo extra.","code":"\n# Informação dos casos\ncase_info <- linelist %>%\n  group_by(hospital) %>%\n  summarise(\n    cases = n(),\n    deaths = sum(outcome == \"Death\", na.rm = T)\n  )\ncontact_fu <- data.frame(\n  hospital = c(\"St. Mark's Maternity Hospital (SMMH)\", \"Military Hospital\", \"Missing\", \"Central Hospital\", \"Port Hospital\", \"Other\"),\n  investigated = c(\"80%\", \"82%\", NA, \"78%\", \"64%\", \"55%\"),\n  per_fu = c(\"60%\", \"25%\", NA, \"20%\", \"75%\", \"80%\") # fu -> follow up\n)"},{"path":"joining-matching.html","id":"utilize-match-para-alinhar-a-ordem","chapter":"14 Juntando dados (Joins)","heading":"Utilize match() para alinhar a ordem","text":"Pelo fato da ordem das linhas ser diferente, um simples bind_cols() resultaria em um desalinhamento dos dados. Para consertar isso, podemos utilizar match() base R para alinhar linhas de um dataframe na mesma ordem de outro. Vamos assumir, para essa abordagem, que não há valores duplicados em nenhum dos dataframes.Quando utilizamos match(), sintaxe é match(ORDEM VETOR ALVO, COLUNA PARA MUDAR), onde o primeiro argumento é ordem desejada (seja um vetor individual, ou nesse caso, uma coluna dataframe), e o segundo argumento é uma coluna dataframe que será reordenado. saída match() é um vetor de números representando posição correta ordenamento. Você pode ler mais com ?match.Você pode utilizar esse vetor numérico para reordenar o dataframe - coloque ele entre colchetes [ ] antes da vírgula. Leia mais sobre sintaxe de subconjuntos com colchetes base R na página Introdução ao R. O comando abaixo cria um novo dataframe, definido como o anterior em que linhas estão ordenadas de acordo com o vetor numérico acima.Agora podemos anexar colunas dos dataframes um outro, com ordem de linhas correta. Note que algumas colunas estão duplicadas e vão precisar de uma limpeza utilizando rename(). Leia mais sobre bind_rows() aqui.Uma alternativo R base bind_cols é função cbind(), que faz mesma operação.","code":"\nmatch(case_info$hospital, contact_fu$hospital)## [1] NA  4  2  6  5  1\ncontact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital), ]\nbind_cols(case_info, contact_fu)## New names:\n## • `hospital` -> `hospital...1`\n## • `hospital` -> `hospital...4`## # A tibble: 6 × 6\n##   hospital...1                         cases deaths hospital...4   investigated per_fu\n##   <chr>                                <int>  <int> <chr>          <chr>        <chr> \n## 1 Ausente                               1469    611 St. Mark's Ma… 80%          60%   \n## 2 Central Hospital                       454    193 Military Hosp… 82%          25%   \n## 3 Military Hospital                      896    399 Missing        <NA>         <NA>  \n## 4 Other                                  885    395 Central Hospi… 78%          20%   \n## 5 Port Hospital                         1762    785 Port Hospital  64%          75%   \n## 6 St. Mark's Maternity Hospital (SMMH)   422    199 Other          55%          80%"},{"path":"joining-matching.html","id":"recursos-7","chapter":"14 Juntando dados (Joins)","heading":"14.5 Recursos","text":"página tidyverse sobre joinsA página R Data Science sobre dados relacionaisA página tidyverse dplyr sobre binding (ligação)Uma vignette sobre fastLink na página Github pacotePublicação descrevendo metodologia fastLinkPublicação descrevendo o pacote RecordLinkage","code":""},{"path":"deduplication.html","id":"deduplication","chapter":"15 Eliminação de duplicidades","heading":"15 Eliminação de duplicidades","text":"Esta página abrange seguintes técnicas de eliminação de duplicidades (ou deduplicação):Identificar e remover duplicidades“Fatiar/subdividir” linhas para manter apenas algumas linhas (por exemplo, mín. ou máx.) de cada grupo de linhas“Acumular” ou combinar de valores de várias linhas em uma linha","code":""},{"path":"deduplication.html","id":"preparação-6","chapter":"15 Eliminação de duplicidades","heading":"15.1 Preparação","text":"","code":""},{"path":"deduplication.html","id":"carregar-pacotes-3","chapter":"15 Eliminação de duplicidades","heading":"Carregar pacotes","text":"Este pedaço de código mostra o carregamento de pacotes necessários para análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() R base. Veja página em Introdução ao R para mais informações sobre pacotes R.","code":"\npacman :: p_load(\n  tidyverse, # deduplicação, agrupamento e funções de fatiamento\n  janitor, # função para revisar duplicidades\n  stringr) # para pesquisas de strings, pode ser usado em valores \"rolling-up\""},{"path":"deduplication.html","id":"importar-dados-1","chapter":"15 Eliminação de duplicidades","heading":"Importar dados","text":"Para demonstração, usaremos um conjunto de dados de exemplo criado com o código R abaixo.Os dados são registros de encontros telefônicos COVID-19, incluindo encontros com contatos e casos. colunas incluem recordID (gerado por computador), personID, name, date encontro, time encontro, o propósito encontro (para entrevistar como um caso ou como um contato ), e symptoms_ever (se pessoa nesse encontro relatou sempre ter sintomas).Aqui está o código para criar o conjunto de dados obs:","code":"\nobs <- data.frame(\n  recordID = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),\n  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),\n  name = c(\"adam\", \"adam\", \"amrish\", \"amrish\", \"mariah\", \"amrish\", \"nikhil\", \"brian\", \"smita\", \"raquel\", \"amrish\",\n                \"adam\", \"mariah\", \"mariah\", \"nikhil\", \"brian\", \"brian\", \"raquel\", \"natalie\"),\n  date = c(\"01/01/2020\", \"01/01/2020\", \"01/02/2020\", \"01/02/2020\", \"01/05/2020\", \"01/05/2020 \", \"01/05/2020\", \"01/05/2020\", \"01/05/2020\", \"01/05/2020\", \"01/02/2020\",\n                \"5/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"7/1/2020\", \"7/1/2020\", \"7/1/2020\"),\n  time = c(\"09:00\", \"09:00\", \"14:20\", \"14:20\", \"12:00\", \"16:10\", \"13:01\", \"15:20 \", \"14:20\", \"12:30\", \"10:24\",\n                \"09:40\", \"07:25\", \"08:32\", \"15:36\", \"15:31\", \"07:59\", \"11:13\", \"17:12\"),\n  encounter = c(1,1,1,1,1,3,1,1,1,1,2,\n                2,2,3,2,2,3,2,1),\n  purpose   = c(\"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"contact\",\n                \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"contact\", \"case\"),\n  symptoms_ever = c(NA, NA, \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", NA, \"Yes\",\n                    \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\",\"No\", \"No\")) %>%\n  mutate(date = as.Date(date, format = \"%d/%m/%Y\"))"},{"path":"deduplication.html","id":"dedup_data","chapter":"15 Eliminação de duplicidades","heading":"Aqui está o data frame","text":"Use caixas de filtro na parte superior para revisar os encontros de cada pessoa.Algumas coisas serem observadas ao revisar os dados:Os dois primeiros registros são duplicados 100% completos, incluindo recordID duplicado (deve ser uma falha computador!)duas segundas linhas são duplicidades, em todas colunas exceto para recordIDVárias pessoas tiveram vários encontros por telefone, em várias datas e horários, e como contatos e/ou casosEm cada encontro, pessoa foi perguntada se ela alguma vez teve sintomas, e algumas dessas informações estão faltando.E aqui está um resumo rápido das pessoas e os propósitos de seus encontros, usando tabyl() janitor:","code":"\nobs %>% \n  tabyl(name, purpose)##     name case contact\n##     adam    1       2\n##   amrish    1       3\n##    brian    1       2\n##   mariah    1       2\n##  natalie    1       0\n##   nikhil    0       2\n##   raquel    0       2\n##    smita    0       1"},{"path":"deduplication.html","id":"remoção-de-duplicidades","chapter":"15 Eliminação de duplicidades","heading":"15.2 Remoção de duplicidades","text":"Esta seção descreve como revisar e remover duplicidades em um data frame. Também mostra como lidar com elementos duplicados em um vetor.","code":""},{"path":"deduplication.html","id":"examinar-duplicidades","chapter":"15 Eliminação de duplicidades","heading":"Examinar duplicidades","text":"Para revisar rapidamente linhas que têm duplicidades, você pode usar get_dupes() pacote janitor. Por padrão, todas colunas são consideradas quando duplicidades são avaliadas - linhas retornadas pela função são 100% duplicadas considerando os valores em todas colunas.data frame obs, duas primeiras linhas são 100% duplicadas - elas têm o mesmo valor em todas colunas (incluindo coluna recordID, que supõe ser única - deve ser alguma falha computador ). O data frame retornado inclui automaticamente uma nova coluna dupe_count lado direito, mostrando o número de linhas com essa combinação de valores duplicados.Veja os dados originaisNo entanto, se optarmos por ignorar recordID, linhas da 3ª e 4ª linhas também serão duplicadas umas das outras. Ou seja, eles têm os mesmos valores em todas colunas exceto para recordID. Você pode especificar colunas específicas serem ignoradas na função usando um símbolo de menos -.Você também pode especificar positivamente colunas serem consideradas. Abaixo, apenas linhas que possuem os mesmos valores nas colunas name e purpose são retornadas. Observe como “amrish” agora tem dupe_count igual 3 para refletir seus três encontros de “contato”.Role para esquerda para mais linhasVeja os dados originais.Veja ?get_dupes para mais detalhes, ou veja esta referência online","code":"\n# 100% duplicados em todas as colunas\nobs %>% \n  janitor::get_dupes()\n# Duplica quando a coluna recordID não é considerada\nobs %>% \n  janitor::get_dupes(-recordID) # se várias colunas, envolva-as em c()\n# duplicatas com base nas colunas de nome e propósito SOMENTE\nobs %>% \n  janitor::get_dupes(name, purpose)"},{"path":"deduplication.html","id":"manter-apenas-linhas-únicas","chapter":"15 Eliminação de duplicidades","heading":"Manter apenas linhas únicas","text":"Para manter apenas linhas exclusivas de um data frame, use distinct() de dplyr (conforme demonstrado na página Limpeza de dados e funções principais). duplicidades são removidas de forma que apenas primeira dessas linhas seja mantida. Por padrão, “primeiro” significa o maior número da linha (ordem das linhas de cima para baixo). Apenas linhas exclusivas permanecem.exemplo abaixo, executamos distinct() de forma que coluna recordID seja excluída da consideração - portanto, duas linhas duplicadas são removidas. primeira linha (para “adam”) foi 100% duplicada e foi removida. Além disso, linha 3 (para “amrish”) era uma duplicata em todas colunas exceto recordID (que não está sendo considerada) e, portanto, também foi removida. O conjunto de dados obs n agora é nrow(obs)-2, não nrow(obs) linhas).Role para esquerda para ver todo o data frameCUIDADO: Se estiver usando distinct() em dados agrupados, função será aplicada cada grupo.Remover duplicidades com base em colunas específicasVocê também pode especificar colunas para serem base para eliminação de duplicação. Dessa forma, eliminação de duplicidades se aplica apenas linhas duplicadas nas colunas especificadas. menos que você defina .keep_all = TRUE, todas colunas não mencionadas serão descartadas.exemplo abaixo, eliminação de duplicidades se aplica apenas linhas com valores idênticos para colunas name e purpose. Assim, “brian” tem apenas 2 linhas em vez de 3 - seu primeiro encontro de “contato” e seu único encontro de “caso”. Para ajustar para que o último encontro de brian de cada propósito seja mantido, veja aba Fatiar dentro de grupos.Role para esquerda para ver todo o data frameVeja os dados originais.","code":"\n# adicionado a uma cadeia de pipes (por exemplo, limpeza de dados)\nobs %>% \n  distinct(across(-recordID), # reduz o data frame para apenas linhas únicas (mantém a primeira de todas as duplicidades)\n           .keep_all = TRUE)\n\n# se fora de pipes, inclua os dados como primeiro argumento \n# distinct(obs)\n# adicionado a uma cadeia de pipes (por exemplo, limpeza de dados)\nobs %>% \n  distinct(name, purpose, .keep_all = TRUE) %>% # mantém as linhas únicas por nome e propósito, mantém todas as colunas\n  arrange(name)       # organize para facilitar a visualização"},{"path":"deduplication.html","id":"remover-duplicidades-em-um-vetor","chapter":"15 Eliminação de duplicidades","heading":"Remover duplicidades em um vetor","text":"função duplicated() R base avaliará um vetor (coluna) e retornará um vetor lógico de mesmo comprimento (VERDADEIRO/FALSO). Na primeira vez que um valor aparecer, ele retornará FALSE (não uma duplicata) e, nas próximas vezes em que esse valor aparecer, ele retornará TRUE. Observe como NA é tratado da mesma forma que qualquer outro valor.Para retornar apenas os elementos duplicados, você pode usar colchetes para subconjunto vetor original:Para retornar apenas os elementos exclusivos, use função unique() R base. Para remover NAs da saída, aninhe na.omit() dentro de unique().","code":"\nx <- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)##  [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nx[duplicated(x)]## [1]  1 NA  4  4  1  2\nunique(x) # alternativamente, use x[!duplicated(x)]## [1]  1  2 NA  4  5\nunique(na.omit(x)) # remove NAs ## [1] 1 2 4 5"},{"path":"deduplication.html","id":"usando-o-r-base-1","chapter":"15 Eliminação de duplicidades","heading":"Usando o R base","text":"Para retornar linhas duplicadasNo R base, você também pode ver quais linhas são 100% duplicadas em um data frame df com o comando duplicated(df) (retorna um vetor lógico das linhas).Assim, você também pode usar o subconjunto base [ ] data frame para ver linhas duplicadas com df[duplicated(df),] (não esqueça vírgula, significando que você quer ver todas colunas!).Para retornar linhas exclusivasVeja notas acima. Para ver linhas únicas, você adiciona o negador lógico ! na frente da função duplicated():df[!duplicado(df),]Para retornar linhas que são duplicidades em determinadas colunasSubsete o df que está dentro dos parênteses duplicated(), então esta função irá operar apenas em certas colunas df.Para especificar colunas, forneça os números ou nomes das colunas após uma vírgula (lembre-se, tudo isso está dentro da função duplicated()).Certifique-se de manter vírgula , fora após função duplicated() também!Por exemplo, para avaliar apenas colunas de 2 5 para duplicatas: df[!duplicated(df[, 2:5]),]\nPara avaliar apenas colunas name e purpose para duplicatas: df[!duplicated(df[, c(\"name\", \"purpose)]),]","code":""},{"path":"deduplication.html","id":"fatiarsubdividir","chapter":"15 Eliminação de duplicidades","heading":"15.3 Fatiar/Subdividir","text":"Subdividir um data frame, ou “fatiá-lo” (literalmente inglês slice), significa aplicar um filtro nas linhas por número/posição de linha. Isso se torna particularmente útil se você tiver várias linhas por grupo funcional (por exemplo, por “pessoa”) e quiser manter apenas uma ou algumas delas.função básica slice() aceita números e retorna linhas nessas posições. Se os números fornecidos forem positivos, somente eles serão retornados. Se negativo, essas linhas não são retornadas. Os números devem ser todos positivos ou todos negativos.Veja os dados originais.Existem várias variações: Estes devem ser fornecidos com uma coluna e um número de linhas para retornar (para n =).slice_min() e slice_max() mantêm apenas (s) linha(s) com o(s) valor(es) mínimo(s) ou máximo(s) da coluna especificada. Isso também funciona para retornar o “min” e o “max” dos fatores ordenados.slice_head() e slice_tail() - mantém apenas primeira ou última linha(s).slice_sample() - mantém apenas uma amostra aleatória das linhas.Use argumentos n = ou prop = para especificar o número ou proporção de linhas serem mantidas. Se não estiver usando função em uma cadeia de pipes, forneça primeiro o argumento de dados (por exemplo, slice(data, n = 2)). Veja ?slice para mais informações.Outros argumentos:.order_by = usado em slice_min() e slice_max() esta é uma coluna para ordenar antes de fatiar.with_ties = TRUE por padrão, significando que os empates são mantidos..preserve = FALSE por padrão. Se TRUE, estrutura de agrupamento é recalculada após o fatiamento.weight_by = Opcional, coluna numérica para ponderar (número maior com maior probabilidade de ser amostrado). Também replace = para se amostragem é feita com/sem substituição.DICA: Ao usar slice_max() e slice_min(), certifique-se de especificar/escrever o n = (por exemplo, n = 2 , não apenas 2). Caso contrário, você pode receber um erro Erro:…não está vazio. NOTE: Você pode encontrar função top_n(), que tem foi substituído pelas funções slice.","code":"\nobs %>% slice(4) # retorna a 4ª linha##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        3        2 amrish 2020-02-01 14:20         1 contact            No\nobs %>% slice(c(2,4)) # retorna as linhas 2 e 4##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        1        1   adam 2020-01-01 09:00         1 contact          <NA>\n## 2        3        2 amrish 2020-02-01 14:20         1 contact            No\n#obs %>% slice(c(2:4)) # retorna as linhas 2 a 4\nobs %>% slice_max(encounter, n = 1) # retorna linhas com o maior número de encontro##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        5        2 amrish 2020-05-01 16:10         3    case           Yes\n## 2       13        3 mariah 2020-01-06 08:32         3 contact            No\n## 3       16        5  brian 2020-01-07 07:59         3    case            No"},{"path":"deduplication.html","id":"subdividão-com-grupos","chapter":"15 Eliminação de duplicidades","heading":"Subdividão com grupos","text":"funções slice_*() podem ser muito úteis se aplicadas um data frame agrupado porque operação de fatia é executada em cada grupo separadamente. Use função group_by() em conjunto com slice() para agrupar os dados para obter uma fatia de cada grupo.Isso é útil para eliminação de duplicação se você tiver várias linhas por pessoa, mas quiser manter apenas uma delas. Você primeiro usa group_by() com colunas-chave que são mesmas por pessoa e, em seguida, usa uma função de fatia em uma coluna que será diferente entre linhas agrupadas.exemplo abaixo, para manter apenas o último encontro por pessoa, agrupamos linhas por name e então usamos slice_max() com n = 1 na coluna date. Estar ciente! Para aplicar uma função como slice_max() em datas, coluna de data deve ser da classe Date.Por padrão, “empates” (por exemplo, mesma data neste cenário) são mantidos e ainda obteríamos várias linhas para algumas pessoas (por exemplo, adam). Para evitar isso, configuramos with_ties = FALSE. Retornamos apenas uma fila por pessoa.CAUTION: Se estiver usando arrange(), especifique .by_group = TRUE para organizar os dados em cada grupo.DANGER: Se with_ties = FALSE, primeira linha de um empate é mantida. Isso pode ser enganoso. Veja como para Mariah, ela tem dois encontros em sua última data (6 de janeiro) e o primeiro (mais antigo) foi mantido. Provavelmente, queremos manter seu encontro posterior naquele dia. Veja como “quebrar” esses empates próximo exemplo. Acima, por exemplo, podemos ver que apenas linha de Amrish em 5 de janeiro foi mantida, e apenas linha de Brian em 7 de janeiro foi mantida. Veja os dados originais.“Desempates”Várias instruções de fatia podem ser executadas para “desempate”. Neste caso, se uma pessoa tiver vários encontros em sua última data, o encontro com última hora é mantido (lubridate::hm() é usado para converter os tempos dos caracteres em uma classe de tempo classificável).\nObserve como agora, única linha mantida para “Mariah” em 6 de janeiro é o encontro 3 das 08:32, não o encontro 2 às 07:25.exemplo acima, também seria possível dividir por número de encounter, mas mostramos fatia em data e hora para fins de exemplo.DICA: Para usar slice_max() ou slice_min() em uma coluna “character”, altere-para uma classe de fator ordenada! extensão>Veja os dados originais.","code":"\nobs %>% \n  group_by(name) %>% # agrupa as linhas por 'name'\n  slice_max(date, # mantém linha por grupo com valor máximo de data \n            n = 1, # mantém apenas a linha mais alta\n            with_ties = F) # se houver empate (de data), pegue a primeira linha\n# Exemplo de várias instruções de fatia para \"desempate\"\nobs %>%\n  group_by(name) %>%\n  \n  # PRIMEIRO - fatia por data mais recente\n  slice_max(date, n = 1, with_ties = TRUE) %>% \n  \n  # SEGUNDO - se houver empate, selecione a linha com o horário mais recente; empates proibidos\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)"},{"path":"deduplication.html","id":"mantenha-tudo-mas-marque-os","chapter":"15 Eliminação de duplicidades","heading":"Mantenha tudo mas marque-os","text":"Se você quiser manter todos os registros, mas marcar apenas alguns para análise, considere uma abordagem de duas etapas utilizando um recordID/número de encontro exclusivo:Reduza/faça o recorte data frame original apenas nas linhas para análise. Salve/retenha este data frame reduzido.data frame original, marque linhas conforme apropriado com case_when(), com base fato de seu identificador exclusivo de registro (recordID neste exemplo) estar presente data frame reduzido.Veja os dados originais.","code":"\n# 1. Defina o data frame de linhas para manter para análise\nobs_keep <- obs %>%\n  group_by(name) %>%\n  slice_max(encounter, n = 1, with_ties = FALSE) # mantém apenas o último encontro por pessoa\n\n\n# 2. Marcar data frame original\nobs_marked <- obs %>%\n\n  # cria uma nova coluna dup_record\n  mutate(dup_record = case_when(\n    \n    # se o registro estiver no data frame obs_keep\n    recordID %in% obs_keep$recordID ~ \"Para análise\", \n    \n    # tudo o mais marcado como \"Ignorar\" para fins de análise\n    TRUE ~ \"Ignorar\"))\n\n# imprimir\nobs_marked##    recordID personID    name       date   time encounter purpose symptoms_ever\n## 1         1        1    adam 2020-01-01  09:00         1 contact          <NA>\n## 2         1        1    adam 2020-01-01  09:00         1 contact          <NA>\n## 3         2        2  amrish 2020-02-01  14:20         1 contact            No\n## 4         3        2  amrish 2020-02-01  14:20         1 contact            No\n## 5         4        3  mariah 2020-05-01  12:00         1    case            No\n## 6         5        2  amrish 2020-05-01  16:10         3    case           Yes\n## 7         6        4  nikhil 2020-05-01  13:01         1 contact           Yes\n## 8         7        5   brian 2020-05-01 15:20          1 contact            No\n## 9         8        6   smita 2020-05-01  14:20         1 contact           Yes\n## 10        9        7  raquel 2020-05-01  12:30         1 contact          <NA>\n## 11       10        2  amrish 2020-02-01  10:24         2 contact           Yes\n## 12       11        1    adam 2020-01-05  09:40         2    case            No\n## 13       12        3  mariah 2020-01-06  07:25         2 contact            No\n## 14       13        3  mariah 2020-01-06  08:32         3 contact            No\n## 15       14        4  nikhil 2020-01-06  15:36         2 contact           Yes\n## 16       15        5   brian 2020-01-06  15:31         2 contact           Yes\n## 17       16        5   brian 2020-01-07  07:59         3    case            No\n## 18       17        7  raquel 2020-01-07  11:13         2 contact            No\n## 19       18        8 natalie 2020-01-07  17:12         1    case            No\n##      dup_record\n## 1       Ignorar\n## 2       Ignorar\n## 3       Ignorar\n## 4       Ignorar\n## 5       Ignorar\n## 6  Para análise\n## 7       Ignorar\n## 8       Ignorar\n## 9  Para análise\n## 10      Ignorar\n## 11      Ignorar\n## 12 Para análise\n## 13      Ignorar\n## 14 Para análise\n## 15 Para análise\n## 16      Ignorar\n## 17 Para análise\n## 18 Para análise\n## 19 Para análise"},{"path":"deduplication.html","id":"calcular-a-completitude-da-linha","chapter":"15 Eliminação de duplicidades","heading":"Calcular a completitude da linha","text":"Crie uma coluna que contenha uma métrica para completitude da linha (não falta). Isso pode ser útil ao decidir quais linhas priorizar em relação outras ao remover duplicidade/fatiar.Neste exemplo, colunas “chave” sobre quais você deseja medir integridade são salvas em um vetor de nomes de coluna.Então nova coluna key_completeness é criada com mutate(). O novo valor em cada linha é definido como uma fração calculada: o número de valores não omissos nessa linha entre colunas-chave, dividido pelo número de colunas-chave.Isso envolve função rowSums() R base. Também é usado ., que dentro encadeamento código (pipe - %>%) se refere ao data frame naquele ponto pipe (neste caso, está sendo subconjunto com colchetes []).*Role para direita para ver mais linhas**Veja os dados originais.","code":"\n# cria uma coluna \"completude da variável chave\"\n# esta é uma *proporção* das colunas designadas como \"key_cols\" que não possuem valores omissos\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %>% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) "},{"path":"deduplication.html","id":"str_rollup","chapter":"15 Eliminação de duplicidades","heading":"15.4 Valores acumulados","text":"Esta seção descreve:Como “agregar” valores de várias linhas em apenas uma linha, com algumas variaçõesDepois de ter os valores “acumulados”, como substituir/priorizar os valores em cada célulaEsta guia usa o conjunto de dados de exemplo da guia Preparação.","code":""},{"path":"deduplication.html","id":"valores-acumulados-em-uma-linha","chapter":"15 Eliminação de duplicidades","heading":"Valores acumulados em uma linha","text":"O exemplo de código abaixo usa group_by() e summarise() para agrupar linhas por pessoa e depois colar todos os valores exclusivos nas linhas agrupadas. Assim, você obtém uma linha de resumo por pessoa. Algumas notas:Um sufixo é anexado todas novas colunas (“_roll” neste exemplo)Se você quiser mostrar apenas valores exclusivos por célula, envolva o na.omit() com unique()na.omit() remove valores NA, mas se isso não desejado, pode ser removido paste0(.x)…O resultado é uma linha por grupo (ID), com entradas organizadas por data e coladas juntas. Role para esquerda para ver mais linhasVeja os dados originais.Esta variação mostra apenas valores únicos:Esta variação anexa um sufixo cada coluna.\nNeste caso “_roll” para significar que foi agregado:","code":"# Valores \"roll-up\" em uma linha por grupo (por \"personID\") \ncases_rolled <- obs %>% \n  \n  #cria grupos por nome\n  group_by(personID) %>% \n  \n  # ordena as linhas dentro de cada grupo (por exemplo, por data)\n  arrange(date, .by_group = TRUE) %>% \n  \n  # Para cada coluna, cole todos os valores dentro das linhas agrupadas, separados por \";\"\n  summarise(\n    across(everything(), # aplica-se a todas as colunas\n           ~paste0(na.omit(.x), collapse = \"; \")))) # função é definida que combina valores não-NA\n# Variação - mostra apenas valores únicos \ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(), # aplica-se a todas as colunas\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # função é definida que combina valores únicos não-NA\n# Variação - sufixo adicionado aos nomes das colunas \ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll é anexado aos nomes das colunas"},{"path":"deduplication.html","id":"substituir-valoreshierarquia","chapter":"15 Eliminação de duplicidades","heading":"Substituir valores/hierarquia","text":"Se você quiser avaliar todos os valores rolados e manter apenas um valor específico (por exemplo, valor “melhor” ou “máximo”), você pode usar mutate() nas colunas desejadas, para implementar case_when() , que usa str_detect() pacote stringr para procurar sequencialmente padrões de string e sobrescrever o conteúdo da célula.Agora você pode ver na coluna symptoms_ever que se pessoa ALGUMA VEZ disse “Sim” aos sintomas, então apenas “Sim” é exibido.Veja os dados originais.","code":"\n# CASOS LIMPOS\n#############\ncases_clean <- cases_rolled %>% \n# limpar vars Yes-No-Unknown: substitui o texto pelo valor \"mais alto\" presente na string\nmutate(across(c(contains(\"symptoms_ever\")), # opera em colunas especificadas (S/N/U)\n       list(mod = ~case_when( # adiciona o sufixo \"_mod\" a new cols; implementa case_when()\n               \n       str_detect(.x, \"Sim\") ~ \"Sim\", # se \"Sim\" for detectado, o valor da célula será convertido em sim\n       str_detect(.x, \"No\") ~ \"No\", # então, se \"No\" for detectado, o valor da célula será convertido em não\n       str_detect(.x, \"Desconhecido\") ~ \"Desconhecido\", # então, se \"Desconhecido\" for detectado, o valor da célula será convertido em Desconhecido\n               TRUE ~ as.character(.x)))), # então, se mais alguma coisa se mantiver como está\n      .keep = \"unused\") # colunas antigas removidas, deixando apenas colunas _mod"},{"path":"deduplication.html","id":"remoção-de-duplicidades-probabilística-1","chapter":"15 Eliminação de duplicidades","heading":"15.5 Remoção de duplicidades probabilística","text":"Às vezes, você pode querer identificar duplicidades “prováveis” com base na semelhança (por exemplo, string “distance”) em várias colunas, como nome, idade, sexo, data de nascimento etc. Você pode aplicar um algoritmo de correspondência probabilística para identificar duplicidades prováveis.Consulte página em Juntar dados para obter uma explicação sobre este método. seção sobre Correspondência Probabilística contém um exemplo de aplicação desses algoritmos para comparar um data frame com o próprio, realizando assim desduplicação probabilística.","code":""},{"path":"deduplication.html","id":"recursos-8","chapter":"15 Eliminação de duplicidades","heading":"15.6 Recursos","text":"Muitas das informações nesta página são adaptadas destes recursos e vinhetas online:datanoviadplyr tidyverse referencevinheta de janitor de cran","code":""},{"path":"iteration.html","id":"iteration","chapter":"16 Iterações, loops e listas","heading":"16 Iterações, loops e listas","text":"Os epidemiologistas muitas vezes se deparam com análises repetidas em subgrupos, como países, distritos ou faixas etárias. Estas são apenas algumas das muitas situações envolvendo iteração. Codificar suas operações iterativamente usando abordagens abaixo ajudará você executar essas tarefas repetitivas mais rapidamente, reduzir chance de erro e reduzir o comprimento código.Esta página apresentará duas abordagens para operações iterativas - usando os loops e usando o pacote purrr.loops iteram código partir de uma série de entradas, mas são menos comuns em R que em outras linguagens de programação. entanto, nós os apresentamos aqui como uma ferramenta de aprendizagem e referênciaO pacote purrr é abordagem tidyverse para operações iterativas - ele funciona “mapeando” uma função em muitas entradas (valores, colunas, conjuntos de dados etc.)Ao longo caminho, mostraremos exemplos como:Importando e exportando vários arquivosCriando curvas epidemiológicas para várias jurisdiçõesExecutando testes T para várias colunas em um data frameNa seção purrr também forneceremos vários exemplos de criação e manipulação de listas.","code":""},{"path":"iteration.html","id":"preparação-7","chapter":"16 Iterações, loops e listas","heading":"16.1 Preparação","text":"","code":""},{"path":"iteration.html","id":"carregando-pacotes","chapter":"16 Iterações, loops e listas","heading":"Carregando pacotes","text":"Este trecho de código mostra o carregamento de pacotes necessários para análises. Neste livro nós enfatizamos o p_load() pacman, que instala o pacote, se necessário, e o carrega para uso. Você também pode carregar pacotes instalados com o library() R base. Veja página sobre o [R - o básico] para mais informações sobre pacotes R.","code":"\npacman::p_load(\n     rio,         # importa/exporta\n     here,        # localizador de arquivos\n     purrr,       # iteração\n     grates,      # scales in ggplot\n     tidyverse    # gerenciamento e visualização de dados\n)"},{"path":"iteration.html","id":"importando-dados","chapter":"16 Iterações, loops e listas","heading":"Importando dados","text":"Importamos o conjunto de dados de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar clique aqui para fazer download da linelist “limpa” (como um arquivo .rds). Importamos os dados com função import() pacote rio (ela lida com muitos tipos de arquivos como .xlsx, .csv, .rds - veja página Importar e exportar para detalhes).primeiras 50 linhas da linelist são exibidas abaixo.","code":"\n# importando a linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"iteration.html","id":"loops-for","chapter":"16 Iterações, loops e listas","heading":"16.2 loops for","text":"","code":""},{"path":"iteration.html","id":"iter_loops","chapter":"16 Iterações, loops e listas","heading":"loops for no R","text":"loops não são enfatizados em R, mas são comuns em outras linguagens de programação. Para iniciantes, eles podem ser úteis para aprender e praticar porque são mais fáceis de “explorar”, “depurar” e entender exatamente o que está acontecendo para cada iteração, especialmente quando você ainda não está confortável em escrever suas próprias funções .Você pode passar rapidamente loop para iterar com funções mapeadas com o purrr (consulte seção abaixo)","code":""},{"path":"iteration.html","id":"principais-componentes","chapter":"16 Iterações, loops e listas","heading":"Principais componentes","text":"Um loop tem três partes principais:sequência de itens para percorrerAs operações serem conduzidas por item na sequênciaO contêiner para armazenar os resultados (opcional)sintaxe básica é: (item em sequência) {fazer operações usando item}. Observe os parênteses e os colchetes. Os resultados podem ser impressos console ou armazenados em um objeto R (o container).Um exemplo simples de loop está abaixo.","code":"\nfor (num in c(1,2,3,4,5)) {  # a SEQUÊNCIA é definida (números 1 a 5) e o loop é aberto com \"{\"\n  print(num + 2)             # As OPERAÇÕES (adicione dois a cada número de sequência e imprima)\n}                            # O loop é fechado com \"}\"                           ## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7"},{"path":"iteration.html","id":"sequência","chapter":"16 Iterações, loops e listas","heading":"Sequência","text":"Esta é parte “” de um loop - operações serão executadas “para” cada item na sequência. sequência pode ser uma série de valores (por exemplo, nomes de jurisdições, doenças, nomes de colunas, elementos de lista, etc.), ou pode ser uma série de números consecutivos (por exemplo, 1,2,3,4,5). Cada abordagem tem suas próprias utilidades, descritas abaixo.estrutura básica de uma instrução de sequência é item em vetor.Você pode escrever qualquer caractere ou palavra lugar de “item” (por exemplo, “”, “num”, “hosp”, “distrito”, etc.). O valor desse “item” muda cada iteração loop, passando por cada valor vetor.O vetor pode ser de valores tipo caracteres, nomes de colunas ou talvez uma sequência de números - esses são os valores que mudarão cada iteração. Você pode usá-los nas operações loop usando o termo “item”.Exemplo: sequência de valores de caracteresNeste exemplo, um loop é executado para cada valor em um vetor de caracteres predefinido de nomes de hospitais.Escolhemos o termo hosp para representar valores vetor hospital_names. Para primeira iteração loop, o valor de hosp será hospital_names[[1]]. Para o segundo loop será hospital_names[[2]]. E assim por diante…Exemplo: sequência de nomes de colunasEsta é uma variação da sequência de caracteres acima, na qual os nomes de um objeto R existente são extraídos e se tornam o vetor. Por exemplo, os nomes das colunas de um data frame. Convenientemente, código de operações loop , os nomes das colunas podem ser usados para indexar (subconjunto) seu data frame original.Abaixo, sequência é o names() (nomes das colunas) data frame linelist. Nosso nome de “item” é col, que representará o nome de cada coluna à medida que os loops prosseguem.Para fins de exemplo, incluímos o código de operações dentro loop , que é executado para cada valor na sequência. Neste código, os valores de sequência (nomes das colunas) são usados para indexar (subconjunto) linelist, um de cada vez. Conforme ensinado na página Introdução ao R, colchetes duplos [[ ]] são usados para subconjunto. coluna resultante é passada para .na(), então para sum() para produzir o número de valores na coluna que estão faltando. O resultado é impresso console - um número para cada coluna.Sequência de númerosNesta abordagem, sequência é uma série de números consecutivos. Assim, o valor “item” não é um valor de caractere (por exemplo, “Hospital Central” ou “data_onset”), mas é um número. Isso é útil para fazer loop pelos data frames, pois você pode usar o número “item” dentro loop para indexar o data frame pelo número da linha.Por exemplo, digamos que você queira percorrer cada linha em seu data frame e extrair determinadas informações. Seus “itens” seriam números de linha numéricos. Frequentemente, “itens” neste caso são escritos como .O processo loop pode ser explicado em palavras como “para cada item em uma sequência de números de 1 ao número total de linhas meu data frame, faça X”. Para primeira iteração loop, o valor de “item” seria 1. Para segunda iteração, seria 2, etc.Aqui está aparência da sequência código: (1:nrow(linelist)) {OPERATIONS CODE} onde representa o “item” e 1:nrow(linelist) produz uma sequência de números de 1 até o número de linhas em linelist.Se você deseja que sequência seja de números, mas está começando de um vetor (não de um data frame), use o atalho seq_along() para retornar uma sequência de números para cada elemento vetor. Por exemplo, (seq_along(hospital_names) {OPERATIONS CODE}.O código abaixo na verdade retorna números, que se tornariam o valor de em seu respectivo loop.Uma vantagem de usar números na sequência é que é fácil também usar o número para indexar um contêiner que armazena saídas loop. Há um exemplo disso na seção Operações abaixo.","code":"\n# criando um vetor com os nomes dos hospitais\nhospital_names <- unique(linelist$hospital)\nhospital_names # printe (mostre o nome do hospital)## [1] \"Other\"                                \"Ausente\"                             \n## [3] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [5] \"Military Hospital\"                    \"Central Hospital\"\n# um 'loop for' com sequência de caracteres\n\nfor (hosp in hospital_names){       # sequência\n  \n       # OPERAÇÕES AQUI\n  }\nfor (col in names(linelist)){        # o loop é executado para cada coluna na linelist; nome da coluna representado por \"col\" \n  \n  # Exemplo de código de operações - printe o número de valores ausentes na coluna\n  print(sum(is.na(linelist[[col]])))  # linelist é indexado pelo valor atual de \"col\"\n     \n}## [1] 0\n## [1] 0\n## [1] 2087\n## [1] 256\n## [1] 0\n## [1] 936\n## [1] 1323\n## [1] 278\n## [1] 86\n## [1] 0\n## [1] 86\n## [1] 86\n## [1] 86\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 2088\n## [1] 2088\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 149\n## [1] 765\n## [1] 0\n## [1] 256\nfor (i in 1:nrow(linelist)) {  # use em um data frame\n  # OPERAÇÕES AQUI\n}  \nseq_along(hospital_names)  # use em um vetor de nomes## [1] 1 2 3 4 5 6"},{"path":"iteration.html","id":"operações","chapter":"16 Iterações, loops e listas","heading":"Operações","text":"Este é o código dentro das chaves { } loop . Você deseja que esse código seja executado para cada “item” na sequência. Portanto, tome cuidado para que cada parte seu código que muda pelo “item” seja codificada corretamente de forma que realmente mude! Por exemplo, lembre-se de usar [[ ]] para indexação.exemplo abaixo, iteramos em cada linha na linelist. Os valores gender e age de cada linha são colados e armazenados vetor de caracteres contêiner cases_demographics. Observe como também usamos indexação [[]] para salvar saída loop na posição correta vetor “contêiner”.","code":"\n# criando contêiner para armazenar resultados - um vetor de caractere\ncases_demographics <- vector(mode = \"character\", length = nrow(linelist))\n\n# o loop for\nfor (i in 1:nrow(linelist)){\n  \n  # OPERAÇÕES\n  # extraindo valores da linelist para a linha i, usando colchetes para indexação\n  row_gender  <- linelist$gender[[i]]\n  row_age     <- linelist$age_years[[i]]    # não se esqueça de indexar!\n     \n  # combinando gender-age e armazenar no vetor de contêiner no local indexado\n  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = \",\") \n\n}  # finalizando o loop for\n\n\n# exibindo as primeiras 10 linhas do contêiner\nhead(cases_demographics, 10)##  [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\""},{"path":"iteration.html","id":"contêiner","chapter":"16 Iterações, loops e listas","heading":"Contêiner","text":"Às vezes, os resultados seu loop serão impressos console ou painel RStudio Plots. Outras vezes, você desejará armazenar saídas em um “contêiner” para uso posterior. Esse contêiner pode ser um vetor, um data frame ou até mesmo uma lista.É mais eficiente criar o contêiner para os resultados antes mesmo de iniciar o loop. Na prática, isso significa criar um vetor, data frame ou lista vazio. Estes podem ser criados com funções vector() para vetores ou listas, ou com matrix() e data.frame() para um data frame.Vetor vazioUse vector() e especifique o mode = com base na classe esperada dos objetos que você irá inserir - seja “double” (para armazenar números), “character” ou “logical”. Você também deve definir o length = com antecedência. Este deve ser o comprimento da sua sequência loop .Digamos que você queira armazenar o atraso médio até admissão de cada hospital. Você usaria “double” e definiria o comprimento como o número de saídas esperadas (o número de hospitais exclusivos conjunto de dados).Data frame vazioVocê pode criar um data frame vazio especificando o número de linhas e colunas assim:Lista vaziaVocê pode querer armazenar alguns gráficos criados por um loop em uma lista. Uma lista é como um vetor, mas contém outros objetos R dentro dela que podem ser de diferentes classes. Os itens em uma lista podem ser um único número, um data frame, um vetor e até outra lista.Você realmente inicializa uma lista vazia usando o mesmo comando vector() acima, mas com mode = \"list\". Especifique o comprimento como desejar.","code":"\ndelays <- vector(\n  mode = \"double\",                            # esperamos armazenar números\n  length = length(unique(linelist$hospital))) # o número de hospitais únicos no conjunto de dados\ndelays <- data.frame(matrix(ncol = 2, nrow = 3))\nplots <- vector(mode = \"list\", length = 16)"},{"path":"iteration.html","id":"imprimindo","chapter":"16 Iterações, loops e listas","heading":"Imprimindo","text":"Observe que para “printar” (mostrar) de dentro de um loop você provavelmente precisará envolver explicitamente função print().Neste exemplo abaixo, sequência é um vetor de caracteres explícito, que é usado para acessar o subconjunto da linelist por hospital. Os resultados não são armazenados em um contêiner, mas são impressos console com função print().","code":"\nfor (hosp in hospital_names){ \n     hospital_cases <- linelist %>% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}## [1] 885\n## [1] 1469\n## [1] 422\n## [1] 1762\n## [1] 896\n## [1] 454"},{"path":"iteration.html","id":"testando-o-seu-loop","chapter":"16 Iterações, loops e listas","heading":"Testando o seu loop","text":"Para testar seu loop, você pode executar um comando para fazer uma atribuição temporária “item”, como <- 10 ou hosp <- \"Central Hospital\". Faça isso fora loop e execute apenas seu código de operações (o código entre colchetes) para ver se os resultados esperados são produzidos.","code":""},{"path":"iteration.html","id":"gráficos-em-loop","chapter":"16 Iterações, loops e listas","heading":"Gráficos em loop","text":"Para juntar todos os três componentes (contêiner, sequência e operações), vamos tentar traçar uma epicurva para cada hospital (consulte página em Curvas epidêmicas).Podemos fazer uma bela epicurva de todos os casos por gênero usando o pacote incidence2 conforme abaixo:Para produzir um gráfico separado para os casos de cada hospital, podemos colocar esse código da epicurva dentro de um loop .Primeiro, salvamos um vetor com os nomes exclusivos hospital, hospital_names. O loop será executado uma vez para cada um destes nomes: (hosp hospital_names). cada iteração loop , o nome hospital atual vetor será representado como hosp para uso dentro loop.Dentro das operações de loop, você pode escrever o código R normalmente, mas use o “item” (hosp neste caso) sabendo que seu valor será alterado. Dentro deste loop:Um filter() é aplicado linelist, de modo que coluna hospital deve ser igual ao valor atual de hospO objeto tipo incidence é criado na linelist filtradaO gráfico para o hospital atual é criado, com um título de ajuste automático que usa hospO gráfico hospital atual é salvo temporariamente e depois impressoO loop então avança para repetir com o próximo hospital em hospital_names","code":"\n# criando o objeto do tipo 'incidence'\noutbreak <- incidence2::incidence(   \n     x = linelist,                   # data frame - linelist completo\n     date_index = \"date_onset\",        # coluna de data\n     interval = \"week\",              # contagens agregadas semanalmente\n     groups = \"gender\")                # valores de grupo por gênero\n     #na_as_group = TRUE)             # o sexo ausente é um grupo próprio\n\n# plotando a epicurva\nggplot(outbreak, # nom de l'objet d'incidence\n        aes(x = date_index, #aesthetiques et axes\n            y = count, \n            fill = gender), # Fill colour of bars by gender\n       color = \"black\"      # Contour colour of bars\n       ) +  \n     geom_col() + \n     facet_wrap(~gender) +\n     theme_bw() + \n     labs(title = \"Outbreak of all cases\", #titre\n          x = \"Counts\", \n          y = \"Date\", \n          fill = \"Gender\", \n          color = \"Gender\")\n# criando o vetor dos nomes dos hospitais\nhospital_names <- unique(linelist$hospital)\n\n# para cada nome (\"hosp\") em hospital_names, crie e imprima a epicurva\nfor (hosp in hospital_names) {\n     \n     # criando objeto de incidência específico para o hospital atual\n     outbreak_hosp <- incidence2::incidence(\n          x = linelist %>% filter(hospital == hosp),   # linelist é filtrada para o hospital atual\n          date_index = \"date_onset\",\n          interval = \"week\", \n          groups = \"gender\"#,\n          #na_as_group = TRUE\n     )\n     \n     # Criando e salvando o gráfico. O título se ajusta automaticamente ao hospital atual\n      plot_hosp <- ggplot(outbreak_hosp, # incidence object name\n                         aes(x = date_index, #axes\n                             y = count, \n                             fill = gender), # fill colour by gender\n                         color = \"black\"      # colour of bar contour\n                         ) +  \n          geom_col() + \n          facet_wrap(~gender) +\n          theme_bw() + \n          labs(title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\"), #title\n               x = \"Counts\", \n               y = \"Date\", \n               fill = \"Gender\", \n               color = \"Gender\")\n     \n     # With older versions of R, remove the # before na_as_group and use this plot command instead.\n    # plot_hosp <- plot(\n#       outbreak_hosp,\n#       fill = \"gender\",\n#       color = \"black\",\n#       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n#     )\n     \n     # exibindo o gráfico para o hospital atual\n     print(plot_hosp)\n     \n} # encerrando o loop for quando ele tiver sido executado para todos os hospitais em hospital_names"},{"path":"iteration.html","id":"acompanhando-o-progresso-de-um-loop","chapter":"16 Iterações, loops e listas","heading":"Acompanhando o progresso de um loop","text":"Um loop com muitas iterações pode ser executado por muitos minutos ou até horas. Assim, pode ser útil imprimir o progresso console R. instrução (que significa “se” em inglês) abaixo pode ser colocada dentro das operações de loop para exibir cada 100 números. Basta ajustá-lo para que seja o “item” em seu loop.","code":"# loop com código para exibir o progresso a cada 100 iterações\nfor (i in seq_len(nrow(linelist))){\n\n  # print progress\n  if(i %% 100==0){    # O operador %% calcula o resto da operação\n    print(i)\n\n}"},{"path":"iteration.html","id":"iter_purrr","chapter":"16 Iterações, loops e listas","heading":"16.3 purrr e listas","text":"Outra abordagem para operações iterativas é o pacote purrr - essa é abordagem tidyverse para iteração.Se você tiver que executar mesma tarefa várias vezes, provavelmente vale pena criar uma solução generalizada que possa ser usada com várias entradas. Por exemplo, produzindo gráficos para várias jurisdições ou importando e combinando muitos arquivos.Há também algumas outras vantagens para usar o purrr - você pode usá-lo com pipes %>%, ele lida com erros melhor que o normal loop , e sintaxe é bastante limpa e simples! Se você estiver usando um loop , provavelmente poderá fazê-lo de forma mais clara e sucinta com purrr!Tenha em mente que o purrr é uma ferramenta de programação funcional. Ou seja, operações que devem ser aplicadas iterativamente são agrupadas em funções. Consulte página Escrevendo funções para aprender escrever suas próprias funções.O purrr também é quase inteiramente baseado em listas e vetores - então pense nisso como aplicar uma função cada elemento dessa lista/vetor!","code":""},{"path":"iteration.html","id":"carregando-pacotes-1","chapter":"16 Iterações, loops e listas","heading":"Carregando pacotes","text":"O purrr faz parte tidyverse, portanto, não há necessidade de instalar/carregar um pacote separado.","code":"\npacman::p_load(\n     rio,            # importa/exporta\n     here,           # caminhos de arquivos relativos\n     tidyverse,      # gerenciamento de dados e visualização\n     writexl,        # escreve arquivos Excel com várias abas\n     readxl          # importa arquivos Excel com várias abas\n)"},{"path":"iteration.html","id":"map","chapter":"16 Iterações, loops e listas","heading":"map()","text":"função principal purrr é map(), que “mapeia” (aplica) uma função para cada elemento de entrada de uma lista/vetor que você fornece.sintaxe básica é map(.x = SEQUENCE, .f = FUNCTION, ARGUMENTS). Com um pouco mais de detalhes:.x = são entradas nas quais função .f será aplicada iterativamente - ex. um vetor de nomes de jurisdição, colunas em um data frame ou uma lista de data frames.f = é função ser aplicada cada elemento da entrada .x - pode ser uma função como print() que já existe, ou uma função personalizada que você define. função geralmente é escrita após um til ~ (detalhes abaixo).Mais algumas notas sobre sintaxe:Se função não precisar de mais argumentos especificados, ela pode ser escrita sem parênteses e sem til (por exemplo, .f = mean). Para fornecer argumentos que terão o mesmo valor para cada iteração, forneça-os dentro da map() mas fora argumento .f =, como na.rm = T em map(.x = my_list, .f = média, na.rm=T).Você pode usar .x (ou simplesmente .) dentro da função .f = como um espaço reservado para o valor .x dessa iteraçãoUse sintaxe til (~) para ter maior controle sobre função - escreva função normalmente com parênteses, como: map(.x = my_list, .f = ~mean(., na.rm = T) ). Use esta sintaxe especialmente se o valor de um argumento mudar cada iteração, ou se o próprio valor .x (veja os exemplos abaixo)O resultado da função map() é uma lista - uma lista é uma classe de objeto como um vetor, mas cujos elementos podem ser de classes diferentes. Assim, uma lista produzida pela map() pode conter muitos data frames, ou muitos vetores, muitos valores únicos, ou mesmo muitas listas! Existem versões alternativas da map() explicadas abaixo que produzem outros tipos de saídas (por exemplo, map_dfr() para produzir um data frame, map_chr() para produzir vetores de caracteres e map_dbl() para produzir vetores).","code":""},{"path":"iteration.html","id":"iter_combined","chapter":"16 Iterações, loops e listas","heading":"Exemplo - importar e combinar planilhas do Excel","text":"Vamos demonstrar com uma tarefa comum de um epidemiologista: - Você deseja importar um arquivo Excel com dados caso, mas os dados são divididos em diferentes abas com nomes. Como você importa e combina com eficiência planilhas em um data frame?Digamos que recebemos arquivo Excel abaixo. Cada folha contém casos de um determinado hospital.Aqui está uma abordagem que usa função map():map() função import() para que seja executada para aba ExcelCombine em um os data frames importados usando bind_rows()Ao longo caminho, preserve o nome da aba original para cada linha, armazenando essas informações em uma nova coluna data frame finalPrimeiro, precisamos extrair os nomes das abas e salvá-los. Fornecemos o caminho arquivo Excel para função excel_sheets() pacote readxl, que extrai os nomes das abas Nós os armazenamos em um vetor de caracteres chamado sheet_names.Aqui estão os nomes:Agora que temos esse vetor de nomes, map() pode fornecê-los um um para função import(). Neste exemplo, os sheet_names são .x e import() é função .f.Lembre-se da página Importar e exportar que quando usado em arquivos Excel, import() pode aceitar o argumento = (qual) especificando aba ser importada. Dentro da função .f import(), fornecemos = .x, cujo valor mudará cada iteração através vetor sheet_names - primeiro “Central Hospital” (“Hospital Central”), depois “Military Hospital” (“Hospital Militar”) etc.Nota - porque usamos map(), os dados em cada planilha Excel serão salvos como um data frame separado dentro de uma lista. Queremos que cada um desses elementos de lista (data frame) tenha um nome, então antes de passarmos sheet_names para map(), passamos por set_names() de purrr, o que garante que cada elemento da lista recebe o nome apropriado.Salvamos lista de saída como o objeto combined.Quando inspecionamos o resultado, vemos que os dados de cada aba Excel são salvos na lista com um nome. Isso é bom, mas ainda não terminamos.Por fim, usamos função bind_rows() (dplyr) que aceita lista de data frames com estrutura semelhante e os combina em um único data frame. Para criar uma nova coluna partir elemento names da lista, usamos o argumento .id = e fornecemos o nome desejado para nova coluna.Abaixo está toda sequência de comandos:E agora temos um data frame com uma coluna contendo aba de origem!Existem variações da map() que você deve conhecer. Por exemplo, map_dfr() retorna um data frame, não uma lista. Assim, poderíamos tê-lo usado para tarefa acima e não ter que vincular linhas. Mas aí não teríamos conseguido capturar de qual aba (hospital) veio cada caso.Outras variações incluem map_chr(), map_dbl(). Estas são funções muito úteis por duas razões. Em primeiro lugar, elas convertem automaticamente saída de uma função iterativa em um vetor (não uma lista). Em segundo lugar, elas podem controlar explicitamente classe em que os dados voltam - você garante que seus dados voltem como um vetor de caracteres com map_chr(), ou vetor numérico com map_dbl(). Vamos voltar eles mais tarde na seção!funções map_at() e map_if() também são muito úteis para iteração - elas permitem que você especifique em quais elementos de uma lista você deve iterar! Estes funcionam simplesmente aplicando um vetor de índices/nomes (caso de map_at()) ou um teste lógico (caso de map_if()).Vamos usar um exemplo em que não queríamos ler primeira aba de dados hospital. Usamos map_at() em vez de map(), e especificamos o argumento .= para c(-1) que significa não usar o primeiro elemento de .x. Alternativamente, você pode fornecer um vetor de números positivos, ou nomes, para .= para especificar quais elementos usar.Observe que o nome da primeira aba ainda aparecerá como um elemento da lista de saída - mas é apenas um nome de caractere único (não um data frame). Você precisaria remover esse elemento antes de vincular linhas. Abordaremos como remover e modificar elementos de uma lista em uma seção posterior.","code":"\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\nsheet_names## [1] \"Central Hospital\"              \"Military Hospital\"            \n## [3] \"Missing\"                       \"Other\"                        \n## [5] \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\ncombined <- sheet_names %>% \n  purrr::set_names() %>% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extraindo o nome das abas\n \ncombined <- sheet_names %>%                                     # começando com os nomes das abas\n  purrr::set_names() %>%                                        # definindo seus nomes\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %>%  # iterando, importando, salvando na lista\n  bind_rows(.id = \"origin_sheet\") # combinar lista de data frames, preservando a origem em uma nova coluna\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined <- sheet_names %>% \n     purrr::set_names() %>% \n     # excluindo a primeira aba\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))"},{"path":"iteration.html","id":"divida-o-conjunto-de-dados-e-exporte","chapter":"16 Iterações, loops e listas","heading":"Divida o conjunto de dados e exporte","text":"Abaixo, damos um exemplo de como dividir um conjunto de dados em partes e, em seguida, usar iteração map() para exportar cada parte como uma aba separada Excel ou como um arquivo CSV separado.","code":""},{"path":"iteration.html","id":"conjunto-de-dados-dividido","chapter":"16 Iterações, loops e listas","heading":"Conjunto de dados dividido","text":"Digamos que temos o caso completo linelist como um data frame e agora queremos criar uma linelist separada para cada hospital e exportar cada um como um arquivo CSV separado. Abaixo, fazemos os seguintes passos:Use group_split() (dplyr) para dividir o data frame linelist por valores únicos na coluna hospital. saída é uma lista contendo um data frame por subconjunto de hospital.Podemos executar View(linelist_split) e ver que esta lista contém 6 data frames (“tibbles”), cada um representando os casos de um hospital.entanto, observe que os data frames na lista não possuem nomes por padrão! Queremos que cada um tenha um nome e, em seguida, use esse nome ao salvar o arquivo CSV.Uma abordagem para extrair os nomes é usar pull() (dplyr) para extrair coluna hospital de cada data frame na lista. Então, por segurança, convertemos os valores em caracteres e usamos unique() para obter o nome desse data frame específico. Todas essas etapas são aplicadas cada data frame via map().Agora podemos ver que cada um dos elementos da lista tem um nome. Esses nomes podem ser acessados via names(linelist_split).","code":"\nlinelist_split <- linelist %>% \n     group_split(hospital)\nnames(linelist_split) <- linelist_split %>%   # Atribuindo os nomes de data frames listados\n     # Extraia os nomes fazendo o seguinte para cada data frame:\n     map(.f = ~pull(.x, hospital)) %>%        # Puxe a coluna do hospital\n     map(.f = ~as.character(.x)) %>%          # Converta em caractere, apenas por garantia\n     map(.f = ~unique(.x))                    # Pegue o nome exclusivo do hospital\nnames(linelist_split)## [1] \"Ausente\"                              \"Central Hospital\"                    \n## [3] \"Military Hospital\"                    \"Other\"                               \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\""},{"path":"iteration.html","id":"mais-de-uma-coluna-group_split","chapter":"16 Iterações, loops e listas","heading":"Mais de uma coluna group_split()","text":"Se você quiser dividir linelist por mais de uma coluna de agrupamento, como para produzir uma lista de linelist pela interseção de hospital E sexo, precisará de uma abordagem diferente para nomear os elementos da lista. Isso envolve coletar “chaves de grupo” exclusivas usando group_keys() dplyr - elas são retornadas como um data frame. Então você pode combinar chaves de grupo em valores com unite() como mostrado abaixo, e atribuir esses nomes de conglomerados linelist_split.Agora combinamos os agrupamentos, separados por traços, e os atribuímos como os nomes dos elementos da lista em linelist_split. Isso leva algumas linhas extras, pois substituimos NA por “Ausente”, usamos unite() dplyr para combinar os valores das colunas (separados por traços) e, em seguida, convertemos em um vetor sem nome para que ele pode ser usado como nomes de linelist_split.","code":"\n# dividindo a linelist por combinações exclusivas de hospital-gênero\nlinelist_split <- linelist %>% \n     group_split(hospital, gender)\n\n# extraindo group_keys() como um data frame\ngroupings <- linelist %>% \n     group_by(hospital, gender) %>%       \n     group_keys()\n\ngroupings      # mostrando agrupamentos únicos## # A tibble: 18 × 2\n##    hospital                             gender\n##    <chr>                                <chr> \n##  1 Ausente                              f     \n##  2 Ausente                              m     \n##  3 Ausente                              <NA>  \n##  4 Central Hospital                     f     \n##  5 Central Hospital                     m     \n##  6 Central Hospital                     <NA>  \n##  7 Military Hospital                    f     \n##  8 Military Hospital                    m     \n##  9 Military Hospital                    <NA>  \n## 10 Other                                f     \n## 11 Other                                m     \n## 12 Other                                <NA>  \n## 13 Port Hospital                        f     \n## 14 Port Hospital                        m     \n## 15 Port Hospital                        <NA>  \n## 16 St. Mark's Maternity Hospital (SMMH) f     \n## 17 St. Mark's Maternity Hospital (SMMH) m     \n## 18 St. Mark's Maternity Hospital (SMMH) <NA>\n# Combinando em um valor de um nome\nnames(linelist_split) <- groupings %>% \n     mutate(across(everything(), replace_na, \"Ausente\")) %>%  # substituindo NA por \"Ausente\" em todas as colunas\n     unite(\"combined\", sep = \"-\") %>%                         # unindo todos os valores da coluna em um\n     setNames(NULL) %>% \n     as_vector() %>% \n     as.list()"},{"path":"iteration.html","id":"exportando-como-abas-do-excel","chapter":"16 Iterações, loops e listas","heading":"Exportando como abas do Excel","text":"Para exportar linelists hospital como um arquivo Excel com uma linelist por aba, podemos apenas fornecer lista nomeada linelist_split para função write_xlsx() pacote writexl. Isso tem capacidade de salvar um arquivo Excel com várias abas. Os nomes dos elementos da lista são aplicados automaticamente como os nomes das abasAgora você pode abrir o arquivo Excel e ver que cada hospital tem sua própria aba","code":"\nlinelist_split %>% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))"},{"path":"iteration.html","id":"exportando-como-arquivos-csv","chapter":"16 Iterações, loops e listas","heading":"Exportando como arquivos CSV","text":"É um comando um pouco mais complexo, mas você também pode exportar cada linelist específica hospital como um arquivo CSV separado, com um nome de arquivo específico para o hospital.Novamente usamos map(): pegamos o vetor de nomes de elementos da lista (mostrado acima) e usamos map() para iterar por eles, aplicando export() (pacote rio, veja página Importar e exportar) data frame na lista linelist_split que tem esse nome. Também usamos o nome para criar um nome de arquivo exclusivo. Aqui está como funciona:Começamos com o vetor de nomes de caracteres, passado para map() como .xComeçamos com o vetor de nomes de caracteres, passado para map() como .xA função .f é export() , que requer um data frame e um caminho de arquivo para gravarA função .f é export() , que requer um data frame e um caminho de arquivo para gravarA entrada .x (o nome hospital) é usada dentro de .f para extrair/indexar aquele elemento específico da lista linelist_split. Isso resulta em apenas um data frame por vez sendo fornecido para export().entrada .x (o nome hospital) é usada dentro de .f para extrair/indexar aquele elemento específico da lista linelist_split. Isso resulta em apenas um data frame por vez sendo fornecido para export().Por exemplo, quando map() itera para “Military Hospital” (“Hospital Militar”), então linelist_split[[.x]] é na verdade linelist_split[[\"Military Hospital\"]], retornando assim o segundo elemento de linelist_split - que são todos os casos Hospital Militar.Por exemplo, quando map() itera para “Military Hospital” (“Hospital Militar”), então linelist_split[[.x]] é na verdade linelist_split[[\"Military Hospital\"]], retornando assim o segundo elemento de linelist_split - que são todos os casos Hospital Militar.O caminho arquivo fornecido para export() é dinâmico através uso de str_glue() (consulte página Caracteres e strings):\n() é usado para obter base caminho arquivo e especificar pasta “data” (observe aspas simples para não interromper aspas duplas str_glue())\nO caminho arquivo fornecido para export() é dinâmico através uso de str_glue() (consulte página Caracteres e strings):() é usado para obter base caminho arquivo e especificar pasta “data” (observe aspas simples para não interromper aspas duplas str_glue())Em seguida, uma barra /, e novamente o .x que imprime o nome hospital atual para tornar o arquivo identificávelEm seguida, uma barra /, e novamente o .x que imprime o nome hospital atual para tornar o arquivo identificávelFinalmente extensão “.csv” que export() usa para criar um arquivo CSVFinalmente extensão “.csv” que export() usa para criar um arquivo CSVAgora você pode ver que cada arquivo é salvo na pasta “data” R Project “Epi_R_handbook”!","code":"\nnames(linelist_split) %>%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))"},{"path":"iteration.html","id":"customizar-funções","chapter":"16 Iterações, loops e listas","heading":"Customizar funções","text":"Você pode querer criar sua própria função para fornecer ao map().Digamos que queremos criar curvas epidêmicas para os casos de cada hospital. Para fazer isso usando purrr, nossa função .f pode ser ggplot() e extensões com + como de costume. Como saída de map() é sempre uma lista, os gráficos são armazenados em uma lista. Por serem gráficos, eles podem ser extraídos e plotados com função ggarrange() pacote ggpubr (documentação ).Se este código map() parecer muito confuso, você pode obter o mesmo resultado salvando seu comando ggplot() específico como uma função personalizada definida pelo usuário, por exemplo, podemos chamá-lo de make_epicurve()). Esta função é então usada dentro map(). .x será substituído iterativamente pelo nome hospital e usado como hosp_name na função make_epicurve(). Consulte página sobre Escrevendo funções.","code":"\n# carregando pacote para plotar elementos da lista\npacman::p_load(ggpubr)\n\n# mapeando o vetor de 6 \"nomes\" de hospitais (criados anteriormente)\n# usando a função ggplot especificada\n# a saída é uma lista com 6 ggplots\n\nhospital_names <- unique(linelist$hospital)\n\nmy_plots <- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# exibindo os ggplots (eles são armazenados em uma lista)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n# Criando a função\nmake_epicurve <- function(hosp_name){\n  \n  ggplot(data = linelist %>% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n# mapeando\nmy_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# exibindo os ggplots (eles são armazenados em uma lista)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)"},{"path":"iteration.html","id":"mapeando-uma-função-ao-longo-de-colunas","chapter":"16 Iterações, loops e listas","heading":"Mapeando uma função ao longo de colunas","text":"Outro caso de uso comum é mapear uma função ao longo de muitas colunas. Abaixo, mapeamos (map()) função t.test() em colunas numéricas data frame linelist, comparando os valores numéricos por gênero.Lembre-se da página em Testes estatísticos simples que t.test() pode receber entradas em um formato de fórmula, como t.test(coluna numérica ~ coluna binária). Neste exemplo, fazemos o seguinte:colunas numéricas de interesse são selecionadas de linelist - elas se tornam entradas .x para map()colunas numéricas de interesse são selecionadas de linelist - elas se tornam entradas .x para map()função t.test() é fornecida como função .f, que é aplicada cada coluna numéricaA função t.test() é fornecida como função .f, que é aplicada cada coluna numéricaDentro dos parênteses de t.test():\no primeiro ~ precede o .f que map() irá iterar sobre .x\no .x representa coluna atual sendo fornecida para função t.test()\no segundo ~ faz parte da equação teste t descrita acima\nfunção t.test() espera uma coluna binária lado direito da equação. Nós fornecemos o vetor linelist$gender independentemente e estaticamente (observe que ele não está incluído em select()).\nDentro dos parênteses de t.test():o primeiro ~ precede o .f que map() irá iterar sobre .xo .x representa coluna atual sendo fornecida para função t.test()o segundo ~ faz parte da equação teste t descrita acimaa função t.test() espera uma coluna binária lado direito da equação. Nós fornecemos o vetor linelist$gender independentemente e estaticamente (observe que ele não está incluído em select()).map() retorna uma lista, então saída é uma lista de resultados teste t - um elemento de lista para cada coluna numérica analisada.Aqui está aparência da lista t.test_results quando aberta (Visualizada) RStudio. Destacamos partes que são importantes para os exemplos nesta página.Você pode ver topo que lista inteira é chamada de t.test_results e tem cinco elementos. Esses cinco elementos são nomeados age, wt_km, ht_cm, ct_blood, temp após cada variável que foi usada em um teste t com gender da linelist.Cada um desses cinco elementos são listas, com elementos dentro deles, como p.value e conf.int. Alguns desses elementos como p.value são números únicos, enquanto alguns como estimate consistem em dois ou mais elementos (média grupo f e média grupo m).Nota: Lembre-se que se você deseja aplicar uma função apenas certas colunas em um data frame, você também pode simplesmente usar mutate() e across(), conforme explicado na página Limpeza de dados e principais funções. Abaixo está um exemplo de aplicação de .character() apenas para colunas “age”. Observe o posicionamento dos parênteses e vírgulas.","code":"\n# Resultados são salvos como uma lista\nt.test_results <- linelist %>% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # mantendo apenas algumas colunas numéricas para mapear\n  map(.f = ~t.test(.x ~ linelist$gender))        # função t.test com equação NUMERIC ~ CATEGORICAL\n# convertendo colunas com nome da coluna contendo \"idade\" para classe Character\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  "},{"path":"iteration.html","id":"extraindo-de-listas","chapter":"16 Iterações, loops e listas","heading":"Extraindo de listas","text":"Como map() produz uma saída da classe List (lista), vamos gastar algum tempo discutindo como extrair dados de listas usando funções acompanhantes purrr. Para demonstrar isso, usaremos lista t.test_results da seção anterior. Esta é uma lista de 5 listas - cada uma das 5 listas contém os resultados de um teste t entre uma coluna data frame linelist e sua coluna binária gender. Veja imagem na seção acima para uma visualização da estrutura da lista.","code":""},{"path":"iteration.html","id":"nomes-dos-elementos","chapter":"16 Iterações, loops e listas","heading":"Nomes dos elementos","text":"Para extrair os nomes dos próprios elementos, simplesmente use names() R base. Neste caso, usamos names() em t.test_results para retornar os nomes de cada sub-lista , que são os nomes das 5 variáveis que tiveram testes t realizados.","code":"\nnames(t.test_results)## [1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\""},{"path":"iteration.html","id":"elementos-por-nome-ou-posição","chapter":"16 Iterações, loops e listas","heading":"Elementos por nome ou posição","text":"Para extrair elementos da lista por nome ou por posição, você pode usar colchetes [[ ]] conforme descrito na página Introdução ao R. Abaixo usamos colchetes duplos para indexar lista t.tests_results e exibir o primeiro elemento que é o resultado teste t em age (idade).entanto, abaixo vamos demonstrar o uso das funções simples e flexíveis purrr map() e pluck() para alcançar os mesmos resultados.","code":"\nt.test_results[[1]] # primeiro elemento por posição## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results[[1]][\"p.value\"] # retorna o elemento nomeado \"p.value\" do primeiro elemento## $p.value\n## [1] 2.350374e-96"},{"path":"iteration.html","id":"pluck","chapter":"16 Iterações, loops e listas","heading":"pluck()","text":"pluck() extrai elementos por nome ou por posição. Por exemplo - para extrair os resultados teste t para idade, você pode usar pluck() assim:Indexe níveis mais profundos especificando os níveis adicionais com vírgulas. O código abaixo extrai o elemento chamado “p.value” (o p-valor)da lista age de dentro da lista t.test_results. Você também pode usar números em vez de nomes de caracteres.Você pode extrair esses elementos internos de todos os elementos de primeiro nível usando map() para executar função pluck() em cada elemento de primeiro nível. Por exemplo, o código abaixo extrai os elementos “p.value” de todas listas dentro de t.test_results. lista de resultados teste t é o .x iterado, pluck() é função .f sendo iterada e o valor “p-value” é fornecido para função.Como outra alternativa, map() oferece uma abreviação onde você pode escrever o nome elemento entre aspas, e ele irá “arrancá-lo”. Se você usar map() saída será uma lista, enquanto que se você usar map_chr() será um vetor de caractere nomeado e se você usar map_dbl() será um vetor numérico nomeado.Você pode ler mais sobre pluck() em sua documentação purrr. Ele tem uma função irmã chuck() que retornará um erro em vez de NULL se um elemento não existir.","code":"\nt.test_results %>% \n  pluck(\"age\")        # alternativamente, use pluck(1)## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results %>% \n  pluck(\"age\", \"p.value\")## [1] 2.350374e-96\nt.test_results %>%\n  map(pluck, \"p.value\")   # retorna cada p-valor## $age\n## [1] 2.350374e-96\n## \n## $wt_kg\n## [1] 2.664367e-182\n## \n## $ht_cm\n## [1] 3.515713e-144\n## \n## $ct_blood\n## [1] 0.4473498\n## \n## $temp\n## [1] 0.5735923\nt.test_results %>% \n  map_dbl(\"p.value\")   # retorna o p-valor como um vetor numérico com nome##           age         wt_kg         ht_cm      ct_blood          temp \n##  2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01"},{"path":"iteration.html","id":"convertendo-uma-lista-em-um-data-frame","chapter":"16 Iterações, loops e listas","heading":"Convertendo uma lista em um data frame","text":"Este é um tópico complexo - consulte seção Recursos para tutoriais mais completos. entanto, demonstraremos conversão da lista de resultados teste t em um data frame. Criaremos um data frame com colunas para variável, seu p-valor e médias dos dois grupos (masculino e feminino).Aqui estão algumas das novas abordagens e funções que serão usadas:função tibble() será usada para criar um tibble (como um data frame)\nEnvolvemos função tibble() com chaves { } para evitar que todo o t.test_results seja armazenado como primeira coluna tibble\nfunção tibble() será usada para criar um tibble (como um data frame)Envolvemos função tibble() com chaves { } para evitar que todo o t.test_results seja armazenado como primeira coluna tibbleDentro de tibble(), cada coluna é criada explicitamente, semelhante à sintaxe de mutate():\nO . representa t.test_results\nPara criar uma coluna com os nomes das variáveis teste t (os nomes de cada elemento da lista) usamos names() conforme descrito acima\nPara criar uma coluna com os p-valores, usamos map_dbl() conforme descrito acima para extrair os elementos p.value e convertê-los em um vetor numérico\nDentro de tibble(), cada coluna é criada explicitamente, semelhante à sintaxe de mutate():O . representa t.test_resultsPara criar uma coluna com os nomes das variáveis teste t (os nomes de cada elemento da lista) usamos names() conforme descrito acimaPara criar uma coluna com os p-valores, usamos map_dbl() conforme descrito acima para extrair os elementos p.value e convertê-los em um vetor numéricoMas agora vamos adicionar colunas contendo médias para cada grupo (masculino e feminino).Precisaríamos extrair o elemento estimate, mas na verdade ele contém dois elementos dentro dele (média grupo f e média grupo m). Portanto, não pode ser simplificado em um vetor com map_chr() ou map_dbl(). Em vez disso, usamos map(), que usado dentro de tibble() criará uma coluna da lista de classes dentro tibble! Sim, isso é possível!Depois de ter essa coluna de lista, há várias funções tidyr (parte tidyverse) que ajudam “retangular” ou “desaninhar” essas colunas de “lista aninhada”. Leia mais sobre eles aqui, ou executando vignette(\"rectangle\"). Em resumo:unnest_wider() - dá cada elemento de uma coluna de lista sua própria colunaunnest_longer() - dá cada elemento de uma coluna de lista sua própria linhahoist() - funciona como unnest_wider() mas você especifica quais elementos serão desaninhadosAbaixo, passamos o tibble para unnest_wider() especificando coluna means tibble (que é uma lista aninhada). O resultado é que means é substituído por duas novas colunas, cada uma refletindo os dois elementos que estavam anteriormente em cada célula means.","code":"\nt.test_results %>% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }## # A tibble: 5 × 2\n##   variables         p\n##   <chr>         <dbl>\n## 1 age       2.35e- 96\n## 2 wt_kg     2.66e-182\n## 3 ht_cm     3.52e-144\n## 4 ct_blood  4.47e-  1\n## 5 temp      5.74e-  1\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}## # A tibble: 5 × 3\n##   variables         p means       \n##   <chr>         <dbl> <named list>\n## 1 age       2.35e- 96 <dbl [2]>   \n## 2 wt_kg     2.66e-182 <dbl [2]>   \n## 3 ht_cm     3.52e-144 <dbl [2]>   \n## 4 ct_blood  4.47e-  1 <dbl [2]>   \n## 5 temp      5.74e-  1 <dbl [2]>\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %>% \n  unnest_wider(means)## # A tibble: 5 × 4\n##   variables         p `mean in group f` `mean in group m`\n##   <chr>         <dbl>             <dbl>             <dbl>\n## 1 age       2.35e- 96              12.7              19.6\n## 2 wt_kg     2.66e-182              45.8              59.6\n## 3 ht_cm     3.52e-144             109.              142. \n## 4 ct_blood  4.47e-  1              21.2              21.2\n## 5 temp      5.74e-  1              38.6              38.6"},{"path":"iteration.html","id":"descartar-manter-e-compactar-listas","chapter":"16 Iterações, loops e listas","heading":"Descartar, manter e compactar listas","text":"Como trabalhar com purrr geralmente envolve listas, exploraremos brevemente algumas funções purrr para modificar listas. Consulte seção Recursos para tutoriais mais completos sobre funções purrr.list_modify() tem muitos usos, um dos quais pode ser remover um elemento da listakeep() retém os elementos especificados para .p =, ou onde uma função fornecida para .p = é avaliada como TRUEdiscard() remove os elementos especificados para .p, ou onde uma função fornecida para .p = é avaliada como TRUEcompact() remove todos os elementos vaziosAqui estão alguns exemplos usando lista combined criada na seção acima em usando map() para importar e combinar vários arquivos (contém 6 data frames de linelist):Elementos podem ser removidos por nome com list_modify() e definindo o nome igual NULL.Você também pode remover elementos por critérios, fornecendo uma equação de “predicado” para .p = (uma equação que avalia como TRUE ou FALSE). Coloque um til ~ antes da função e use .x para representar o elemento da lista. Usando keep() os elementos da lista que forem avaliados como TRUE serão mantidos. Inversamente, se estiver usando discard(), os elementos da lista que forem avaliados como TRUE serão removidos.exemplo abaixo, os elementos da lista são descartados se suas classes não forem data frames.Sua função de predição também pode referenciar elementos/colunas dentro de cada item da lista. Por exemplo, abaixo, os elementos da lista onde média da coluna ct_blood é superior 25 são descartados.Este comando remove todos os elementos vazios da lista:","code":"\ncombined %>% \n  list_modify(\"Central Hospital\" = NULL)   # remove elemento da lista por nome\n# mantenha apenas elementos de lista com mais de 500 linhas\ncombined %>% \n  keep(.p = ~nrow(.x) > 500)  \n# descartando elementos que não são data frame\ncombined %>% \n  discard(.p = ~class(.x) != \"data.frame\")\n# mantenha apenas elementos onde a média da coluna ct_blood é maior que 25\ncombined %>% \n  discard(.p = ~mean(.x$ct_blood) > 25)  \n# remove todos os elementos vazios da lista\ncombined %>% \n  compact()"},{"path":"iteration.html","id":"pmap","chapter":"16 Iterações, loops e listas","heading":"pmap()","text":"ESTA SEÇÃO ESTÁ EM CONSTRUÇÃO","code":""},{"path":"iteration.html","id":"funções-apply","chapter":"16 Iterações, loops e listas","heading":"16.4 funções Apply","text":"família de funções “apply” é uma alternativa R base ao purrr para operações iterativas. Você pode ler mais sobre eles aqui.","code":""},{"path":"iteration.html","id":"recursos-9","chapter":"16 Iterações, loops e listas","heading":"16.5 Recursos","text":"para loops com Data CarpentryA página R Data Science sobre iteraçãoVinheta sobre gravação/leitura de arquivos ExcelUm tutorial purrr por jennybcOutro purrr tutorial por Rebecca BarterUm tutorial purrr para map, pmap e imappurrr cheatsheetdicas e truques purrrmanter e descartar","code":""},{"path":"tables-descriptive.html","id":"tables-descriptive","chapter":"17 Tabelas descritivas","heading":"17 Tabelas descritivas","text":"Esta página demonstra o uso dos pacotes janitor, dplyr, gtsummary, rstatix, e R base para gerar um resumo dos dados e criar tabelas com estatísticas descritivas.Esta página explica como criar* tabelas básicas e detalhadas, enquanto que página Tabelas para apresentações descreve como formatar e imprimir essas tabelas de forma visualmente agradável.*Cada um destes pacotes tem vantagens e desvantagens em relação à simplicidade código, acessibilidade dos resultados gerados, e qualidade da impressão destes resultados. Utilize esta página para decidir qual abordagem funciona melhor para sua realidade.Você tem várias opções para produzir tabelas simples e tabelas cruzadas (também conhecidas como tabelas de contingência). Entretanto, é necessário levar em consideração alguns fatores, como simplicidade código R utilizado; capacidade de personalização deste código; forma de geração dos resultados (para visualização terminal R, ou como uma tabela de dados (data frame), e/ou como uma imagem ‘bonita’ nos formatos .png/.jpeg/.html); e facilidade de pós-processamento dos resultados gerados. Leve em consideração os pontos abaixo ao escolher uma ferramenta para atender suas necessidades.Use função tabyl() janitor para produzir e personalizar tabulações simples e tabulações cruzadasUse função get_summary_stats() rstatix para gerar tabelas com resumos estatísticos de diferentes colunas e/ou grupos de dados de forma fácilUse funções summarise() e count() dplyr para realizar análises estatísticas mais complexas, gerar tabelas de dados organizadas, ou preparar os dados para utilizar na função ggplot()Use função tbl_summary() gtsummary para produzir tabelas detalhadas prontas para publicaçãoUse função table() R base se você não tiver acesso aos pacotes citados acima","code":""},{"path":"tables-descriptive.html","id":"preparação-8","chapter":"17 Tabelas descritivas","heading":"17.1 Preparação","text":"","code":""},{"path":"tables-descriptive.html","id":"carregue-os-pacotes-r-2","chapter":"17 Tabelas descritivas","heading":"Carregue os pacotes R","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), r base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  rio,          # importa arquivos\n  here,         # localiza arquivos\n  skimr,        # gera visualização dos dados\n  tidyverse,    # gestão dos dados + gráficos no ggplot2 \n  gtsummary,    # resumo estatísticos e testes\n  rstatix,      # resumo e testes estatísticos\n  janitor,      # adiciona números absolutos e porcentagens às tabelas\n  scales,       # facilmente converte proporções para porcentagens\n  flextable     # converte tabelas para o formato de imagens\n  )"},{"path":"tables-descriptive.html","id":"importe-os-dados-no-r","chapter":"17 Tabelas descritivas","heading":"Importe os dados no R","text":"Nós iremos importar o banco de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando função import() pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja página Importar e exportar para detalhes).primeiras 50 linhas banco de dados são mostradas abaixo.","code":"\n# importe o banco de dados limpo\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"tables-descriptive.html","id":"explore-seus-dados","chapter":"17 Tabelas descritivas","heading":"17.2 Explore seus dados","text":"","code":""},{"path":"tables-descriptive.html","id":"pacote-skimr","chapter":"17 Tabelas descritivas","heading":"Pacote skimr","text":"Ao utilizar o pacote skimr, você pode obter um resumo detalhado e esteticamente agradável de cada variável seu banco de dados. Leia mais sobre o skimr na sua página github.Abaixo, função skim() é aplicada todos os dados objeto linelist, criado código acima. Após execução código, uma visão geral dos dados e um resumo de cada coluna (por classe) são gerados.\nTable 17.1: Data summary\nVariable type: characterVariable type: DateVariable type: factorVariable type: numericVocê também pode usar função summary(), R base, para obter informações sobre o banco de dados inteiro, mas os resultados obtidos podem ser mais difíceis de visualizar que utilizando o skimr. O resultado da análise com summary() não é mostrado abaixo, visando poupar espaço na página.","code":"\n## obtenha informações sobre cada variável no banco de dados\nskim(linelist)\n## obtenha informações sobre cada coluna no banco de dados\nsummary(linelist)"},{"path":"tables-descriptive.html","id":"resumos-estatísticos","chapter":"17 Tabelas descritivas","heading":"Resumos estatísticos","text":"Você pode utilizar funções R base para obter resumos estatísticos de uma coluna com dados numéricos. Boa parte das análises estatísticas mais úteis com este tipo de coluna pode ser obtido utilizando função summary(), como mostrado abaixo. Observe que o nome da tabela de dados e da coluna (linelist) precisam ser especificados como mostrado abaixo.Você pode obter e salvar uma parte específica da análise utilizando o indexador com colchetes [ ]:Você pode obter estatísticas individuais com outras funções R base, como max(), min(), median(), mean(), quantile(), sd(), e range(). Veja página Introdução ao R para uma lista completa.CUIDADO: Caso seus dados contenham campos em branco, o R quer que você saiba disso e irá gerar NA na análise. Isso só não irá ocorrer caso você ‘peça’ para o R ignorar esses campos em branco nas funções matemáticas acima. Isso pode ser realizado com o argumentona.rm = TRUE.Você pode usar função get_summary_stats(), rstatix, para obter o resumo estatístico em formato de quadro de dados (data frame). Isso pode ser útil na execução de comandos posteriores ou para criação de gráficos com os valores. Veja página Testes estatísticos simples para mais detalhes pacote rstatix e suas funções.","code":"\nsummary(linelist$age_years)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.02   23.00   84.00      86\nsummary(linelist$age_years)[[2]] # obtém apenas o resultado da análise no índice [2]## [1] 6\n# alternativa equivalente ao indexador [2], utilizando o nome do campo:\n# summary(linelist$age_years)[[\"1st Qu.\"]]  \nlinelist %>% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # variáveis para realizar o cálculo\n    type = \"common\")                    # tipo do resumo estatístico a ser gerado## # A tibble: 5 × 10\n##   variable     n   min   max median   iqr  mean     sd    se    ci\n##   <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n## 1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\n## 2 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475\n## 3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \n## 4 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\n## 5 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025"},{"path":"tables-descriptive.html","id":"tbl_janitor","chapter":"17 Tabelas descritivas","heading":"17.3 Pacote janitor","text":"O pacote janitor contém função tabyl(), que gera tabulações simples e tabulações cruzadas que podem ser modificadas com funções auxiliares para mostrarem porcentagens, proporções, contagens, etc.Abaixo, nós utilizamos funções janitor banco de dados linelist, criado anteriormente, e visualizamos o resultado da análise. Se necessário, é possível salvar tabelas geradas utilizando o operador <-, e atribuindo elas um novo objeto R.","code":""},{"path":"tables-descriptive.html","id":"básico-do-tabyl","chapter":"17 Tabelas descritivas","heading":"Básico do tabyl","text":"O uso tabyl(), modo padrão, em uma coluna específica produz uma tabela com os valores únicos desta coluna, suas contagens, e “porcentagens” (proporções, na realidade). Como proporções podem ter muitos dígitos, é possível ajustar o número de casas decimais com função adorn_rounding(), descrita abaixo.Como observado acima, se existirem campos em branco na coluna analisada, eles são mostrados em uma linha chamada <NA>. Você pode omitir estes campos com o atributo show_na = FALSE. Se não existirem campos em branco, essa linha não irá aparecer. Se estes campos existirem, todas proporções são geradas como ‘brutas’ (coluna ‘percent’ gerada, em que quantidade de campos NA está inclusa denominador) e ‘válidas’ (coluna ‘valid_percent’, onde quantidade de campos NA não é considerada cálculo).Se coluna um fator (da classe Factor) e apenas alguns níveis dessa classe estiverem presentes em seus dados, todos os níveis desta classe serão mostrados na tabela de análise. Você pode omitir essa característica ao usar o atributo show_missing_levels = FALSE. Leia mais na página Fatores.","code":"\nlinelist %>% tabyl(age_cat)##  age_cat    n     percent valid_percent\n##      0-4 1095 0.185971467   0.188728025\n##      5-9 1095 0.185971467   0.188728025\n##    10-14  941 0.159816576   0.162185453\n##    15-19  743 0.126188859   0.128059290\n##    20-29 1073 0.182235054   0.184936229\n##    30-49  754 0.128057065   0.129955188\n##    50-69   95 0.016134511   0.016373664\n##      70+    6 0.001019022   0.001034126\n##     <NA>   86 0.014605978            NA"},{"path":"tables-descriptive.html","id":"tabulação-cruzada-tabela-de-contingência","chapter":"17 Tabelas descritivas","heading":"Tabulação cruzada (tabela de contingência)","text":"quantidades absolutas das tabulações cruzadas são obtidas ao adicionarmos uma ou mais variáveis dentro da função tabyl(). Observe que agora apenas os números absolutos são obtidos - proporções e porcentagens podem ser adicionadas à análise com etapas adicionais mostradas abaixo.","code":"\nlinelist %>% tabyl(age_cat, gender)##  age_cat   f   m NA_\n##      0-4 640 416  39\n##      5-9 641 412  42\n##    10-14 518 383  40\n##    15-19 359 364  20\n##    20-29 468 575  30\n##    30-49 179 557  18\n##    50-69   2  91   2\n##      70+   0   5   1\n##     <NA>   0   0  86"},{"path":"tables-descriptive.html","id":"tbl_adorn","chapter":"17 Tabelas descritivas","heading":"Personalizando o tabyl","text":"Use funções “adorn”, janitor, para adicionar ao resultado da análise colunas de números absolutos assim como converter para proporções, percentuais, ou ajustar o formato de gerado. Você utilizar essas funções nas tabelas geradas pelo tabyl frequentemente.Preste atenção na ordem em que você utiliza estas funções. Abaixo estão alguns exemplos:Uma tabela simples com porcentagens lugar das proporções, que são padrão.Uma tabela cruzada com os números absolutos e porcentagens de cada linha.O código abaixo modifica uma tabela cruzada de dados de forma que quantidades absolutas e os percentuais sejam mostrados.","code":"\nlinelist %>%               # fonte dos dados\n  tabyl(age_cat) %>%       # tabula números absolutos e proporções por idade\n  adorn_pct_formatting()   # converte as proporções para porcentagens##  age_cat    n percent valid_percent\n##      0-4 1095   18.6%         18.9%\n##      5-9 1095   18.6%         18.9%\n##    10-14  941   16.0%         16.2%\n##    15-19  743   12.6%         12.8%\n##    20-29 1073   18.2%         18.5%\n##    30-49  754   12.8%         13.0%\n##    50-69   95    1.6%          1.6%\n##      70+    6    0.1%          0.1%\n##     <NA>   86    1.5%             -\nlinelist %>%                                  \n  tabyl(age_cat, gender) %>%                  # contagens absolutas e proporções cruzando idade e gênero\n  adorn_totals(where = \"row\") %>%             # adiciona uma linha chamada 'Total', com os totais\n  adorn_percentages(denominator = \"row\") %>%  # converte os números absolutos para proporções\n  adorn_pct_formatting(digits = 1)            # converte as proporções para porcentagens##  age_cat     f     m    NA_\n##      0-4 58.4% 38.0%   3.6%\n##      5-9 58.5% 37.6%   3.8%\n##    10-14 55.0% 40.7%   4.3%\n##    15-19 48.3% 49.0%   2.7%\n##    20-29 43.6% 53.6%   2.8%\n##    30-49 23.7% 73.9%   2.4%\n##    50-69  2.1% 95.8%   2.1%\n##      70+  0.0% 83.3%  16.7%\n##     <NA>  0.0%  0.0% 100.0%\n##    Total 47.7% 47.6%   4.7%\nlinelist %>%                                  # fonte dos dados\n  tabyl(age_cat, gender) %>%                  # geração da tabela cruzada\n  adorn_totals(where = \"row\") %>%             # adiciona uma linha \"Total\", com os totais\n  adorn_percentages(denominator = \"col\") %>%  # converte as quantidades absolutas para proporções\n  adorn_pct_formatting() %>%                  # converte as proporções para porcentagens\n  adorn_ns(position = \"front\") %>%            # mostra os dados como: \"n° absoluto (porcentagem)\"\n  adorn_title(                                # nomeia os títulos das colunas e linhas\n    row_name = \"Age Category\",\n    col_name = \"Gender\")##                       Gender                            \n##  Age Category              f              m          NA_\n##           0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n##           5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n##         10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n##         15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n##         20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n##         30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n##         50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n##           70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n##          <NA>     0   (0.0%)     0   (0.0%)  86  (30.9%)\n##         Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)"},{"path":"tables-descriptive.html","id":"convertendo-a-tabela-do-tabyl-para-uma-imagem","chapter":"17 Tabelas descritivas","heading":"Convertendo a tabela do tabyl para uma imagem","text":"Por padrão, o tabyl vai gerar uma tabela ‘crua’ seu console R.Adicionalmente, você pode obter tabela tabyl e utiliza-la nas funções pacote flextable, ou outros pacotes similares, para gerar uma tabela formato de imagem RStudio Viewer, que pode ser exportada nos formatos .png, .jpeg, .html, etc. Isto é discutido na página Tabelas para apresentação. Observe que, caso você gere tabela desta forma e utilize função adorn_titles(), você precisa aplicar o atributo placement = \"combined\".Age Category/GenderfmNA_0-4640  (22.8%)416  (14.8%)39  (14.0%)5-9641  (22.8%)412  (14.7%)42  (15.1%)10-14518  (18.5%)383  (13.7%)40  (14.4%)15-19359  (12.8%)364  (13.0%)20   (7.2%)20-29468  (16.7%)575  (20.5%)30  (10.8%)30-49179   (6.4%)557  (19.9%)18   (6.5%)50-692   (0.1%)91   (3.2%)2   (0.7%)70+0   (0.0%)5   (0.2%)1   (0.4%)0   (0.0%)0   (0.0%)86  (30.9%)Total2,807 (100.0%)2,803 (100.0%)278 (100.0%)","code":"\nlinelist %>%                                  # fonte dos dados\n  tabyl(age_cat, gender) %>%                  # geração da tabela cruzada\n  adorn_totals(where = \"row\") %>%             # adiciona uma linha \"Total\", com os totais\n  adorn_percentages(denominator = \"col\") %>%  # converte as quantidades absolutas para proporções\n  adorn_pct_formatting() %>%                  # converte as proporções para porcentagens\n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %>% # isto é necessário para gerar a tabela como imagem\n  flextable::flextable() %>%    # converte a tabela em imagem\n  flextable::autofit()          # formata a tabela em linha por coluna"},{"path":"tables-descriptive.html","id":"personalizando-outras-tabelas-com-funções-adorn","chapter":"17 Tabelas descritivas","heading":"Personalizando outras tabelas com funções ‘adorn’","text":"Você pode utilizar funções adorn_*(), pacote janitor, em outras tabelas, como criadas pelas funções summarise() e count() pacote dplyr, ou table() R base. Simplesmente aplique tabela gerada à função desejada pacote janitor. Por exemplo:","code":"\nlinelist %>% \n  count(hospital) %>%   # função do pacote dplyr\n  adorn_totals()        # função do pacote janitor##                              hospital    n\n##                               Ausente 1469\n##                      Central Hospital  454\n##                     Military Hospital  896\n##                                 Other  885\n##                         Port Hospital 1762\n##  St. Mark's Maternity Hospital (SMMH)  422\n##                                 Total 5888"},{"path":"tables-descriptive.html","id":"salvando-a-tabela-do-tabyl","chapter":"17 Tabelas descritivas","heading":"Salvando a tabela do tabyl","text":"Se você converteu tabela para uma imagem ‘bonita’ utilizando um pacote como flextable, você pode salvar ela com funções desse pacote - utilizando funções save_as_html(), save_as_word(), save_as_ppt(), e save_as_image() flextable (discutido em detalhes na página Tabelas para apresentação). código abaixo, tabela é salva em um documento Word, onde poderá ser editada manualmente.","code":"\nlinelist %>%\n  tabyl(age_cat, gender) %>% \n  adorn_totals(where = \"col\") %>% \n  adorn_percentages(denominator = \"col\") %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Faixa-Etária\",\n    col_name = \"Gênero\",\n    placement = \"combined\") %>% \n  flextable::flextable() %>%                     # converte para imagem\n  flextable::autofit() %>%                       # garante apenas uma linha por coluna\n  flextable::save_as_docx(path = \"tabyl.docx\")   # salva a imagem como um documento Word no endereço do documento (filepath)"},{"path":"tables-descriptive.html","id":"janitor_age_out_stats","chapter":"17 Tabelas descritivas","heading":"Análises estatísticas","text":"Como mostrado abaixo, você pode aplicar testes estatísticos nas tabelas dos tabyls, como chisq.test() ou fisher.test() pacote stats. Observe que campos em branco não são permitidos, devendo serem excluídos tabyl com o atributo show_na = FALSE.Veja página Testes estatísticos simples para mais códigos e dicas sobre estatística.","code":"\nage_by_outcome <- linelist %>% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)## \n##  Pearson's Chi-squared test\n## \n## data:  age_by_outcome\n## X-squared = 6.4931, df = 7, p-value = 0.4835"},{"path":"tables-descriptive.html","id":"outras-dicas","chapter":"17 Tabelas descritivas","heading":"Outras dicas","text":"Utilize o argumento na.rm = TRUE para excluir campos em brancos de qualquer um dos cálculos acima.Se utilizar qualquer função adorn_*() em tabelas criadas com outra função além tabyl(), você pode especificar (s) coluna(s) para aplicar o “adorn”, como em adorn_percentage(,,,c(cases,deaths)) (onde porcentagem será adicionada somente quarto argumento da análise). Como sintaxe não é simples, considere utilizar função summarise() em seu lugar.Você pode obter mais detalhes na página janitor e nesse resumo tabyl.","code":""},{"path":"tables-descriptive.html","id":"pacote-dplyr","chapter":"17 Tabelas descritivas","heading":"17.4 Pacote dplyr","text":"dplyr faz parte dos pacotes tidyverse, sendo uma ferramenta de gestão de dados muito comum. Criar tabelas com funções summarise() e count() dplyr é uma abordagem útil para obter resumos estatísticos, resumos por grupos, ou para utilizá-las ggplot().função summarise() cria uma nova tabela resumo dos dados. Se os dados não são agrupados, esta função gera uma tabela de dados de uma linha com os resumos estatísticos desejados banco de dados inteiro. Se os dados são agrupados, nova tabela terá um linha por grupo (veja página Agrupando dados).Dentro dos parênteses da função summarise(), você pode incluir os nomes de cada nova coluna, seguido pelo sinal de igual e uma função estatística ser utilizada.DICA: função summarise pode ser escrita na forma inglês britânico e americano (summarise() e summarize()).","code":""},{"path":"tables-descriptive.html","id":"obtendo-as-quantidades-absolutas","chapter":"17 Tabelas descritivas","heading":"Obtendo as quantidades absolutas","text":"função mais simples para utilizar dentro de summarise() é função n(). Não insira nada dentro dos parênteses para função contar o total de linhas.Esta análise é mais interessante se agruparmos os dados antes.O código acima pode ser encurtado ao utilizar função count() em vez de summarise() e n(). função count() faz o seguinte:Agrupa os dados de acordo com colunas escolhidasGera um resumo destes grupos utilizando função n() (criando coluna n)Desagrupa os dadosVocê pode mudar o nome da coluna resultante n para um diferente, ao especificar o novo nome com o atributo name =.Os resultados das contagens de duas ou mais colunas usadas para agrupar os dados são gerados formato “longo”, com contagens na coluna n. Veja página sobre Pivotando dados para aprender sobre tabelas nos formatos “longos” e “amplos”.","code":"\nlinelist %>%                 # inicia com o banco de dados 'linelist'\n  summarise(n_rows = n())    # gera uma nova tabela com uma coluna contendo o número de linhas##   n_rows\n## 1   5888\nlinelist %>% \n  group_by(age_cat) %>%     # agrupe os dados por valores únicos da coluna 'age_cat'\n  summarise(n_rows = n())   # gera o número de linhas *por grupo*## # A tibble: 9 × 2\n##   age_cat n_rows\n##   <fct>    <int>\n## 1 0-4       1095\n## 2 5-9       1095\n## 3 10-14      941\n## 4 15-19      743\n## 5 20-29     1073\n## 6 30-49      754\n## 7 50-69       95\n## 8 70+          6\n## 9 <NA>        86\nlinelist %>% \n  count(age_cat)##   age_cat    n\n## 1     0-4 1095\n## 2     5-9 1095\n## 3   10-14  941\n## 4   15-19  743\n## 5   20-29 1073\n## 6   30-49  754\n## 7   50-69   95\n## 8     70+    6\n## 9    <NA>   86\nlinelist %>% \n  count(age_cat, outcome)##    age_cat outcome   n\n## 1      0-4   Death 471\n## 2      0-4 Recover 364\n## 3      0-4    <NA> 260\n## 4      5-9   Death 476\n## 5      5-9 Recover 391\n## 6      5-9    <NA> 228\n## 7    10-14   Death 438\n## 8    10-14 Recover 303\n## 9    10-14    <NA> 200\n## 10   15-19   Death 323\n## 11   15-19 Recover 251\n## 12   15-19    <NA> 169\n## 13   20-29   Death 477\n## 14   20-29 Recover 367\n## 15   20-29    <NA> 229\n## 16   30-49   Death 329\n## 17   30-49 Recover 238\n## 18   30-49    <NA> 187\n## 19   50-69   Death  33\n## 20   50-69 Recover  38\n## 21   50-69    <NA>  24\n## 22     70+   Death   3\n## 23     70+ Recover   3\n## 24    <NA>   Death  32\n## 25    <NA> Recover  28\n## 26    <NA>    <NA>  26"},{"path":"tables-descriptive.html","id":"mostre-todos-os-níveis-da-classe-factor","chapter":"17 Tabelas descritivas","heading":"Mostre todos os níveis da classe factor","text":"Se você estiver tabelando uma coluna da classe factor, é possível fazer com que todos os níveis dessa classe sejam mostrados (não apenas os níveis presentes nos dados) ao adicionar o atributo .drop = FALSE dentro das funções summarise() ou count().Está técnica é útil para padronizar suas tabelas/gráficos. Por exemplo, se você estiver criando figuras para diferentes sub-grupos, ou precisar criar um mesmo tipo de figura para relatórios de rotina. Em cada uma dessas circuntâncias, os valores nos dados podem variar, mas é possível definir níveis que continuem constantes.Veja página sobre Fatores para mais informações.","code":""},{"path":"tables-descriptive.html","id":"tbl_dplyr_prop","chapter":"17 Tabelas descritivas","heading":"Proporções","text":"Colunas com proporções podem ser criadas ao canalizar (pipe) tabela gerada para função mutate(). partir disso, proporções podem ser calculadas através da divisão das quantidades absolutas geradas na coluna de contagem (n por padrão), divididos pela soma (sum()) de todas contagens nessa coluna.Observe que, neste caso, utilizar função sum() dentro mutate() irá gerar soma da coluna n inteira, e utilizá-la como denominador cálculo das proporções. Como explicado na página de agrupamento de dados, se sum() utilizada em dados agrupados (por exemplo, se o mutate() imediatamente seguido pela função group_by()), somas serão realizadas por grupos. Como dito acima, função count() termina suas ações realizando o desagrupamento dos dados. Assim, neste cenário, nós obtemos proporções da coluna inteira, e não apenas dos grupos.Para facilmente mostrar os percentuais, é possível incorporar proporção gerada dentro da função percent(), pacote scales (tenha em mente que isso converte porcentagem para classe character).Abaixo, um método para calcular proporções dentro dos grupos é mostrado. Esta metodologia utiliza os diferentes níveis de agrupamento e desagrupamento de dados. Primeiro, os dados são agrupados de acordo com o outcome, utilizando função group_by(). Então, função count() é aplicada. Essa função realiza mais agrupamentos dos dados utilizando variável age_cat, e gera contagens para cada combinação outcome-age-cat. Lembre-se que, ao finalizar o processo, função count() também desagrupa os grupos age_cat. Assim, o único grupo de dados restante é o agrupamento inicial pelo outcome. Assim, etapa final em que proporções são calculadas (denominador sum(n)) é realizada com o grupo outcome.","code":"\nage_summary <- linelist %>% \n  count(age_cat) %>%                     # agrupe e conte por gênero (produz a coluna 'n'), finaliza desagrupando os dados\n  mutate(                                # cria a porcentagem da coluna - observe o denominador\n    percent = scales::percent(n / sum(n))) \n\n# print\nage_summary##   age_cat    n percent\n## 1     0-4 1095  18.60%\n## 2     5-9 1095  18.60%\n## 3   10-14  941  15.98%\n## 4   15-19  743  12.62%\n## 5   20-29 1073  18.22%\n## 6   30-49  754  12.81%\n## 7   50-69   95   1.61%\n## 8     70+    6   0.10%\n## 9    <NA>   86   1.46%\nage_by_outcome <- linelist %>%                  # inicie com os dados do linelist\n  group_by(outcome) %>%                         # agrupe por outcome \n  count(age_cat) %>%                            # agrupe e conte por age_cat, e então remova os grupos age_cat\n  mutate(percent = scales::percent(n / sum(n))) # calcule as porcentagem - repare que o denominador é o grupo outcome"},{"path":"tables-descriptive.html","id":"visualização-dos-dados","chapter":"17 Tabelas descritivas","heading":"Visualização dos dados","text":"Utilizar função ggplot() com os dados de uma tabela formato “longo”, como mostrada acima, é relativamente simples. Esses dados, formato “longo”, são facilmente aceitos pelo ggplot(). Veja mais exemplos nas páginas básico ggplot e dicas ggplot.","code":"\nlinelist %>%                      # inicie com a linelist\n  count(age_cat, outcome) %>%     # agrupe e tabule as contagens utilizando duas variáveis\n  ggplot()+                       # utilize a tabulação gerada no ggplot\n    geom_col(                     # crie um gráfico de barras\n      mapping = aes(   \n        x = outcome,              # mapeie o grupo outcome para o eixo x\n        fill = age_cat,           # mapeie o grupo age_cat para o fill\n        y = n))                   # mapeie as contagens (coluna 'n') para o eixo y"},{"path":"tables-descriptive.html","id":"resumo-estatístico","chapter":"17 Tabelas descritivas","heading":"Resumo estatístico","text":"Uma das principais vantagens pacote dplyr e da função summarise() é habilidade deles gerarem resumos estatísticos mais avançados, como median(), mean(), max(), min(), sd() (desvio padrão), e percentis. Você também pode utilizar função sum() para contar o número de linhas que cumprem certos critérios lógicos. Como mostrado acima, essas informações podem ser obtidas com todo o banco de dados, ou por grupos.sintaxe é mesma - dentro dos parênteses da função summarise(), você adiciona os nomes de cada nova coluna resumo, seguido pelos sinais de igual e função estatística ser realizada. Dentro da função estatística, escolha (s) coluna(s) para serem utilizadas cálculo, e qualquer outro argumento relevante (exemplo: na.rm = TRUE para boa parte das funções matemáticas).Como dito acima, função sum() também pode ser utilizada para obter o número de linhas que cumprem certos critérios lógicos. São contadas apenas linhas que forem verdade (TRUE) para os critérios em parênteses. Por exemplo:sum(age_years < 18, na.rm=T)sum(gender == \"male\", na.rm=T)sum(response %% c(\"Likely\", \"Likely\"))Abaixo, os dados linelist são analisados para avaliar os dias entre o início dos sintomas e admissão hospital (coluna days_onset_hosp), de acordo com o hospital.Algumas dicas:Use função sum() com uma expressão lógica para quantificar linhas que cumprem certos critérios (==)Use função sum() com uma expressão lógica para quantificar linhas que cumprem certos critérios (==)Repare uso argumento na.rm = TRUE dentro de funções matemáticas como sum(). Seu uso impede que NA seja gerado caso existam campos em brancoRepare uso argumento na.rm = TRUE dentro de funções matemáticas como sum(). Seu uso impede que NA seja gerado caso existam campos em brancoUse função percent(), pacote scales, para facilmente obter porcentagens\nEscolha accuracy = para 0.1 ou 0.01 para garantir 1 ou 2 vírgulas decimais, respectivamente\nUse função percent(), pacote scales, para facilmente obter porcentagensEscolha accuracy = para 0.1 ou 0.01 para garantir 1 ou 2 vírgulas decimais, respectivamenteUse função round(), pacote R base, para arredondar e especificar quantidade de casas decimaisUse função round(), pacote R base, para arredondar e especificar quantidade de casas decimaisPara obter dados estatísticos banco de dados completo, utilize função summarise() sem função group_by()Para obter dados estatísticos banco de dados completo, utilize função summarise() sem função group_by()Você pode criar colunas para realizar cálculos futuros (ex.: como denominadores), que podem ser, posteriormente, retiradas da sua tabela de dados com função select().Você pode criar colunas para realizar cálculos futuros (ex.: como denominadores), que podem ser, posteriormente, retiradas da sua tabela de dados com função select().","code":"\nsummary_table <- linelist %>%                                        # inicie com o linelist, salvando os novos dados como um novo objeto\n  group_by(hospital) %>%                                             # agrupe todos os cálculos por hospital\n  summarise(                                                         # apenas as colunas abaixo serão geradas\n    cases       = n(),                                                # n° de casos por grupo\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # tempo máximo entre o ínicio dos sintomas e a admissão\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # tempo médio, arredondado\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # desvio padrão do intervalo de tempo, arredondado\n    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # n° de acsos com intervalo igual ou maior à 3 dias\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # gera nova coluna convertendo o delay_3 em porcentagem\n  )\n\nsummary_table  # exporte a tabela## # A tibble: 6 × 7\n##   hospital                     cases delay_max delay_mean delay_sd delay_3 pct_delay_3\n##   <chr>                        <int>     <dbl>      <dbl>    <dbl>   <int> <chr>      \n## 1 Ausente                       1469        22        2.1      2.3     399 27%        \n## 2 Central Hospital               454        12        1.9      1.9     108 24%        \n## 3 Military Hospital              896        15        2.1      2.4     253 28%        \n## 4 Other                          885        18        2        2.2     234 26%        \n## 5 Port Hospital                 1762        16        2.1      2.2     470 27%        \n## 6 St. Mark's Maternity Hospit…   422        18        2.1      2.3     116 27%"},{"path":"tables-descriptive.html","id":"estatísticas-condicionais","chapter":"17 Tabelas descritivas","heading":"Estatísticas condicionais","text":"Você pode querer realizar análises estatísticas condicionais - por exemplo, quantidade de linhas que cumprem certos critérios. Isto pode ser feito ao utilizar os colchetes [ ] para especificar os grupos desejados dentro de uma coluna. código abaixo, temperatura máxima dos pacientes com e sem febre é obtida. Entranto, neste caso, é melhor criar uma nova coluna utilizando funções group_by() e pivot_wider() (como demonstrado abaixo).","code":"\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )## # A tibble: 6 × 3\n##   hospital                             max_temp_fvr max_temp_no\n##   <chr>                                       <dbl>       <dbl>\n## 1 Ausente                                      40.6        38  \n## 2 Central Hospital                             40.4        38  \n## 3 Military Hospital                            40.5        38  \n## 4 Other                                        40.8        37.9\n## 5 Port Hospital                                40.6        38  \n## 6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9"},{"path":"tables-descriptive.html","id":"unindo-colunas","chapter":"17 Tabelas descritivas","heading":"Unindo colunas","text":"função str_glue(), pacote stringr, é útil para combinar valores de diferentes colunas em uma nova coluna. Geralmente, essa função é aplicada após utilizar função summarise().Na página sobre Caracteres e strings, várias opções para combinar colunas são discutidas, incluindo funções unite() e paste0(). Entretanto, nós recomendamos função str_glue() por ser mais flexível que unite() e possuir uma sintaxe mais simples que paste0().Abaixo, tabela summary_table (criada acima) é modificada de forma que colunas delay_mean e delay_sd sejam combinadas. nova coluna é gerada com os dados formatados utilizando parênteses, e colunas utilizadas são removidas.Então, para tornar coluna mais apresentável, uma linha com os totais é adicionada com função adorn_totals(), pacote janitor (que ignora colunas não-numéricas). Finalmente, nós utilizamos função select(), pacote dplyr, para reordenar colunas e renomeá-las como desejado.Também é possível utilizar funções flextable para exportar tabela para Word, .png, .jpeg, .html, Powerpoint, RMarkdown, etc.! (veja página Tabelas para apresentações).","code":"\nsummary_table %>% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %>%  # crie uma nova coluna ao combinar e formatar valores de outras colunas\n  select(-c(delay_mean, delay_sd)) %>%                       # remova as duas colunas utilizadas   \n  adorn_totals(where = \"row\") %>%                            # adiciona uma linha com os totais\n  select(                                                    # reorganize e renomeie as colunas\n    \"Nome do Hospital\"   = hospital,\n    \"Casos\"           = cases,\n    \"Atraso máximo\"       = delay_max,\n    \"Média (dp)\"       = delay,\n    \"Atraso 3+ dias\"   = delay_3,\n    \"% atrasos 3+ dias\" = pct_delay_3\n    )##                      Nome do Hospital Casos Atraso máximo Média (dp) Atraso 3+ dias\n##                               Ausente  1469            22  2.1 (2.3)            399\n##                      Central Hospital   454            12  1.9 (1.9)            108\n##                     Military Hospital   896            15  2.1 (2.4)            253\n##                                 Other   885            18    2 (2.2)            234\n##                         Port Hospital  1762            16  2.1 (2.2)            470\n##  St. Mark's Maternity Hospital (SMMH)   422            18  2.1 (2.3)            116\n##                                 Total  5888           101          -           1580\n##  % atrasos 3+ dias\n##                27%\n##                24%\n##                28%\n##                26%\n##                27%\n##                27%\n##                  -"},{"path":"tables-descriptive.html","id":"percentis","chapter":"17 Tabelas descritivas","heading":"Percentis","text":"O cálculo dos percentis e quantis dplyr merece uma menção especial. Para obter os quantis, utilize função quantile() com os intervalos padrões, ou especifique os valores alterando o atributo probs =.Se você quiser obter os quantis por grupos, é mais viável utilizar função group_by() e criar novas colunas, uma vez que isso irá gerar dados mais claros em relação ao método acima, onde seriam obtidos resultados longos e menos úteis. Desta forma, experimente essa abordagem: crie um coluna para cada nível de quantil desejado.Enquanto função summarise() dplyr certamente possibilita mais controle das alterações, todos os resumos estatísticos de que precisa podem ser produzidos com função get_summary_stat(), pacote rstatix. Ao ser utilizado em dados agrupados, esta função vai retornar percentis de 0%, 25%, 50%, 75%, e 100%. Se utilizado em dados não agrupados, você pode especificar os percentis com o atributo probs = c(.05, .5, .75, .98).","code":"\n# obtenha os percentis padrões da variável age (0%, 25%, 50%, 75%, 100%)\nlinelist %>% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))## Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in dplyr\n## 1.1.0.\n## ℹ Please use `reframe()` instead.\n## ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()` always\n##   returns an ungrouped data frame and adjust accordingly.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.##   age_percentiles\n## 1               0\n## 2               6\n## 3              13\n## 4              23\n## 5              84\n# obtenha os percentis em diferentes níveis da mesma variável (5%, 50%, 75%, 98%)\nlinelist %>% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )## Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in dplyr\n## 1.1.0.\n## ℹ Please use `reframe()` instead.\n## ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()` always\n##   returns an ungrouped data frame and adjust accordingly.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.##   age_percentiles\n## 1               1\n## 2              13\n## 3              23\n## 4              48\n# obtenha os valores de percentis nos níveis desejados de acordo com a variável age (5%, 50%, 75%, 98%), agrupando os dados por hospital\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )## # A tibble: 6 × 5\n##   hospital                               p05   p50   p75   p98\n##   <chr>                                <dbl> <dbl> <dbl> <dbl>\n## 1 Ausente                                  1    13    23  48.2\n## 2 Central Hospital                         1    12    21  48  \n## 3 Military Hospital                        1    13    24  45  \n## 4 Other                                    1    13    23  50  \n## 5 Port Hospital                            1    14    24  49  \n## 6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\nlinelist %>% \n  group_by(hospital) %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## # A tibble: 6 × 8\n##   hospital                             variable     n  `0%` `25%` `50%` `75%` `100%`\n##   <chr>                                <fct>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\n## 1 Ausente                              age       1441     0     6    13    23     76\n## 2 Central Hospital                     age        445     0     6    12    21     58\n## 3 Military Hospital                    age        884     0     6    14    24     72\n## 4 Other                                age        873     0     6    13    23     69\n## 5 Port Hospital                        age       1739     0     6    14    24     68\n## 6 St. Mark's Maternity Hospital (SMMH) age        420     0     7    12    22     84\nlinelist %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## # A tibble: 1 × 7\n##   variable     n  `0%` `25%` `50%` `75%` `100%`\n##   <fct>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\n## 1 age       5802     0     6    13    23     84"},{"path":"tables-descriptive.html","id":"obtenha-um-resumo-dos-dados-agregados","chapter":"17 Tabelas descritivas","heading":"Obtenha um resumo dos dados agregados","text":"Se você iniciar sua análise com dados agregados, ao utilizar função n() você irá obter o número de linhas, não soma das contagens agregadas. Para obter somas, use função sum() na coluna de contagens.Por exemplo, suponha que você está iniciando com tabela de contagens abaixo, chamada linelist_agg - ela mostra formato “longo” contagens número de casos por outcome e gender.Para fins de exemplificação, abaixo, nós criamos uma tabela de dados com quantidade de casos por outcome e gender dos dados linelist (campos em branco foram removidos para facilitar o entendimento).Para somar contagens (da coluna n) por grupo, você pode usar função summarise() e ajustar nova coluna para ser igual à sum(n, na.rm=T). Para adicionar um elemento condicional à essa operação, você pode selecionar, na coluna de contagem (n), uma parte dos dados utilizando os colchetes [ ].","code":"\nlinelist_agg <- linelist %>% \n  drop_na(gender, outcome) %>% \n  count(outcome, gender)\n\nlinelist_agg##   outcome gender    n\n## 1   Death      f 1227\n## 2   Death      m 1228\n## 3 Recover      f  953\n## 4 Recover      m  950\nlinelist_agg %>% \n  group_by(outcome) %>% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))## # A tibble: 2 × 4\n##   outcome total_cases male_cases female_cases\n##   <chr>         <int>      <int>        <int>\n## 1 Death          2455       1228         1227\n## 2 Recover        1903        950          953"},{"path":"tables-descriptive.html","id":"across-em-mais-de-uma-coluna","chapter":"17 Tabelas descritivas","heading":"across() em mais de uma coluna","text":"Você pode utilizar função summarise() em mais de uma coluna utilizado função across(). Isto torna o trabalho mais fácil quando você quer obter mesma estatística de muitas colunas. Coloque across() dentro de summarise() e especifique o seguinte:.cols = vetor com o nome das colunas c() ou funções auxiliares “tidyselect” (explicado abaixo).fns = função ser aplicada (sem parênteses) - você pode fornecer múltiplas funções dentro de uma list()Abaixo, função mean() é aplicada para diferentes colunas numéricas. Um vetor com colunas é dado explicitamente para o atributo .cols = e uma função simples (mean) é especificada (sem parênteses) em .fns =. Quaisquer argumentos adicionais para função (por ex.: na.rm=TRUE) são colocados após .fns =, separados por uma vírgula.Pode ser difícil acertar ordem dos parênteses e vírgulas ao utilizar across(). Lembre que, dentro across(), você deve incluir colunas, funções, e qualquer argumento extra que seja necessário para funções.Funções múltiplas podem ser executadas de uma vez. Abaixo, o atributo .fns = recebe funções mean e sd dentro de uma list(). Você tem oportunidade de escolher nomes das características (ex.: “mean” e “sd”) que serão colocadas inseridas ao nome das novas colunas.Aqui são funções auxiliares “tidyselect”, que você pode utilizar em .cols = para selecionar colunas:everything() - todas outras colunas não mencionadaslast_col() - última colunawhere() - aplica uma função à todas colunas, e seleciona apenas aquelas que são verdadeiras (TRUE)starts_with() - seleciona colunas cujos nomes iniciam com determinado prefixo. Exemplo: starts_with(\"date\")ends_with() - seleciona colunas cujos normes terminam com determinado sufixo. Exemplo: ends_with(\"_end\")contains() - colunas que contêm determinada sequência de caracteres. Exemplo: contains(\"time\")matches() - aplica sintaxe de uma expressão regular (regex). Exemplo: contains(\"[pt]al\")num_range() -any_of() - seleciona colunas com certos nomes. Útil caso o nome buscado não exista. Exemplo: any_of(date_onset, date_death, cardiac_arrest)Por exemplo, para obter média de cada coluna numérica, use função () e aplique função .numeric() (sem os parêntesese) para escolher colunas numéricas, e então obtenha média com mean. Tudo isso dentro da função across().","code":"\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # colunas utilizadas\n                   .fns = mean,                               # função aplicada\n                   na.rm=T))                                  # argumentos extras## # A tibble: 3 × 5\n##   outcome age_years  temp wt_kg ht_cm\n##   <chr>       <dbl> <dbl> <dbl> <dbl>\n## 1 Death        15.9  38.6  52.6  125.\n## 2 Recover      16.1  38.6  52.5  125.\n## 3 <NA>         16.2  38.6  53.0  125.\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # colunas\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # múltiplas funções\n                   na.rm=T))                                 # argumentos extras## # A tibble: 3 × 9\n##   outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd ht_cm_mean\n##   <chr>            <dbl>        <dbl>     <dbl>   <dbl>      <dbl>    <dbl>      <dbl>\n## 1 Death             15.9         12.3      38.6   0.962       52.6     18.4       125.\n## 2 Recover           16.1         13.0      38.6   0.997       52.5     18.6       125.\n## 3 <NA>              16.2         12.8      38.6   0.976       53.0     18.9       125.\n## # ℹ 1 more variable: ht_cm_sd <dbl>\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(\n    .cols = where(is.numeric),  # all numeric columns in the data frame\n    .fns = mean,\n    na.rm=T))## # A tibble: 3 × 12\n##   outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp   bmi\n##   <chr>        <dbl> <dbl>     <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>\n## 1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6  45.6\n## 2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6  47.7\n## 3 <NA>          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6  48.3\n## # ℹ 1 more variable: days_onset_hosp <dbl>"},{"path":"tables-descriptive.html","id":"tbls_pivot_wider","chapter":"17 Tabelas descritivas","heading":"Utilizando o pivot_wider()","text":"Se você preferir sua tabela formato “largo”, você pode transformar ela utilizando função pivot_wider(), pacote tidyr. Você provavelmente precisará renomear colunas com função rename(). Para mais informações, veja página sobre Pivoteando os dados.O exemplo abaixo utiliza tabela age_by_outcome com formato “longo”, da seção de proporções. Para faciliar o entendimento, nós criamos essa tabela novamente, e mostramos como é seu formato “longo”:Para realizar o pivoteamento para tabela criada fique formato “largo”, nós criamos novas colunas partir dos valores na coluna existente age_cat (ao configurar names_from = age_cat). Nós também especificamos que os valores da nova tabela virão da coluna existente n, utilizando o atributo values_from = n. colunas não mencionadas nosso comando de pivoteamento (outcome) continuarão sem alterações na extremidade esquerda da tabela final.","code":"\nage_by_outcome <- linelist %>%                  # inicie com o linelist\n  group_by(outcome) %>%                         # agrupe por outcome \n  count(age_cat) %>%                            # agrupe e conte por age_cat, e então remova o agrupamento age_cat\n  mutate(percent = scales::percent(n / sum(n))) # calcule a porcentagem - observe que o denominador é o grupo outcome\nage_by_outcome %>% \n  select(-percent) %>%   # para não complicar, mantenha apenas as contagens\n  pivot_wider(names_from = age_cat, values_from = n)  ## # A tibble: 3 × 10\n## # Groups:   outcome [3]\n##   outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\n##   <chr>   <int> <int>   <int>   <int>   <int>   <int>   <int> <int> <int>\n## 1 Death     471   476     438     323     477     329      33     3    32\n## 2 Recover   364   391     303     251     367     238      38     3    28\n## 3 <NA>      260   228     200     169     229     187      24    NA    26"},{"path":"tables-descriptive.html","id":"tbl_dplyr_totals","chapter":"17 Tabelas descritivas","heading":"Adicionando as linhas com os totais","text":"Quando função summarise() é utilizada em dados agrupados, linha com os “totais” não é produzida automaticamente. Abaixo, duas abordagens para adicionar esta linha são mostrados:","code":""},{"path":"tables-descriptive.html","id":"função-adorn_totals-do-pacote-janitor","chapter":"17 Tabelas descritivas","heading":"Função adorn_totals() do pacote janitor","text":"Se sua tabela contém apenas contagens ou proporções/porcentagens, que podem ser somados para obter os totais, então é possível realizar essa soma utilizando função adorn_totals(), pacote janitor, como descrito na seção acima. Observe que esta função consegue somar apenas colunas numéricas - se você quiser calcular outros resumos estatísticos, veja próxima abordagem com o pacote dplyr.Abaixo, os dados linelist são agrupados por gênero e resumidos em uma tabela que descreve o número de casos com evolução conhecida (outcome), mortes (deaths) ou recuperados (recovered). Ao canalizar tabela para função adorn_totals(), uma linha com os totais é adicionada final para refletir soma de cada coluna. próximas funções adorn_*() ajustam o design, como comentado código.","code":"\nlinelist %>% \n  group_by(gender) %>%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # N° de linhas em que o outcome não é desconhecido\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # N° de linhas em que o outcome é Death\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # N° de linhas em que o outcome é Recovered\n  ) %>% \n  adorn_totals() %>%                                # Adiciona a linha 'total' (soma de cada coluna numérica)\n  adorn_percentages(\"col\") %>%                      # Obtenha as proporções\n  adorn_pct_formatting() %>%                        # Converta as proporções para porcentagens\n  adorn_ns(position = \"front\")                      # mostra % e n° absolutos juntos (com n° absoluto na frente)##  gender  known_outcome        n_death      n_recover\n##       f 2,180  (47.8%) 1,227  (47.5%)   953  (48.1%)\n##       m 2,178  (47.7%) 1,228  (47.6%)   950  (47.9%)\n##    <NA>   207   (4.5%)   127   (4.9%)    80   (4.0%)\n##   Total 4,565 (100.0%) 2,582 (100.0%) 1,983 (100.0%)"},{"path":"tables-descriptive.html","id":"uso-da-função-summarise-nos-dados-totais-seguido-por-bind_rows","chapter":"17 Tabelas descritivas","heading":"Uso da função summarise() nos dados “totais” seguido por bind_rows()","text":"Se sua tabela consistir feita de resumos estatísticos como median(), mean(), etc, funçãoadorn_totals() utilizada acima não será suficiente. Assim, para obter o resumo estatístico de todo o banco de dados, você precisa calcular eles com uma função summarise() separada e, então, conectar os resultados à tabela resumo inicial. Para fazer essa conexão, você pode usar função bind_rows(), pacote dplyr, descrito na página Agrupando dados. Abaixo está um exemplo:Você pode criar uma tabela resumo com os resultados da intersecção por hospital, com funções group_by() e summarise() da seguinte forma:Para obter os totais, execute mesma função summarise(), mas com os dados agrupados apenas por outcome (não por hospital), da seguinte forma:Agora, nós podemos unir duas tabelas geradas. Observe que tabela by_hospital tem 4 colunas, enquanto tabela totals tem 3 colunas. Ao utilizar função bind_rows(), colunas são combinadas por nome, onde cada espaço extra (linhas mais) são preenchidos com NA (ex.: na coluna hospital os campos das duas novas linhas de totals). Após unir linhas, nós iremos converter esses espaços em branco para “Total” utilizando função replace_na() (veja página Limpando os dados e funções essenciais).Aqui está nova tabela com linhas “Total” final.Esta tabela está formato “longo/comprido”, que pode ser o desejado. Opcionalmente, você pode mudar essa tabela para o formato largo, de forma torná-la mais fácil de interpretar. Veja seção acima sobre como transformar tabela para o formato “largo”, ou na página Pivoteando dados. Você também pode adicionar mais colunas, e ajustá-las de forma que considere mais agradável. Segue o código:Após isso, você pode exportar essa tabela como uma imagem - abaixo, o resultado é exportado com o pacote flextable. Para mais detalhes sobre esse exemplo, e sobre como produzir uma imagem dessa forma, leia página Tabelas para apresentações.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nby_hospital <- linelist %>% \n  filter(!is.na(outcome) & hospital != \"Missing\") %>%  # Remova os casos sem resultado (outcome) ou nome do hospital\n  group_by(hospital, outcome) %>%                      # Agrupe os dados\n  summarise(                                           # Crie um novo resumo com as colunas com os indicadores de interesse\n    N = n(),                                           # N° de linhas por grupo hospital-outcome     \n    ct_value = median(ct_blood, na.rm=T))              # Obtenha a média dos valores CT por grupo\n  \nby_hospital # exporte a tabela## # A tibble: 12 × 4\n## # Groups:   hospital [6]\n##    hospital                             outcome     N ct_value\n##    <chr>                                <chr>   <int>    <dbl>\n##  1 Ausente                              Death     611       21\n##  2 Ausente                              Recover   514       21\n##  3 Central Hospital                     Death     193       22\n##  4 Central Hospital                     Recover   165       22\n##  5 Military Hospital                    Death     399       21\n##  6 Military Hospital                    Recover   309       22\n##  7 Other                                Death     395       22\n##  8 Other                                Recover   290       21\n##  9 Port Hospital                        Death     785       22\n## 10 Port Hospital                        Recover   579       21\n## 11 St. Mark's Maternity Hospital (SMMH) Death     199       22\n## 12 St. Mark's Maternity Hospital (SMMH) Recover   126       22\ntotals <- linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Agrupado apenas por outcome, não por hospital    \n      summarise(\n        N = n(),                                       # Essas estatísticas são apenas por outcome\n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # exporte a tabela gerada## # A tibble: 2 × 3\n##   outcome     N ct_value\n##   <chr>   <int>    <dbl>\n## 1 Death    2582       22\n## 2 Recover  1983       21\ntable_long <- bind_rows(by_hospital, totals) %>% \n  mutate(hospital = replace_na(hospital, \"Total\"))\ntable_long %>% \n  \n  # Muda para o formato amplo e formata a tabela\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Mude de \"longo\" para \"largo\"\n    values_from = c(ct_value, N),                       # novos valores provenientes das colunas ct e de contagen (n)\n    names_from = outcome) %>%                           # novos nomes das colunas proveniente dos outcomes\n  mutate(                                              # adiciona novas colunas\n    N_Known = N_Death + N_Recover,                               # casos com evolução (outcome) conhecido\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percentual de casos que evoluíram para óbito (até 1ª casa decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percentual de casos que recuperaram (até a 1ª casa decimal)\n  select(                                              # Reordena as colunas\n    hospital, N_Known,                                   # Coluna introdutórias\n    N_Recover, Pct_Recover, ct_value_Recover,            # Colunas dos recuperados\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Colunas de óbitos\n  arrange(N_Known)                                  # Organize as linhas do menor para o maior (linha com totais por último)## # A tibble: 7 × 8\n## # Groups:   hospital [7]\n##   hospital            N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n##   <chr>                 <int>     <int> <chr>                  <dbl>   <int> <chr>    \n## 1 St. Mark's Materni…     325       126 38.8%                     22     199 61.2%    \n## 2 Central Hospital        358       165 46.1%                     22     193 53.9%    \n## 3 Other                   685       290 42.3%                     21     395 57.7%    \n## 4 Military Hospital       708       309 43.6%                     22     399 56.4%    \n## 5 Ausente                1125       514 45.7%                     21     611 54.3%    \n## 6 Port Hospital          1364       579 42.4%                     21     785 57.6%    \n## 7 Total                  4565      1983 43.4%                     21    2582 56.6%    \n## # ℹ 1 more variable: ct_value_Death <dbl>"},{"path":"tables-descriptive.html","id":"tbl_gt","chapter":"17 Tabelas descritivas","heading":"17.5 Pacote gtsummary","text":"Se você quer exportar seu resumo estatístico em um gráfico ‘bonito’, pronto para publicação, você pode usar o pacote gtsummary e sua função tbl_summary(). Em um primeiro momento, o código pode parecer complexo, mas tabelas geradas são lindas e exportadas para o seu painel RStudio Viewer como uma imagem HTML. Veja um tutorial mais detalhado aqui.Você também pode adicionar os resultados dos testes estatísticos nas tabelas geradas pelo gtsummary. Este processo está decrito na seção gtsummary, da página testes estatísticos simples.Para introduzir função tbl_summary(), nós vamos primeiro demostrar seu funcionamento básico, que produz uma tabela bonita e extensa. Então, examinaremos em detalhes como fazer ajustes finos e tabelas mais customizadas.","code":""},{"path":"tables-descriptive.html","id":"tabela-resumo","chapter":"17 Tabelas descritivas","heading":"Tabela resumo","text":"O comportamento padrão tbl_summary() é incrível - ele utiliza colunas fornecidas e cria uma tabela resumo em apenas um comando. Esta função realiza estatísticas apropriadas de acordo com classe da coluna: média e intervalo interquartil (IQR) para colunas numéricas, e contagens (%) para colunas categóricas. Valores em branco são convertidos para “Unknown”. Notas de rodapé são adicionadas para explicar estatísticas utilizadas, enquanto quantidade total N é mostrada topo.","code":"\n# Use a função abaixo para que a tabela saia em portugês\n\ntheme_gtsummary_language(\"pt\")\n\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>%  # mantenha apenas as colunas de interesse\n  tbl_summary()                                                  # função no modo padrão"},{"path":"tables-descriptive.html","id":"ajustes","chapter":"17 Tabelas descritivas","heading":"Ajustes","text":"Agora iremos explicar como esta função funciona e como fazer ajustes. Os argumentos chave estão detalhados abaixo:=\nVocê pode estratificar sua tabela utilizando uma coluna (ex.: outcome), ao criar uma tabela de duas vias.statistic =\nUse equações para especificar quais estatísticas mostrar e como mostrá-las. Existem dois lados para essa equação, separados por um til ~. lado direito, entre aspas, é colocado o teste estatístico desejado, e lado esquerdo são colocadas colunas em que esse teste será aplicado.O lado direito da equação utiliza sintaxe da função str_glue(), pacote stringr (veja mais em Caractéres e Strings), com o texto ser mostrado entre aspas e o teste estatístico dentro de colchetes encaracolados { }. Você pode incluir estatísticas como “n” (para contagens), “N” (para denominador), “mean” (média), “median” (mediana), “sd” (desvio padrão), “max” (valor máximo), “min” (valor mínimo), percentis “p##” como “p25”, ou percentual total como “p”. Utilize o comando ?tbl_summary para mais detalhes.lado esquerdo da equação, você pode especificar colunas por nome (ex.: age ou c(age, gender)) ou utilizando funções auxiliares como all_continuous(), all_categorical(), contains(), starts_with(), etc.Uma exemplo simples da equação statistic = é mostrado abaixo, onde apenas média da coluna age_years é obtida:Uma equação um pouco mais complexa é obtida \"({min}, {max})\", incorporando os valores mínimos e máximos dentro de parênteses e separados por vírgula:Você também pode utilizar uma sintaxe diferente para colunas distintas ou diferentes tipos de colunas. Em um exemplo mais complexo, mostrado abaixo, o argumento dado à statistic = é uma list (list) indicando que para todas colunas com valores contínuos, tabela deve gerar média com o desvio padrão em parênteses, enquanto que, para colunas categóricas, ela deve gerar o n, o denominador, e o percentual.digits =\nAjuste quantidade de dígitos e de arredondamento. Opcionalmente, isto pode ser limitado à colunas contínuas apenas (como mostrado abaixo).label =\nAjuste como o rótulo da coluna deve ser mostrado. Forneça o nome da coluna e o rótulo desejado, separado por um til ~. O padrão rótulo é o nome da coluna.missing_text =\nAjuste como os campos em branco são mostrados. opção padrão é “Unknown”.type =\nIsto é utilizado para ajustar quantos níveis das estatísticas são mostradas. sintaxe é similar ao atributo statistic =, pois você fornece uma equação com colunas lado esquerdo, e um valor lado direito. Dois cenários comuns incluem:type = all_categorical() ~ \"categorical\" Força colunas dicotômicas (ex.: fever sim/não) mostrar todos os níveis em vez de apenas linha “sim”type = all_continuous() ~ \"continuous2\" Permite realização de estatísticas em múltiplas linha (“multi-line”) por variável, como mostrado em seção posteriorNo exemplo abaixo, cada um desses argumentos é utilizado para modificar tabela resumo original:","code":"\nlinelist %>% \n  select(age_years) %>%         # mantenha apenas as colunas de interesse\n  tbl_summary(                  # crie uma tabela resumo\n    statistic = age_years ~ \"{mean}\") # calcule a média de idades (age)\nlinelist %>% \n  select(age_years) %>%                       # mantenha apenas as colunas de interesse\n  tbl_summary(                                # crie uma tabela resumo\n    statistic = age_years ~ \"({min}, {max})\") # calcule o min e max da idade (age)\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>% # utilize apenas as colunas de interesse\n  tbl_summary(     \n    by = outcome,                                               # estratifique a tabela inteira pelo outcome\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # estatísticas e formatação para colunas contínuas\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # estatísticas e formatação para colunas categóricas\n    digits = all_continuous() ~ 1,                              # arredondamento para colunas contínuas\n    type   = all_categorical() ~ \"categorical\",                 # force todos os níveis de colunas categóricas a serem mostrados\n    label  = list(                                              # mostre etiquetas de acordo com o nome das colunas\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # como valores em branco devem ser mostrados\n  )## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`."},{"path":"tables-descriptive.html","id":"estatísticas-de-múltiplas-linhas-multi-line-para-variáveis-contínuas","chapter":"17 Tabelas descritivas","heading":"Estatísticas de múltiplas linhas (“multi-line”) para variáveis contínuas","text":"Se você quiser obter múltiplas linhas de estatísticas para variáveis contínuas, é possível indicar isto ao ajustar o atributo type = para “continuous2”. É possível combinar todos os elementos mostrados anteriormente em uma tabela, ao escolher quais estatísticas quer mostrar. Para fazer isso, é necessário ‘dizer’ para função que você quer tabela de volta ao inserir seu tipo como “continous2”. quantidade de campos em braco é mostrado como “Unknown”.Existem diversas formas de modificar essas tabelas, como adicionar valores p, ajustar cores e títulos, etc. Muitas destas modificações estão descritas na documentação (digite ?tbl_summary Console), e algumas destas são mostradas na seção sobre testes estatísticos.","code":"\nlinelist %>% \n  select(age_years, temp) %>%                      # mantenha apenas colunas de interesse\n  tbl_summary(                                     # crie tabelas resumo\n    type = all_continuous() ~ \"continuous2\",       # indique que você quer obter mais de uma estatística\n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # linha 1: média e desvio padrão\n      \"{median} ({p25}, {p75})\",                   # linha 2: média e IQR\n      \"{min}, {max}\")                              # linha 3: min e max\n    )"},{"path":"tables-descriptive.html","id":"pacote-r-base","chapter":"17 Tabelas descritivas","heading":"17.6 Pacote R base","text":"Você pode usar função table() para tabular e realizar tabulações cruzadas das colunas. Diferente das opções acima, você precisa especificar o quadro de dados cada vez que o nome de uma coluna é apontado, como mostrado abaixo.CUIDADO: NA valores em branco não serão tabulados não ser que você coloque o argumento useNA = \"always\" (que também pode ser ajustado para “” ou “ifany”).DICA: É possível usar o %$% pacote magrittr para remover necessidade de repetir quantidade de vezes que o quadro de dados é chamado dentro das funções pacote R base. Por exemplo, o código abaixo poderia ser reescrito como linelist %$% table(outcome, useNA = \"always\")Múltiplas colunas podem ser utilizadas para tabulação cruzada ao listá-las uma após outra, separadas por vírgulas. Opcionalmente, você pode dar um “nome” cada coluna, como em Outcome = linelist$outcome.","code":"\ntable(linelist$outcome, useNA = \"always\")## \n##   Death Recover    <NA> \n##    2582    1983    1323\nage_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # salve a tabela como objeto\nage_by_outcome   # exporte a tabela##        \n##         Death Recover <NA>\n##   0-4     471     364  260\n##   5-9     476     391  228\n##   10-14   438     303  200\n##   15-19   323     251  169\n##   20-29   477     367  229\n##   30-49   329     238  187\n##   50-69    33      38   24\n##   70+       3       3    0\n##   <NA>     32      28   26"},{"path":"tables-descriptive.html","id":"proporções","chapter":"17 Tabelas descritivas","heading":"Proporções","text":"Para obter proporções, utilize tabela acima na função prop.table(). Use o argumento margins = para especificar caso você queira que proporções sejam calculadas das linhas (1), colunas (2), ou da tabela inteira (3). código abaixo, encadeamos (“piped”) tabela com função round(), R base, especificando 2 dígitos.","code":"\n# obtenhas as proporções da tabela definida acima, por linhas, arredondado\nprop.table(age_by_outcome, 1) %>% round(2)##        \n##         Death Recover <NA>\n##   0-4    0.43    0.33 0.24\n##   5-9    0.43    0.36 0.21\n##   10-14  0.47    0.32 0.21\n##   15-19  0.43    0.34 0.23\n##   20-29  0.44    0.34 0.21\n##   30-49  0.44    0.32 0.25\n##   50-69  0.35    0.40 0.25\n##   70+    0.50    0.50 0.00\n##   <NA>   0.37    0.33 0.30"},{"path":"tables-descriptive.html","id":"totais","chapter":"17 Tabelas descritivas","heading":"Totais","text":"Para adicionar colunas e linhas com totais, passe tabela gerada para função addmargins(). Isto funciona para contagens e proporções.","code":"\naddmargins(age_by_outcome)##        \n##         Death Recover <NA>  Sum\n##   0-4     471     364  260 1095\n##   5-9     476     391  228 1095\n##   10-14   438     303  200  941\n##   15-19   323     251  169  743\n##   20-29   477     367  229 1073\n##   30-49   329     238  187  754\n##   50-69    33      38   24   95\n##   70+       3       3    0    6\n##   <NA>     32      28   26   86\n##   Sum    2582    1983 1323 5888"},{"path":"tables-descriptive.html","id":"converta-para-um-quadro-de-dados","chapter":"17 Tabelas descritivas","heading":"Converta para um quadro de dados","text":"Converter um objeto table() diretamente para um quadro de dado (data frame)s não é simples. Uma possível abordagem é mostrada abaixo:Crie tabela, sem utilizar useNA = \"always\". Em vez disso, converta os valores NA para “(Missing)” com função fct_explicit_na(), pacote forcats.Adicione os totais (opcional) ao aplicar tabela na função addmargins()Utilize tabela na função R base .data.frame.matrix()Transforme tabela utilizando função pacote tibble, rownames_to_column(), especificando o nome da primeira colunaExporte, Visualize, ou exporte como desejado. Neste exemplo, nós utilizamos função flextable(), pacote flextable, como descrito na página Tabelas para apresentação. Isto irá exportar tabela para o RStudio viewer como uma linda imagem HTML.Age CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888","code":"\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% \n  addmargins() %>% \n  as.data.frame.matrix() %>% \n  tibble::rownames_to_column(var = \"Age Category\") %>% \n  flextable::flextable()"},{"path":"tables-descriptive.html","id":"recursos-extras","chapter":"17 Tabelas descritivas","heading":"17.7 Recursos extras","text":"Muitas das informações desta página foram adaptadas destes recursos e tutoriais online:gtsummarydplyr","code":""},{"path":"stat-tests.html","id":"stat-tests","chapter":"18 Testes estatísticos simples","heading":"18 Testes estatísticos simples","text":"Esta página demonstra como realizar testes estatísticos simples com os pacotes R base, rstatix, e gtsummary.Teste tTeste de Shapiro-WilkTeste de WilcoxonTeste de Kruskal-WallisTeste qui-quadrado de PearsonCorrelações entre variáveis numéricas…muitos outros testes podem ser realizados, mas mostramos apenas os mais comuns e fornecemos links para outras fontes.Cada um dos pacotes acima possui certas vantagens e desvantagens:Utilize funções pacote R base para exportar resultados estatísticos para o console RUtilize funções pacote rstatix para gerar os resultados em um quadro de dados, ou caso queira que os testes sejam realizados por gruposUtilize o pacote gtsummary para exportar facilmente tabelas prontas para publicação.","code":""},{"path":"stat-tests.html","id":"preparação-9","chapter":"18 Testes estatísticos simples","heading":"18.1 Preparação","text":"","code":""},{"path":"stat-tests.html","id":"carregue-os-pacotes-1","chapter":"18 Testes estatísticos simples","heading":"Carregue os pacotes","text":"Este pequeno código carrega os pacotes necessários para análises. Neste manual, nós estimulamos o uso da função p_load(), pacman, que instala os pacotes, caso necessários, e os carrega para utilização. Também é possível carregar pacotes já instalados com função library() pacote R base. Veja página sobre Introdução ao R para mais informações sobre pacotes R.","code":"\npacman::p_load(\n  rio,          # Importa arquivos\n  here,         # Localiza arquivos\n  skimr,        # visualize os dados\n  tidyverse,    # gerenciamento dos dados + gráficos no ggplot2, \n  gtsummary,    # resumo estatístico e testes\n  rstatix,      # estatísticas\n  corrr,        # análise de correlação entre variáveis numéricas\n  janitor,      # adicione totais e porcentagens às tabelas\n  flextable     # converte tabelas para o formato HTML\n  )"},{"path":"stat-tests.html","id":"importando-os-dados","chapter":"18 Testes estatísticos simples","heading":"Importando os dados","text":"Nós iremos importar o banco de dados dos casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para baixar o banco “limpo” (como arquivo .rds). Importe os dados com função import(), pacote rio (ela aceita muitos formatos de arquivos, como .xlsx, .rds, .csv - veja página Importar e exportar para detalhes).primeiras 50 linhas dos dados são mostradas abaixo.","code":"\n# importa o 'linelist'\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"stat-tests.html","id":"pacote-r-base-1","chapter":"18 Testes estatísticos simples","heading":"18.2 Pacote R base","text":"Você pode utilizar funções pacote R base para realizar testes estatísticos. Os comandos são relativamente simples, e os resultados são exportados para o terminal R para visualização. Entretanto, normalmente os resultados são gerados formato de listas, o que dificulta manipulação, caso queira utilizá-los posteriormente.","code":""},{"path":"stat-tests.html","id":"testes-t","chapter":"18 Testes estatísticos simples","heading":"Testes T","text":"O teste t, também chamando de “Teste t de Student”, é tipicamente utilizado para determinar se existem diferenças significativas entre médias de variáveis numéricas de dois grupos distintos. Aqui, nós iremos mostrar duas sintaxes para realizar esse teste, de acordo com presença ou não das colunas mesmo quadro de dados.Sintaxe 1: Esta é sintaxe utilizada quando colunas numéricas e categóricas estão mesmo quadro de dados (data frame). Especifique coluna numérica lado esquerdo da equação, e coluna categórica lado direito. Coloque o nome banco de dados argumento data =. Opcionalmente, ajuste os argumentos paired = TRUE, conf.level = para (0.95 default), e alternative = para (“two.sided”, “less”, ou “greater”). Digite ?t.test para mais detalhes.Sintaxe 2: Você pode comparar dois vetores numéricos separados com essa sintaxe. Por exemplo, se duas colunas estão em bancos de dados distintos.Também é possível utilizar o teste t para determinar se média de uma amostra é significativamente diferente de algum valor específico. Aqui, nós aplicamos o teste t entre uma amostra e uma média conhecida/suposta de uma população (mu =):","code":"\n## compare a média das idades de acordo com o sexo com um teste t\nt.test(age_years ~ gender, data = linelist)## \n##  Welch Two Sample t-test\n## \n## data:  age_years by gender\n## t = -21.344, df = 4902.3, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.571920 -6.297975\n## sample estimates:\n## mean in group f mean in group m \n##        12.60207        19.53701\nt.test(df1$age_years, df2$age_years)\nt.test(linelist$age_years, mu = 45)"},{"path":"stat-tests.html","id":"teste-de-shapiro-wilk","chapter":"18 Testes estatísticos simples","heading":"Teste de Shapiro-Wilk","text":"O teste de Shapiro-Wilk pode ser utilizado para determinar se uma amostra foi obtida de uma população com distribuição normal (um pré-requisito de muitos outros testes e análises, como o teste t). Entretanto, isto só pode ser utilizado em uma amostra de 3 5000 observações. Para amostras maiores, um gráfico de Quantil-Quantil é recomendado.","code":"\nshapiro.test(linelist$age_years)"},{"path":"stat-tests.html","id":"teste-de-wilcoxon","chapter":"18 Testes estatísticos simples","heading":"Teste de Wilcoxon","text":"O teste de Wilcoxon, também chamado de teste U de Mann–Whitney, é frequentemente utilizado para determinar se duas amostras numéricas possuem mesma distribuição, mesmo quando suas populações não possuem distribuição normal ou possuem variância independente (desiguais).","code":"\n## compare a distribuição da idade de acordo com o grupo 'outcome' utilizando o teste wilcox\nwilcox.test(age_years ~ outcome, data = linelist)## \n##  Wilcoxon rank sum test with continuity correction\n## \n## data:  age_years by outcome\n## W = 2501868, p-value = 0.8308\n## alternative hypothesis: true location shift is not equal to 0"},{"path":"stat-tests.html","id":"teste-de-kruskal-wallis","chapter":"18 Testes estatísticos simples","heading":"Teste de Kruskal-Wallis","text":"O tesde de Kruskal-Wallis é uma extensão teste de Wilcoxon que pode ser utilizado para verificar diferenças na distribuição de mais de duas amostras. Quando apenas duas amostras são utilizadas, os resultados são idênticos ao teste de Wilcoxon.","code":"\n## compare a distribuição da idade de acordo com o grupo 'outcome' utilizando o teste de kruskal-wallis\nkruskal.test(age_years ~ outcome, linelist)## \n##  Kruskal-Wallis rank sum test\n## \n## data:  age_years by outcome\n## Kruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308"},{"path":"stat-tests.html","id":"teste-de-qui-quadrado","chapter":"18 Testes estatísticos simples","heading":"Teste de qui-quadrado","text":"O teste qui-quadrado de Pearson é utilizado para verificar se existem diferenças significativas entre grupos categóricos.","code":"\n## compare as proporções em cada grupo utilizando o teste do qui-quadrado\nchisq.test(linelist$gender, linelist$outcome)## \n##  Pearson's Chi-squared test with Yates' continuity correction\n## \n## data:  linelist$gender and linelist$outcome\n## X-squared = 0.0011841, df = 1, p-value = 0.9725"},{"path":"stat-tests.html","id":"pacote-rstatix","chapter":"18 Testes estatísticos simples","heading":"18.3 Pacote rstatix","text":"O pacote rstatix realiza testes estatísticos e gera os resultados de forma que possam ser manipulados (“pipe-friendly”). Os resultados são gerados automaticamente em um quadro de dados (data frame), sendo possível realizar operações posteriores com eles. Também é fácil agrupar os dados utilizados nas funções, podendo estatísticas serem executadas por cada grupo.","code":""},{"path":"stat-tests.html","id":"estatísticas-resumo","chapter":"18 Testes estatísticos simples","heading":"Estatísticas resumo","text":"função get_summary_stats() é uma maneira rápida de gerar resultados estatísticos. Simplesmente aplique seu banco de dados nessa função, e escolha colunas para analisar. Se nenhuma coluna especificada, estatísticas são calculadas com todas colunas.Por padrão, um resumo estatístico completo é gerado: n, max, min, mediana, 25%ile, 75%ile, IQR, desvio absoluto mediano (mad), média, desvio padrão, erro padrão, e o intervalo de confiança da média.Você pode especificar um sub-grupo resumo estatístico ser gerado, ao fornecer um dos seguintes valores ao argumento type =: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci”, “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.Esta função também pode ser utilizada com dados agrupados, de forma que uma linha é gerada por cada variável agrupável:O pacote rstatix também pode ser utilizado para realizar testes estatísticos:","code":"\nlinelist %>%\n  rstatix::get_summary_stats(age, temp)## # A tibble: 2 × 13\n##   variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se    ci\n##   <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl> <dbl>\n## 1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166 0.325\n## 2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013 0.025\nlinelist %>%\n  group_by(hospital) %>%\n  rstatix::get_summary_stats(age, temp, type = \"common\")## # A tibble: 12 × 11\n##    hospital           variable     n   min   max median   iqr  mean     sd    se    ci\n##    <chr>              <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n##  1 Ausente            age       1441   0    76     13    17    16.0 12.9   0.339 0.665\n##  2 Ausente            temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \n##  3 Central Hospital   age        445   0    58     12    15    15.7 12.5   0.591 1.16 \n##  4 Central Hospital   temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\n##  5 Military Hospital  age        884   0    72     14    18    16.1 12.4   0.417 0.818\n##  6 Military Hospital  temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\n##  7 Other              age        873   0    69     13    17    16.0 12.5   0.422 0.828\n##  8 Other              temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\n##  9 Port Hospital      age       1739   0    68     14    18    16.3 12.7   0.305 0.598\n## 10 Port Hospital      temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\n## 11 St. Mark's Matern… age        420   0    84     12    15    15.7 12.4   0.606 1.19 \n## 12 St. Mark's Matern… temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095"},{"path":"stat-tests.html","id":"teste-t","chapter":"18 Testes estatísticos simples","heading":"Teste t","text":"Utilize sintaxe para especificar colunas numérica e categórica:Ou utilize ~ 1 e especifique mu = para realizar o teste t de uma amostra. Isto também pode ser realizado por grupos.Se necessário, os testes estatísticos podem ser realizados por grupos, como mostrado abaixo:","code":"\nlinelist %>% \n  t_test(age_years ~ gender)## # A tibble: 1 × 10\n##   .y.       group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl> <dbl>    <dbl>    <dbl> <chr>       \n## 1 age_years f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****\nlinelist %>% \n  t_test(age_years ~ 1, mu = 30)## # A tibble: 1 × 7\n##   .y.       group1 group2         n statistic    df     p\n## * <chr>     <chr>  <chr>      <int>     <dbl> <dbl> <dbl>\n## 1 age_years 1      null model  5802     -84.2  5801     0\nlinelist %>% \n  group_by(gender) %>% \n  t_test(age_years ~ 1, mu = 18)## # A tibble: 3 × 8\n##   gender .y.       group1 group2         n statistic    df         p\n## * <chr>  <chr>     <chr>  <chr>      <int>     <dbl> <dbl>     <dbl>\n## 1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\n## 2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\n## 3 <NA>   age_years 1      null model   192     -3.80   191 1.96e-  4"},{"path":"stat-tests.html","id":"tesde-de-shapiro-wilk","chapter":"18 Testes estatísticos simples","heading":"Tesde de Shapiro-Wilk","text":"Como dito acima, o tamanho da amostra precisa estar entre 3 e 5000.","code":"\nlinelist %>% \n  head(500) %>%            # primeiras 500 linhas dos dados em linelist, para exemplificação apenas\n  shapiro_test(age_years)## # A tibble: 1 × 3\n##   variable  statistic        p\n##   <chr>         <dbl>    <dbl>\n## 1 age_years     0.917 6.67e-16"},{"path":"stat-tests.html","id":"tesde-de-wilcoxon","chapter":"18 Testes estatísticos simples","heading":"Tesde de Wilcoxon","text":"","code":"\nlinelist %>% \n  wilcox_test(age_years ~ gender)## # A tibble: 1 × 9\n##   .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl>    <dbl>    <dbl> <chr>       \n## 1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****"},{"path":"stat-tests.html","id":"teste-de-kruskal-wallis-1","chapter":"18 Testes estatísticos simples","heading":"Teste de Kruskal-Wallis","text":"Também conhecido como teste U de Mann-Whitney.","code":"\nlinelist %>% \n  kruskal_test(age_years ~ outcome)## # A tibble: 1 × 6\n##   .y.           n statistic    df     p method        \n## * <chr>     <int>     <dbl> <int> <dbl> <chr>         \n## 1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis"},{"path":"stat-tests.html","id":"teste-do-qui-quadrado","chapter":"18 Testes estatísticos simples","heading":"Teste do Qui-quadrado","text":"função teste Qui-quadrado pode utilizar uma tabela, então primeiro criamos uma tabulação cruzada. Existem diversas formas de realizar isto (veja página de Tabelas descritivas), mas aqui utilizamos função tabyl(), pacote janitor, e então removemos coluna mais esquerda (com os nomes) antes de utilizá-la na função chisq_test().Muitas outras funções e testes estatísticos podem ser realizados com funções rstatix. Veja documentação rstatix online aqui ou digite ?rstatix.","code":"\nlinelist %>% \n  tabyl(gender, outcome) %>% \n  select(-1) %>% \n  chisq_test()## # A tibble: 1 × 6\n##       n statistic     p    df method          p.signif\n## * <dbl>     <dbl> <dbl> <int> <chr>           <chr>   \n## 1  5888      3.53 0.473     4 Chi-square test ns"},{"path":"stat-tests.html","id":"stats_gt","chapter":"18 Testes estatísticos simples","heading":"18.4 Pacote gtsummary","text":"Use o gtsummary se você quiser adicionar os resultados de um teste estatístico em uma tabela criada com esse pacote (como descrito na seção gtsummary na página de Tabelas descritivas).Para realizar testes estatísticos de comparação com função tbl_summary, basta adicionar função add_p na tabela e especificar qual teste utilizar. É possível obter os p-valores corrigidos para testes múltiplos ao utilizar função add_q. Utilize o comando ?tbl_summary para mais detalhes.","code":""},{"path":"stat-tests.html","id":"teste-qui-quadrado","chapter":"18 Testes estatísticos simples","heading":"Teste Qui-quadrado","text":"Compare proporções de uma variável categórica em dois grupos. O teste estatístico padrão para função add_p() para uma variável categórica é o teste Qui-quadrado de independência com correção de continuidade. Entretanto, caso alguma contagem seja abaixo de 5, o teste exato de Fisher é utilizado em seu lugar.","code":"\ntheme_gtsummary_language(\"pt\") # acrescentando tradução para o portugues## Setting theme `language: pt`\nlinelist %>% \n  select(gender, outcome) %>% # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %>%  #só traduzindo \n  tbl_summary(by = outcome, # produza uma tabela resumo e especifique a variável de agrupamento\n              label = list( gender ~\"gênero\")) %>% # traduzindo o rótulo\n  add_p()                        # especifique qual teste estatístico realizar %>% ## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"testes-t-1","chapter":"18 Testes estatísticos simples","heading":"Testes t","text":"Compare diferença média de uma variável contínua em dois grupos.\nPor exemplo, compare média das idades de acordo com evolução clínica paciente.","code":"\nlinelist %>% \n  select(age_years, outcome) %>%             # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %>%  #só traduzindo \n  tbl_summary(                               # produza uma tabela resumo\n    statistic = age_years ~ \"{mean} ({sd})\", # especifique quais estatísticas mostrar\n    by = outcome, # especifique a variável de agrupamento\n    label = list(age_years ~ \"idade\")) %>%   # traduzindo                     \n  add_p(age_years ~ \"t.test\")                # especifique quais testes realizar## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"teste-de-wilcoxon-1","chapter":"18 Testes estatísticos simples","heading":"Teste de Wilcoxon","text":"Compare distribuição de uma variável contínua em dois grupos. O padrão é utilizar o teste de Wilcoxon e mediana (IQR) quando comparar dois grupos. Entretanto, para dados sem distribuição normal ou ao comparar grupos múltiplos, o teste de Kruskal-Wallis é o mais apropriado.","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %>% # traduzindo\n  tbl_summary(                                         # produz uma tabela resumo\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # especifique quais estatísticas mostrar (estes valores são padrão e podem ser removidos)\n    by = outcome, # especifique a variável de agrupamento\n    label = list( age_years ~ \"idade\")) %>%    # traduxindo                              \n  add_p(age_years ~ \"wilcox.test\")                     # especifique qual teste realizar (existem testes padrão, então é possível deixar os parênteses em branco)## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"teste-de-kruskal-wallis-2","chapter":"18 Testes estatísticos simples","heading":"Teste de Kruskal-wallis","text":"Compare distribuição de uma variável contínua em dois ou mais grupos, independentemente dos dados terem distribuição normal ou não.","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %>% # traduzindo\n  tbl_summary(                                         # produza tabelas resumo\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # especifique quais estatísticas mostrar (existem valores padrão, então pode-se deixar os parênteses em branco)\n    by = outcome, # especifique a variável de agrupamento\n    label = list(age_years ~ \"idade\")) %>%     # traduzindo                             \n  add_p(age_years ~ \"kruskal.test\")                    # especifique qual teste realizar## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"correlações","chapter":"18 Testes estatísticos simples","heading":"18.5 Correlações","text":"Correlações entre variáveis numéricas podem ser investigadas utilizando os pacotes tidyverse corrr. Assim, é possível realizar os testes de correlação de Pearson, tau (\\(\\tau\\)) de Kendall ou rho (\\(\\rho\\)) de Spearman. O pacote cria uma tabela e tem uma função para gerar um gráfico os valores automaticamente.","code":"\ncorrelation_tab <- linelist %>% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # selecione as variáveis numéricas de interesse\n  correlate()      # cria uma tabela de correlação (utilizando o teste padrão pearson)\n\ncorrelation_tab    # exporte a tabela para o terminal ## # A tibble: 6 × 7\n##   term            generation       age ct_blood days_onset_hosp    wt_kg    ht_cm\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>    <dbl>    <dbl>\n## 1 generation        NA       -0.0222    0.179         -0.288    -0.0302  -0.00942\n## 2 age               -0.0222  NA         0.00849       -0.000635  0.833    0.877  \n## 3 ct_blood           0.179    0.00849  NA             -0.600    -0.00636  0.0181 \n## 4 days_onset_hosp   -0.288   -0.000635 -0.600         NA         0.0153  -0.00953\n## 5 wt_kg             -0.0302   0.833    -0.00636        0.0153   NA        0.884  \n## 6 ht_cm             -0.00942  0.877     0.0181        -0.00953   0.884   NA\n## remove entradas duplicadas (a tabela acima é espelhada) \ncorrelation_tab <- correlation_tab %>% \n  shave()\n\n## visualize a a tabela de correlação\ncorrelation_tab## # A tibble: 6 × 7\n##   term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>  <dbl> <dbl>\n## 1 generation        NA       NA        NA              NA       NA        NA\n## 2 age               -0.0222  NA        NA              NA       NA        NA\n## 3 ct_blood           0.179    0.00849  NA              NA       NA        NA\n## 4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\n## 5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\n## 6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n## plote as correlações\nrplot(correlation_tab)"},{"path":"stat-tests.html","id":"recursos-10","chapter":"18 Testes estatísticos simples","heading":"18.6 Recursos","text":"Muitas informações dessa página foram adaptadas dos recursos e tutoriais online abaixo:gtsummary\ndplyr\ncorrr\nsthda correlation","code":""},{"path":"regression.html","id":"regression","chapter":"19 Regressão simples e múltipla","heading":"19 Regressão simples e múltipla","text":"Esta página demonstra o uso das funções de regressão pacote R base , como glm(), e o pacote gtsummary para\nverificar associações entre variáveis (ex.: riscos relativos, relações de risco e hazard ratio).\nTambém serão mostradads funções como tidy(), pacote broom, para limpar os resultados da regressão.Univariado: tabelas 2 x 2Estratificado: método de Mantel-HaenszelMultivariada: seleção variada, seleção de modelo, tabela finalGráfico em florestaPara realizar regressão proporcional de riscos (regressão Cox), veja página Análise de sobrevivência.NOTE: O termo multivariável é utilizado aqui ao se referir à uma regressão com múltiplas variáveis explicativas. Assim, um modelo multivariado seria uma regressão com diferentes resultados - veja esse editorial para detalhes ","code":""},{"path":"regression.html","id":"preparação-10","chapter":"19 Regressão simples e múltipla","heading":"19.1 Preparação","text":"","code":""},{"path":"regression.html","id":"carregue-os-pacotes-2","chapter":"19 Regressão simples e múltipla","heading":"Carregue os pacotes","text":"Este código realiza o carregamento dos pacotes necessários para análises. Neste manual, nós enfatizamos o uso da função p_load(), pacote pacman, que instala os pacotes, caso necessário, e os carrega para utilização. Você também pode utilizar função library(), pacote R base , para carregar pacotes instalados. Veja página sobre o Introdução ao R](#basics) para mais informações sobre os pacotes R.","code":"\npacman::p_load(\n  rio,          # Importa arquivos\n  here,         # Localiza arquivos\n  tidyverse,    # gestão dos dados + gráficos no ggplot2\n  stringr,      # manipulação de textos em formato string\n  purrr,        # explore os objetos de forma organizada\n  gtsummary,    # resumos estatísticos e testes\n  broom,        # organize os resultados das regressões\n  lmtest,       # testes de relação de verosimilhança\n  parameters,   # alternativa para organizar os resultados das regressões\n  see           # alternativa para visualizar os gráficos em floresta\n  )"},{"path":"regression.html","id":"importe-os-dados-2","chapter":"19 Regressão simples e múltipla","heading":"Importe os dados","text":"Nós iremos importar o banco de dados dos casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando função import(), pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja página Importar e exportar para detalhes).primeiras 50 linhas linelist são mostradas abaixo.","code":"\n# importe os dados no R no objeto linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"regression.html","id":"limpando-os-dados","chapter":"19 Regressão simples e múltipla","heading":"Limpando os dados","text":"","code":""},{"path":"regression.html","id":"armazene-as-variáveis-explicativas","chapter":"19 Regressão simples e múltipla","heading":"Armazene as variáveis explicativas","text":"código abaixo, os nomes das colunas explicativas são salvos como um vetor de caracteres. Eles serão utilizados posteriormente.","code":"\n## escolha as variáveis de interesse\nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")"},{"path":"regression.html","id":"converta-para-1s-e-0s","chapter":"19 Regressão simples e múltipla","heading":"Converta para 1s e 0s","text":"Abaixo, colunas de variáveis explicativas com opções binárias “yes”/“”, “m”/“f”, e “dead”/“alive” são convertidas para 1 / 0, visando serem utilizadas nos modelos de regressão. Para fazer isso de forma eficiente, utilize função across(), dplyr, para transformar múltiplas colunas de uma vez. função case_when() (também dplyr) utiliza argumentos lógicos para converter valores específicos para 1s ou 0s. Veja seções das funções across() e case_when() na página de limpando dados e funções essenciais).Nota: o “.” abaixo representa coluna que está sendo processada pela função across() momento.","code":"\n## converte variáveis dicotômicas para 0/1 \nlinelist <- linelist %>%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## para cada coluna listada e \"outcome\"\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## transforma male/yes/death em 1\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## transforma female/no/recover em 0\n      TRUE                            ~ NA_real_)    ## do contrário, transforma em 'missing'\n    )\n  )"},{"path":"regression.html","id":"exclua-linhas-com-valores-em-branco","chapter":"19 Regressão simples e múltipla","heading":"Exclua linhas com valores em branco","text":"Para excluir linhas com valores em branco, é possível utilizar função drop_na(), pacote tidyr. Entretanto, nós queremos que isso aconteça apenas nas linhas com campos em branco nas colunas de interesse.primeira coisa fazer é garantir que o nosso vetor explanatory_vars contenha coluna age (age deve ter gerado um erro na operação anterior utilizando case_when(), que era apenas para variáveis dicotômicas). Então, nós utilizamos o objeto linelist na função drop_na() para remover qualquer linha com campos em branco na coluna outcome ou em qualquer uma das colunas salvas em explanatory_vars.Antes de executar o código, o número de linhas objeto linelist é obtido por nrow(linelist).O número de linhas restante linelist é nrow(linelist).","code":"\n## adiciona a coluna age_category no vetor explanatory_vars \nexplanatory_vars <- c(explanatory_vars, \"age_cat\")\n\n## exclua linhas com campos em branco nas variáveis de interesse\nlinelist <- linelist %>% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))"},{"path":"regression.html","id":"univariado","chapter":"19 Regressão simples e múltipla","heading":"19.2 Univariado","text":"Assim como na página sobre Tabelas descritivas, os seus objetivos irão determinar quais pacotes R utilizar. Aqui, nós apresentamos duas opções para realizar análises univariadas:Utilize funções disponíveis pacote R base para rapidamente obter os resultados terminal. Utilize o pacote broom para organizar os resultados.Utilize o pacote gtsummary para modelar e obter resultados prontos para publicação","code":""},{"path":"regression.html","id":"pacote-r-base-2","chapter":"19 Regressão simples e múltipla","heading":"Pacote R base","text":"","code":""},{"path":"regression.html","id":"regressão-linear","chapter":"19 Regressão simples e múltipla","heading":"Regressão linear","text":"função lm(), R base, executa regressões lineares, avaliando relação entre respostas numéricas e variáveis explanatórias (independentes), que se presume terem uma relação linear.Forneça equação como uma fórmula, com os nomes das colunas contendo respostas numéricas e variáveis explanatórias separadas por um til ~. Adicionalmente, especifique qual o banco de dados em data =. Para utiliza-los posteriormente, atribua os resultados da modelagem um objeto R.Você pode executar função summary() nos resultados obtidos para visualizar os coeficientes (Estimates), p-valor, resíduos, e outras medições.Alternativamente, é possível utilizar função tidy(), pacote broom, para organizar os resultados em uma tabela. O que os resultados nos mostram é que, cada ano, altura aumenta em 3.5 cm, e isto é estatisticamente significativo.Você também pode adicionar essa regressão na função ggplot. Para tanto,\nprimeiro plotamos os dados observados e linha de tendência da regressão linear em um quadro de dados\nutilizando função augment(), pacote broom.Também é possível adicionar uma linha simples de regressão linear diretamente ggplot,\nutilizando função geom_smooth().Veja seção sobre Recursos extras final deste capítulo para mais tutoriais detalhados.","code":"\nlm_results <- lm(ht_cm ~ age, data = linelist)\nsummary(lm_results)## \n## Call:\n## lm(formula = ht_cm ~ age, data = linelist)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -128.579  -15.854    1.177   15.887  175.483 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept)  69.9051     0.5979   116.9   <2e-16 ***\n## age           3.4354     0.0293   117.2   <2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 23.75 on 4165 degrees of freedom\n## Multiple R-squared:  0.7675, Adjusted R-squared:  0.7674 \n## F-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: < 2.2e-16\ntidy(lm_results)## # A tibble: 2 × 5\n##   term        estimate std.error statistic p.value\n##   <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n## 1 (Intercept)    69.9     0.598       117.       0\n## 2 age             3.44    0.0293      117.       0\n## coloque os pontos da regressão e os dados observados em um banco de dados\npoints <- augment(lm_results)\n\n## trace um gráfico dos dados utilizando a variável 'age' no eixo x\nggplot(points, aes(x = age)) + \n  ## inclua os pontos para a altura\n  geom_point(aes(y = ht_cm)) + \n  ## inclua a linha de tendência da regressão linear\n  geom_line(aes(y = .fitted), colour = \"red\")\n## coloque seus dados em um gráfico\n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## mostre os pontos\n  geom_point() + \n  ## inclua uma regressão linear\n  geom_smooth(method = \"lm\", se = FALSE)## `geom_smooth()` using formula = 'y ~ x'"},{"path":"regression.html","id":"regressão-logística","chapter":"19 Regressão simples e múltipla","heading":"Regressão logística","text":"função glm(), pacote stats (parte pacote R base), é utilizada para ajustar Modelos Lineares Generalizados (GLM).glm() pode ser utilizada para regressões logísticas univariadas e multivariadas (ex.: para obter probabilidades). Aqui estão partes principais:formula = o modelo é fornecido ao glm() como uma equação, com o resultado lado esquerdo e variáveis explicativas lado direito de um til ~.family = Isto determina o tipo de modelo ser executado. Para regressão logística, utilize family = \"binomial\", para o modelo log-linear de poisson utilize family = \"poisson\". Outros exemplos estão na tabela abaixo.data = Especifique sua fonte de dadosSe necessário, você pode especificar o link da função utilizando sintaxe family = familytype(link = \"linkfunction\")). Você pode obter mais informações sobre outras famílias e argumentos opcionais, como weights = e subset = (?glm), na documentação.Ao executar funçaõ glm(), é comum salvar os resultados em um objeto R. Assim, você pode visualizar os resultados em seu terminal utilizando função summary(), como mostrado abaixo, ou realizar outras operações com os resultados (ex.: potenciação).Se você precisa executar uma regressão binominal negativa, é possível utilizar o pacote MASS; função glm.nb() utiliza mesma sintaxe que glm().\nPara um passo passo sobre os diferentes modelos de regressão, acesse página sobre estatística da UCLA.","code":"\n# argumentos utilizados na função glm()\nglm(formula, family, data, weights, subset, ...)"},{"path":"regression.html","id":"função-glm-univariada","chapter":"19 Regressão simples e múltipla","heading":"Função glm() univariada","text":"Neste exemplo, nós iremos avaliar associação entre diferentes categorias de idades e evolução para óbito (codificado como 1 na seção de Preparação). Abaixo está um modelo univariado de outcome por age_cat. Os resultados modelo são savos como model, e mostrados terminal com função summary(). Observe que estimativas fornecidas são probabilidades em log, onde o nível base é o primeiro Factor (classe Factor) da variável age_cat(“0-4”).Para alterar o nível base de comparação de dada variável, garanta que coluna é da classe Factor e altere primeira posição ao nível desejado utilizando função fct_relevel() (veja página sobre Fatores). Por exemplo, abaixo nós adaptamos coluna age_cat e escolhemos “20-29” como nível base antes de aplicar estes dados na função glm().","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)   \n## (Intercept)   0.233738   0.072805   3.210  0.00133 **\n## age_cat5-9   -0.062898   0.101733  -0.618  0.53640   \n## age_cat10-14  0.138204   0.107186   1.289  0.19726   \n## age_cat15-19 -0.005565   0.113343  -0.049  0.96084   \n## age_cat20-29  0.027511   0.102133   0.269  0.78765   \n## age_cat30-49  0.063764   0.113771   0.560  0.57517   \n## age_cat50-69 -0.387889   0.259240  -1.496  0.13459   \n## age_cat70+   -0.639203   0.915770  -0.698  0.48518   \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4\nlinelist %>% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %>% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %>% \n  summary()## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n## \n## Coefficients:\n##              Estimate Std. Error z value Pr(>|z|)    \n## (Intercept)   0.26125    0.07163   3.647 0.000265 ***\n## age_cat0-4   -0.02751    0.10213  -0.269 0.787652    \n## age_cat5-9   -0.09041    0.10090  -0.896 0.370220    \n## age_cat10-14  0.11069    0.10639   1.040 0.298133    \n## age_cat15-19 -0.03308    0.11259  -0.294 0.768934    \n## age_cat30-49  0.03625    0.11302   0.321 0.748390    \n## age_cat50-69 -0.41540    0.25891  -1.604 0.108625    \n## age_cat70+   -0.66671    0.91568  -0.728 0.466546    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4"},{"path":"regression.html","id":"vizualizando-os-resultados","chapter":"19 Regressão simples e múltipla","heading":"Vizualizando os resultados","text":"Na maioria das vezes, diferentes modificações precisam ser feitas nos resultados acima. função tidy(), pacote broom, é conveniente para transformar os resultados em um formato apresentável.Aqui, nós demonstramos como combinar o resultado da modelagem com uma tabela de contagens.Obtenha probabilidades em log na forma exponencial e os intervalos de confiança ao aplicar o modelo na função tidy(), e ajustar os atributos exponentiate = TRUE e conf.int = TRUE.Abaixo é o objeto model mostrado de forma organizada:Combine os resultados dessa modelagem com uma tabela de contagens. Abaixo, nós criamos uma tabela cruzada de contagens com função tabyl() pacote janitor, como descrito na página sobre Tabelas descritivas:Aqui está como os dados em counts_table ficam quando tabelados:Agora nós podemos ligar os resultados dos objetos counts_table e model horizontalmente com função bind_cols() (dplyr). Lembre que, com função bind_cols(), linhas dos dois objetos precisam estar alinhadas perfeitamente. Neste código, porque estamos ligando uma cadeia de comandos, nós utilizamos o . para representar o objeto de counts_table enquanto o ligamos ao model. Para finalizar o processo, função select() é utilizada para selecionar colunas de interesse e sua ordem, e finalmente aplicar função round(), R base, em todas colunas numéricas para até duas casas decimais.Aqui está o resultado da combinação de duas tabelas, exportado como um bela imagem utilizando uma função flextable. página Tabelas para apresentação explica como customizar tais tabelas com o flextable, mas você pode utilizar outros inúmeros pacotes R, como knitr ou GT.","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %>% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %>%        # realize a potenciação e produza intervalos de confiança\n  mutate(across(where(is.numeric), round, digits = 2))  # arredonde todas as colunas numéricas\ncounts_table <- linelist %>% \n  janitor::tabyl(age_cat, outcome)\ncombined <- counts_table %>%           # inicie com uma tabela de contagens\n  bind_cols(., model) %>%              # combine ela com os resultados da regressão\n  select(term, 2:3, estimate,          # selecione e organize as colunas\n         conf.low, conf.high, p.value) %>% \n  mutate(across(where(is.numeric), round, digits = 2)) # arredonde para 2 casas decimais\ncombined <- combined %>% \n  flextable::qflextable()"},{"path":"regression.html","id":"rodando-múltiplos-modelos-univariados","chapter":"19 Regressão simples e múltipla","heading":"Rodando múltiplos modelos univariados","text":"Abaixo, nós mostramos um método usando glm()e tidy(). Para uma abordagem mais simples, veja seção sobre o gtsummary.Para rodar os modelos com diferentes variáveis e produzir probabilidades univariadas (ex.: sem dependência entre elas), você pode utilizar abordagem abaixo. Ela utiliza função str_c(), pacote stringr, para criar fórmulas univaridas (veja página caracteres e strings), e rodar regressão glm()com cada fórmula, aplicando cada resultado glm() tidy(), e, finalmente, unindo todos os resultados dos modelos com função bind_rows(), pacote tidyr. Esta abordagem utiliza função map(), pacote purrr, para repetir funções - veja página sobre Iteração, loops, e listas para mais informações sobre essa ferramenta.Crie um vetor com o nome das colunas com variáveis explicativas. Nós já criamos este vetor como explanatory_vars na seção Preparação desta página.Crie um vetor com o nome das colunas com variáveis explicativas. Nós já criamos este vetor como explanatory_vars na seção Preparação desta página.Utilize função str_c() para criar múltiplas fórmulas em texto, com o outcome lado esquerdo, e o nome de uma coluna explanatory_varsno lado direito. O ponto final ‘.’ é substituído pelo nome da coluna em explanatory_vars.Utilize função str_c() para criar múltiplas fórmulas em texto, com o outcome lado esquerdo, e o nome de uma coluna explanatory_varsno lado direito. O ponto final ‘.’ é substituído pelo nome da coluna em explanatory_vars.Utilize essas fórmulas na função map() e ajuste ~glm() como função ser utilizada com cada entrada. Dentro da função glm(), ajuste fórmula de regressão para .formula(.x), onde .x será substituído pela fórmula definida na etapa acima. função map()irá rodar com cada uma das fórmulas, executando regressões para cada uma.Utilize essas fórmulas na função map() e ajuste ~glm() como função ser utilizada com cada entrada. Dentro da função glm(), ajuste fórmula de regressão para .formula(.x), onde .x será substituído pela fórmula definida na etapa acima. função map()irá rodar com cada uma das fórmulas, executando regressões para cada uma.Os resultados deste primeiro map() são utilizados em um segundo comando map(), que aplica tidy() nos resultados das regressões.Os resultados deste primeiro map() são utilizados em um segundo comando map(), que aplica tidy() nos resultados das regressões.Finalmente, o resultado segundo map() (uma lista de quadros de dados organizados) é condensado com função bind_rows(), resultando em um quadro de dados com todos os resultados univariados.Finalmente, o resultado segundo map() (uma lista de quadros de dados organizados) é condensado com função bind_rows(), resultando em um quadro de dados com todos os resultados univariados.Desta vez, o objeto final models é maior porque agora representa os resultados combinados de diferentes regressões univariadas. Clique na tabela para visualizar todas linhas model.Como antes, nós podemos criar uma tabela de contagem objeto linelist para cada variável explicativa, ligar ela objeto models, e fazer uma bela tabela. Nós podemos começar com variáveis, e repetir os processos com função map(). Nós repetimos execução de uma função definida pelo usuário, que envolve criação de uma tabela de contagem utilizando funções dplyr. Então, os resultados são combinados e ligados com os resultados de models.Abaixo é como o quadro de dados fica após execução código. Veja página sobre Tabelas para apresentação para ideias de como converter essa tabela para um formato bonito em HTML (ex.: com flextable).","code":"\nexplanatory_vars %>% str_c(\"outcome ~ \", .)## [1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\"  \"outcome ~ cough\"  \n## [5] \"outcome ~ aches\"   \"outcome ~ vomit\"   \"outcome ~ age_cat\"\nmodels <- explanatory_vars %>%       # inicie com as variáveis de interesse\n  str_c(\"outcome ~ \", .) %>%         # combine cada variável na fórmula (\"outcome ~ variável de interesse\")\n  \n  # repita as etapas para cada fórmula univariável\n  map(                               \n    .f = ~glm(                       # utilize as fórmulas uma por uma no glm()\n      formula = as.formula(.x),      # dentro do glm(), a formula é representada por .x\n      family = \"binomial\",           # especifique o tipo do glm (logístico)\n      data = linelist)) %>%          # indique o banco de dados\n  \n  # organize cada um dos resultados das regressões acima\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # realize a exponenciação\n      conf.int = TRUE)) %>%          # obtenha os intervalos de confiança\n  \n  # condensa a lista dos resultados das regressões em um único quadro de dados\n  bind_rows() %>% \n  \n  # arredonde todas as colunas numéricas\n  mutate(across(where(is.numeric), round, digits = 2))\n## para cada variável explanatória\nuniv_tab_base <- explanatory_vars %>% \n  map(.f = \n    ~{linelist %>%                ## inicie com o linelist\n        group_by(outcome) %>%     ## agrupe os dados por outcome\n        count(.data[[.x]]) %>%    ## produza contagens das variáveis de interesse\n        pivot_wider(              ## transforme para o formato amplo (wide), como em uma tabulação cruzada\n          names_from = outcome,\n          values_from = n) %>% \n        drop_na(.data[[.x]]) %>%         ## exclua as linhas com campos em branco\n        rename(\"variable\" = .x) %>%      ## altere a coluna com a variável de interesse para \"variable\"\n        mutate(variable = as.character(variable))} ## converta para caractéres, do contrário as variáveis não dicotômicas (categóricas) geram a classe factor e não podem ser unidas\n      ) %>% \n  \n  ## condensa a lista com o resultado das contagens em um único quadro de dados\n  bind_rows() %>% \n  \n  ## une com os resultados da regressão\n  bind_cols(., models) %>% \n  \n  ## mantenha apenas as colunas de interesse\n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %>% \n  \n  ## arredonde as casas decimais\n  mutate(across(where(is.numeric), round, digits = 2))"},{"path":"regression.html","id":"reg_gt_uni","chapter":"19 Regressão simples e múltipla","heading":"Pacote gtsummary","text":"Abaixo, nós apresentamos o uso da função tbl_uvregression() pacote gtsummary. Assim como na página sobre Tabelas descritivas, funções gtsummary fazem um bom trabalho executando estatísticas e produzindo resultados com aparência profissional. função tbl_uvregression() produz uma tabela com os resultados de uma regressão univariada.Primeiro, nós selecionamos apenas colunas de interesse objeto linelist (variáveis explanatórias e variável de evolução clínica \\[outcome\\]), e aplicamos na função tbl_uvregression(). Então, iremos executar uma regressão univariada em cada uma das colunas definidas vetor explanatory_vars, previamente criado na seção sobre Preparação dos dados (colunas gender, fever, chills, cough, aches, vomit, e age_cat).Dentro da função, os atributos serão modificados, como em method = ao glm (sem aspas), o y = com coluna de evolução dos casos (outcome), especificar para o method.args = que queremos rodar uma regressão logística através atributo family = binomial, e então finalizamos com um comando para realizar exponenciação dos resultados.O resultado é gerado formado HTML, e contém contagensExitem muitas modificações que podem ser feitas com tabela gerada, como ajustar os rótulos em texto, destacar linhas pelo seu valor de p, etc. Veja tutoriais aqui e em outras fontes online.","code":"\nuniv_tab <- linelist %>% \n  dplyr::select(explanatory_vars, outcome) %>% ## selecione as variáveis de interesse\n\n  tbl_uvregression(                         ## produz uma tabela univariável\n    method = glm,                           ## define qual regressão será rodada (glm)\n    y = outcome,                            ## define a variável da evolução clínica (outcome)\n    method.args = list(family = binomial),  ## define qual tipo de glm será rodador (logístico)\n    exponentiate = TRUE                     ## realiza a exponenciação para produzir as probabilidades (em vez de probabilidaes em log)\n  )\n\n## visualize a tabela com os resultados da análise univariada\nuniv_tab"},{"path":"regression.html","id":"análise-estratificada","chapter":"19 Regressão simples e múltipla","heading":"19.3 Análise estratificada","text":"seção sobre análise estratificada ainda está sendo trabalhada gtsummary.\nEsta página será atualizada quando possível.","code":""},{"path":"regression.html","id":"multivariada","chapter":"19 Regressão simples e múltipla","heading":"19.4 Multivariada","text":"Para análise multivariada, novamente apresentamos duas abordagens:glm() e tidy()pacote gtsummaryO fluxo de trabalho é similar para cada uma das abordagens, sendo apenas última diferente quando tabela final é obtida.","code":""},{"path":"regression.html","id":"conduza-a-análise-multivariada","chapter":"19 Regressão simples e múltipla","heading":"Conduza a análise multivariada","text":"Aqui nós utilizamos função glm(), mas adicionaremos mais variáveis lado direito da equação, separadas pelos símbolos de mais (+).Para rodar o modelo com todas nossas variáveis exploratórias, nós executamos o seguinte código:Se você quiser incluir duas variáveis e uma interação entre elas, é possível separá-las com um asterisco * em vez +. Separe eles com dois pontos : se você está especificando apenas interação. Por exemplo:Opcionalmente, você pode utilizar este código para nivelar o vetor pré-definido com os nomes das colunas, e re-criar o comando acima utilizando função str_c(). Isto pode ser útil caso os nomes das suas variáveis explicativas estiverem mudando, ou se você não quiser digitar todas elas novamente.","code":"\nmv_reg <- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)## \n## Call:\n## glm(formula = outcome ~ gender + fever + chills + cough + aches + \n##     vomit + age_cat, family = \"binomial\", data = linelist)\n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)\n## (Intercept)   0.069054   0.131726   0.524    0.600\n## gender        0.002448   0.065133   0.038    0.970\n## fever         0.004309   0.080522   0.054    0.957\n## chills        0.034112   0.078924   0.432    0.666\n## cough         0.138584   0.089909   1.541    0.123\n## aches        -0.070705   0.104078  -0.679    0.497\n## vomit         0.086098   0.062618   1.375    0.169\n## age_cat5-9   -0.063562   0.101851  -0.624    0.533\n## age_cat10-14  0.136372   0.107275   1.271    0.204\n## age_cat15-19 -0.011074   0.113640  -0.097    0.922\n## age_cat20-29  0.026552   0.102780   0.258    0.796\n## age_cat30-49  0.059569   0.116402   0.512    0.609\n## age_cat50-69 -0.388964   0.262384  -1.482    0.138\n## age_cat70+   -0.647443   0.917375  -0.706    0.480\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5700.2  on 4153  degrees of freedom\n## AIC: 5728.2\n## \n## Number of Fisher Scoring iterations: 4\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n## rode uma regressão com todas as variáveis de interesse\nmv_reg <- explanatory_vars %>%  ## inicie com um vetor contendo o nome das colunas explicativas\n  str_c(collapse = \"+\") %>%     ## combine todos os nomes das variáveis de interesse separados por um 'mais'\n  str_c(\"outcome ~ \", .) %>%    ## combine os nomes das variáveis de interesse com o 'outcome' no estilo de fórmula\n  glm(family = \"binomial\",      ## defina o tipo de glm como logístico,\n      data = linelist)          ## defina seu banco de dados"},{"path":"regression.html","id":"construíndo-o-modelo","chapter":"19 Regressão simples e múltipla","heading":"Construíndo o modelo","text":"É possível construir seu modelo passo passo, salvando diferentes modelos que incluem certas variáveis explicativas. Esses modelos podem ser comparados com os testes de probabilidade utilizando função lrtest(), pacote lmtest, como mostrado abaixo:NOTA: Utilizar o teste anova(model1, model2, test = \"Chisq) R base produz os mesmos resultados Outra opção é utilizar o objeto modelado diretamente na função step(), pacote stats. Especifique qual direção da seleção das variáveis que quer utilizar quando construir o modelo.Para facilitar visualização, é possível desativar notação científica na sua sessão R:Como descrito na seção sobre análise univariada, aplique o resultado da modelagem na função tidy() para potencializar probabilidades em log e os intervalos de confiança. Finalmente, todas colunas numéricas são arredondadads para duas casas decimais. Role o cursor para visualizar todas linhas.Aqui está o quadro de dados final:","code":"\nmodel1 <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 <- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)## Likelihood ratio test\n## \n## Model 1: outcome ~ age_cat\n## Model 2: outcome ~ age_cat + gender\n##   #Df  LogLik Df  Chisq Pr(>Chisq)\n## 1   8 -2852.6                     \n## 2   9 -2852.6  1 0.0002     0.9883\n## escolha um modelo utilizando a seleção 'foward' baseada no AIC\n## você também pode escolher \"backward\" ou \"both\" ao ajustar a direção\nfinal_mv_reg <- mv_reg %>%\n  step(direction = \"forward\", trace = FALSE)\noptions(scipen=999)\nmv_tab_base <- final_mv_reg %>% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>%  ## obtenha um quadro de dados organizado das estimativas\n  mutate(across(where(is.numeric), round, digits = 2))          ## arredonde "},{"path":"regression.html","id":"combine-as-análises-univariadas-e-multivariadas","chapter":"19 Regressão simples e múltipla","heading":"Combine as análises univariadas e multivariadas","text":"","code":""},{"path":"regression.html","id":"combine-com-o-gtsummary","chapter":"19 Regressão simples e múltipla","heading":"Combine com o gtsummary","text":"O pacote gtsummary possui função tbl_regression(), que utiliza\nos resultados de uma regressão (glm() neste caso) e produz uma linda\ntabela resumo.Vamos visualizar tabela:Também é possível combinar diferentes tabelas de resultados produzidas pelo gtsummary com\nfunção tbl_merge(). Assim, podemos combinar os resultados multivariados com os resultados univariados gtsummary que criamos acima:","code":"\n## mostra a tabela de resultados de uma regressão\nmv_tab <- tbl_regression(final_mv_reg, exponentiate = TRUE)\nmv_tab\n## combine com os resultados univariados\ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # combine as tabelas\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # escolha o nome dos cabeçalhos"},{"path":"regression.html","id":"combine-com-o-pacote-dplyr","chapter":"19 Regressão simples e múltipla","heading":"Combine com o pacote dplyr","text":"Uma alternativa para combinar os resultados univariados e multivariados glm()/tidy() é com funções de união dplyr.Una os resultados univariados anteriores (univ_tab_base, com contagens) com os resultados multivariados organizados mv_tab_baseUse função select() para manter apenas colunas de interesse, especificar sua ordem, e renomear elasUse função round() com duas casas decimais em todas colunas da classe Double","code":"\n## combine tabelas univariadas e multivariadas \nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %>% \n  ## escolha as colunas e as renomeie\n  select( # new name =  old name\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %>% \n  mutate(across(where(is.double), round, 2))   ## # A tibble: 20 × 11\n##    characteristic recovered  dead univ_or univ_ci_low univ_ci_high univ_pval mv_or\n##    <chr>              <dbl> <dbl>   <dbl>       <dbl>        <dbl>     <dbl> <dbl>\n##  1 (Intercept)          909  1168    1.28        1.18         1.4       0     1.07\n##  2 gender               916  1174    1           0.88         1.13      0.97  1   \n##  3 (Intercept)          340   436    1.28        1.11         1.48      0     1.07\n##  4 fever               1485  1906    1           0.85         1.17      0.99  1   \n##  5 (Intercept)         1472  1877    1.28        1.19         1.37      0     1.07\n##  6 chills               353   465    1.03        0.89         1.21      0.68  1.03\n##  7 (Intercept)          272   309    1.14        0.97         1.34      0.13  1.07\n##  8 cough               1553  2033    1.15        0.97         1.37      0.11  1.15\n##  9 (Intercept)         1636  2114    1.29        1.21         1.38      0     1.07\n## 10 aches                189   228    0.93        0.76         1.14      0.51  0.93\n## 11 (Intercept)          931  1144    1.23        1.13         1.34      0     1.07\n## 12 vomit                894  1198    1.09        0.96         1.23      0.17  1.09\n## 13 (Intercept)          338   427    1.26        1.1          1.46      0     1.07\n## 14 age_cat5-9           365   433    0.94        0.77         1.15      0.54  0.94\n## 15 age_cat10-14         273   396    1.15        0.93         1.42      0.2   1.15\n## 16 age_cat15-19         238   299    0.99        0.8          1.24      0.96  0.99\n## 17 age_cat20-29         345   448    1.03        0.84         1.26      0.79  1.03\n## 18 age_cat30-49         228   307    1.07        0.85         1.33      0.58  1.06\n## 19 age_cat50-69          35    30    0.68        0.41         1.13      0.13  0.68\n## 20 age_cat70+             3     2    0.53        0.07         3.2       0.49  0.52\n## # ℹ 3 more variables: mvv_ci_low <dbl>, mv_ci_high <dbl>, mv_pval <dbl>"},{"path":"regression.html","id":"gráfico-em-floresta-forest-plot","chapter":"19 Regressão simples e múltipla","heading":"19.5 Gráfico em floresta (Forest Plot)","text":"Esta seção mostra como produzir um gráfico com os resultados da sua regressão.\nExistem duas opções. Você pode construir uma plotagem utilizando o ggplot2 ou utilizando\num pacote-meta (um pacote que incluí muitos pacotes) chamado easystats.Veja página sobre básico ggplot se você não é familiar com o pacote de plotagem ggplot2.","code":""},{"path":"regression.html","id":"pacote-ggplot2","chapter":"19 Regressão simples e múltipla","heading":"Pacote ggplot2","text":"É possível construir um gráfico em floresta com função ggplot() ao plotar os resultados de uma regressão multivariada. Adicione camadas das plotagens com estas funções “geoms”:realize estimativas com geom_point()obtenha intervalos de confiança com geom_errorbar()uma linha vertical em OU = 1 com geom_vline()Antes de traçar o gráfico, é interessante utilizar função fct_relevel(), pacote forcats, para escolher ordem das variáveis/níveis eixo y. ggplot() pode mostrar elas em uma ordem alfa-numérica que pode não funcionar bem com os valores da variável ‘age category’ (“30” apareceria antes de “5”). Veja página sobre fatores para mais detalhes.","code":"\n## remove o termo da intercepção dos seus resultados multivariados\nmv_tab_base %>% \n  \n  # escolhe a ordem dos níveis que aparecem no eixo y\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %>%\n  \n  # remove a linha \"intercept\" do gráfico\n  filter(term != \"(Intercept)\") %>% \n  \n  ## trace um gráfico no eixo y e/ou as estimativas no eixo x\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## mostre a estimativa como um ponto\n  geom_point() + \n  \n  ## adicione uma barra de erro para os intervalos de confiança\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## mostre a linha. OR = 1 é referência para uma linha tracejada\n  geom_vline(xintercept = 1, linetype = \"dashed\")"},{"path":"regression.html","id":"pacotes-easystats","chapter":"19 Regressão simples e múltipla","heading":"Pacotes easystats","text":"Uma alternativa, caso você não queira realizar os ajustes finos ggplot2, é utilizar uma combinação dos pacotes easystats.função model_parameters(), pacote parameters, faz o equivalente\nda função tidy() pacote broom. O pacote see aceita estes resultados\ne cria uma plotagem em floresta padrão, como se fosse um objeto ggplot().","code":"\npacman::p_load(easystats)\n\n## remove a intercepção dos seus resultados multivariados\nfinal_mv_reg %>% \n  model_parameters(exponentiate = TRUE) %>% \n  plot()"},{"path":"regression.html","id":"recursos-11","chapter":"19 Regressão simples e múltipla","heading":"19.6 Recursos","text":"O conteúdo desta página foi adaptado destes recursos e tutoriais onlines:Regressão linear RgtsummaryPágina sobre estatística da UCLARegressão gradual sthda","code":""},{"path":"missing-data.html","id":"missing-data","chapter":"20 Campos em branco/faltantes","heading":"20 Campos em branco/faltantes","text":"Está página irá abordar como:Avaliar quantidade de campos em brancoFiltrar linhas com variáveis em brancoTraçar um gráfico da quantidade de campos em branco ao longo tempoModificar como os valores NA são mostrados nos gráficosRealizar atribuição de valores aos campos em branco: MCAR, MAR, MNAR","code":""},{"path":"missing-data.html","id":"preparando-o-ambiente-r","chapter":"20 Campos em branco/faltantes","heading":"20.1 Preparando o ambiente R","text":"","code":""},{"path":"missing-data.html","id":"carregue-os-pacotes-3","chapter":"20 Campos em branco/faltantes","heading":"Carregue os pacotes","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  rio,           # importar/exportar\n  tidyverse,     # gerenciamento e visualização dos dados\n  naniar,        # avaliar e visualizar campos em branco\n  mice           # atribuir valores aos campos em branco\n)"},{"path":"missing-data.html","id":"importe-os-dados-3","chapter":"20 Campos em branco/faltantes","heading":"Importe os dados","text":"Nós iremos importar o banco de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando função import() pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja página Importar e exportar para detalhes).primeiras 50 linhas banco são mostradas abaixo","code":"\n# importe os dados no R\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"missing-data.html","id":"padronize-os-dados-dos-campos-em-branco-durante-a-importação","chapter":"20 Campos em branco/faltantes","heading":"Padronize os dados dos campos em branco durante a importação","text":"Ao importar os seus dados, esteja ciente de valores que deveriam ser classificados como campos em branco. Por exemplo, 99, 999, “Missing”, células em branco (““), ou céluas com um espaço em branco (” “). Você pode converter esses tipos de campos em branco (e outros) para NA (formato de campos em branco R) ainda código usado para importar os dados.\nVeja seção sobre como importar os dados na página Campos em branco para mais detalhes, uma vez que sintaxe muda de acordo com o tipo de arquivo.","code":""},{"path":"missing-data.html","id":"campos-em-branco-no-r","chapter":"20 Campos em branco/faltantes","heading":"20.2 Campos em branco no R","text":"Abaixo, nós exploramos formas como os campos em branco são mostrados e analisados R, assim como valores e funções adjacentes.","code":""},{"path":"missing-data.html","id":"na","chapter":"20 Campos em branco/faltantes","heading":"NA","text":"R, campos em branco são representados por um valor especial e reservado - NA. Notar que é escrito sem aspas. Já “NA”, com aspas, é diferente, sendo apenas um caractere normal R (além de ser parte da letra de Hey Jude dos Beatles).Os campos em branco nos seus dados podem estar representados com outras formas, como “99”, ou “Missing”, ou “Unknown” - ou até como um caractere vazio ““, parecido com um campo em branco, ou um espaço simples” “. Esteja ciente disto, e verifique possibilidade de converte-los para NA durante importação ou durante limpeza dos dados, com função na_if().Durante limpeza dos dados, você também pode realizar o oposto - alterando todos os NA para “Missing”, ou algo similar, utilizando função replace_na() ou fct_explicit_na(), para valores da classe Factor.","code":""},{"path":"missing-data.html","id":"versões-de-na","chapter":"20 Campos em branco/faltantes","heading":"Versões de NA","text":"Para boa parte dos casos, NA representa os campos em branco e tudo funciona bem. Entretanto, em algumas circunstâncias você pode precisar de variações NA, específicas para uma classe de objeto (caractere, numérico, etc). Isto será raro, mas esteja ciente dessa possibilidade.\nO cenário típico para isso ocorre ao criar uma nova coluna com função case_when(), pacote dplyr. Como descrito na página sobre Limpeza dos dados e principais funções, esta função verifica cada linha banco de dados, avalia se cumprem regras lógicas (lado direito código), e atribuem um novo valor correto (lado esquerdo código). Importante: todos os valores lado direito da fórmula precisam ser da mesma classe.Se você quiser NA lado direito, é necessário especificar uma das opções especiais da NA, listadas abaixo. Para valores em caracteres, utilize “Missing” em vez de NA, ou NA_character_. Se todos os valores são numéricos, utilize opção NA_real_. Se todos os valores são formato de datas ou lógicos, utilize NA.NA - utilize para datas ou valores lógicos TRUE/FALSENA_character_ - utilize para caracteresNA_real_ - utilize para valores numéricosNovamente, é improvável que você encontre essas variações, não ser que você esteja utilizando função case_when()para criar uma nova coluna. Veja documentação R sobre NA para mais informações.","code":"\nlinelist <- linelist %>% \n  \n  # Cria uma nova coluna chamada \"age_years\", utilizando a coluna \"age\"\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # se a idade (age) é dada em anos, este valor é mantido\n    age_unit == \"months\" ~ age/12,    # se a idade é dada em meses, o valor é dividido por 12\n    is.na(age_unit)      ~ age,       # se a unidade da idade não é informada, assume-se que sejam em anos\n    TRUE                 ~ NA_real_)) # para qualquer outra circunstância, o valor de campo em branco é atribuído"},{"path":"missing-data.html","id":"null","chapter":"20 Campos em branco/faltantes","heading":"NULL","text":"NULL é outro valor reservado (especial) R. É representação lógica de uma declaração que não é nem verdadeira (true), tampouco falsa (false). Ele é gerado por expressões ou funções em que os valores são indefinidos. Geralemnte, não atribua NULL como um valor, exceto ao escrever funções ou, talvez, uma [aplicação em shiny][Dashboards com Shiny] para gerar NULL em cenários específicos.Para avaliar se é um valor NULL, é só utilizar função .null(), e conversões podem ser feitas com função .null().Veja essa postagem detalhando diferenças entre NULL e NA.","code":""},{"path":"missing-data.html","id":"nan","chapter":"20 Campos em branco/faltantes","heading":"NaN","text":"Valores impossíveis são representados pelo valor especial NaN. Um exemplo disso é quando você força o R dividir 0 por 0. Você pode verificar se algo é impossível com função .nan(). Você também pode encontrar funções complementares, incluindo .infinite() e .finite().","code":""},{"path":"missing-data.html","id":"inf","chapter":"20 Campos em branco/faltantes","heading":"Inf","text":"Inf representa um valor infinito, como o obtido ao dividir um número por 0.Um exemplo de como isto pode impactar seu trabalho: digamos que você possua um vetor/coluna z que contém estes valores: z <- c(1, 22, NA, Inf, NaN, 5)Se você utilizar função max() nesta coluna para encontrar o maior valor, é possível utilizar o atributo na.rm = TRUE para remover o NA da análise, mas os valores Inf e NaN continuarão e Inf será o resultado desta análise. Para resolver isto, você pode utilizar colchetes quadrados [ ] e função .finite() para analisar apenas o subconjunto de dados com apenas valores finitos: max(z[.finite(z)]).","code":"\nz <- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # retorna NA\nmax(z, na.rm=T)                  # retorna Inf\nmax(z[is.finite(z)])             # retorna 22"},{"path":"missing-data.html","id":"exemplos-1","chapter":"20 Campos em branco/faltantes","heading":"Exemplos","text":"“NAs introduzidos forçadamente” (“NAs introduced coercion”) é uma mensagem de aviso comum. Isto pode acontecer se você tentar realizar uma conversão ilegal, como inserir um valor tipo caractere em um vetor numérico.NULL é ignorado em um vetor.Variação de um número resulta em NA.","code":"\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))## Warning: NAs introduced by coercion## [1] 10 20 NA 40\nmy_vector <- c(25, NA, 10, NULL)  # defina\nmy_vector                         # print## [1] 25 NA 10\nvar(22)## [1] NA"},{"path":"missing-data.html","id":"funções-úteis","chapter":"20 Campos em branco/faltantes","heading":"20.3 Funções úteis","text":"Abaixo são elencadas funções úteis R base para avaliar e trabalhar com campos em branco:","code":""},{"path":"missing-data.html","id":"is.na-e-is.na","chapter":"20 Campos em branco/faltantes","heading":"is.na() e !is.na()","text":"Utilize função .na() para identificar campos em branco, ou utilize o oposto desta função (com ! na frente) para identificar campos preenchidos. Ambas funções retornam um valor lógico (TRUE ou FALSE). Lembre que você pode somar (sum()) o vetor resultante para contar quantidade de TRUE, ex.: sum(.na(linelist$date_outcome)).","code":"\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)## [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n!is.na(my_vector)## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nsum(is.na(my_vector))## [1] 2"},{"path":"missing-data.html","id":"na.omit","chapter":"20 Campos em branco/faltantes","heading":"na.omit()","text":"Esta função, se aplicada em um conjunto de dados, irá remover linhas com qualquer campo em branco. Esta função também é pacote R base.\nSe aplicada em um vetor, os valores NA neste vetor serão removidos. Por exemplo:","code":"\nna.omit(my_vector)## [1]  1  4 56  5 22\n## attr(,\"na.action\")\n## [1] 4 6\n## attr(,\"class\")\n## [1] \"omit\""},{"path":"missing-data.html","id":"drop_na","chapter":"20 Campos em branco/faltantes","heading":"drop_na()","text":"Esta é uma função pacote tidyr, que é útil em um pipeline de limpeza de dados. Se executada com os parênteses vazios, ela remove linhas com qualquer um dos campos esteja em brancos. Se o nome das colunas são especificados em parênteses, linhas com campos em branco apenas nestas colunas serão excluídas. Você pode também utilizar sintaxe “tidyselect” para especificar colunas.","code":"\nlinelist %>% \n  drop_na(case_id, date_onset, age) # exclui linhas com campos em branco em alguma dessas colunas"},{"path":"missing-data.html","id":"na.rm-true","chapter":"20 Campos em branco/faltantes","heading":"na.rm = TRUE","text":"Quando você executa uma função matemática, como max(), min(), sum() ou mean(), se existir quaisquer valores NA presentes, o resultado da análise será NA. Este comportamento padrão é intencional, de forma que você seja alertado caso de seus dados estarem em branco.Você pode evitar isto ao remover os campos em branco dos cálculos. Para fazer isto, inclua o argumento na.rm = TRUE (“na.rm” significa “remova os NA”).","code":"\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     ## [1] NA\nmean(my_vector, na.rm = TRUE)## [1] 17.6"},{"path":"missing-data.html","id":"avalie-os-campos-em-branco-no-conjunto-de-dados","chapter":"20 Campos em branco/faltantes","heading":"20.4 Avalie os campos em branco no conjunto de dados","text":"Você pode utilizar o pacote naniar para avaliar e visualizar os campos em brancos seu conjunto de dados presente objeto linelist.","code":"\n# instale e/ou carregue o pacote\npacman::p_load(naniar)"},{"path":"missing-data.html","id":"quantificando-os-campos-em-branco","chapter":"20 Campos em branco/faltantes","heading":"Quantificando os campos em branco","text":"Para encontrar o percentual da quantidade de campos em branco, utilize função pct_miss(). Utilize n_miss() para obter o número absoluto de campos em branco.duas funções abaixo retornam o percentual de linhas com qualquer campo em branco, ou que estão com todos os campos preenchidos, respectivamente. Lembre que NA significa perdido/em branco, e que \"\" ou \" \" não serão considerados campos em branco.","code":"\n# percentual de TODOS os campos em branco no banco de dados\npct_miss(linelist)## [1] 6.688745\n# Percentual de linhas com algum campo em branco\npct_miss_case(linelist)   # utilize n_complete() para obter quantidades absolutas## [1] 69.12364\n# Percentual de linhas com todos os campos preenchidos (sem campos em branco)\npct_complete_case(linelist) # utilize n_complete() para obter quantidades absolutas## [1] 30.87636"},{"path":"missing-data.html","id":"visualizando-as-quantidades-de-campos-em-branco","chapter":"20 Campos em branco/faltantes","heading":"Visualizando as quantidades de campos em branco","text":"função gg_miss_var() irá gerar o número absoluto (ou %) de campos em branco em cada coluna. Seguem alguns detalhes:Você pode adicionar um nome de coluna (sem aspas) ao atributo facet = para visualizar o gráfico por gruposPor padrão, contagens absolutas são mostradas lugar dos percentuais. Altere isso com o atributo show_pct = TRUEVocê pode adicionar etiquetas aos eixos e títulos utilizando + labs(...), como ggplot()Aqui, os dados são encadeados %>% (inglês pipe) na função. O atributo facet = também é utilizado para dividir os dados.Você pode utilizar função vis_miss() para visualizar os dados como um mapa de calor, mostrando se algum campo está em branco ou não. Também é possível utilizar o select() para escolher colunas específicas banco de dados, e trabalhar apenas com elas.","code":"\ngg_miss_var(linelist, show_pct = TRUE)\nlinelist %>% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n# Mapa de calor dos campos em branco no banco de dados inteiro\nvis_miss(linelist)"},{"path":"missing-data.html","id":"explore-e-visualize-as-relações-entre-os-campos-em-branco","chapter":"20 Campos em branco/faltantes","heading":"Explore e visualize as relações entre os campos em branco","text":"Como você visualiza algo que não existe??? Por padrão, o ggplot() remove pontos sem valores dos gráficos.O pacote naniar oferece uma solução com função geom_miss_point(). Ao criar um gráfico de dispersão de duas colunas, uma delas é construída sem os valores em branco, e outra com estes pontos, onde valores 10% menores que o menor valor da coluna são atribuídos estes campos em branco, que são então coloridos de forma distinta dos demais pontos.gráfico de dispersão abaixo, os pontos vermelhos são os que foram adicionados, estando presentes em uma coluna, mas não na outra. Isto permite visualizar distribuição de campos em branco em relação aos campos preenchidos.Para analisar os campos em branco nos dados, estratificados por outra coluna, utilize função gg_miss_fct(), que gera um mapa de calor com o percentual de campos em brancos banco de dados utilizando uma coluna da classe factor/categórica (ou por datas):Esta função também pode ser utilizada com uma coluna com datas, para visualizar como quantidade de campos em branco alterou de acordo com o tempo:","code":"\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\ngg_miss_fct(linelist, age_cat5)\ngg_miss_fct(linelist, date_onset)## Warning: Removed 29 rows containing missing values (`geom_tile()`)."},{"path":"missing-data.html","id":"colunas-sombra-shadow","chapter":"20 Campos em branco/faltantes","heading":"Colunas Sombra “Shadow”","text":"Outra forma de visualizar os campos em branco em uma coluna, de acordo com os valores de uma segunda coluna, é utilizando o “shadow” que o pacote naniar consegue criar. função bind_shadow() cria uma nova coluna com os valores binários NA/NA para cada coluna existente, e então conecta todas essas colunas novas ao banco de dados original utilizando o sufixo “_NA” em seus nomes. Isto duplica o número de colunas:Estas colunas “shadow” podem ser utilizadas para traçar um gráfico da proporção de campos em branco, em relação à qualquer outra coluna.Por exemplo, o gráfico abaixo mostra proporção de campos em branco na coluna days_onset_hosp (número de dias entre o início dos sintomas e hospitalização), de acordo com o campo em date_hospitalisation. Essencialmente, você está criando um gráfico da densidade da coluna eixo x, mas estratificando os resultados (color =) pela coluna “shadow” de interesse. Esta análise funciona melhor se o eixo x é uma coluna numérica ou com dados cronológicos.Você pode também utilizar colunas “shadow” para estratificar um resumo estatístico, como mostrado abaixo:Uma forma alternativa para traçar um gráfico da proporção de campos em branco em uma coluna de acordo com o tempo é mostrada abaixo. Esta forma não involve o pacote naniar. Este exemplo mostra porcentagem de observações semanais que estão em branco.Agregue os dados em uma unidade de tempo útil (dias, semanas, etc.), resumindo proporção de observações com NA(e/ou qualquer outro valor de interesse)Faça um gáfico da proporção de campos em brancos como uma linha, utilizando o ggplot()Abaixo, nós trabalhamos com linelist, adicionamos uma nova coluna contendo semana, então agrupamos os dados por semana, e calculamos o percentual de registros em branco de acordo com semana. (nota: se você quisesse obter % por 7 dias, o cálculo seria sutilmente diferente).Então nóstraçamos um gráfico das proporções dos campos em branco como uma linha, de acordo com semana. página sobre básico ggplot pode ser utilizada se você não tiver familiaridade com o pacote ggplot2 de visuzalização de dados.","code":"\nshadowed_linelist <- linelist %>% \n  bind_shadow()\n\nnames(shadowed_linelist)##  [1] \"case_id\"                 \"generation\"              \"date_infection\"         \n##  [4] \"date_onset\"              \"date_hospitalisation\"    \"date_outcome\"           \n##  [7] \"outcome\"                 \"gender\"                  \"age\"                    \n## [10] \"age_unit\"                \"age_years\"               \"age_cat\"                \n## [13] \"age_cat5\"                \"hospital\"                \"lon\"                    \n## [16] \"lat\"                     \"infector\"                \"source\"                 \n## [19] \"wt_kg\"                   \"ht_cm\"                   \"ct_blood\"               \n## [22] \"fever\"                   \"chills\"                  \"cough\"                  \n## [25] \"aches\"                   \"vomit\"                   \"temp\"                   \n## [28] \"time_admission\"          \"bmi\"                     \"days_onset_hosp\"        \n## [31] \"case_id_NA\"              \"generation_NA\"           \"date_infection_NA\"      \n## [34] \"date_onset_NA\"           \"date_hospitalisation_NA\" \"date_outcome_NA\"        \n## [37] \"outcome_NA\"              \"gender_NA\"               \"age_NA\"                 \n## [40] \"age_unit_NA\"             \"age_years_NA\"            \"age_cat_NA\"             \n## [43] \"age_cat5_NA\"             \"hospital_NA\"             \"lon_NA\"                 \n## [46] \"lat_NA\"                  \"infector_NA\"             \"source_NA\"              \n## [49] \"wt_kg_NA\"                \"ht_cm_NA\"                \"ct_blood_NA\"            \n## [52] \"fever_NA\"                \"chills_NA\"               \"cough_NA\"               \n## [55] \"aches_NA\"                \"vomit_NA\"                \"temp_NA\"                \n## [58] \"time_admission_NA\"       \"bmi_NA\"                  \"days_onset_hosp_NA\"\nggplot(data = shadowed_linelist,          # banco de dados com as colunas \"shadow\"\n  mapping = aes(x = date_hospitalisation, # colunas numéricas ou cronológicas\n                colour = age_years_NA)) + # coluna \"shadow\" de interesse\n  geom_density()                          # adição das curvas de densidade\nlinelist %>%\n  bind_shadow() %>%                # cria as colunas \"shadow\"\n  group_by(date_outcome_NA) %>%    # coluna \"shadow\" escolhida para estratificar\n  summarise(across(\n    .cols = age_years,             # variável de interesse para realizar os cálculos\n    .fns = list(\"mean\" = mean,     # estatísticas calculadas\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # outros argumentos para o cálculo das estatísticas## # A tibble: 2 × 6\n##   date_outcome_NA age_years_mean age_years_sd age_years_var age_years_min\n##   <fct>                    <dbl>        <dbl>         <dbl>         <dbl>\n## 1 !NA                       16.0         12.6          158.             0\n## 2 NA                        16.2         12.9          167.             0\n## # ℹ 1 more variable: age_years_max <dbl>\noutcome_missing <- linelist %>%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %>%   # crie uma coluna com as semanas\n  group_by(week) %>%                                             # agrupe as linhas por semana\n  summarise(                                                     # faça o resumo por cada semana\n    n_obs = n(),                                                  # número absoluto de registros\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # número de registros com campos em branco\n    outcome_p_miss  = outcome_missing / n_obs,                    # proporção de registros em branco\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # número de registros com evolução para óbito\n    outcome_p_dead  = outcome_dead / n_obs) %>%                   # proporção de registros com evolução para óbito\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %>%         # para utilizar o ggplot, altere todas as colunas, exceto a coluna com as semanas, para o formato longo\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # mantenha apenas os valores proporcionais\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")"},{"path":"missing-data.html","id":"utilizando-dados-com-campos-em-branco","chapter":"20 Campos em branco/faltantes","heading":"20.5 Utilizando dados com campos em branco","text":"","code":""},{"path":"missing-data.html","id":"exclua-linhas-com-campos-em-branco","chapter":"20 Campos em branco/faltantes","heading":"Exclua linhas com campos em branco","text":"Para rapidamente excluir linhas com valores em branco, utilize função drop_na(), pacote dplyr.O objeto linelist original possui nrow(linelist) linhas. O número ajustado de linhas, após exclusão das que possuíam campos em branco, é mostrado abaixo:Você pode especificar para excluir linhas com campos em branco apenas em colunas específicas:Você pode listar colunas uma após outra, ou utilizar funções auxiliares “tidyselect”:","code":"\nlinelist %>% \n  drop_na() %>%     # excluí linhas com QUALQUER campo em branco\n  nrow()## [1] 1818\nlinelist %>% \n  drop_na(date_onset) %>% # exclua as linhas com campos em branco na coluna date_onset \n  nrow()## [1] 5632\nlinelist %>% \n  drop_na(contains(\"date\")) %>% # exclua linhas com campos em branco em qualquer coluna que contenha \"date\" no nome\n  nrow()## [1] 3029"},{"path":"missing-data.html","id":"trabalhando-com-na-no-ggplot","chapter":"20 Campos em branco/faltantes","heading":"Trabalhando com NA no ggplot()","text":"Frequentemente, é sábio mostrar quantidade de valores excluídos na confeção de um gráfico em sua legenda. Abaixo é um exemplo:ggplot(), você pode adicionar etiquetas com labs(), e dentro da função utilizar o atributo caption =. Neste atributo, você pode utilizar função str_glue(), pacote stringr, para unir os valores em uma senteça, de forma que eles são ajustados automaticamente. Um exemplo é mostrado abaixo:Observe o uso \\n para adicionar uma nova linhaObserve que, caso colunas múltiplas contribuam para exclusão dos valores gráfico (ex.: age ou sex se estes interferirem gráfico), então você precisa filtrar por estas colunas assim como calcular o número de registros não mostrados de forma correta.vezes, pode ser mais fácil salvar o texto em um objeto em comandos anteriores função ggplot(), e, simplesmente, referenciar o objeto criado dentro da função str_glue().","code":"\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} do Hospital Central;\n  {nrow(central_data %>% filter(is.na(date_onset)))} registros sem as datas de início dos sintomas não são mostrados.\"))  "},{"path":"missing-data.html","id":"na-na-classe-factors","chapter":"20 Campos em branco/faltantes","heading":"NA na classe factors","text":"Se sua coluna de interesse um fator (da classe factors), utilize função fct_explicit_na(), pacote forcats, para converter os valores tipo NA para valores tipo caractere. Veja mais detalhes na página Fatores. Por padrão, o novo valor atribuído é “(Missing)”, mas pode ser ajustado através argumento na_level =.","code":"\npacman::p_load(forcats)   # carregue o pacote\n\nlinelist <- linelist %>% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)## [1] \"f\"       \"m\"       \"Missing\""},{"path":"missing-data.html","id":"imputação-de-dados-nos-campos-em-branco","chapter":"20 Campos em branco/faltantes","heading":"20.6 Imputação de dados nos campos em branco","text":"vezes, ao analisar os dados, será importante “preencher lacunas” e atribuir valores nos campos vazios. Mesmo que você possa analisar os dados após remover todos os campos em branco, isto pode causar diversos problemas. Aqui estão dois exemplos:Ao remover todas observações com campos em branco, ou variáveis com uma quantidade elevada de dados em branco, você pode reduzir seu poder de amostra ou capacidade para realizar algumas análises. Por exemplo, como descobrimos anteriormente, apenas uma pequena fração das observações nosso banco de dados linelist não possui campos em branco em todas variáveis. Se nós removessemos maioria dessas linhas, estaríamos perdendo muita informação! Também vimos que boa parte das nossas variáveis possui alguma quantidade de dados em branco – assim, para boa parte da análise, provavelmente não é razoável excluir todas variáveis que possuem muitos campos vazios.Ao remover todas observações com campos em branco, ou variáveis com uma quantidade elevada de dados em branco, você pode reduzir seu poder de amostra ou capacidade para realizar algumas análises. Por exemplo, como descobrimos anteriormente, apenas uma pequena fração das observações nosso banco de dados linelist não possui campos em branco em todas variáveis. Se nós removessemos maioria dessas linhas, estaríamos perdendo muita informação! Também vimos que boa parte das nossas variáveis possui alguma quantidade de dados em branco – assim, para boa parte da análise, provavelmente não é razoável excluir todas variáveis que possuem muitos campos vazios.Dependendo motivo de seus dados estarem em branco, realizar análise apenas de dados completos pode levar resultados enviesados ou incorretos. Por exemplo, anteriormente, nós descobrimos que estamos sem dados de alguns pacientes que tange à presença de sintomas importantes, como febre e tosse. Mas, como uma possibilidade, talvez essa informação não foi registrada para pessoas que, obviamente, não estavam muito doentes. Neste caso, se nós apenas removermos essas observações, estaremos excluindo algumas das pessoas mais saudáveis nosso banco de dados, o que iria enviesar nossos resultados.Dependendo motivo de seus dados estarem em branco, realizar análise apenas de dados completos pode levar resultados enviesados ou incorretos. Por exemplo, anteriormente, nós descobrimos que estamos sem dados de alguns pacientes que tange à presença de sintomas importantes, como febre e tosse. Mas, como uma possibilidade, talvez essa informação não foi registrada para pessoas que, obviamente, não estavam muito doentes. Neste caso, se nós apenas removermos essas observações, estaremos excluindo algumas das pessoas mais saudáveis nosso banco de dados, o que iria enviesar nossos resultados.É importante pensar sobre o porque seus dados podem estar em branco, além de avaliar quantidade de campos em branco. Fazer isto pode ajudá-lo decidir o quão importante será atribuir valores nos campos em branco, e qual o melhor método de imputação para sua situação.","code":""},{"path":"missing-data.html","id":"tipos-de-dados-em-branco","chapter":"20 Campos em branco/faltantes","heading":"Tipos de dados em branco","text":"Aqui estão três tipos gerais de dados em branco:Dados faltantes completamente de forma aleatória (MCAR, inglês Missing Comnpletely Random). Isto significa que não existe relação entre os dados em branco e qualquer outra variável dos seus dados. probabilidade dos dados estarem em branco são mesmas para todos os casos. Isto é uma situação rara. Mas, se você tiver uma forte razão para acreditar que seus dados são tipo MCAR, analisar apenas os dados completos sem atribuir valores não irá enviesar seus resultados (apesar de que você pode perder algum poder de amostra). [fazer: considere discutir testes estatísticos para MCAR]Dados faltantes completamente de forma aleatória (MCAR, inglês Missing Comnpletely Random). Isto significa que não existe relação entre os dados em branco e qualquer outra variável dos seus dados. probabilidade dos dados estarem em branco são mesmas para todos os casos. Isto é uma situação rara. Mas, se você tiver uma forte razão para acreditar que seus dados são tipo MCAR, analisar apenas os dados completos sem atribuir valores não irá enviesar seus resultados (apesar de que você pode perder algum poder de amostra). [fazer: considere discutir testes estatísticos para MCAR]Dados faltantes aleatoriamente (MAR, inglês Missing Random). Este nome é, na verdade, um pouco incorreto, uma vez que dados tipo MAR não estão perdidos de forma alearória, e sim de forma sistemática e previsível, baseado em outras informações que você tem. Por exemplo, talvez cada observação em branco seu banco de dados para febre não foi registrada porque assumiram que todos os pacientes com calafrios e dores estavam com febre, e, então, suas temperaturas não foram medidas. Se verdade, nós poderíamos facilmente predizer que cada observação em branco em que o paciente tivesse calafrios e dores, ele também teve febre, e utilizar essa informação para atribuir dados. Na prática, existe um espectro de possibilidades. Talvez, se um paciente sem temperatura medida tivesse tanto calafrios quanto dores, ele provavelmente também teria febre, mas nem sempre. Isto ainda é previsível, embora não seja perfeitamente previsível. Este é um tipo comum de perda de dados.Dados faltantes aleatoriamente (MAR, inglês Missing Random). Este nome é, na verdade, um pouco incorreto, uma vez que dados tipo MAR não estão perdidos de forma alearória, e sim de forma sistemática e previsível, baseado em outras informações que você tem. Por exemplo, talvez cada observação em branco seu banco de dados para febre não foi registrada porque assumiram que todos os pacientes com calafrios e dores estavam com febre, e, então, suas temperaturas não foram medidas. Se verdade, nós poderíamos facilmente predizer que cada observação em branco em que o paciente tivesse calafrios e dores, ele também teve febre, e utilizar essa informação para atribuir dados. Na prática, existe um espectro de possibilidades. Talvez, se um paciente sem temperatura medida tivesse tanto calafrios quanto dores, ele provavelmente também teria febre, mas nem sempre. Isto ainda é previsível, embora não seja perfeitamente previsível. Este é um tipo comum de perda de dados.Dados faltantes de forma não aleatória (MNAR, inglês Missing Random). vezes, também chamado de Não perdidos aleatoriamente (NMAR). Esta situação considera que probabilidade de um campo estar em branco NÃO é sistemática ou previsível utilizando outras informações que temos, mas também não foram perdidos de forma aleatória. Assim, os dados foram perdidos por razões desconhecidas ou por motivos que você não tem informações sobre. Por exemplo, em nosso banco de dados, talvez informações sobre idades estejam em branco porque alguns pacientes muito idosos ou não sabiam idade, ou recusaram informar idade. Nesta situação, os dados perdidos de idade estão relacionados à idade diretamente (e, assim, não são perdas aleatórias), e não são dados previsíveis através de outras informações que temos. MNAR é complexo e, frequentemente, melhor forma de trabalhar com isso é tentar coletar mais dados ou informações sobre o porque os dados estão faltando, em vez de atribuir valores.Dados faltantes de forma não aleatória (MNAR, inglês Missing Random). vezes, também chamado de Não perdidos aleatoriamente (NMAR). Esta situação considera que probabilidade de um campo estar em branco NÃO é sistemática ou previsível utilizando outras informações que temos, mas também não foram perdidos de forma aleatória. Assim, os dados foram perdidos por razões desconhecidas ou por motivos que você não tem informações sobre. Por exemplo, em nosso banco de dados, talvez informações sobre idades estejam em branco porque alguns pacientes muito idosos ou não sabiam idade, ou recusaram informar idade. Nesta situação, os dados perdidos de idade estão relacionados à idade diretamente (e, assim, não são perdas aleatórias), e não são dados previsíveis através de outras informações que temos. MNAR é complexo e, frequentemente, melhor forma de trabalhar com isso é tentar coletar mais dados ou informações sobre o porque os dados estão faltando, em vez de atribuir valores.Concluindo, geralmente, atribuir valores em dados MCAR é simples, enquanto em dados MNAR é desafiador, senão impossível. Muitos dos métodos de imputação de valores assumem dados MAR.","code":""},{"path":"missing-data.html","id":"pacotes-úteis","chapter":"20 Campos em branco/faltantes","heading":"Pacotes úteis","text":"Alguns pacotes úteis para imputar dados perdidos são Mmisc, missForest (que utiliza o modelo de florestas aleatórias para imputar dados perdidos), e mice (Imputação Multivariada por Equações em Cadeia). Para essa seção, nós iremos utilizar apenas o pacote mice, que implementa uma variedade de técnicas. O mantenedor pacote mice publicou um livro online com mais detalhes sobre como imputar dados perdidos (https://stefvanbuuren.name/fimd/).Segue o código para carregar o pacote mice:","code":"\npacman::p_load(mice)"},{"path":"missing-data.html","id":"imputação-por-média","chapter":"20 Campos em branco/faltantes","heading":"Imputação por média","text":"vezes, se você está realizando uma análise simples, ou possui uma forte razão para pensar que pode assumir os dados perdidos como MCAR, é possível simplesmente atribuir média daquela variável nos campos em branco. Talvez possamos assumir que perda de medições de temperatura em nosso banco de dados foi MCAR ou apenas valores normais. Aqui está o código para criar uma nova variável que substitui os valores faltantes pela temperatura média nosso banco de dados. Entretanto, em muitas situações, substituir dados com o valor médio pode gerar resultados enviesados, então seja cuidadoso.Você pode também realizar um processo similar para substituir dados categóricos por um valor específico. Para o nosso banco de dados, imagine que você soubesse que todas observações com um campo em branco na variável outcome (evolução clínica, que pode ser “Death” ou “Recover”) foram de pessoas que evoluíram para óbito (nota: isto não é verdade para o nosso banco de dados):","code":"\nlinelist <- linelist %>%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\nlinelist <- linelist %>%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))"},{"path":"missing-data.html","id":"imputação-por-regressão","chapter":"20 Campos em branco/faltantes","heading":"Imputação por regressão","text":"Outro método de certa forma mais avançado para imputar valores é utilizar algum tipo de modelo estatístico para prever o que um valor perdido é. Aqui está um exemplo onde os valores preditos são criados para todos os campos sem temperatura, mas com os campos de age (idade) e fever (febre) preenchidos, utilizando estas variáveis como preditoras em uma regressão linear simples. Na prática, você iria querer utilizar um modelo melhor que este, que é mais simples.Ou, utilizando mesma abordagem de modelagem com o pacote mice para imputar valores de temperatura nos campos em branco:Este é o mesmo tipo de abordagem feita por alguns métodos mais avançados, como utilizando o pacote missForest para substituir os campos em branco pelos valores preditos. Neste caso, o modelo de predição utilizado é o de florestas aleatórias (random forest) em vez de uma regressão linear. Você pode utilizar outros tipos de modelos para fazer isso. Entretanto, enquanto esta abordagem funciona bem com dados MCAR, você deve ser cuidadoso se acredita que seus dados perdidos sejam tipo MAR ou MNAR. qualidade da imputação irá depender quão bom o seu modelo de predição é, e, mesmo com um modelo muito bom, variedade dos dados imputados pode ser subestimada.","code":"\nsimple_temperature_model_fit <- lm(temp ~ fever + age_years, data = linelist)\n\n#utilizando o nosso simples modelo de temperatura para predizer valores de temperatura apenas para os campos em branco\npredictions_for_missing_temps <- predict(simple_temperature_model_fit,\n                                        newdata = linelist %>% filter(is.na(temp))) \nmodel_dataset <- linelist %>%\n  select(temp, fever, age_years)  \n\ntemp_imputed <- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)## Warning: Number of logged events: 1\ntemp_imputed_values <- temp_imputed$imp$temp"},{"path":"missing-data.html","id":"locf-e-bocf","chapter":"20 Campos em branco/faltantes","heading":"LOCF e BOCF","text":"Última observação levada adiante (LOCF, inglês “Last observation carried forward”) e observação de base levada adiante (BOCF, inglês “baseline observation carried forward”) são métodos de imputação para séries temporais/dados longitudinais. ideia é utilizar o último valor observado para atribuir nos campos em branco. Quando valores múltiplos são perdidos sucessivamente, o método busca pelo último valor observado.função fill(), pacote tidyr, pode ser utilizada para realizar imputação por LOCF e BOCF (entretanto, outros pacotes como HMISC, zoo, e data.table também incluem métodos para fazer isto). Para mostrar sintaxe fill(), nós iremos criar um simples banco de dados com série temporal contendo o número de casos de uma doença para cada quadrimestre dos anos 2000 e 2001. Entretanto, os valores para os quadrimestres após Q1 estão faltando, então nós iremos imputá-los. sintaxe fill() também é demonstrada na página sobre Pivoteamento dos dados.Nota: tenha certeza de que seus dados estão ordenados corretamente antes de utilizar função fill(). Por padrão, fill() irá preencher de cima para baixo, mas você também pode imputar valores em direções diferentes ao mudar o parâmetro .direction. Nós podemos criar um banco de dados similar onde os valores dos anos estão registrados apenas ano final, e ausentes para quadrimestres anteriores:Neste exemplo, LOCF e BOCF são claramente os métodos corretos para se fazer, mas, em situações mais complicadas, pode ser mais difícil decidir se estes métodos são apropriados. Por exemplo, você pode ter valores em branco dos dados laboratoriais de um paciente hospital após o primeiro dia. vezes, isto quer dizer que os resultados laboratoriais não mudaram após o primeiro dia…mas também pode significar que o paciente se recuperou e seus valores seriam muito diferentes em relação ao primeiro dia! Utilize estes métodos com cautela.","code":"\n#criando um banco de dados simples\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n#imputando os valores perdidos dos anos\ndisease %>% fill(year)## # A tibble: 8 × 3\n##   quarter  year cases\n##   <chr>   <dbl> <dbl>\n## 1 Q1       2000 66013\n## 2 Q2       2000 69182\n## 3 Q3       2000 53175\n## 4 Q4       2000 21001\n## 5 Q1       2001 46036\n## 6 Q2       2001 58842\n## 7 Q3       2001 44568\n## 8 Q4       2001 50197\n#criando um banco de dados sutilmente diferente\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n#impute os anos nos campos em branco na direção para 'cima' (\"up\"):\ndisease %>% fill(year, .direction = \"up\")## # A tibble: 8 × 3\n##   quarter  year cases\n##   <chr>   <dbl> <dbl>\n## 1 Q1       2000 66013\n## 2 Q2       2000 69182\n## 3 Q3       2000 53175\n## 4 Q4       2000 21001\n## 5 Q1       2001 46036\n## 6 Q2       2001 58842\n## 7 Q3       2001 44568\n## 8 Q4       2001 50197"},{"path":"missing-data.html","id":"imputação-múltipla","chapter":"20 Campos em branco/faltantes","heading":"Imputação múltipla","text":"O livro online que mencionamos anteriormente, autor pacote mice (https://stefvanbuuren.name/fimd/), contém uma explicação detalhada da imputação múltipla e porque você gostaria de utilizá-la. Mas aqui está uma explicação básica método:Quando você faz uma imputação múltipla, múltiplos bancos de dados com valores plausíveis imputados nos campos em branco são criados (dependendo dos seus dados de pesquisa, você pode querer criar mais ou menos desses bancos de dados, mas o pacote mice produz 5 bancos de dados por padrão). diferença é que, ao invés de um valor único e específico, cada valor imputado é retirado de uma distribuição estimada (então inclui alguma aleatoridade). Como resultado, cada um desses bancos de dados terá valores imputados ligeiramente diferentes (entretanto, os dados que não estavam em branco continuarão os mesmos nos diferentes bancos de dados). Você irá utilizar algum tipo de modelo preditivo para realizar imputação em cada um dos novos bancos de dados (o pacote mice possui muitas opções para cada método de predição, incluíndo Correspondência Média Preditiva, regressão logística, e florestas aleatórias), mas o pacote mice cuida de muitos dos detalhes da modelagem.Então, assim que você tiver criado estes novos bancos de dados com os valores imputados, é possível aplicar quaisquer modelos estatísticos ou análises que estava planejando realizar em cada um dos bancos, e então unir os resultados destes modelos. Isto funciona muito bem para reduzir o enviesamento dos resultados nas situações de MCAR e MAR, e, frequentemente, os resultados são mais acurados.Aqui está um exemplo da aplicação da Imputação Múltipla para predizer temperaturas em nosso banco de dados linelist, utilizando variáveis idade (age) e status da febre (fever) (nosso simples model_dataset anterior):Aqui nós utilizamos o método padrão mice para imputação, que é Correspondência Média Preditiva. Nós, então, utilizamos os bancos de dados gerados para, separadamente, estimar resultados com regressões lineares simples, e então uni-los. Existem muitos detalhes que não discutimos e muitas configurações que podem ser ajustadas durante o processo de Imputação Múltipla utilizando o pacote mice. Por exemplo, você nem sempre terá dados numéricos e pode precisar usar outros métodos de imputação (você ainda pode utilizar o pacote mice para muitos outros tipos de dados e métodos). Mas, para uma análise mais robusta quando os campos em branco são uma preocupação significativa, o método de Imputação Múltipla é uma boa solução que, quase sempre, não é muito mais trabalhosa que realizar uma análise completa dos casos.","code":"\n# imputando valores perdidos para todas as variáveis em nosso model_dataset, criando 10 novos bancos de dados com valores imputados\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) ## Warning: Number of logged events: 1\nmodel_fit <- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))##          term     estimate    std.error     statistic        df       p.value\n## 1 (Intercept) 3.703143e+01 0.0270863456 1367.16240465  26.83673  1.583113e-66\n## 2   age_years 3.867829e-05 0.0006090202    0.06350905 171.44363  9.494351e-01\n## 3    feveryes 1.978044e+00 0.0193587115  102.17849544 176.51325 5.666771e-159"},{"path":"missing-data.html","id":"recursos-12","chapter":"20 Campos em branco/faltantes","heading":"20.7 Recursos","text":"Manual sobre o pacote naniarGaleria com visualização dos valores perdidosLivro online sobre imputação múltipla R, escrito pelo mantenedor pacote mice","code":""},{"path":"standardization.html","id":"standardization","chapter":"21 Normalização de taxas","heading":"21 Normalização de taxas","text":"Esta página irá descrever duas maneiras de normalizar os dados, como hospitalizações ou mortalidade, com características como idade e sexo.Utilizando o pacote dsrUtilizando o pacote PHEindicatormethodsNós iniciaremos enfatizando os processos de preparação/limpeza/união dos dados, por serem atividades comuns ao combinar dados populacionais de diferentes países, dados populacionais padrões, óbitos, etc.","code":""},{"path":"standardization.html","id":"visão-geral-1","chapter":"21 Normalização de taxas","heading":"21.1 Visão geral","text":"Existem duas principais formas de normalizar: normalização direta e indireta.\nDigamos que gostaríamos de normalizar taxas de mortalidade por idade e sexo, nos países e B, e, então, comparar taxas entre esses países.Para realizar normalização direta, você precisa saber o número da população sob-risco, e o número de mortes para cada faixa etária por sexo, tanto para o país , quanto para o B. Uma faixa etária em nosso exemplo poderia ser mulheres entre 15-44 anos.Para realizar normalizaçaõ de forma indireta, você apenas precisa saber o número total de mortes, e composição da população por sexo e idade em cada país. Logo, está opção é viável quando taxas de mortalidade específicas por idade e sexo, ou números da população, não estão disponíveis. normalização indireta também é preferida nos casos de pequenas quantidades por estrato, uma vez que estimativas com normalização direta seriam influenciadas pela variação amostral.","code":""},{"path":"standardization.html","id":"preparação-11","chapter":"21 Normalização de taxas","heading":"21.2 Preparação","text":"Para mostrar como normalização é feita, nós iremos utilizar dados ficcionais com quantidade populacional e quantidade de mortes dos países e B, por idade (em categorias de 5 anos) e sexo (mulheres, homens). Para criar conjuntos de dados prontos para uso, nós iremos executar seguintes etapas de preparação:Carregar os pacotesCarregar os conjuntos dos dadosUnir os dados populacionais e de óbitos dos dois paísesTransformar para o formato longo, de forma que haja apenas uma linha por estrato idade-sexoLimpar população de referência (população mundial padrão) e uni-la aos dados dos paísesNo seu cenário, os dados podem estar em um formato diferente. Talvez seus dados sejam por províncias, cidades, ou outros tipos de área. Talvez você tenha uma linha para cada óbito, e informações (ou uma proporção significante) sobre idade e sexo para cada um desses óbitos. Neste caso, veja páginas sobre Agrupando dados, Pivoteando os dados, e Tabelas descritivas para criar um conjunto de dados com quantidades de eventos e população por estrato idade-sexo.Nós também precisamos de uma população de referência, população padrão. Para os propósitos deste exercício, nós iremos utilizar o world_standard_population_by_sex. “população padrão mundial” é baseada nas populações de 46 países e foi criada em 1960. Existem muitas populações “padrão” - por exemplo, o site NHS Scotland possui muitas informações sobre População Padrão Européia, População Padrão Mundial, e População Padrão Escocesa.","code":""},{"path":"standardization.html","id":"carregue-os-pacotes-r-3","chapter":"21 Normalização de taxas","heading":"Carregue os pacotes R","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.CUIDADO: Se você tem uma versão mais nova R, o pacote dsr não pode ser diretamente baixado CRAN. Entretanto, ainda está disponível arquivo CRAN. Você pode instalar e utilizar esta versão arquivo. Para os que não utilizam Mac:Para usuários de Mac:","code":"\npacman::p_load(\n     rio,                 # importar/exportar dados\n     here,                # localizar arquivos\n     tidyverse,           # gerenciamento e visualização dos dados\n     stringr,             # limpar caracteres e strings\n     frailtypack,         # necessário para dsr, para modelos de fragilidade\n     PHEindicatormethods) # alternativa para padronização das taxas\n\npacman::p_load_gh(\"cran/dsr\") # foi removido do CRAN\npackageurl <- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n# Outra solução que pode funcionar\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")"},{"path":"standardization.html","id":"carregue-os-dados-populacionais","chapter":"21 Normalização de taxas","heading":"Carregue os dados populacionais","text":"Veja página Download manual e dados para instruções sobre como baixar todos os dados de exemplos utilizados neste manual. Você pode importar os dados da página de Padronização dos dados diretamente R, nosso repositório Github, ao executar os comandos import() abaixo:Primeiro, nós carregamos os dados demográficos (contanges de homens e mulheres por categorias de 5 em 5 anos) para os países que iremos comparar, “País ” e “País B”.","code":"\n# importe dados demográficos do país A diretamente do Github\nA_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# importe dados de óbitos do país A diretamente do Github\nA_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n# importe dados demográficos do país B diretamente do Github\nB_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# importe dados de óbitos do país B diretamente do Github\nB_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n# importe dados demográficos da População padrão mundial diretamente do Github\nstandard_pop_data <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n# País A\nA_demo <- import(\"country_demographics.csv\")\n# País B\nB_demo <- import(\"country_demographics_2.csv\")"},{"path":"standardization.html","id":"carregue-a-quantidade-de-óbitos","chapter":"21 Normalização de taxas","heading":"Carregue a quantidade de óbitos","text":"Convenientemente, quantidade de óbitos, por idade e sexo durante o período de interesse, também está disponível. Cada contagem por país está em arquivos separados, como mostrado abaixo.Óbitos país AÓbitos país B","code":""},{"path":"standardization.html","id":"limpe-os-dados-populacionais-e-de-óbitos","chapter":"21 Normalização de taxas","heading":"Limpe os dados populacionais e de óbitos","text":"Nós precisamos unir e transformar estes dados da seguinte maneira:Combine populações dos países em um conjunto de dados e o transforme para o formato “longo”, de forma que cada estrato idade-sexo esteja em uma linhaCombine quantidade de óbitos dos países em um conjunto de dados e o transforme para o formato “longo”, de forma que cada estrato idade-sexo esteja em uma linhaUna os óbitos com populaçõesPrimeiro, nós iremos unir os dados de população por país, transformar para o formato longo, e realizar uma limpeza mínima dos dados. Veja página sobre Pivoteando os dados para mais detalhes.Agora, os dados populacionais combinados estão assim (clique para ver os países e B)E, agora, nós iremos realizar operações similares nos dois bancos de óbitos.Agora, os dados de óbitos estão da seguinte forma, e contêm dados de ambos países:Agora, nós uniremos os dados populacionais e de óbitos, baseado nas colunas em comum Country, age_cat5, e Sex. O processo também adiciona coluna Deaths.Então, podemos classificar Sex, age_cat5, e Country como factors, e ajustar ordem dos níveis com função fct_relevel() pacote forcats, como descrito na página Fatores. Nota, visivelmente, classificar os níveis dos factors não altera os dados, mas o comando arrange() ordena os dados por país (Country), categoria de idade (age), e sexo (sex).CUIDADO: Se você possuir poucos óbitos por estrato, considere utilizar categorias com intervalos de 10 ou 15 anos, em vez de 5 anos.","code":"\npop_countries <- A_demo %>%  # inicie com os dados do país A\n     bind_rows(B_demo) %>%        # una as linhas, uma vez que as colunas têm o mesmo nome\n     pivot_longer(                       # transforme (pivot) para o formato longo\n          cols = c(m, f),                   # colunas para combinar em uma\n          names_to = \"Sex\",                 # nome para a nova coluna contendo a categoria (\"m\" ou \"f\") \n          values_to = \"Population\") %>%     # nome para a nova coluna contendo os valores numéricos transformados (pivoted)\n     mutate(Sex = recode(Sex,            # re-codifique os valores para clareza\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\ndeaths_countries <- A_deaths %>%    # inicie com os dados de óbitos do país A\n     bind_rows(B_deaths) %>%        # una as linhas com os dados do país B, uma vez que o nome das colunas é igual\n     pivot_longer(                  # transforme para formato longo\n          cols = c(Male, Female),        # colunas para transformar em uma\n          names_to = \"Sex\",              # nome da nova coluna contendo a categoria (\"m\" ou \"f\") \n          values_to = \"Deaths\") %>%      # nome da nova coluna contendo os valores numéricos transformados\n     rename(age_cat5 = AgeCat)      # renomeie para mais clareza\ncountry_data <- pop_countries %>% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\ncountry_data <- country_data %>% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %>% \n          \n  arrange(Country, age_cat5, Sex)"},{"path":"standardization.html","id":"carregue-os-dados-populacionais-de-referência","chapter":"21 Normalização de taxas","heading":"Carregue os dados populacionais de referência","text":"Por último, para realizar padronização direta, nós iremos importar população de referência (“população mundial de referência” por sexo)","code":"\n# População de referência\nstandard_pop_data <- import(\"world_standard_population_by_sex.csv\")"},{"path":"standardization.html","id":"limpe-os-dados-da-população-de-referência","chapter":"21 Normalização de taxas","heading":"Limpe os dados da população de referência","text":"Os valores por categorias de idade nos conjuntos de dados country_data e standard_pop_data precisam ser alinhados.momento, os valores da coluna age_cat5, conjunto standard_pop_data, contém palavras “years” e “plus”, enquanto os dados em country_data não possuem essas palavras. Nós precisamos garantir que os valores da categoria “age” coincidam. Para tanto, utilizaremos função str_replace_all(), pacote stringr, como descrito na página sobre Caracteres e strings, para substituir estes padrões para “sem espaço” \"\".Além disso, o pacote dsr espera que, na população de referência, coluna contendo contagens será chamada de \"pop\". Então, iremos renomear essa coluna desta forma.CUIDADO: Se você tentar utilizar função str_replace_all() para remover o símbolo de adição, ele não irá funcionar pois é um símbolo especial. “Ignore” o caráter especial ao colocar duas barras invertidas na frente, como em str_replace_call(column, \"\\\\+\", \"\"). ","code":"\n# Remova palavras específicas da coluna valores (\"values\")\nstandard_pop_clean <- standard_pop_data %>%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"),   # remova \"year\"\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"),    # remova \"plus\"\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %>%   # remova \" \" espaço\n     \n     rename(pop = WorldStandardPopulation)   # mude o nome da coluna para \"pop\", como o pacote dsr solicita"},{"path":"standardization.html","id":"standard_all","chapter":"21 Normalização de taxas","heading":"Crie um conjunto de dados com uma população padrão","text":"Finalmente, o pacote PHEindicatormethods, detalhado abaixo, trabalha com populações padrões unidas aos dados dos países e contagens da população. Então, nós iremos criar um banco de dados chamado all_data para isto.O conjunto de dados inteiro ficou assim:","code":"\nall_data <- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))"},{"path":"standardization.html","id":"pacote-dsr","chapter":"21 Normalização de taxas","heading":"21.3 pacote dsr","text":"Abaixo, nós demonstramos como calcular e comparar taxas normalizadas diretamente, utilizando o pacote dsr. O pacote dsr permite o cálculo e comparação de taxas normalizadas diretamente (mas não taxas normalizadas indiretamente!).Na seção sobre Preparação dos dados, nós construímos diferentes conjuntos de dados para contagens dos países e da população padrão:o objeto country_data contém uma tabela populacional com quantidade da população e o número de mortes por estrato por paíso objeto standard_pop_clean contém o número da população por estrato da população padrão, População Mundial PadrãoNós iremos utilizar estes dados separados na abordagem dsr.","code":""},{"path":"standardization.html","id":"taxas-normalizadas","chapter":"21 Normalização de taxas","heading":"Taxas normalizadas","text":"Abaixo, nós calculamos taxas por país normalizadas diretamente para idade e sexo. Nós utilizamos função dsr().De nota - função dsr() espera uma tabela de dados para populações país e contagens dos eventos (mortes), e um data frame separado contendo população padrão. Ela também considera que banco de dados da população padrão, o nome da coluna com unidade-tempo é “pop” (nós garantimos isto na seção sobre Preparação de dados).Existem muitos argumentos possíveis, como anotado código abaixo. Notavelmente, coluna Deaths está selecionada em event =, e coluna Population está selecionada para fu = (“acompanhamento”). Nós selecionamos os subgrupos de comparação como sendo da coluna Country, e padronizamos baseado em age_cat5 e Sex. Estas últimas duas colunas não foram utilizadas em nenhum argumento em particular. Veja ?dsr para detalhes.Acima, nós vemos que enquanto o país possui uma menor taxa de mortalidade bruta que o país B, ele possui uma maior taxa normalizada de mortalidade após normalizar utilizando idade e o sexo.","code":"\n# Calcula as taxas por país normalizadas diretamente por idade (age) e sexo (sex)\nmortality_rate <- dsr::dsr(\n     data = country_data,  # especifique o objeto contendo o número de mortes por estrato\n     event = Deaths,       # coluna contendo o número de mortes por estrato\n     fu = Population,      # coluna contendo o número da população por estrato\n     subgroup = Country,   # unidades que gostaríamos de comparar\n     age_cat5,             # outras colunas - taxas serão normalizadas por estas colunas\n     Sex,\n     refdata = standard_pop_clean, # data frame contendo a população de referência, com a coluna chamada pop\n     method = \"gamma\",      # método para calcular o IC 95%\n     sig = 0.95,            # nível de significância\n     mp = 100000,           # nós queremos taxas por 100.000 habitantes\n     decimals = 2)          # quantidade de decimais\n\n\n# Printa o output como uma tabela em HTML\nknitr::kable(mortality_rate) # mostra as taxas de mortalidade antes e após padronização direta"},{"path":"standardization.html","id":"relação-entre-taxas-normalizadas","chapter":"21 Normalização de taxas","heading":"Relação entre taxas normalizadas","text":"taxa de mortalidade normalizada é 1.22 vezes maior país em relação ao país B (IC 95% 1.17-1.27).","code":"\n# Calcule a razão entre as taxas (rates ratio)\nmortality_rr <- dsr::dsrr(\n     data = country_data, # especifique o objeto que contém o número de mortes por estrato\n     event = Deaths,      # coluna contendo o número de óbitos por estrato\n     fu = Population,     # coluna contendo o número da população por estrato\n     subgroup = Country,  # unidades que queremos comparar\n     age_cat5,\n     Sex,                 # características para as quais gostaríamos de normalizar\n     refdata = standard_pop_clean, # população de referência, com números em uma coluna chamada pop\n     refgroup = \"B\",      # referência para comparação\n     estimate = \"ratio\",  # tipo de estimativa\n     sig = 0.95,          # nível de significância\n     mp = 100000,         # nós queremos taxas por 100.000 habitantes\n     decimals = 2)        # quantidade de decimais\n\n# Printa a tabela\nknitr::kable(mortality_rr) "},{"path":"standardization.html","id":"diferença-entre-taxas-normalizadas","chapter":"21 Normalização de taxas","heading":"Diferença entre taxas normalizadas","text":"Quando comparado ao país B, o país possui 4.24 óbitos adicionais por 100.000 habitantes (IC 95% 3.24-5.24).","code":"\n# Calcule a diferença entre taxas normalizadas (Rates Difference)\nmortality_rd <- dsr::dsrr(\n     data = country_data,       # especifique o objeto contendo o número de mortes por estrato\n     event = Deaths,            # coluna contendo o número de óbitos por estrato\n     fu = Population,           # coluna contendo a quantidade de população por estrato\n     subgroup = Country,        # unidades que gostaríamos de comparar\n     age_cat5,                  # características para as quais gostaríamos de normalizar\n     Sex,                        \n     refdata = standard_pop_clean, # população de referência, com números na coluna chamada pop\n     refgroup = \"B\",            # refência para comparação\n     estimate = \"difference\",   # tipo de estimativa\n     sig = 0.95,                # nível de significância\n     mp = 100000,               # nós queremos taxas por 100.000 habitantes\n     decimals = 2)              # quantidade de decimais\n\n# Printa a tabela\nknitr::kable(mortality_rd) "},{"path":"standardization.html","id":"standard_phe","chapter":"21 Normalização de taxas","heading":"21.4 pacote PHEindicatormethods","text":"Outra forma de calcular taxas normalizadas é com o pacote PHEindicatormethods. Este pacote permite calcular tanto taxas normalizadas diretamente, como taxas normalizadas indiretamente. Nós iremos mostrar como realizar ambos cálculos.Neste seção, iremos utilizar os dados objeto all_data, criado fim da seção de Preparação. Estes dados possuem população dos países, quantidade de mortes, e população padrão mundial. Você pode vê-lo aqui.","code":""},{"path":"standardization.html","id":"taxas-normalizadas-diretamente","chapter":"21 Normalização de taxas","heading":"Taxas normalizadas diretamente","text":"Abaixo, primeiro agrupamos os dados por País, e então aplicamos função phe_dsr() para obter taxas diretamente normalizadas por país.De nota - população de referência (padrão) pode ser fornecida como uma coluna dentro de uma tabela de dados específica para cada país ou como um vetor separado. Se fornecida dentro de uma tabela específica para um país, você precisa ajustar stdpoptype = \"field\". Se fornecido como um vetor, ajuste stdpoptype = \"vector\". Neste último caso, você precisa garantir que ordem das linhas por estrato é similar em ambas tabelas dos países e população de referência, pois os registros serão ligados por posição. exemplo abaixo, fornecemos população de referência como uma coluna dentro de uma tabela específica de um páís.Para mais informações, utilize ?phr_dsr, ou acesse os links na seção de Referências.","code":"\n# Calcule as taxas por país diretamente normalizadas para idade e sexo\nmortality_ds_rate_phe <- all_data %>%\n     group_by(Country) %>%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths,                 # coluna com o número observado de eventos\n          n = Population,             # coluna com a população não-normalizada para cada estrato\n          stdpop = pop,               # populações padronizadas para cada estrato\n          stdpoptype = \"field\")       # ou \"vector\" para vetor autônomo ou \"field\" para populações padronizadas nos dados\n\n# Printa a tabela\nknitr::kable(mortality_ds_rate_phe)"},{"path":"standardization.html","id":"standard_indirect","chapter":"21 Normalização de taxas","heading":"Taxas normalizadas indiretamente","text":"Para normalização indireta, você precisa de uma população de referência com o número de óbitos e quantidade da população por estrato. Neste exemplo, nós iremos calcular taxas para o país utilizando o país B como população de referência, uma vez que população de referência em standard_pop_clean não possui quantidade de mortes por estrato.Abaixo, primeiro criamos população de referência país B. Então, passamos os dados populacionais e de mortalidade país , combinamos ele com população de referência, e passamos para função calculate_ISRate(), para obter taxas indiretamente normalizadas. Claro, você pode fazer isto vice versa.De nota - exemplo abaixo, população de referência é fornecida como um data frame separado. Neste caso, nós garantimos que os vetores x =, n =, x_ref = e n_ref = são todos ordenados pelos mesmos valores da categoria de padronização (estrato) como nos nossos dados específicos dos países, uma vez que os registros serão ligados pela posição na tabela.Para mais informações, utilize ?phr_isr, ou acesse os links na seção de Referências.","code":"\n# Crie a população de referência\nrefpopCountryB <- country_data %>% \n  filter(Country == \"B\") \n\n# Calcule taxas para o país A indiretamente normalizada por idade e sexo\nmortality_is_rate_phe_A <- country_data %>%\n     filter(Country == \"A\") %>%\n     PHEindicatormethods::calculate_ISRate(\n          x = Deaths,                 # coluna com o número observado de eventos\n          n = Population,             # coluna com população não padronizada para cada estrato\n          x_ref = refpopCountryB$Deaths,  # quantidade referência de mortes  para cada estrato\n          n_ref = refpopCountryB$Population)  # população de referência para cada estrato\n\n# Printa a tabela\nknitr::kable(mortality_is_rate_phe_A)"},{"path":"standardization.html","id":"recursos-13","chapter":"21 Normalização de taxas","heading":"21.5 Recursos","text":"Se você quiser ver outros exemplos reproduzíveis utilizando dsr, por favor veja esse tutorialPara outro exemplo utilizando PHEindicatormethods, por favor vá esse websiteVeja o arquivo de referência PHEindicatormethods em pdf","code":""},{"path":"moving-average.html","id":"moving-average","chapter":"22 Médias móveis","heading":"22 Médias móveis","text":"Nesta página, dois métodos para calcular e visualizar médias móveis serão abordados:Calcule com o pacote sliderCalcule com um comando dentro da função ggplot(), utilizando o pacote tidyquant","code":""},{"path":"moving-average.html","id":"preparação-12","chapter":"22 Médias móveis","heading":"22.1 Preparação","text":"","code":""},{"path":"moving-average.html","id":"carregue-os-pacotes-4","chapter":"22 Médias móveis","heading":"Carregue os pacotes","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  tidyverse,      # para gerenciamento e visualização dos dados\n  slider,         # para calcular médias móveis\n  tidyquant       # para calcular médias móveis dentro do ggplot\n)"},{"path":"moving-average.html","id":"importe-os-dados-para-r","chapter":"22 Médias móveis","heading":"Importe os dados para R","text":"Nós iremos importar o banco de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando função import() pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja página Importar e exportar para detalhes).primeiras 50 linhas banco de dados são mostradas abaixo.","code":"\n# importe o *linelist*\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"moving-average.html","id":"calculando-com-o-pacote-slider","chapter":"22 Médias móveis","heading":"22.2 Calculando com o pacote slider","text":"Utilize esta abordagem para calcular uma média móvel em um conjunto de dados antes de traçar o gráfico.O pacote slider fornece diferentes funções que utilizam abordagem de “janelas deslizantes” (inglês, sliding window) para calcular médias móveis, somas cumulativas, regressões móveis, etc. Este pacote trata o conjunto de dados como um vetor de linhas, permitindo iteração entre linhas conjunto de dados.Aqui estão algumas das funções mais comuns:slide_dbl() - realiza iteração de uma coluna numérica (logo “_dbl”) enquanto executa uma operação usando o protocolo das janelas deslizantes\nslide_sum() - função atalho para realizar soma móvel para função slide_dbl()\nslide_mean() - função atalho para realizar média móvel para função slide_dbl()\nslide_dbl() - realiza iteração de uma coluna numérica (logo “_dbl”) enquanto executa uma operação usando o protocolo das janelas deslizantesslide_sum() - função atalho para realizar soma móvel para função slide_dbl()slide_mean() - função atalho para realizar média móvel para função slide_dbl()slide_index_dbl() - aplica janelas deslizantes em uma coluna numérica, utilizando uma coluna separada para indexar progressão das janelas (útil se progressão estiver sendo por datas e algumas estiverem ausentes)\nslide_index_sum() - função atalho para realizar soma móvel usando indexador\nslide_index_mean() - função atalho para realizar média móvel usando indexador\nslide_index_dbl() - aplica janelas deslizantes em uma coluna numérica, utilizando uma coluna separada para indexar progressão das janelas (útil se progressão estiver sendo por datas e algumas estiverem ausentes)slide_index_sum() - função atalho para realizar soma móvel usando indexadorslide_index_mean() - função atalho para realizar média móvel usando indexadorO pacote slider possui muitas outras funções que são cobertas na seção sobre Recursos extras desta página. Aqui, nós abordamos brevemente funções mais comuns.Argumentos essenciais.x, por padrão, o primeiro argumento é o vetor sobre o qual serão realizadas iterarações e sobre o qual será aplicada função.x, por padrão, o primeiro argumento é o vetor sobre o qual serão realizadas iterarações e sobre o qual será aplicada função.= para versões “index” das funções pacote slider - indique coluna para “indexar” o “delizamento” (veja seção abaixo).= para versões “index” das funções pacote slider - indique coluna para “indexar” o “delizamento” (veja seção abaixo).f =, por padrão, o segundo argumento é:\nUma função, escrita sem parênteses, como mean, ou\nUma fórmula, que será convertida em uma função. Por exemplo, ~ .x - mean(.x) irá gerar o resultado valor corrente menos média valor da janela\n.f =, por padrão, o segundo argumento é:Uma função, escrita sem parênteses, como mean, ouUma fórmula, que será convertida em uma função. Por exemplo, ~ .x - mean(.x) irá gerar o resultado valor corrente menos média valor da janelaPara mais detalhes, veja esse material de referênciaPara mais detalhes, veja esse material de referênciaTamanho da janelaEspecifique extensão da janela ao usar ., ., ou ambos argumentos:.= - Forneça um número inteiro.= - Forneça um número inteiro.complete = - Ajuste isso para TRUE se você apenas quiser realizar os cálculos em janelas completasPor exemplo, para atingir uma janela de 7 dias incluindo o valor corrente e os seis anteriores, utilize .= 6. Para obter uma janela “central”, forneça o mesmo número tanto para .= quanto para .=.Por padrão, .complete = será FALSE. Então, se janela inteira de linhas não existir, funções irão utilizar linhas disponíveis para executar os cálculos. Alterar para TRUE restringue isso, de forma que os cálculos serão realizados apenas em janelas completas.Janelas em expansãoPara obter operações cumulativas, ajuste o argumento .= para Inf. Isto irá realizar operação valor corrente e em todos os valores anteriores.","code":""},{"path":"moving-average.html","id":"roll_index","chapter":"22 Médias móveis","heading":"Deslizando por data","text":"aplicação mais provável de cálculos móveis em epidemiologia aplicada é para examinar um indicador ao longo tempo. Por exemplo, uma medida móvel da incidência de casos, baseado na contagem diária dos casos.Se você possuir dados com séries cronológicas limpas, com valores para cada data, você pode estar OK para utilizar função slide_dbl(), como demonstrado aqui na página sobre Séries temporais e detecção de surtos.Entretanto, em muitas situações da epidemiologia aplicada, você pode não ter algumas datas nos seus dados, em que os eventos não foram registrados. Nestes casos, é melhor utilizar versões “index” das funções slider.","code":""},{"path":"moving-average.html","id":"dados-indexados","chapter":"22 Médias móveis","heading":"Dados indexados","text":"Abaixo, nós mostramos um exemplo utilizando função slide_index_dbl() objeto linelist criado acima. Digamos que nosso objetivo é calcular uma incidência móvel de 7 dias - soma dos casos utilizando uma janela de 7 dias. Se você estiver procurando por um exemplo de média móvel, veja seção abaixo sobre deslocamento agrupado.Para iniciar, o conjunto de dados daily_counts é criado para refletir contagem diária de casos linelist, sendo calculado com função count() dplyr.Aqui estão os dados daily_counts - existem nrow(daily_counts) linhas, onde cada dia é representado por uma linha mas, especialmente início da epidemia, alguns dias não estão presentes (não existem casos admitidos nestes dias).É crucial reconhecer que uma função móvel padrão (como slide_dbl()) iria utilizar uma janela de 7 linhas, não de 7 dias. Logo, se existirem datas ausentes, algumas janelas irão abrangir mais que 7 dias de um calendário!Uma janela móvel “inteligente” pode ser obtida com função slide_index_dbl(). O “index” significa que função utiliza uma coluna separada como “indexador” para janela deslizante. Assim, janela não é simplesmente baseada nas linhas conjunto de dados.Se coluna indexadora uma data, você possui habilidade para especificar extensão da janela em .= e/ou .= em diferentes unidades, utilizando funções days() ou months() pacote lubridate. Se você fizer isto, função irá incluir os dias ausentes nas janelas como se lá estivessem (com valores NA).Vamos mostrar uma comparação. Abaixo, nós calculamos incidência móvel de casos por 7 dias, utilizando uma janela regular e uma indexada.Observe como, na coluna regular, contagem aumenta constantemente nas primeiras 7 linhas, mesmo com estas linhas estando fora intervalo de 7 dias entre elas! coluna adjacente “indexada” leva em consideração estes dias ausentes calendário, então suas somas móveis de 7 dias são muito menores, pelo menos neste período da epidemia, quando os casos estão mais distantes uns dos outros.Agora você pode traçar um gráfico desses dados utilizando o ggplot():","code":"\n# crie um conjunto de dados das contagens diárias\ndaily_counts <- linelist %>% \n  count(date_hospitalisation, name = \"new_cases\")\nrolling <- daily_counts %>% \n  mutate(                                # crie novas colunas\n    # Utilizando slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # calcule utilizando new_cases\n      .f = ~sum(.x, na.rm = T),          # função sum() com os campos em branco removidos\n      .before = 6),                      # a janela é a LINHA corrente e as 6 LINHAS anteriores\n    \n    # Utilizando slide_index_dbl()\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # calcule com new_cases\n        .i = date_hospitalisation,       # indexado com date_onset \n        .f = ~sum(.x, na.rm = TRUE),     # função sum() com os campos em branco removidos\n        .before = days(6))               # a janela é o DIA e os 6 DIAS anteriores\n    )\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)"},{"path":"moving-average.html","id":"roll_slider_group","chapter":"22 Médias móveis","heading":"Deslizando por grupo","text":"Se você agrupar seus dados antes de utilizar uma função slider, janelas deslizantes serão aplicadas por grupos. Tenha cuidado para organizar suas linhas na ordem desejada por grupo.cada momento que um novo grupo se inicia, janelas deslizantes irão reiniciar. Logo, um detalhe para se ter em mente é, se seus dados são agrupados e você realizou o ajuste .complete = TRUE, você terá valores em branco cada transição entre os grupos. Enquanto função se desloca para baixo ao longo das linhas, cada transição na coluna de agrupamento irá reiniciar o acúmulo tamanho mínimo da janela, de forma permitir realização cálculo.Veja página sobre Agrupamento dos dados, deste manual, para detalhes sobre agrupamento dos dados.Abaixo, nós contamos os casos linelist por dia e por hospital. Então, ordenamos linhas em ordem ascendente, primeiro ordenando por hospital, e então por dia (dentro da ordem dos hospitais). Por fim, nós ajustamos função group_by(), e assim criamos nossa nova média móvel.Aqui está o novo conjunto de dados:Agora, nós podemos traçar os gráficos das médias móveis, mostrando os dados por grupo ao especificar ~ hospital para facet_wrap() ggplot(). Por diversão, incluímos dois tipos de visualização - uma geom_col(), mostrando contagem diária de casos, e uma geom_line(), mostrando média móvel de 7 dias.PERIGO: Se você obtiver um erro dizendo “slide() deprecated tsibble 0.9.0 now defunct. Please use slider::slide() instead.”, significa que função slide(), pacote tsibble, está mascarando função slide(), pacote slider. Corrija isso ao especificar o pacote comando, como em slider::slide_dbl().","code":"\ngrouped_roll <- linelist %>%\n\n  count(hospital, date_hospitalisation, name = \"new_cases\") %>% \n\n  arrange(hospital, date_hospitalisation) %>%   # organize as linhas por hospital, e então por datas\n  \n  group_by(hospital) %>%              # agrupe por hospital\n    \n  mutate(                             # média móvel\n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # a contagem de casos por hospital-dia\n      .i = date_hospitalisation,      # indexe por dia de admissão\n      .f = mean,                      # utilize mean()                   \n      .before = days(6)               # utilize o dia corrente e os 6 dias anteriores\n      )\n  )\nggplot(data = grouped_roll)+\n  geom_col(                       # adicione a contagem diária de casos como barras cinzas\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # adicione a média móvel como linhas coloridas por hospital\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # crie pequenos gráficos por hospital\n  theme_classic()+                 # simplifique o plano de fundo\n  theme(legend.position = \"none\")+ # remova a legenda\n  labs(                            # adicione legendas aos eixos e título do gráfico\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")"},{"path":"moving-average.html","id":"calcule-com-o-pacote-tidyquant-dentro-da-função-ggplot","chapter":"22 Médias móveis","heading":"22.3 Calcule com o pacote tidyquant dentro da função ggplot()","text":"O pacote tidyquant oferece outra abordagem para calcular médias móveis - desta vez, de dentro de um comando ggplot().Abaixo, os dados linelist são contados por dia início de sintomas, e isto é adicionado ao gráfico como uma linha desbotada (alpha < 1). Em frente à essa linha, está uma outra linha criada com função geom_ma(), pacote tidyquant, com uma janela de 7 dias (n = 7), cor e espessura especificados.Por padrão, geom_ma() utiliza uma média móvel simples (ma_fun = \"SMA\"), mas outros tipos podem ser especificados, como:“EMA” - média móvel exponencial (mais peso para observações recentes)“WMA” - média móvel ponderada (wts são utilizadas para ponder observações na média móvel)Outros tipos podem ser encontrados na documentação da funçãoVeja esse tutorial para mais detalhes das opções disponíveis dentro pacote tidyquant.","code":"\nlinelist %>% \n  count(date_onset) %>%                 # conte os casos por dia\n  drop_na(date_onset) %>%               # remova casos sem a data de início dos sintomas\n  ggplot(aes(x = date_onset, y = n))+   # inicie o ggplot\n    geom_line(                          # adicione uma linha com os valores brutos\n      size = 1,\n      alpha = 0.2                       # linha semi-transparente\n      )+             \n    tidyquant::geom_ma(                 # adicione a média móvel\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # plano de fundo simples"},{"path":"moving-average.html","id":"recursos-extras-1","chapter":"22 Médias móveis","heading":"22.4 Recursos extras","text":"Veja este útil tutorial online pacote sliderA página pacote slider githubUm tutorial sliderTutorial tidyquantSe seus casos necessitam que você “pule” fins de semana, ou até mesmo feriados, você pode gostar pacote almanac.","code":""},{"path":"epidemic-models.html","id":"epidemic-models","chapter":"23 Modelagem de epidemias","heading":"23 Modelagem de epidemias","text":"","code":""},{"path":"epidemic-models.html","id":"visão-geral-do-tópico","chapter":"23 Modelagem de epidemias","heading":"23.1 Visão geral do tópico","text":"Existe um conjunto crescente de ferramentas para modelagem em epidemiologia que nos permite desenvolver\nanálises complexas com esforço mínimo. Este capítulo apresenta\numa síntese sobre como usar essas ferramentas para:estimar o número efetivo de reprodução Rt e estatísticas relacionadas como tempo de duplicaçãoestimar o número efetivo de reprodução Rt e estatísticas relacionadas como tempo de duplicaçãoproduzir projeções de curto prazo da incidência futuraproduzir projeções de curto prazo da incidência futuraTenha em mente que esta página não é uma revisão das metodologias e métodos estatísticos\nempregados por estas ferramentas. Para tanto, utilize os links disponíveis subtópico Recursos extras para\nencontrar artigos detalhando essas metodologias. Antes de utilizar ferramentas seguir, garanta que você\ncompreenda os métodos subjacentes empregados; isto garantirá que você possa interpretar\nadequadamente os resultados.Abaixo está um exemplo de uma das análises que construíremos neste capítulo.","code":""},{"path":"epidemic-models.html","id":"preparação-13","chapter":"23 Modelagem de epidemias","heading":"23.2 Preparação","text":"Iremos utilizar dois métodos e pacotes diferentes para estimar o Rt,\nchamados de EpiNow e EpiEstim, assim como o pacote projections para\nfazer previsões da incidência de casos.Este pedaço de código mostra o carregamento dos pacotes necessários para análises.\nNeste manual, enfatizamos o uso de p_load(), pacote pacman, que instala o pacote, caso necessário, e o inicia para uso.\nVocê também pode carregar pacotes instalados com library(), R base. Veja página sobre Introdução ao R para mais informações sobre pacotes R.Nesta seção, iremos utilizar linelist dos casos limpa para todas análises. Se você quiser acomapnhar, clique para baixar linelist “limpa” (como arquivo .rds). Veja página Download manual e dados para baixar todos os dados utilizados como exemplo neste manual.","code":"\npacman::p_load(\n   rio,          # Importar arquivos\n   here,         # Localizar arquivos\n   tidyverse,    # Gerenciamento dos dados + gráficos ggplot2\n   epicontacts,  # Analisar as redes de transmissão\n   EpiNow2,      # Estimar o Rt\n   EpiEstim,     # Estimar Rt\n   projections,  # Projeções da incidência\n   incidence2,   # Trabalhando com dados de incidência\n   epitrix,      # Funções uteis de epi\n   distcrete     # Distribuições discretas .;\n)\n# importe a linelist limpa\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"epidemic-models.html","id":"estimando-o-rt","chapter":"23 Modelagem de epidemias","heading":"23.3 Estimando o Rt","text":"","code":""},{"path":"epidemic-models.html","id":"epinow2-vs.-epiestim","chapter":"23 Modelagem de epidemias","heading":"EpiNow2 vs. EpiEstim","text":"O número de reprodução R é uma medida da capacidade de transmissão de uma doença e\né definido como quantidade esperada de casos secundários para cada caso infectado. Em uma\npopulação totalmente susceptível, este valor representa o número básico\nde reprodução R0. Entretanto, conforme o número de indivíduos susceptíveis em uma\npopulação muda decorrer de um surto ou pandemia, e conforme várias\nmedidas de resposta e controle são implementadas, medida mais comumente utilizada de\ntransmissibilidade é o número efetivo de reprodução Rt; este é\ndefinido como quantidade de casos secundários por cada caso infectado em um determinando\nponto tempo t.O pacote EpiNow2 fornece estrutura mais sofisticada para estimar o\nRt. Ele tem duas vantagens chave sobre o outro pacote comumente utilizado,\nEpiEstim:Ele leva em consideração demoras nas notificações ao estimar o Rt,\nmesmo quando dados recentes são incompletos.Ele estima o Rt partir das datas de infecção, em vez das datas\nde início das notificações, o que significa que o efeito de uma intervenção irá\nimediatamente refletir em mudanças Rt, em vez de demorar\npara alterar.Entretanto, ele também possuí duas desvantagens chave:Ele necessita de conhecimento da distribuição tempo de geração (ex.: distribuição\ndos intervalos de infecção entre casos primários e secundários), distribuição \ntempo de incubação (ex.: distribuição dos intervalos entre infecção e o início dos\nsintomas) e qualquer outra distribuição de intervalos relevante para os seus dados (ex.: se você\ntiver datas de notificação, você precisa da distribuição dos intervalos entre início dos sintomas\ne notificação dos casos). Enquanto isto irá permitir estimativas mais acuradas \nRt, EpiEstim apenas requer distribuição seriada dos intervalos\n(ex.: distribuição de intervalos entre o início dos sintomas de casos primários\ne secundários), que pode ser única distribuição disponível para você.EpiNow2 é significamente mais devagar que EpiEstim, por fatores entre\n100-1000 mais lento! Por exemplo, estimar o Rt para amostra surto\ntrabalhada nesta seção levou por volta de quatro horas (esta estimativa rodou por um elevado\nnúmero de iterações para garantir elevada acurácia, e provavelmente poderia ser reduzida caso\nnecessário. Entretanto, o ponto é que este algoritmo é mais devagar,\ngeral). Logo, este pacote pode ser inviável caso você esteja atualizando regularmente suas estimativas\nRt.Qual pacote você irá escolher irá depender dos seus dados, tempo e\nrecursos computacionais disponíveis.","code":""},{"path":"epidemic-models.html","id":"epinow2","chapter":"23 Modelagem de epidemias","heading":"EpiNow2","text":"","code":""},{"path":"epidemic-models.html","id":"estimando-a-distribuição-dos-intervalos","chapter":"23 Modelagem de epidemias","heading":"Estimando a distribuição dos intervalos","text":"distribuições dos intervalos necessárias para utilizar o EpiNow2 variam de acordo com os\nseus dados. Essencialmente, você precisar ser capaz de descrever o intervalo entre data\nde infecção e data evento que você quer utilizar para estimar o Rt. Caso\nvocê esteha utilizando datas de início dos sintomas, isto seria simplesmente distribuição período de\nincubação. Se você estiver utilizando datas de notificação, você utiliza o\nintervalo entre infecção à notificação. Como é improvável que esta distribuição seja conhecida\ndiretamente, EpiNow2 permite conectar múltiplas distribuições de intervalo; neste\ncaso, os intervalos entre infecção e o aparecimento dos sintomas (ex.: o período\nde incubação, que provavelmente é conhecido) e entre o início dos sintomas e notificação (que você pode\nfrequentemente estimar partir dos seus dados).Como temos datas de início dos sintomas para todos os nossos casos em nossa linelist de exemplo, nós\napenas precisamos da distribuição período de incubação para conectar os nossos dados (ex.: datas de\ninício dos sintomas) para data de infecção. Nós podemos ou estimar esta distribuição\npartir dos dados, ou utilizar valores da literatura.Uma estimativa período de incubação da Ebola encontrada na literatura (obtida deste artigo) possuí uma\nmédia de 9.1, desvio padrão de 7.3, e o valor máximo de 30. Isto pode ser\nespecificado R como mostrado seguir:Observe que o EpiNow2 pede que distribuição destes intervalos seja fornecida em uma escala log\n(logarítmica), por isso chamamos log ao redor de cada valor (exceto o parâmetro max que,\nde forma confusa, precisa ser fornecido em uma escala natural). Os mean_sd e sd_sd\ndefinem o desvio padrão da média e estimativas desvio padrão. Como\nneste caso estes valores não são conhecidos, nós escolhemos um valor bastante arbitrário, 0.1.Nesta análise, nós estimamos distribuição período de incubação\npartir da própria linelist utilizando função bootstrapped_dist_fit, que irá\najustar uma distribuição log-normal para os intervalos observados entre infecção e o aparecimento dos sintomas\nna linelist.outra distribuição que precisamos é o tempo de geração. Como temos dados sober\nos tempos de infecção os links de transmissão, nós podemos estimar esta\ndistribuição partir da linelist ao calcular o intervalo entre o tempo de infecção\nde pares infectores-infectados. Para fazer isto, nós utilizamos função get_pairwise\npacote epicontacts, que nos permite calcular diferenças\nentre os pares partir das propriedades da linelist sobre os pares de transmissão. Nós primeiro criamos um\nobjeto epicontact (veja página Cadeias de transmissão para mais\ndetalhes):Então, ajustamos diferença tempo de incubação entre os pares da transmissão,\ncalculado com get_pairwise, em uma distribuição gamma:","code":"\nincubation_period_lit <- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n## estime o período de incubação\nincubation_period <- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n## gere o objeto contatos\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## gere o objeto epicontact\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## estime o tempo de geração gamma\ngeneration_time <- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)"},{"path":"epidemic-models.html","id":"executando-o-epinow2","chapter":"23 Modelagem de epidemias","heading":"Executando o EpiNow2","text":"Agora nós só precisamos calcular incidência diária partir da linelist, que podemos fazer\nfacilmente com funções group_by() e n(), dplyr. Note\nque o EpiNow2 requer que os nomes das colunas sejam date e confirm.Podemos, então, estimar o Rt utilizando função epinow. Algumas notas sobre\nos dados usados:Nós podemos fornecer qualquer quantidade de distribuições de intervalos ‘encadeados’ para o argumento\ndelays; simplesmente iríamos inserí-los junto com o objeto incubation_period\ndentro da função delay_opts.return_output garante que o resultado da análise é obtido dentro R, e não apenas salvo\nem um arquivo.verbose especifica que queremos uma leitura/update progresso.horizon indica em quantos dias queremos estimar incidência futura.Nós adicionamos outras opções argumento stan para especificar por quanto tempo\nqueremos executar inferência. Aumentar o samples e chains irá te\ndar uma estimativa mais precisa que melhor caracteriza incerteza, entretanto\nirá demorar mais para ser calculada.","code":"\n## obtenha a incidência a partir da data de início dos sintomas\ncases <- linelist %>%\n  group_by(date = date_onset) %>%\n  summarise(confirm = n())\n## execute o epinow\nepinow_res <- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)"},{"path":"epidemic-models.html","id":"analisando-o-resultado-da-análise","chapter":"23 Modelagem de epidemias","heading":"Analisando o resultado da análise","text":"Assim que o código terminar de ser executado, nós podemos criar um resumo da análise facilmente, da seguinte maneira. Role imagem para ver sua real extensão.Nós também podemos olher diferentes resumos estatísticos:Para mais análise e customização gráfico, você pode acessar estimativas diárias\nresumidas através de $estimates$summarised. Nós iremos converter isto padrão\ndata.table para um tibble, facilitando o uso com dplyr.Como um exemplo, vamos criar um gráfico tempo de duplicação e Rt. Nós iremos\napenas olhar os primeiros meses surto, quando o Rt está bem\nacima de um, para evitar traçar tempos de duplicação extremamente elevados.Nós utilizamos fórmula log(2)/growth_rate para calcular o tempo de duplicação partir da\ntaxa de crescimento estimada.","code":"\n## faça uma figura do sumário da análise\nplot(epinow_res)\n## tabela resumo\nepinow_res$summary##                                  measure                  estimate  numeric_estimate\n## 1: New confirmed cases by infection date                4 (2 -- 6) <data.table[1x9]>\n## 2:        Expected change in daily cases                    Unsure              0.56\n## 3:            Effective reproduction no.        0.88 (0.73 -- 1.1) <data.table[1x9]>\n## 4:                        Rate of growth -0.012 (-0.028 -- 0.0052) <data.table[1x9]>\n## 5:          Doubling/halving time (days)          -60 (130 -- -25) <data.table[1x9]>\n## extraia o resumo e converta para formato tibble\nestimates <- as_tibble(epinow_res$estimates$summarised)\nestimates\n## crie amplas df para um gráfico mediano\ndf_wide <- estimates %>%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date < as.Date(\"2014-09-01\")\n  ) %>%\n  ## converta as taxas de crescimento para o tempo de duplicação\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## renomeie a variável para refletir na transformação de taxa de crescimento para tempo de duplicação\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## crie um data frame longo para criar gráfico de quantis\ndf_long <- df_wide %>%\n  ## aqui nós combinamos quantis correspondentes (ex.: lower_90 para upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## crie um gráfico\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## utilize label_parsed para conseguir subscrever o rótulo\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## defina manualmente a transparência do quantil\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )"},{"path":"epidemic-models.html","id":"epiestim","chapter":"23 Modelagem de epidemias","heading":"EpiEstim","text":"Para executar EpiEstim, nós precisamos fornecer dados de incidência diária, e especificar\no intervalo seriado (.e.: distribuição dos intervalos entre o início dos sintomas dos\ncasos primários e secundários).Dados de incidência podem ser fornecidos para o EpiEstim como um vetor, um quadro de dados, ou um objeto\nincidence pacote original incidence. Você consegue até distinguir entre importados\ne infecções adquiridas localmente; veja documentação em ?estimate_R para\nmais detalhes.Nós iremos criar entrada de dados usando incidence2. Veja página sobre Curvas epidêmicas para mais exemplos com o pacote incidence2. Já que existem updates pacote incidence2 que não fornecem entrada necessária estimateR(), existem algumas pequenas etapas adicionais necessárias. O objeto incidence consiste de uma tabela tibble com datas e respectivas contagens. Nós usamos complete(), pacote tidyr, para garantir que todas datas sejam incluídas (até datas sem casos), e então rename() colunas para gerarem o que é esperado pela função estimate_R() em uma etapa posterior.O pacote fornece diferentes opções para especificar os intervalos seriados, os\ndetalhes são fornecidos na documentação em ?estimate_R. Nós iremos\ncobrir duas das opções aqui.","code":"\n## obtenha a incidência a partir da data de início dos sintomas\ncases <- incidence2::incidence(linelist, date_index = \"date_onset\") %>% # obtenha a quantidade de casos por dia\n  tidyr::complete(date_index = seq.Date(                              # garanta que todas as datas estão presentes\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %>%                                       # converta contagens NA para 0\n  rename(I = count,                                                   # renomeie para os nomes utilizados no estimateR\n         dates = date_index)"},{"path":"epidemic-models.html","id":"utilizando-estimativas-de-intervalos-seriados-da-literatura","chapter":"23 Modelagem de epidemias","heading":"Utilizando estimativas de intervalos seriados da literatura","text":"Ao usar opção method = \"parametric_si\", podemos especificar manualmente média e\ndesvio padrão intervalo seriado em um objeto config criado usando \nfunção make_config. Nós usamos uma média e um desvio padrão de 12.0 e 5.2, respectivamente, definidos neste\nartigo:Então, nós podemos estimar o Rt com função estimate_R:e criar um gráfico resumindo os resultados da análise:","code":"\n## crie o config\nconfig_lit <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\ncases <- cases %>% \n     filter(!is.na(date))\n#create a dataframe for the function estimate_R()\ncases_incidence <- data.frame(dates = seq.Date(from = min(cases$dates),\n                               to = max(cases$dates), \n                               by = 1))\ncases_incidence <- left_join(cases_incidence, cases) %>% \n     select(dates, I) %>% \n     mutate(I = ifelse(is.na(I), 0, I))## Joining with `by = join_by(dates)`\nepiestim_res_lit <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_lit\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\nplot(epiestim_res_lit)"},{"path":"epidemic-models.html","id":"utilizando-estimativas-de-intervalos-seriados-dos-dados","chapter":"23 Modelagem de epidemias","heading":"Utilizando estimativas de intervalos seriados dos dados","text":"Conforme obtemos dados sobre datas de início dos sintomas e links de transmissão, nós podemos\ntambém estimar o intervalo seriado partir da linelist ao calcular o intervalo\nentre datas de início dos sintomas dos pares infectante-infectado.Como fizemos na seção EpiNow2,\nnós iremos agora utilizar função get_pairwise, pacote epicontacts,\nque nos permite calcular diferenças entre os pares de transmissão nas\ncaracterísticas na linelsit. Primeiro, criamos um objeto epicontact\n(veja página Cadeias de transmissão para mais detalhes):Então ajustamos diferença entre datas de início dos sintomas dos pares de transmissão, calculado\nusando get_pairwise, para uma distribuição gamma. Utilizamos função fit_disc_gamma,\npacote epitrix, para fazer este procedimento de ajuste, uma vez que precisamos\nde uma distribuição discreta.Então aplicamos esta informação objeto config, executamos o EpiEstim\nnovamente, e criamos um gráfico dos resultados:","code":"\n## gere os contatos\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## gere um objeto epicontact\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## estime o intervalo seriado gamma\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n## crie o config\nconfig_emp <- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## execute o epiestim\nepiestim_res_emp <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_emp\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\n## crie um gráfico dos resultados\nplot(epiestim_res_emp)"},{"path":"epidemic-models.html","id":"especificando-as-janelas-de-estimação-do-tempo","chapter":"23 Modelagem de epidemias","heading":"Especificando as janelas de estimação do tempo","text":"Estas opções padrão irão fornecer uma estimativa semanal móvel, e podem atuar como um\naviso que você está estimando o Rt mutio precocemente surto, para uma\nestimativa precisa. Você pode mudar isto ao ajustar uma data de início posterior para \nestimativa, como mostrado abaixo. Infelizmente, o EpiEstim apenas fornece um método\nbem desajeitado de especificar estes tempos de estimativas, em que você precisa fornecer um\nvetor de números inteiros referentes datas de início e fim para cada\nintervalo de tempo.Agora re-executamos o EpiEstim, e podemos ver estimativas apenas partir de junho:","code":"\n## defina um vetor de datas iniciando em 1o de junho\nstart_dates <- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %>%\n  ## substraia a data de início para converto para numérico\n  `-`(min(cases$dates)) %>%\n  ## converta para número inteiro\n  as.integer()\n\n## adicione seis dias para um intervalo móvel de uma semana\nend_dates <- start_dates + 6\n  \n## crie o config\nconfig_partial <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n## rode o epiestim\nepiestim_res_partial <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## crie um gráfico dos resultados\nplot(epiestim_res_partial)"},{"path":"epidemic-models.html","id":"analisando-os-resultados","chapter":"23 Modelagem de epidemias","heading":"Analisando os resultados","text":"Os principais resultados podem ser acessados através de $R. Como um exemplo, nós iremos criar um gráfico \nRt e uma medida de “potencial de transmissão”, dada pelo produto de\nRt e o número de casos notificados naquele dia; isto representa o\nnúmero esperado de casos na próxima geração da infecção.","code":"\n## crie um quadro de dados amplo para a mediana\ndf_wide <- epiestim_res_lit$R %>%\n  rename_all(clean_labels) %>%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %>%\n  mutate(\n    ## extraia a data média de t_start e t_end\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %>%\n  ## una com os dados de incidência diária\n  left_join(cases, \"dates\") %>%\n  ## calcule o risco através de todas as estimativas de r\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %>%\n  ## separe as estimativas de r e as estimativas de risco\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %>%\n  ## atribua os níveis do fator\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## crie um data frame longo a partir dos quantis\ndf_long <- df_wide %>%\n  select(-variable, -median) %>%\n  ## separe o r/estimativas de risco e níveis de quantis\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %>%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## crie o gráfico\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## use label_parsed para permitir rótulos subescritos\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## defina manualmente a transparência do quantil\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )"},{"path":"epidemic-models.html","id":"projeções-da-incidência","chapter":"23 Modelagem de epidemias","heading":"23.4 Projeções da incidência","text":"","code":""},{"path":"epidemic-models.html","id":"epinow2-1","chapter":"23 Modelagem de epidemias","heading":"EpiNow2","text":"Além de estimar o Rt, EpiNow2 também é capaz de prever o\nRt e projetar o número de casos ao ser integrado com o\npacote EpiSoon. Tudo o que você precisa fazer é especificar o argumento horizon\nao usar função epinow, indicando quantos dias você quer\nprojetar futuro; veja seção EpiNow2 em “Estimando o\nRt” para detalhes sobre como configurar e executar o EpiNow2. Nesta seção,\nnós iremos apenas fazer o gráfico dos resultados desta análise, salvos \nobjeto epinow_res.","code":"\n## defina a data mínima do gráfico\nmin_date <- as.Date(\"2015-03-01\")\n\n## extraia as estimativas resumidas\nestimates <-  as_tibble(epinow_res$estimates$summarised)\n\n## extraia os dados brutos da incidência de casos\nobservations <- as_tibble(epinow_res$estimates$observations) %>%\n  filter(date > min_date)\n\n## extraia as estimativas previstas do número de caso\ndf_wide <- estimates %>%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date > min_date\n  )\n\n## converta para o formato longo para criar o gráfico de quantil\ndf_long <- df_wide %>%\n  ## aqui combinamos os quantis correspondentes (ex.: lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## crie o gráfico\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## defina manualmente a transparência do quantil\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Casos notificados diariamente\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)"},{"path":"epidemic-models.html","id":"pacote-projections","chapter":"23 Modelagem de epidemias","heading":"Pacote projections","text":"O pacote projections, desenvolvido pela RECON, torna bem fácil o ato de\nprever incidências curto prazo, requerindo apenas conhecimento número efetivo de\nreprodução Rt, e o intervalo seriado. Aqui, nós iremos abordar como usar\nestimativas seriadas de intervalo da literatura e como usar nossas próprias estimativas\nbaseadas na linelist.","code":""},{"path":"epidemic-models.html","id":"utilizando-estimativas-de-intervalo-seriado-da-literatura","chapter":"23 Modelagem de epidemias","heading":"Utilizando estimativas de intervalo seriado da literatura","text":"O pacote projections precise de uma distribuição seriada discreta de intervalos da classe\ndistcrete, pacote distcrete. Nós iremos utilizar uma distribuição gamma\ncom uma média de 12.0 e desvio padrão de 5.2 definido neste\nartigo. Para\nconverter estes valores para os parâmetros de formato e escala requiridos para distribuição\ngamma, iremos utilizar função gamma_mucv2shapescale pacote\nepitrix.Aqui está uma checagem rápida para garantir que o intervalo seriado está correto. Nós\nacessamos densidade da distribuição gamma que acabamos de definir com $d, que\né equivalente chamar dgamma:","code":"\n## obtenha os parâmetros de formato e escala da média mu e o coeficiente de\n## variação (ex.: a razão do desvio padrão para a média)\nshapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## crie um objeto do tipo *distcrete*\nserial_interval_lit <- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n## cheque para garantir que o intervalo seriado está correto\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Intervalo seriado\", ylab = \"Densidade\"\n)"},{"path":"epidemic-models.html","id":"utilizando-estivamitvas-de-intervalo-seriadas-a-partir-dos-dados","chapter":"23 Modelagem de epidemias","heading":"Utilizando estivamitvas de intervalo seriadas a partir dos dados","text":"Como temos dados com datas de início dos sintomas e links de transmissão, nós podemos\ntambém estimar o intervalo seriado partir da linelist ao calcular o intervalo\nentre datas de início dos sintomas dos pares infectante-infectado. Como fizemos na seção EpiNow2,\nnós iremos utilizar função get_pairwise pacote epicontacts, que nos permite calcular diferenças em pares das propriedades\nda linelist nos pares de transmissão. Primeiro, criamos um objeto epicontact\n(veja página Cadeias de transmissão para mais detalhes):Então ajustamos diferença início de sintomas entre os pares de transmissão, calculando\nusando get_pairwise, para uma distriuição gamma. Nós usamos função fit_disc_gamma,\npacote epitrix, para realizar este procedimento de ajuste, uma vez que precisamos de\numa distribuição discreta.","code":"\n## crie os contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## crie o objeto epicontacts\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## estime o intervalo seriado gamma\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## inspecione a estimativa\nserial_interval[c(\"mu\", \"sd\")]## $mu\n## [1] 11.51047\n## \n## $sd\n## [1] 7.696056"},{"path":"epidemic-models.html","id":"projeções-da-incidência-1","chapter":"23 Modelagem de epidemias","heading":"Projeções da incidência","text":"Para prever incidência futura, nós ainda precisamos fornecer incidência histórica na\nforma de um objeto incidence, assim como uma amostra de valores plausíveis de\nRt. Nós iremos gerar estes valores utilizando estimativas de Rt\ngeradas pelo EpiEstim na seção anterior (na subseção “Estimando\nRt”) e salvo objeto epiestim_res_emp. código abaixo,\nnós extraímos média e estimativas de desvio padrão Rt para \núltima janela de tempo surto (usando função tail para acessar o último\nelemento em um vetor), e simulamos 1000 valores de uma distribuição gamma utilizando\nrgamma. Você também pode fornecer seu própria vetor de valores Rt que você\nquer usar para projeções futuras.Nós então usamos função project() para criar previsão atual. Nós especificamos quantos\ndias queremos prever através dos argumentos n_days, e especificamos o\nnúmero de simulações usando o argumento n_sim.Nós podemos, então, criar um gráfico da incidência e projeções usando funções plot() e\nadd_projections(). Nós podemos facilmente criar subconjuntos objeto incidence para apenas\nmostrar os casos mais recentes ao utilizar o operador de colchetes retos.Você pode também facilmente extrair novas estimativas brutas número diário de casos ao\nconverter o resultado da análise para um quadro de dados.","code":"\n## crie um objeto incidence a partir das datas de início dos sintomas\ninc <- incidence::incidence(linelist$date_onset)## 256 missing observations were removed.\n## extraia valores plausíveis de r para maior parte das estimativas recentes\nmean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## cheque a distribuição\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Contagens\")## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n## crie a projeção\nproj <- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n## crie um gráfico da incidência e projeções\nplot(inc[inc$dates > as.Date(\"2015-03-01\")]) %>%\n  add_projections(proj)\n## converta para um quadro de dados os dados brutos\nproj_df <- as.data.frame(proj)\nproj_df"},{"path":"epidemic-models.html","id":"recursos-extras-2","chapter":"23 Modelagem de epidemias","heading":"23.5 Recursos extras","text":"Aqui está o artigo descrevendo\nmetodologia empregada EpiEstim.Aqui está o artigo descrevendo\nmetodologia implementada EpiNow2.Aqui está um artigo descrevendo\ndiferentes considerações dos metodológicas e práticas para estimar o Rt.","code":""},{"path":"contact-tracing.html","id":"contact-tracing","chapter":"24 Rastreamento de contatos","heading":"24 Rastreamento de contatos","text":"Esta página demonstra uma análise descritiva dos dados de rastreio de contatos, acrescentando algumas considerações-chave e abordagens únicas este tipo de dados.Esta página faz referência muitas das competências centrais de gestão e visualização de dados em R, cobertas em outras páginas (por exemplo, limpeza de dados, pivoteamento, tabelas, análises de séries temporais). Contudo, destacaremos exemplos específicos de rastreio de contatos que têm sido úteis para tomada de decisões operacionais. Por exemplo, está inclusa visualização de dados de seguimento de rastreio de contatos ao longo tempo ou através de áreas geográficas, ou produção de tabelas de Indicadores de Desempenho Chave (KPI, inglês Key Performance Indicator) limpas para supervisores de rastreio de contatos.Para fins de demonstração, utilizaremos amostras de dados de rastreio de contatos da plataforma Go.Data. Os princípios aqui abordados serão aplicados aos dados de rastreio de contatos de outras plataformas - você poderá apenas precisar passar por diferentes etapas de pré-processamento de dados, dependendo da estrutura da base.Leia mais sobre o projeto Go.Data site Github Documentation site ou Community Practice.","code":""},{"path":"contact-tracing.html","id":"preparação-14","chapter":"24 Rastreamento de contatos","heading":"24.1 Preparação","text":"","code":""},{"path":"contact-tracing.html","id":"carregar-pacotes-4","chapter":"24 Rastreamento de contatos","heading":"Carregar pacotes","text":"Esta chunck mostra o carregamento dos pacotes necessários para análises. Neste manual damos ênfase função p_load() pacman,\nque instala o pacote se necessário e carrega-o para utilização. Também se pode carregar pacotes instalados com library() partir R base. Veja página Introdução ao R para mais informações sobre pacotes R.","code":"\npacman::p_load(\n  rio,          # importar dados  \n  here,         # caminhos relativos de arquivos \n  janitor,      # limpeza dos dados e tabelas\n  lubridate,    # trabalhar com datas\n  epikit,       # função age_categories()\n  apyramid,     # piramides etárias\n  tidyverse,    # manipulação e visualização de dados\n  RColorBrewer, # paletas de cores\n  formattable,  # formatação de tabelas\n  kableExtra    # formatação de tabelas\n)"},{"path":"contact-tracing.html","id":"importação-de-dados-1","chapter":"24 Rastreamento de contatos","heading":"Importação de dados","text":"Importaremos amostras de conjuntos de dados de contatos e de seus “acompanhamentos”. Estes dados foram recuperados e separados da API Go.Data e armazenados como arquivos “.rds”.Você pode fazer o download de todos os dados de exemplo para este manual partir da página Download manual e dados.Se desejar fazer o download exemplo de dados de rastreio de contatos específicos para esta página, utilize os três links de download abaixo:\nClique para fazer o download dos dados da investigação caso (arquivo\n.rds) \nClique para fazer o download dos dados de registo de contato (arquivo\n.rds) \nClique para fazer o download dos dados de acompanhamento dos contatos\n(arquivo .rds) Na sua forma original nos arquivos passíveis de download, os dados são exibidos como fornecidos pela API Go.Data (saiba mais sobre APIs aqui). Para fins de exemplo, aqui vamos limpar os dados para facilitar leitura nesta página. Se estiver usando uma extensão Go.Data, pode ver instruções completas sobre como recuperar os seus dados aqui.Abaixo, os conjuntos de dados são importados utilizando função import() pacote rio. Veja página Importar e exportar para várias formas de importação de dados. Utilizamos () para especificar o caminho arquivo - forneça o caminho específico arquivo para o seu computador. Em seguida, utilizamos select() para selecionar apenas certas colunas dos dados, simplificando para efeitos de demonstração.","code":""},{"path":"contact-tracing.html","id":"dados-do-caso","chapter":"24 Rastreamento de contatos","heading":"Dados do caso","text":"Estes dados são uma tabela com informações sobre os casos.Aqui estão os casos nrow(cases):","code":"\ncases <- import(here(\"data\", \"godata\", \"cases_clean.rds\")) %>% \n  select(case_id, firstName, lastName, gender, age, age_class,\n         occupation, classification, was_contact, hospitalization_typeid)"},{"path":"contact-tracing.html","id":"dados-de-contatos","chapter":"24 Rastreamento de contatos","heading":"Dados de contatos","text":"Estes dados são uma tabela de todos os contatos e suas informações. Mais uma vez, forneça o seu próprio caminho para o arquivo. Após importação, realizamos alguns passos preliminares de limpeza de dados, incluindo:Definir age_class (faixa-etária) como fator e inverter ordem desses níveis, de modo que idades menores sejam primeiras aparecer;Selecionar apenas algumas colunas específicas, ao mesmo tempo que se\nrenomeia uma delas;Atribuir artificialmente às linhas cuja coluna admin_2_name estiver o nome “Djembe”, melhorando clareza da visualização de alguns exemplos;Aqui estão linhas nrow(contacts) da base de dados contacts:","code":"\ncontacts <- import(here(\"data\", \"godata\", \"contacts_clean.rds\")) %>% \n  mutate(age_class = forcats::fct_rev(age_class)) %>% \n  select(contact_id, contact_status, firstName, lastName, gender, age,\n         age_class, occupation, date_of_reporting, date_of_data_entry,\n         date_of_last_exposure = date_of_last_contact,\n         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %>% \n  mutate(admin_2_name = replace_na(admin_2_name, \"Djembe\"))"},{"path":"contact-tracing.html","id":"dados-de-acompanhamento","chapter":"24 Rastreamento de contatos","heading":"Dados de acompanhamento","text":"Esses dados são registros das interações de “acompanhamento” (follow-) com os contatos. Espera-se que cada contato tenha um encontro de onitoramento cada dia durante 14 dias após sua exposição.Importamos base e executamos algumas etapas de limpeza. Selecionamos certas colunas e também convertemos uma coluna de caracteres em todos os valores em minúsculas.Aqui estão primeiras 50 linhas conjunto de dados da fila de acompanhamento (nrow(followups)). Cada linha é uma interação de acompanhamento, com o status resultado na coluna followup_status:","code":"\nfollowups <- rio::import(here::here(\"data\", \"godata\", \"followups_clean.rds\")) %>% \n  select(contact_id, followup_status, followup_number,\n         date_of_followup, admin_2_name, admin_1_name) %>% \n  mutate(followup_status = str_to_lower(followup_status))"},{"path":"contact-tracing.html","id":"dados-de-relação","chapter":"24 Rastreamento de contatos","heading":"Dados de relação","text":"Aqui importamos os dados mostrando relação entre os casos e contatos. Selecionamos certas colunas para demonstrar.Abaixo estão primeiras 50 linhas da base de dados relationships, que contém todas relações entre casos e contatos.","code":"\nrelationships <- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %>% \n  select(source_visualid, source_gender, source_age, date_of_last_contact,\n         date_of_data_entry, target_visualid, target_gender,\n         target_age, exposure_type)"},{"path":"contact-tracing.html","id":"análises-descritivas","chapter":"24 Rastreamento de contatos","heading":"24.2 Análises descritivas","text":"Você pode utilizar técnicas abordadas em outras páginas deste manual para realizar análises descritivas dos seus casos, contatos e respectivas relações. Abaixo estão alguns exemplos.","code":""},{"path":"contact-tracing.html","id":"demográficos","chapter":"24 Rastreamento de contatos","heading":"Demográficos","text":"Como demonstrado neste manual Pirâmides demográficas, é possível visualizar idade e distribuição por sexo (aqui utilizamos o pacote apyramid).","code":""},{"path":"contact-tracing.html","id":"idade-e-gênero-dos-contatos","chapter":"24 Rastreamento de contatos","heading":"Idade e Gênero dos contatos","text":"pirâmide abaixo compara distribuição etária dos contatos, por sexo. Note que contatos com idades faltosas (missing) estão inclusos em uma\nbarra topo. Você pode alterar este comportamento padrão, mas depois considere listar os valores ausentes (“missing”) em uma legenda.Com estrutura de dados Go.Data, o conjunto de dados relationships contém idades de ambos os casos e contatos, para que você pudesse\nutilizar esse conjunto de dados e criar uma pirâmide de idades mostrando diferenças entre esses dois grupos de pessoas. base relationships será alterada para transformar colunas numéricas de idade em categorias, ou seja, faixas-etárias (veja página Dados de limpeza e principais funções). Também pivotamos base de dados de forma mais longa, para facilitar criaçãodo gráfico com ggplot2 (ver Pivotando dados).Agora podemos traçar este conjunto de dados transformados com função age_pyramid() como antes, mas substituindo gênder por category\n(Caso, ou Contato).Também podemos ver outras características, como discriminação por ocupação (ex. em forma de gráfico de setores).","code":"\napyramid::age_pyramid(\n  data = contacts,                                   # usar base de dados de contatos\n  age_group = \"age_class\",                           # coluna de faixa-etária\n  split_by = \"gender\") +                             # lados da pirâmide divididos por gênero\n  labs(\n    fill = \"Gender\",                                 # título da legenda\n    title = \"Age/Sex Pyramid of COVID-19 contacts\")+ # título da figura\n  theme_minimal()                                    # plano de fundo simples\nrelation_age <- relationships %>% \n  select(source_age, target_age) %>% \n  transmute(                              # transmute é como a função mutate(), mas remove todas as outras colunas não mencionadas\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),\n    ) %>% \n  pivot_longer(cols = contains(\"class\"), names_to = \"category\", values_to = \"age_class\")# pivotação longa\n\n\nrelation_age## # A tibble: 200 × 2\n##    category         age_class\n##    <chr>            <fct>    \n##  1 source_age_class 80+      \n##  2 target_age_class 15-19    \n##  3 source_age_class <NA>     \n##  4 target_age_class 50-54    \n##  5 source_age_class <NA>     \n##  6 target_age_class 20-24    \n##  7 source_age_class 30-34    \n##  8 target_age_class 45-49    \n##  9 source_age_class 40-44    \n## 10 target_age_class 30-34    \n## # ℹ 190 more rows\napyramid::age_pyramid(\n  data = relation_age,                               # usar a base de dados modificada `reltionship`\n  age_group = \"age_class\",                           # coluna categórica de idade\n  split_by = \"category\") +                           # dividir por casos e contatos\n  scale_fill_manual(\n    values = c(\"orange\", \"purple\"),                  # para especificar cores E nomes\n    labels = c(\"Caso\", \"Contato\"))+\n  labs(\n    fill = \"Legend\",                                           # título da legenda\n    title = \"Pirâmide Idade/Sexo de casos e contatos de COVID-19\")+ # título da figura\n  theme_minimal()                                              # plano de fundo simples\n# Limpar a base de dados e contar as ocupações\nocc_plot_data <- cases %>% \n  mutate(occupation = forcats::fct_explicit_na(occupation),  # fazer valores NA e vazios uma categoria\n         occupation = forcats::fct_infreq(occupation)) %>%   # ordenar em níveis, em ordem de frequência\n  count(occupation)                                          # contagens por ocupação\n  \n# fazer gráfico de setores\nggplot(data = occ_plot_data, mapping = aes(x = \"\", y = n, fill = occupation))+\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(\"y\", start = 0) +\n  labs(\n    fill = \"Ocupação\",\n    title = \"Ocupações conhecidadas de casos de COVID-19\")+\n  theme_minimal() +                    \n  theme(axis.line = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank())"},{"path":"contact-tracing.html","id":"contatos-por-caso","chapter":"24 Rastreamento de contatos","heading":"Contatos por caso","text":"O número de contatos por caso pode ser uma métrica importante para avaliar qualidade da contagem de contatos e conformidade da população para uma resposta de saúde pública.Dependendo de sua estrutura de dados, isto pode ser avaliado com um conjunto de dados que contém todos os casos e contatos. Nos conjuntos de\ndados Go.Data, os links entre os casos (“fontes”) e os contatos (“alvos”) é armazenado conjunto de dados relationships.Neste conjunto de dados, cada linha é um contato, e o caso da fonte é listado em uma linha. Não há contatos que tenham relações com múltiplos\ncasos, mas se isso existir, você pode precisar computá-los antes de criar o gráfico.Começamos contando o número de linhas (contatos) por caso de origem. Isto é salvo como um data frame.Podemos usar geom_histogram() para fazer um histograma partir desses dados.","code":"\ncontacts_per_case <- relationships %>% \n  count(source_visualid)\n\ncontacts_per_case##    source_visualid  n\n## 1   CASE-2020-0001 13\n## 2   CASE-2020-0002  5\n## 3   CASE-2020-0003  2\n## 4   CASE-2020-0004  4\n## 5   CASE-2020-0005  5\n## 6   CASE-2020-0006  3\n## 7   CASE-2020-0008  3\n## 8   CASE-2020-0009  3\n## 9   CASE-2020-0010  3\n## 10  CASE-2020-0012  3\n## 11  CASE-2020-0013  5\n## 12  CASE-2020-0014  3\n## 13  CASE-2020-0016  3\n## 14  CASE-2020-0018  4\n## 15  CASE-2020-0022  3\n## 16  CASE-2020-0023  4\n## 17  CASE-2020-0030  3\n## 18  CASE-2020-0031  3\n## 19  CASE-2020-0034  4\n## 20  CASE-2020-0036  1\n## 21  CASE-2020-0037  3\n## 22  CASE-2020-0045  3\n## 23            <NA> 17\nggplot(data = contacts_per_case)+        # começar com a contagem da base de dados criada anteriormente\n  geom_histogram(mapping = aes(x = n))+  # criar o histograma do número de contatos por caso\n  scale_y_continuous(expand = c(0,0))+   # remover o espaço em excesso abaixo de 0 no eixo y\n  theme_light()+                         # simplificar o plano de fundo\n  labs(\n    title = \"Número de contatos por caso\",\n    y = \"Casus\",\n    x = \"Contatos por caso\"\n  )"},{"path":"contact-tracing.html","id":"acompanhamento-de-contato","chapter":"24 Rastreamento de contatos","heading":"24.3 Acompanhamento de contato","text":"Os dados de rastreamento de contatos geralmente contêm dados de “acompanhamento”, que registram resultados das verificações diárias dos sintomas das pessoas em quarentena. Análises destes dados podem informar estratégia de resposta, identificar contatos em risco de perda acompanhamento ou risco de desenvolver doenças.","code":""},{"path":"contact-tracing.html","id":"limpeza-do-dados","chapter":"24 Rastreamento de contatos","heading":"Limpeza do dados","text":"Estes dados podem existir em uma variedade de formatos, como um formato Excel “largo/amplo”, com uma linha por contato e uma coluna por dia de acompanhamento. Veja Pivoteando dados para descrições de dados “longos” e “largos”, e como pivotar dados mais amplos/largos ou mais longos.Em nosso exemplo com Go.Data, estes dados são armazenados nos dados de acompanhamento (followups), em um formato “longo”, com uma linha por acompanhamento interação. primeiras 50 filas são dessa forma:CUIDADO: Cuidado com duplicatas ao lidar com dados de acompanhamento; podem haver vários seguimentos errôneos mesmo dia para um determinado contato. Talvez pareça um erro, mas reflete realidade - por exemplo, um investigador poderia submeter um formulário de acompanhamento início dia, quando não foi possível contactar o indivíduo e, mais tarde, submeter um segundo formulário quando conseguir contato. Dependerá contexto operacional forma como você quer lida com duplicatas - apenas certifique-se de documentar sua abordagem claramente.Vamos ver quantas linhas “duplicadas” nós temos:Em nossos dados de exemplo, os únicos registros aos quais isto se aplica são os que faltam um ID! Podemos removê-los. Mas, para fins de demonstração vamos mostrar os passos para remoção de duplicidades, de forma que haja apenas um acompanhamento por pessoa por dia. Para mais detalhes, veja página Eliminando duplicidades. Vamos supor que o registro mais recente é o correto. Também aproveitamos oportunidade para limpar coluna followup_number (o “dia” de acompanhamento que deve variar de 1 - 14).Para cada encontro de acompanhamento, temos um status de acompanhamento (por exemplo se o encontro ocorreu e se o contato teve sintomas ou não).\nPara ver todos os valores, podemos executar um rápido tabyl() (janitor) ou table() (R Base) (ver Tabelas descritivas) por ‘followup_status’ para ver frequência de cada um dos resultados.Neste conjunto de dados, “seen_not_ok” significa “visto com sintomas” e “seen_ok” significa “visto sem sintomas”","code":"\nfollowups %>% \n  count(contact_id, date_of_followup) %>%   # obter valores únicos para dias de contato (contact_days)\n  filter(n > 1)                             # ver registros onde a contagem é maior que 1##   contact_id date_of_followup n\n## 1       <NA>       2020-09-03 2\n## 2       <NA>       2020-09-04 2\n## 3       <NA>       2020-09-05 2\nfollowups_clean <- followups %>%\n  \n  # Remover duplicidades\n  group_by(contact_id, date_of_followup) %>%        # agrupar linhas por dia de contato (contact-day)\n  arrange(contact_id, desc(date_of_followup)) %>%   # organizar linhas por dia de contato, data de acompanhamento (date of follow-up), trazendo o mais recente para o topo\n  slice_head() %>%                                  # manter apenas a primeira linha por valor único de ID do contato (contact id)\n  ungroup() %>% \n  \n  # Outras limpezas\n  mutate(followup_number = replace(followup_number, followup_number > 14, NA)) %>% # limpar dados errados\n  drop_na(contact_id)                               # remover linhas com valor em branco para contact_id\nfollowups_clean %>% \n  tabyl(followup_status)##  followup_status   n    percent\n##           missed  10 0.02325581\n##    not_attempted   5 0.01162791\n##    not_performed 319 0.74186047\n##      seen_not_ok   6 0.01395349\n##          seen_ok  90 0.20930233"},{"path":"contact-tracing.html","id":"gráfico-ao-longo-do-tempo","chapter":"24 Rastreamento de contatos","heading":"Gráfico ao longo do tempo","text":"Como os dados das datas são contínuos, usaremos um histograma para representá-los com data de acompanhamento (date_of_followup) atribuída ao eixo x. Podemos produzir um histograma “empilhado”, especificando um argumento fill = dentro de aes(), que atribuímos à coluna de status acompanhamento (followup_status).\nConsequentemente, você pode definir o título da legenda utilizando o argumento fill = labs().Podemos ver que os contatos foram identificados em ondas (presumivelmente correspondente às ondas epidêmicas de casos), e que conclusão acompanhamento não parece ter melhorado ao longo curso da epidemia.CUIDADO: Se você estiver preparando muitos gráficos (por exemplo, para múltiplas jurisdições) é preferível que legendas apareçam de forma idêntica, mesmo com diferentes níveis de preenchimento ou composição de dados. Podem haver gráficos para os quais nem todos os status de acompanhamento estão presentes nos dados, mas você ainda quer que essas categorias apareçam nas legendas. Em ggplots (como acima), você pode especificar o argumento drop = FALSE scale_fill_discrete(). Nas tabelas, utilize tabyl() que mostra contagens para todos os níveis de fatores, ou se utilizandocount() dplyr adicione o argumento .drop = FALSE para incluir contagens para todos os níveis de fatores.","code":"\nggplot(data = followups_clean)+\n  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +\n  scale_fill_discrete(drop = FALSE)+   # exibir todos os níveis de fatores (followup_status) na legenda, mesmo os não utilizados\n  theme_classic() +\n  labs(\n    x = \"\",\n    y = \"Número de contatos\",\n    title = \"Status de acompanhamento de contato diário\",\n    fill = \"Status de acompanhamento\",\n    subtitle = str_glue(\"Dados de {max(followups$date_of_followup, na.rm=T)}\"))   # subtítulo dinâmico subtitle"},{"path":"contact-tracing.html","id":"rastreamento-individual-diário","chapter":"24 Rastreamento de contatos","heading":"Rastreamento individual diário","text":"Se seu surto pequeno o suficiente, pode ser interessante olhar para cada contato individualmente e ver seu status ao longo de seu acompanhamento. Felizmente, este conjunto de dados followups já contém uma coluna com o “número” dia de acompanhamento (de 1 14). Se isto não existir em seus dados, você poderia criá-lo calculando diferença entre data contato e data que o acompanhamento foi planejado para começar.Um mecanismo de visualização conveniente (se o número de casos não muito grande) pode ser um gráfico de calor, feito com geom_tile().\nVeja mais detalhes na página Gráfico de calor.","code":"\nggplot(data = followups_clean)+\n  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),\n            color = \"grey\")+       # linhas de grade na cor cinza\n  scale_fill_manual( values = c(\"yellow\", \"grey\", \"orange\", \"darkred\", \"darkgreen\"))+\n  theme_minimal()+\n  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))"},{"path":"contact-tracing.html","id":"análises-por-grupo","chapter":"24 Rastreamento de contatos","heading":"Análises por grupo","text":"Talvez esses dados de acompanhamento estejam sendo vistos diariamente ou semanalmente para tomada de decisões operacionais. Você pode considerar mais significativo desagregação por área geográfica ou por equipe de rastreamento de contatos. Podemos fazer isso ajustando colunas fornecidas group_by().","code":"\nplot_by_region <- followups_clean %>%        # começar com a base de dados de acompanhamento\n  count(admin_1_name, admin_2_name, followup_status) %>% # contagem por valores únicos no \"region-status\" (cria coluna 'n' com a contagem )\n  \n  # iniciar o ggplot()\n  ggplot(                                         # iniciar o ggplot\n    mapping = aes(x = reorder(admin_2_name, n),   # reordenar os níveis dos fatores de administração pelos valores numéricos na coluna 'n'\n                  y = n,                            # altura das barras segundo coluna 'n'\n                  fill = followup_status,           # cor da barra empilhada segundo seu status\n                  label = n))+                      # transição para o geom_label()              \n  geom_col()+                              # barras empilhadas, vindo do mapeamento anterior\n  geom_text(                               # adicionar texto, vindo do mapeamento anterior\n    size = 3,                                         \n    position = position_stack(vjust = 0.5), \n    color = \"white\",           \n    check_overlap = TRUE,\n    fontface = \"bold\")+\n  coord_flip()+\n  labs(\n    x = \"\",\n    y = \"Número de contatos\",\n    title = \"Status do acompanhamento do contato, por Região\",\n    fill = \"Status do acompanhamento\",\n    subtitle = str_glue(\"Dados de {max(followups_clean$date_of_followup, na.rm=T)}\")) +\n  theme_classic()+                                               # Plano de fundo simplificado\n  facet_wrap(~admin_1_name, strip.position = \"right\", scales = \"free_y\", ncol = 1) # introduzir facetas \n\nplot_by_region"},{"path":"contact-tracing.html","id":"tabelas-kpi","chapter":"24 Rastreamento de contatos","heading":"24.4 Tabelas KPI","text":"Há uma série de diferentes indicadores-Chave de Desempenho (KPIs, de Key Performance Indicators em inglês) que podem ser calculados e rastreados em diferentes níveis de desagregação e ao longo de diferentes períodos de tempo para monitorar o desempenho rastreamento de contatos. Uma vez que você tenha os cálculos e o formato básico da tabela; é bastante fácil trocar por diferentes KPIs.Existem várias fontes de rastreamento de contatos KPIs, tais como este (de ResolveToSaveLives.org).maior parte trabalho será caminhar através de sua estrutura de dados e pensar em todos os critérios de inclusão/exclusão. Mostramos alguns exemplos abaixo; usando estrutura de metadados Go.Data:Abaixo, iremos passar por um exercício de exemplo de criação de uma tabela que mostra o acompanhamento dos contatos ao longo de áreas administrativas. final, tornaremos essa tabela apresentável com o pacote formattable (mas você poderia usar outros pacotes, como flextable - veja Tabelas para apresentação).criação de tabelas como esta, dependerá da sua estrutura de dados de rastreamento de contatos. Visite página Tabelas descritivas para aprender como resumir os dados usando funções dplyr.Criaremos uma tabela que será dinâmica e mudará de acordo com mudança dos dados. Para tornar os resultados interessantes, estabeleceremos uma data de relato (report_date), que nos permite simular o funcionamento da tabela em um determinado dia (escolhemos 10 de Junho de 2020). Os dados são filtrados até essa data.Agora, com base em nossa estrutura de dados, faremos o seguinte:Comece com os followups e use o summarise para que contenha, em cada contato único:data último registro (não importa o status encontro)data último encontro em que o contato foi “visto”O status encontro naquela última vez em que o contato foi “visto” (por exemplo, com sintomas ou sem sintomas)Junte estes dados aos dados de contato, que contêm outras informações como o status geral de contato, data último exposição um caso, etc. Também calcularemos métricas de interesse para cada contato, tais como dias desde última exposiçãoAgrupamos os dados de contato melhorados por região geográfica (admin_2_name) e calculamos estatísticas resumidas por regiãoFinalmente, formatamos tabela para apresentaçãoPrimeiro resumimos os dados de acompanhamento para obter informações de interesse:Aqui vemos os dados:Agora vamos adicionar essas informações à base de dados contacts e calcular algumas colunas adicionaisAqui vemos aparência dos dados. Observe coluna contacts à direita e nova coluna calculada na extrema direita.seguir, resumimos os dados de contato por região, para obter uma base concisa de colunas estatísticas resumidas.E agora aplicamos estilos dos pacotes formattable e knitr, incluindo uma nota de rodapé que mostra data “partir de”.","code":"\n# Criar a \"Report date\" para simular simular a execução do relatório com dados \"a partir\" desta data\nreport_date <- as.Date(\"2020-06-10\")\n\n# Criar dados de acompanhamento para refletir a data do relatório\ntable_data <- followups_clean %>% \n  filter(date_of_followup <= report_date)\nfollowup_info <- table_data %>% \n  group_by(contact_id) %>% \n  summarise(\n    date_last_record   = max(date_of_followup, na.rm=T),\n    date_last_seen     = max(date_of_followup[followup_status %in% c(\"seen_ok\", \"seen_not_ok\")], na.rm=T),\n    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %>% \n  ungroup()\ncontacts_info <- followup_info %>% \n  right_join(contacts, by = \"contact_id\") %>% \n  mutate(\n    database_date       = max(date_last_record, na.rm=T),\n    days_since_seen     = database_date - date_last_seen,\n    days_since_exposure = database_date - date_of_last_exposure\n    )\ncontacts_table <- contacts_info %>% \n  \n  group_by(`Admin 2` = admin_2_name) %>%\n  \n  summarise(\n    `Registered contacts` = n(),\n    `Active contacts`     = sum(contact_status == \"UNDER_FOLLOW_UP\", na.rm=T),\n    `In first week`       = sum(days_since_exposure < 8, na.rm=T),\n    `In second week`      = sum(days_since_exposure >= 8 & days_since_exposure < 15, na.rm=T),\n    `Became case`         = sum(contact_status == \"BECAME_CASE\", na.rm=T),\n    `Lost to follow up`   = sum(days_since_seen >= 3, na.rm=T),\n    `Never seen`          = sum(is.na(date_last_seen)),\n    `Followed up - signs` = sum(status_last_record == \"Seen_not_ok\" & date_last_record == database_date, na.rm=T),\n    `Followed up - no signs` = sum(status_last_record == \"Seen_ok\" & date_last_record == database_date, na.rm=T),\n    `Not Followed up`     = sum(\n      (status_last_record == \"NOT_ATTEMPTED\" | status_last_record == \"NOT_PERFORMED\") &\n        date_last_record == database_date, na.rm=T)) %>% \n    \n  arrange(desc(`Registered contacts`))\ncontacts_table %>%\n  mutate(\n    `Admin 2` = formatter(\"span\", style = ~ formattable::style(\n      color = ifelse(`Admin 2` == NA, \"red\", \"grey\"),\n      font.weight = \"bold\",font.style = \"italic\"))(`Admin 2`),\n    `Followed up - signs`= color_tile(\"white\", \"orange\")(`Followed up - signs`),\n    `Followed up - no signs`= color_tile(\"white\", \"#A0E2BD\")(`Followed up - no signs`),\n    `Became case`= color_tile(\"white\", \"grey\")(`Became case`),\n    `Lost to follow up`= color_tile(\"white\", \"grey\")(`Lost to follow up`), \n    `Never seen`= color_tile(\"white\", \"red\")(`Never seen`),\n    `Active contacts` = color_tile(\"white\", \"#81A4CE\")(`Active contacts`)\n  ) %>%\n  kable(\"html\", escape = F, align =c(\"l\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\")) %>%\n  kable_styling(\"hover\", full_width = FALSE) %>%\n  add_header_above(c(\" \" = 3, \n                     \"Contatos atualmente em acompanhamento\" = 5,\n                     \"Status na última visita\" = 3)) %>% \n  kableExtra::footnote(general = str_glue(\"Data are current to {format(report_date, '%b %d %Y')}\"))"},{"path":"contact-tracing.html","id":"matrizes-de-transmissão","chapter":"24 Rastreamento de contatos","heading":"24.5 Matrizes de transmissão","text":"Como foi discutido na página Gráficos de calor, você pode criar uma matriz de “quem infectou quem” utilizando geom_tile().Quando novos contatos são criados, o Go.Data armazena essa informação de relações ponto final da API relationships; e podemos ver o primeiras 50 filas deste conjunto de dados abaixo. Isto significa que podemos criar um gráfico de calor com relativamente poucas etapas, dado que cada contato já está unido ao seu caso de origem.Como feito anteriormente para pirâmide etária comparando casos e contatos, podemos selecionar poucas variáveis necessárias e criar colunas com faixas etárias categóricas, tanto para fontes (casos) quanto para alvos (contatos).Como descrito anteriormente, criamos uma tabulação cruzada;converter em formato longo com proporções;e criar um gráfico de calor para idade.","code":"\nheatmap_ages <- relationships %>% \n  select(source_age, target_age) %>% \n  mutate(   # a função transmute é como a função mutate(), mas remove todas as outras colunas\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) \ncross_tab <- table(\n  source_cases = heatmap_ages$source_age_class,\n  target_cases = heatmap_ages$target_age_class)\n\ncross_tab##             target_cases\n## source_cases 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54 55-59\n##        0-4     0   0     0     0     0     0     0     0     0     1     0     1\n##        5-9     0   0     1     0     0     0     0     1     0     0     0     1\n##        10-14   0   0     0     0     0     0     0     0     0     0     0     0\n##        15-19   0   0     0     0     0     0     0     0     0     0     0     0\n##        20-24   1   1     0     1     2     0     2     1     0     0     0     1\n##        25-29   1   2     0     0     0     0     0     0     0     0     0     0\n##        30-34   0   0     0     0     0     0     0     0     1     1     0     1\n##        35-39   0   2     0     0     0     0     0     0     0     1     0     0\n##        40-44   0   0     0     0     1     0     2     1     0     3     1     1\n##        45-49   1   2     2     0     0     0     3     0     1     0     3     2\n##        50-54   1   2     1     2     0     0     1     0     0     3     4     1\n##        55-59   0   1     0     0     1     1     2     0     0     0     0     0\n##        60-64   0   0     0     0     0     0     0     0     0     0     0     0\n##        65-69   0   0     0     0     0     0     0     0     0     0     0     0\n##        70-74   0   0     0     0     0     0     0     0     0     0     0     0\n##        75-79   0   0     0     0     0     0     0     0     0     0     0     0\n##        80+     1   0     0     2     1     0     0     0     1     0     0     0\n##             target_cases\n## source_cases 60-64 65-69 70-74 75-79 80+\n##        0-4       0     0     0     0   0\n##        5-9       0     0     0     0   0\n##        10-14     0     0     0     0   0\n##        15-19     0     0     0     0   0\n##        20-24     0     0     0     0   1\n##        25-29     0     0     0     0   0\n##        30-34     0     0     0     0   0\n##        35-39     0     0     0     0   0\n##        40-44     0     0     0     1   1\n##        45-49     1     0     0     0   1\n##        50-54     0     1     0     0   1\n##        55-59     0     0     0     0   0\n##        60-64     0     0     0     0   0\n##        65-69     0     0     0     0   0\n##        70-74     0     0     0     0   0\n##        75-79     0     0     0     0   0\n##        80+       0     0     0     0   0\nlong_prop <- data.frame(prop.table(cross_tab))\nggplot(data = long_prop)+       # usar dados longos, com proporção como Freq\n  geom_tile(                    # visualizar quadrantes\n    aes(\n      x = target_cases,         # eixo X é a idade do Alvo\n      y = source_cases,         # eixo Y é a idade da Fonte\n      fill = Freq))+            # cor dos quadrantes é de acordo com a coluna Freq da base de dados\n  scale_fill_gradient(          # ajustar a cor de enchimento das quadrantes\n    low = \"blue\",\n    high = \"orange\")+\n  theme(axis.text.x = element_text(angle = 90))+\n  labs(                         # rótulos\n    x = \"Idade dos casos alvo\",\n    y = \"Idade dos casos fonte\",\n    title = \"Quem infectou quem\",\n    subtitle = \"Matriz de frequências de eventos de transmissão\",\n    fill = \"Porporção de todos\\neventos de transmissão\"     # título da legenda\n  )"},{"path":"contact-tracing.html","id":"fontes","chapter":"24 Rastreamento de contatos","heading":"24.6 Fontes","text":"https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reportinghttps://worldhealthorganization.github.io/godata/https://community-godata..int/","code":""},{"path":"survey-analysis.html","id":"survey-analysis","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25 Analises de pesquisa de questionários (survey)","text":"","code":""},{"path":"survey-analysis.html","id":"visão-geral-2","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.1 Visão Geral","text":"Esta página demonstra o uso de vários pacotes para análise de pesquisas de questionários (tipo survey).maioria dos pacotes de pesquisa R depende pacote survey para fazer análises ponderadas.\nUtilizaremos survey assim como srvyr(que funciona como uma roupagem (wrapper)\npara o pacote survey, isto é, simplificando seu uso e permitindo uma codificação em estilo “tidyverse”) e gtsummary (que funciona como uma roupagem (wrapper) para o pacote survey, permitindo publicação de tabelas prontas).Embora o pacote original de survey não permita uma codificação em estilo “tidyverse”, ele tem o benefício adicional de permitir modelos lineares generalizados\nponderados (que serão adicionados esta página posteriormente). Também demonstraremos usando uma função pacote sitrep,\npara criar pesos de amostragem (n.b este pacote ainda não está atualmente CRAN, mas pode ser instalado partir github).maior parte desta página é baseada trabalho feito para o projeto “R4Epis”; para obter o código detalhado e modelos R-markdown\nveja página github “R4Epis”. Alguns dos códigos survey baseados em pacotes são baseados nas primeiras versões \nEPIET case studies.momento, esta página não aborda os cálculos de tamanho de amostra ou amostragem. Para uma calculadora de tamanho de amostra simples de usar, consulte\nOpenEpi. página Introdução GIS (https://epirhandbook.com/gis-basics.html) manual terá eventualmente uma seção sobre\namostragem espacial aleatória, e esta página terá eventualmente uma seção sobre estruturas de amostragem, bem como cálculos de tamanho de amostra.Dados da pesquisaTempo de observaçãoPonderaçãoObjetos de projeto de pesquisaAnálise descritivaProporções ponderadasTaxas ponderadas","code":""},{"path":"survey-analysis.html","id":"preparação-15","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.2 Preparação","text":"","code":""},{"path":"survey-analysis.html","id":"pacotes-1","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"Pacotes","text":"Este trecho de código mostra o carregamento dos pacotes necessários para análises. Neste manual, enfatizamos p_load() pacman, que instala o pacote\nse necessário e o carrega para utilização. Você também pode carregar pacotes usando library() R Base. Veja página Introdução ao R para mais informações\nsobre os pacotes R.\nAqui também demonstramos utilizando função p_load_gh() de pacman para instalar e carregar pacote github que ainda não foi publicado \nCRAN.","code":"\n## carregar pacotes do CRAN\npacman::p_load(rio,          # Importar arquivo\n               here,         # Local do arquivo\n               tidyverse,    # manipulação de dados + gráficos com ggplot2\n               tsibble,      # manipulação de bases de séries temporais\n               survey,       # funções de pesquisa\n               srvyr,        # roupagem (wraper) para o pacote survey\n               gtsummary,    # wrapper para o pacote survey, para produzir tabelas\n               apyramid,     # pacote destinado a criação de pirâmides etárias\n               patchwork,    # combinação de gráficos ggplots\n               ggforce       # para diagramas aluviais e de sankey\n               ) \n\n## carregar pacotes do github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # para funções de tempo de observação / ponderação\n)"},{"path":"survey-analysis.html","id":"carregar-dados","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"Carregar dados","text":"O conjunto de dados de exemplo utilizado nesta seção:dados fictícios da pesquisa de mortalidade.população fictícia conta para área de pesquisa.dicionário de dados para os dados fictícios da pesquisa de\nmortalidade.Isto é baseado na pesquisa pré-aprovada pelo conselho de análise ética da MSF OCA. O conjunto de dados fictício foi produzido como parte projeto “R4Epis”. Baseado em dados coletados usando KoboToolbox, que é um software de coleta de dados baseado em\nOpen Data Kit.Kobo lhe permite exportar tanto os dados coletados quanto o dicionário para esse conjunto de dados. Recomendamos fortemente que se faça isso, pois simplifica limpeza de dados e é útil para pesquisa devariáveis/questões.DICA: O dicionário de dados Kobo tem nomes de variáveis na coluna”name” da planilha de pesquisa. Os valores possíveis para cada variável\nsão especificado na planilha de escolhas. Na planilha de escolhas, coluna “name” tem o nome abreviado e colunas “label::english” e “label::french” têm nome completo. Use o pacote epidict, função msf_dict_survey() para importar um arquivo excel dicionário Kobo e formatá-lo para que possa ser usado facilmente\nem uma recodificação.CUIDADO: O conjunto de dados exemplo não é o mesmo que uma exportação (como em Kobo você exporta diferentes níveis de questionários individualmente) -\nveja o seção de dados da pesquisa abaixo para fundir diferentes níveisO conjunto de dados é importado utilizando função import() pacote rio. Veja página Importar e exportação para outrasmaneiras de importar dados.primeiras 10 linhas da pesquisa são exibidas abaixo.Também queremos importar os dados sobre população de amostragem para que possamos produzir pesos adequados. Estes dados podem estar em diferentes formatos,\nentanto, sugerimos que seja como visto abaixo (podendo ser apenas digitado numa planilha).primeiras 10 linhas da pesquisa são exibidas abaixo.Para pesquisas de cluster (grupos, agregados) você pode querer adicionar pesos de pesquisa nível cluster. Você poderia ler estes\ndados como acima. Alternativamente, se houver apenas algumas contagens, estas poderiam ser inseridas como abaixo em um tibble (data frame com alguns ajustes\npara deixá-lo mais amigável). Em qualquer caso você precisará ter uma coluna com um identificador de cluster, que corresponde aos dados de sua pesquisa, e outra\ncoluna com o número de agregados familiares em cada grupo.","code":"\n# importar os dados da pesquisa\nsurvey_data <- rio::import(\"survey_data.xlsx\")\n\n# importar o dicionário para o R\nsurvey_dict <- rio::import(\"survey_dict.xlsx\") \n# importar os dados da população\npopulation <- rio::import(\"population.xlsx\")\n## definir o número de agregados familiares em cada cluster\ncluster_counts <- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))"},{"path":"survey-analysis.html","id":"limpar-dados","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"Limpar dados","text":"Abaixo, garantimos que coluna de datas esteja formato apropriado. Há várias outras maneiras de fazer isso (veja página Trabalhando com datas para mais detalhes), porém utilização dicionário para definir datas é rápida e fácil.Também criamos uma variável de faixa etária utilizando função age_categories() pacote epikit - veja seção limpeza de dados para mais detalhes. Além disso, criamos uma variável tipo caractere, que define em\nqual distrito se encontram os vários agrupamentos.Finalmente, recodificamos todas variáveis yes/(sim/não) para variáveis TRUE/FALSE (Verdadeiro/Falso) - caso contrário, estas não poderão ser utilizadas pelas funções de proporção survey.","code":"\n## selecione os nomes das variáveis de data no dicionário \nDATEVARS <- survey_dict %>% \n  filter(type == \"date\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filtro para corresponder aos nomes das colunas de seus dados\n  pull(name) # selecione variáveis de data\n  \n## mudança para data\nsurvey_data <- survey_data %>%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## adicionar aqueles com apenas idade em meses à variável ano (dividir por doze)\nsurvey_data <- survey_data %>% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## definir a variável de faixa etária\nsurvey_data <- survey_data %>% \n     mutate(age_group = epikit::age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## criar uma variável do tipo caractere baseada em grupos de uma variável diferente\nsurvey_data <- survey_data %>% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## selecionar nomes de variáveis yes/no do dicionário\nYNVARS <- survey_dict %>% \n  filter(type == \"yn\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filtro para corresponder aos nomes das colunas de seus dados\n  pull(name) # selecionar variáveis yn (yes/no)\n  \n## recodificação\nsurvey_data <- survey_data %>%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))"},{"path":"survey-analysis.html","id":"dados-da-pesquisa","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.3 Dados da pesquisa","text":"Existem inúmeras técnicas de amostragem que podem ser usados para pesquisas. Aqui demonstraremos o código para: - Estratificado -\nConglomerados (Cluster) - Estratificado e ConglomeradosComo descrito acima (dependendo de como você projeta seu questionário) os dados para cada nível seriam exportados como um conjunto separado de dados Kobo.\nEm nosso exemplo, há um nível para domicílio e um nível para indivíduos dentro desses domicílios.Estes dois níveis estão ligados por um identificador único. Para um conjunto de dados Kobo esta variável é “_index” nível de domicílios, que corresponde\nao “_parent_index” nível individual. Isto criará novas linhas para domicílio com cada indivíduo correspondente. Para maiores detalhes, veja seção manual sobre união de bases (https://epirhandbook.com/joining-data.html).","code":"\n## juntar os dados individuais e de domicílio para formar um conjunto completo de dados\nsurvey_data <- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## criar um identificador único, combinando as peças dos dois níveis \nsurvey_data <- survey_data %>% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))"},{"path":"survey-analysis.html","id":"tempo-de-observação","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.4 Tempo de observação","text":"Para pesquisas de mortalidade, queremos agora saber quanto tempo cada indivíduo esteve presente local, para podermos calcular um taxa de mortalidade para nosso\nperíodo de interesse. Isto não é relevante para todas, mas particularmente para pesquisas de mortalidade, isso é importante, pois são conduzidas frequentemente\nentre populações móveis ou deslocadas.Para isso, definimos primeiro nosso período de tempo de interesse, também conhecido como período de retordo, ou período de recall (.e. o tempo que os participantes\nsão instruídos se reportarem quando respondem perguntas). Podemos então utilizar este período para definir datas inadequadas para o ausência, ou seja, se mortes forem relatadas fora período de interesse.Podemos usar nossas variáveis de data para definir datas de inicio e fim para cada individuo. Usamos função find_start_date() sitrep para apurar causas\npara datas e depois usar isso para calcular diferença entre os dias (pessoa - tempo).Data de início: Primeiro evento de chegada apropriado dentro de seu período de recall, ou o início de seu período de recall (que você define em previamente), ou uma\ndata após o início recall, se aplicável (por exemplo chegadas ou nascimentos).Data final: Primeiro evento de partida apropriado dentro de seu período de recall, ou o final de seu período de recall, ou uma data antes final recall se\naplicável (por exemplo, partidas e mortes).","code":"\n## definir o início/fim do período de recall\n## pode ser alterado para variáveis de data do conjunto de dados \n## (por exemplo, questionário de data de chegada e data)\nsurvey_data <- survey_data %>% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# estabelecer datas inadequadas para NA com base em regras \n## por exemplo, chegadas antes do início, partidas após o fim\nsurvey_data <- survey_data %>%\n      mutate(\n           arrived_date = if_else(arrived_date < recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date < recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date > recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date > recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n## criar novas variáveis para datas/causas de início e fim\nsurvey_data <- survey_data %>% \n     ## escolher a data mais próxima informada na pesquisa\n     ## de nascimentos, chegadas ao domicílio e chegadas ao local\n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %>%\n     ## escolher a data mais próxima informada na pesquisa\n     ## das partidas do local, morte e fim do estudo\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## rotular aqueles que estavam presentes no início/fim (exceto nascimentos/mortes)\nsurvey_data <- survey_data %>% \n     mutate(\n       ## preencher a data de início para ser o início do período de recall (para aqueles vazios) \n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## definir a causa inicial para apresentar no início se for igual ao período de recall \n       ## a menos que seja igual à data de nascimento \n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## preencher a data final para ser o fim do período de recall (para aqueles vazios) \n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## definir a causa final a apresentar ao fim se for igual ao recall final \n       ## a menos que seja igual à data da morte\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Define o tempo de observação em dias\nsurvey_data <- survey_data %>% \n  mutate(obstime = as.numeric(enddate - startdate))"},{"path":"survey-analysis.html","id":"ponderação","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.5 Ponderação","text":"É importante que você remova observações errôneas antes de acrescentar pesos à pesquisa. Por exemplo, se você tiver registros com tempos de observação negativos,\nprecisará verificá-los (você pode fazer isso com funçãoassert_positive_timespan() pacote sitrep. Outra questão é se você quiser eliminar linhas vazias (por\nexemplo, com drop_na(uid)) ou remover duplicidades (consulte seção manual sobre Eliminando duplicidades para maiores detalhes). Aqueles sem consentimento\ntambém precisarão ser removidos.Neste exemplo, filtramos para os casos que queremos remover e os armazenamos em um data frame separado - desta forma podemos descrever aqueles que foram excluídos da\npesquisa. Em seguida, utilizamos função anti_join() dplyr para remover estes casos descartados de nossos dados de pesquisa.PERIGO: Você não pode ter valores ausentes em sua variável de peso, ou qualquer uma das variáveis relevantes para o projeto de sua pesquisa (por exemplo, idade, sexo, estratos ou variáveis de agrupamento).Como mencionado acima, demonstramos como adicionar pesos para três formas de amostragem (estratificado, conglomerado e conglomerado estratificado). Estas exigem informações sobre população de origem e/ou os aglomerados pesquisados. Usaremos o código “conglomerado estratificado” para este exemplo, mas escolha o que mais apropriado para seu modelo de estudo.","code":"\n## armazene os casos que deseja remover para que possa descrevê-los (por exemplo, sem consentimento) \n## ou local/cluster errados)\ndropped <- survey_data %>% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## usar os casos descartados para remover as linhas não utilizadas do conjunto de dados da pesquisa \nsurvey_data <- anti_join(survey_data, dropped, by = names(dropped))\n# estratificado ----------------------------------------------------------------\n# criar uma variável chamada \"surv_weight_strata\n# contém pesos para cada indivíduo - por faixa etária, sexo e distrito de saúde\nsurvey_data <- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## por conglomerados (cluster) ---------------------------------------------------------------------\n\n# obter o número de pessoas entrevistadas por domicílio\n# adiciona uma variável com contagens da variável de índice doméstico\nsurvey_data <- survey_data %>%\n  add_count(index, name = \"interviewed\")\n\n\n## criar pesos para o conglomerados (cluster)\nsurvey_data <- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# estratificado e conglomerado (cluster) ------------------------------------------------------\n# criar um peso de pesquisa para o cluster e os estratos\nsurvey_data <- survey_data %>%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)"},{"path":"survey-analysis.html","id":"objetos-de-delineamento-de-pesquisa","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.6 Objetos de delineamento de pesquisa","text":"Crie um objeto de pesquisa de acordo com seu projeto de estudo. Utilizado da mesma forma que os data frames para calcular proporções de peso etc.\nCertifique-se de que todas variáveis necessárias sejam criadas antes disso.Há quatro opções, comente aquelas que você não utiliza: - Aleatório simples - Estratificado - Conglomerado (cluster) - Conglomerado estratificadoPara este modelo - vamos fingir que agrupamos pesquisas em dois estratos separados (distritos de saúde e B). Portanto, para obter estimativas gerais, precisamos ter pesos combinados de conglomerados e estratos.Como mencionado anteriormente, há dois pacotes disponíveis para fazer isto. O clássico é o survey e depois há um pacote de “roupagem” (wrapper) chamado\nsrvyr que torna os objetos e funções mais fáceis de arrumar. Demonstraremos ambos, mas observe que maioria dos códigos neste capítulo utilizará objetos\nbaseados srvyr. única exceção é que o pacote gtsummary só aceita objetos survey.","code":""},{"path":"survey-analysis.html","id":"pacote-survey","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.6.1 Pacote survey","text":"O pacote survey utiliza, forma eficaz, codificação em R base, e por isso não é possível utilizar os pipes (%>%) ou outra sintaxe dplyr.\nCom o pacote survey, utilizamos função svydesign() para definir um objeto de pesquisa com agrupamentos (cluster), pesos e estratificações apropriados.NOTA: precisamos utilizar o til (~) em frente às variáveis, pois o pacote usa sintaxe R base para atribuição variáveis baseada em fórmulas.","code":"\n# aleatório simples ------------------------------------------------------------\nbase_survey_design_simple <- svydesign(ids = ~1, # 1 para nenhuma identificação de cluster\n                   weights = NULL,               # sem adição de pesos\n                   strata = NULL,                # amostragem simples (não estratificada)\n                   data = survey_data            # especificar a base de dados\n                  )\n\n## estratificado ---------------------------------------------------------------\nbase_survey_design_strata <- svydesign(ids = ~1,  # 1 para nenhuma identificação de cluster\n                   weights = ~surv_weight_strata, # variável de peso criada acima\n                   strata = ~health_district,     # amostragem estratificada por distrito\n                   data = survey_data             # especificar a base de dados\n                  )\n\n# conglomerado ---------------------------------------------------------------------\nbase_survey_design_cluster <- svydesign(ids = ~village_name, # identificação do cluster\n                   weights = ~surv_weight_cluster, # variável de peso criada acima\n                   strata = NULL,                 # amostragem simples (não estratificada)\n                   data = survey_data              # especificar a base de dados\n                  )\n\n# conglomerado estratificado --------------------------------------------------------\nbase_survey_design <- svydesign(ids = ~village_name,      # identificação do conglomerado\n                   weights = ~surv_weight_cluster_strata, # variável de peso criada acima\n                   strata = ~health_district,             # amostragem estratificada por distrito\n                   data = survey_data                     # especificar a base de dados\n                  )"},{"path":"survey-analysis.html","id":"pacote-srvyr","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.6.2 Pacote srvyr","text":"Com o pacote srvyr* podemos utilizar função as_survey_design(), que tem os mesmos argumentos exemplificados acima, mas permite pipes (%>%),\ne assim não precisamos utilizar o til (~).","code":"\n# aleatório simples ------------------------------------------------------------\nsurvey_design_simple <- survey_data %>% \n  as_survey_design(ids = 1, # 1 para nenhuma identificação de cluster\n                   weights = NULL, # sem adição de pesos\n                   strata = NULL # amostragem simples (não estratificada)\n                  )\n## estratificado ---------------------------------------------------------------\nsurvey_design_strata <- survey_data %>%\n  as_survey_design(ids = 1, # 1 para nenhuma identificação de cluster\n                   weights = surv_weight_strata, # variável de peso criada acima\n                   strata = health_district # amostragem estratificada por distrito\n                  )\n## cluster ---------------------------------------------------------------------\nsurvey_design_cluster <- survey_data %>%\n  as_survey_design(ids = village_name, # identificação do cluster\n                   weights = surv_weight_cluster, # variável de peso criada acima\n                   strata = NULL # amostragem simples (não estratificada)\n                  )\n\n# cluster estratificado --------------------------------------------------------\nsurvey_design <- survey_data %>%\n  as_survey_design(ids = village_name, # identificação do cluster\n                   weights = surv_weight_cluster_strata, # variável de peso criada acima\n                   strata = health_district # amostragem estratificada por distrito\n                  )"},{"path":"survey-analysis.html","id":"análise-descritiva","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.7 Análise descritiva","text":"análise descritiva básica e visualização são amplamente cobertas em outros capítulos manual, portanto, não vamos nos deter aqui. Para detalhes veja os\ncapítulos Tabelas Descritivas, Testes Estatísticos,\nTabelas para Apresentação,Introdução ao ggplot e Relatórios em R markdown.Nesta seção, vamos nos concentrar em como investigar o viés em sua amostra e em como visualizá-lo. Também vamos visualizar o fluxo populacional em um ambiente de pesquisa usando diagramas aluviais/sankey.Em geral, você deve considerar incluir seguintes análises descritivas:Número final de agrupamentos, domicílios e indivíduos incluídos.Número de indivíduos excluídos e os motivos de exclusãoNúmero médio (intervalo) de domicílios por agrupamento e de indivíduos por doméstico","code":""},{"path":"survey-analysis.html","id":"viés-de-amostras","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.7.1 Viés de amostras","text":"Compare proporções em cada faixa etária entre sua amostra e população de origem. Isto é importante para poder destacar um potencial viés de amostragem.\nDa mesma forma, você poderia repetir esta análise nas distribuições por sexo.Note que estes p-valores são apenas indicativos e uma discussão descritiva (ou visualização em pirâmides etárias abaixo) dadistribuições de sua amostra de estudo,\nem comparação com população de origem, é mais importante que o próprio teste binomial. Isto se deve ao fato de que o tamanho da amostra levará, na maioria\ndas vezes, diferenças que podem ser irrelevantes após ponderação dos dados.","code":"\n## contagem e proporção da população estudada\nag <- survey_data %>% \n  group_by(age_group) %>% \n  drop_na(age_group) %>% \n  tally() %>% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## contagem e proporção da população original\npropcount <- population %>% \n  group_by(age_group) %>%\n    tally(population) %>%\n    mutate(proportion = n / sum(n))\n\n## unir as colunas de duas tabelas, agrupar por idade, e executar um \n## teste binomial para ver se n/total é significativamente diferente da \n## proporção populacional.\n  ## sufixo aqui adicionado ao texto no final das colunas em cada um dos dois \n  ## conjuntos de dados\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %>%\n  group_by(age_group) %>%\n  ## broom::tidy(binom.test()) faz um data frame a partir do teste binomial e\n  ## adicionará as variáveis p.value (p-valor), parameter (parâmetro), \n  ## conf.low (intervalo de confiança inferior), method (método, o tipo de teste),\n  ## conf.high (intervalo de confiança superior) e alternative (alternativa à hipotese nula).\n  ## Aqui usaremos apenas p.value. Você pode incluir outras colunas se quiser\n  ## informar intervalos de confiança\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%\n  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %>%\n  ## Ajustando os p-valor para corrigir os falsos positivos \n  ## (testando várias faixas etárias). Isto só fará diferença\n  ## se você tem muitas categorias etárias\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %>%\n                      \n  ## somente mostrar o p-valor acima de  0.001 (inferiores, mostrar como 0.001)\n  mutate(p.value = ifelse(p.value < 0.001, \n                          \"<0.001\", \n                          as.character(round(p.value, 3)))) %>% \n  \n  ## renomear as colunas de forma apropriada\n  select(\n    \"Faixa-etária\" = age_group,\n    \"População de estudo (n)\" = n,\n    \"População de estudo (%)\" = proportion,\n    \"População fonte (n)\" = n_pop,\n    \"População fonte (%)\" = proportion_pop,\n    \"P-valor\" = p.value\n  )## # A tibble: 5 × 6\n## # Groups:   Faixa-etária [5]\n##   `Faixa-etária` População de estudo (n…¹ População de estudo …² `População fonte (n)`\n##   <chr>                             <int>                  <dbl>                 <dbl>\n## 1 0-2                                  12                 0.0256                  1360\n## 2 3-14                                 42                 0.0896                  7244\n## 3 15-29                                64                 0.136                   5520\n## 4 30-44                                52                 0.111                   3232\n## 5 45+                                 299                 0.638                   2644\n## # ℹ abbreviated names: ¹​`População de estudo (n)`, ²​`População de estudo (%)`\n## # ℹ 2 more variables: `População fonte (%)` <dbl>, `P-valor` <chr>"},{"path":"survey-analysis.html","id":"pirâmides-demográficas","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.7.2 Pirâmides demográficas","text":"pirâmides demográficas (ou de idade-sexo) são uma maneira fácil de visualizar distribuição em sua população pesquisada. Também vale pena considerar criação\nde Tabelas Descritivas de idade e sexo por estratos de pesquisa. Demonstraremos utilizando o pacote apyramid,\npois ele permite proporções ponderadas utilizando nosso objeto de pesquisa criado acima. Outras opções para criar Pirâmides Demográficas são amplamente cobertas nesse capítulo manual. Também utilizaremos uma função wrapper da\napyramid chamada age_pyramid() que economiza algumas linhas de código para produzir um gráfico comproporções.Como teste binomial formal de diferença, visto acima na seção de viés de amostragem, estamos interessados aqui em visualizar se nossa população amostrada é\nsubstancialmente diferente da população original e se ponderação corrige esta diferença. Para isso, usaremos o pacote patchwork para mostrar nossas visualizações ggplot lado lado; para detalhes, veja seção sobre combinação de lotes capítulo dicas ggplot manual. Visualizaremos nossa população original, nossa população não ponderada de pesquisa e nossa população ponderada de pesquisa. Você\ntambém pode considerar visualização por cada estrato de sua pesquisa - em nosso exemplo aqui, isso seria utilizando o argumento\nstack_by = \"health_district\" (veja `?age_pyramid’ para detalhes).NOTA: Os eixos x e y são invertidos em pirâmides","code":"\n## definir limites e rótulos do eixo x -----------------------------------------\n## (atualize estes números para serem os valores adequado ao seu gráfico)\nmax_prop <- 35      # escolha a maior proporção que quer mostrar\nstep <- 5           # escolha o espaço que quer mostrar entre as legendas\n\n## esta parte define o vetor usando os números acima com quebras de eixo\nbreaks <- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## esta parte define o vetor usando os números acima com limites de eixo\nlimits <- c(max_prop/100 * -1, max_prop/100)\n\n## esta parte define o vetor usando os números acima com legendas de eixo\nlabels <-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## criar gráficos individualmente ---------------------------------------------\n\n## Traçar a população de original \n## nb: precisa de ser comprimido para a população em geral (isto é, removendo distritos de saúde)\nsource_population <- population %>%\n  ## garantir que a idade e o sexo sejam fatores\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %>% \n  group_by(age_group, sex) %>% \n  ## somar as contagens para cada distrito sanitário em conjunto\n  summarise(population = sum(population)) %>% \n  ## remover o agrupamento para poder calcular a proporção total\n  ungroup() %>% \n  mutate(proportion = population / sum(population)) %>% \n  ## exibir a pirâmide \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## mostrar apenas a legenda do eixo y (caso contrário será repetida nos três gráficos)\n  labs(title = \"População de origem\", \n       y = \"\", \n       x = \"Faixa-etária (anos)\") + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## Traçar a população não ponderada da amostra \nsample_population <- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## mostrar apenas a legenda do eixo x (caso contrário será repetida nos três gráficos)\n  labs(title = \"População amostrada sem ponderação\", \n       y = \"Proporção (%)\", \n       x = \"\") + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## Traçar a população de amostra ponderada \nweighted_population <- survey_design %>% \n  ## garantir que as variáveis sejam fatores\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %>%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## mostrar apenas a legenda do eixo x (caso contrário será repetida nos três gráficos)\n  labs(title = \"População amostrada ponderada\", \n       y = \"\", \n       x = \"\")  + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## ccombinar os três gráficos   ------------------------------------------------\n## combinar três gráficos próximos uns aos outros usando + \nsource_population + sample_population + weighted_population + \n  ## mostrar apenas uma legenda e definir o tema\n  ## observe o uso de & para combinar o tema com o plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # mover legenda para baixo\n        legend.title = element_blank(),                # remover o título\n        text = element_text(size = 18),                # dimensionar o texto\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # girar texto do eixo x\n       )"},{"path":"survey-analysis.html","id":"diagrama-aluvialsankey","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.7.3 Diagrama aluvial/sankey","text":"visualização de pontos de partida e resultados para indivíduos pode ser muito útil para se ter uma visão geral. Há uma aplicação bastante óbvia para populações\nmóveis, porém existem inúmeras outras aplicações, tais como coortes ou qualquer outra situação em que há transições nos estados para indivíduos. Estes diagramas são\nconhecidos por vários nomes diferentes, incluindo aluvial, sankey e conjuntos paralelos - os detalhes estão capítulo sobre Diagramas e Gráficos.","code":"\n## resuma os dados \nflow_table <- survey_data %>%\n  count(startcause, endcause, sex) %>%  # faz contagem\n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # muda o formato para gráfico\n\n\n## trace um gráfico \n  ## no eixo x estão as causas do início e fim\n  ## a função gather_set_datagera um ID para cada combinação\n  ## dividindo (splitting) pelo y te da um combo de possibilidades de início/fim \n  ## valor (value) como \"n\" fornece a contagem (também pode ser usado com proporção)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ##linhas coloridas segundo sexo\n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## preenche as caixas de rotulagem com cinza\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## muda a cor do tetxo e ângulo (precisa ser ajustado)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## remove rótulos dos eixos\n  theme_void()+\n  ## move a legenda para baixo\n  theme(legend.position = \"bottom\")               "},{"path":"survey-analysis.html","id":"proporções-ponderadas","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.8 Proporções ponderadas","text":"Esta seção detalha como produzir tabelas para contagens e proporções ponderadas, com os intervalos de confiança associados e delineamento.\nExistem quatro opções diferentes, utilizando funções dos seguintes pacotes: survey, srvyr, sitrep e gtsummary. Para para\nproduzir uma tabela de estilo epidemiológico padrão com mínimo de código, nós recomendamos função sitrep - que é um wrapper para códigos srvyr; note,\nentretanto, que isso ainda não está CRAN e pode mudar futuro. Caso contrário, o código survey será provavelmente o mais estável longo prazo, enquanto\nsrvyr caberá melhor dentro fluxos de trabalho. Embora funções gtsummary tenham um grande potencial, elas parecem ser experimentais e incompletas\nmomento em que da escrita deste manual.","code":""},{"path":"survey-analysis.html","id":"pacote-survey-1","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.8.1 Pacote survey","text":"Podemos utilizar função svyciprop() survey para obter proporções ponderadas e intervalos de confiança de 95%. Um delineamento apropriado pode ser extraído\nutilizando o svymean() em vez da função svyprop(). Vale notar que função svyprop() parece apenas aceitar variáveis entre 0 e 1 (ou TRUE/FALSE), então, variáveis categóricas não funcionarão.NOTA: Funções survey também aceitam objetos srvyr mas aqui usamos o objeto de delineamento survey apenas por uma questão de consistênciaPodemos combinar funções de survey mostradas acima em um função chamada svy_prop; e podemos então utilize essa função junto com o map() pacote purrr\npara repetir sobre várias variáveis e criar uma tabela. Veja o capítulo Iterações e loops para mais detalhes \npacote purrr.","code":"\n##  produção contagens ponderadas \nsvytable(~died, base_survey_design)## died\n##      FALSE       TRUE \n## 1406244.43   76213.01\n##  produção proporções ponderadas \nsvyciprop(~died, base_survey_design, na.rm = T)##               2.5% 97.5%\n## died 0.0514 0.0208  0.12\n## obtem o efeito de delineamento  \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %>% \n  deff()## diedFALSE  diedTRUE \n##  3.755508  3.755508\n# Definir função para calcular contagens ponderadas, proporções, IC e efeito de delineamento\n# x é a variável entre aspas \n# O delineamento é seu objeto de desenho de pesquisa\n\nsvy_prop <- function(design, x) {\n  \n  ## colocar as variáveis de interesse em uma fórmula\n  form <- as.formula(paste0( \"~\" , x))\n  ## manter apenas a coluna TRUE do svytable\n  weighted_counts <- svytable(form, design)[[2]]\n  ## calcular proporções (multiplicar por 100 para obter porcentagens)\n  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100\n  ## extrair os intervalos de confiança e multiplicar para obter porcentagens\n  weighted_confint <- confint(weighted_props) * 100\n  ## use svymean para calcular o efeito do delinemanto e mantenha apenas a coluna TRUE\n  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## combinar em um único dataframe\n  full_table <- cbind(\n    \"Variável\"        = x,\n    \"Contagens\"           = weighted_counts,\n    \"Proporção\"      = weighted_props,\n    weighted_confint, \n    \"Efeito de delineamento\"   = design_eff\n    )\n  \n  ## retorna tabela como um dataframe\n  full_table <- data.frame(full_table, \n             ## remover os nomes das variáveis das linhas (é uma coluna separada agora)\n             row.names = NULL)\n  \n  ## mudar números de volta ao formato numérico\n  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])\n  \n  ## retornar o dataframe\n  full_table\n}\n\n## repetir em diversar variáveis para criar uma tabela  \npurrr::map(\n  ## definir variáveis de interesse\n  c(\"left\", \"died\", \"arrived\"), \n  ## função de estado usando e argumentos para essa função (delineamento)\n  svy_prop, design = base_survey_design) %>% \n  ## fundir lista em um único data frame\n  bind_rows() %>% \n  ## arredondar \n  mutate(across(where(is.numeric), round, digits = 1))##   Variável Contagens Proporção X2.5. X97.5. Efeito.de.delineamento\n## 1     left  701199.1      47.3  39.2   55.5                    2.4\n## 2     died   76213.0       5.1   2.1   12.1                    3.8\n## 3  arrived  761799.0      51.4  40.9   61.7                    3.9"},{"path":"survey-analysis.html","id":"pacote-srvyr-1","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.8.2 Pacote srvyr","text":"Com srvyr podemos usar sintaxe dplyr para criar uma tabela. Note que função survey_mean() é utilizada e o argumento da proporção é especificado, e\ntambém que mesma função é utilizada para calcular o efeito delineamento. Isto porque srvyr envolve ambas funções pacote survey svyciprop()\ne svymean(), que são utilizadas na seção acima.NOTA: Não parece ser possível obter proporções partir de variáveis categóricas utilizando srvyr, se você precisar disto então verifique seção abaixo usando sitrepTambém aqui poderíamos escrever uma função para então reiterar sobre múltiplas variáveis usando o pacote purrr. Veja o capítulo manual Iterações e loops para detalhes sobre purrr.","code":"\n## usar o objeto delineado srvyr\nsurvey_design %>% \n  summarise(\n    ## produzir as contagens ponderadas\n    counts = survey_total(died), \n    ## produzir proporções ponderadas e intervalos de confiança \n    ## multiplicar por 100 para obter uma porcentagem \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produzir o efeito de delineamento\n    deff = survey_mean(died, deff = TRUE)) %>% \n  ## manter apenas as fileiras de interesse\n  ## (remove erros padrão e repete o cálculo de proporção)\n  select(counts, props, props_low, props_upp, deff_deff)## # A tibble: 1 × 5\n##   counts props props_low props_upp deff_deff\n##    <dbl> <dbl>     <dbl>     <dbl>     <dbl>\n## 1 76213.  5.14      2.08      12.1      3.76\n# definir função para calcular contagens ponderadas, proporções, IC e delineamento\n# o desenho é seu objeto de desenho de pesquisa\n# x é a variável entre aspas \n\n\nsrvyr_prop <- function(design, x) {\n  \n  summarise(\n    ## usando o objeto delimitado de pesquisa\n    design, \n    ## produzir as contagens ponderadas\n    counts = survey_total(.data[[x]]), \n    ## produzir as proporções e intervalos de confiaça ponderados\n    ## multiplicar por 100 para obter uma porcentagem \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produzir o efeito de delineamento\n    deff = survey_mean(.data[[x]], deff = TRUE)) %>% \n  ## adicionar na variável de nome\n  mutate(variable = x) %>% \n  ## manter apenas as linhas de interesse\n  ## (remove erros padrão e repete o cálculo de proporção)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## reitera em diferentes variáveis para criar uma tabela\npurrr::map(\n  ## define  as variáveis de interesse\n  c(\"left\", \"died\", \"arrived\"), \n  ## função *state* e argumentos para essa função (delineamento)\n  ~srvyr_prop(.x, design = survey_design)) %>% \n  ## unificar lista em uma única data frame\n  bind_rows()## # A tibble: 3 × 6\n##   variable  counts props props_low props_upp deff_deff\n##   <chr>      <dbl> <dbl>     <dbl>     <dbl>     <dbl>\n## 1 left     701199. 47.3      39.2       55.5      2.38\n## 2 died      76213.  5.14      2.08      12.1      3.76\n## 3 arrived  761799. 51.4      40.9       61.7      3.93"},{"path":"survey-analysis.html","id":"pacote-sitrep","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.8.3 Pacote sitrep","text":"função tab_survey() de sitrep é um wrapper para srvyr, permitindo criação de tabelas ponderadas com codificação mínima.\nTambém permite calcular proporções ponderadas para variáveis categóricas.","code":"\n    ## usando o objeto delimitado de pesquisa\nsurvey_design %>% \n  ## passe os nomes das variáveis de interesse não cotadas\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # calcular o efeito de delineamento\n             pretty = TRUE  # fundir proporção e intervalo de confiança 95%\n             )## Warning: removing 257 missing value(s) from `education_level`## # A tibble: 9 × 5\n##   variable        value            n  deff ci               \n##   <chr>           <chr>        <dbl> <dbl> <chr>            \n## 1 arrived         TRUE       761799.  3.93 51.4% (40.9-61.7)\n## 2 arrived         FALSE      720658.  3.93 48.6% (38.3-59.1)\n## 3 left            TRUE       701199.  2.38 47.3% (39.2-55.5)\n## 4 left            FALSE      781258.  2.38 52.7% (44.5-60.8)\n## 5 died            TRUE        76213.  3.76 5.1% (2.1-12.1)  \n## 6 died            FALSE     1406244.  3.76 94.9% (87.9-97.9)\n## 7 education_level higher     171644.  4.70 42.4% (26.9-59.7)\n## 8 education_level primary    102609.  2.37 25.4% (16.2-37.3)\n## 9 education_level secondary  130201.  6.68 32.2% (16.5-53.3)"},{"path":"survey-analysis.html","id":"pacote-gtsummary","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.8.4 Pacote gtsummary","text":"Com gtsummary não parece haver ainda funções embutidas para acrescentar intervalos de confiança ou efeito de delineamento. Aqui mostramos como definir uma função\npara adicionar intervalos de confiança e depois adicionar intervalos de confiança uma tabela gtsummary criada utilizando função tbl_svysummary().","code":"\nconfidence_intervals <- function(data, variable, by, ...) {\n  \n  ## extrair os intervalos de confiança e multiplicar para obter porcentagens\n  props <- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## extrair os intervalos de confiança \n  as.numeric(confint(props) * 100) %>% ## transformar em número e multiplicar para obter o percentual\n    round(., digits = 1) %>%           ## arredondar para um dígito\n    c(.) %>%                           ## ## extrair os números da matriz\n    paste0(., collapse = \"-\")          ## combinar para caracter único\n}\n\n## usando o objeto delimitado do pacote survey\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## definir variáveis a serem incluídas\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %>% ## definir estatísticas de interesse\n  add_n() %>%  ## adicionar o peso total\n  add_stat(fns = everything() ~ confidence_intervals) %>% ## adicionar intervalos de confiança\n  ## modificar títulos das colunas\n  modify_header(\n    list(\n      n ~ \"**Total ponderado (N)**\",\n      stat_0 ~ \"**Contagem ponderada**\",\n      add_stat_1 ~ \"**95%IC**\"\n    )\n    )"},{"path":"survey-analysis.html","id":"razões-ponderadas","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.9 Razões ponderadas","text":"Da mesma forma, para relações ponderadas (como para relações de mortalidade) você pode usar o pacote survey ou o pacote srvyr.\nVocê poderia escrever funções (semelhantes àquelas acima) para iterar sobre várias variáveis. Você também poderá criar uma função para o pacote gtsummary,\ncomo acima, mas atualmente ela não tem nenhuma funcionalidade embutida.","code":""},{"path":"survey-analysis.html","id":"pacote-survey-2","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.9.1 Pacote survey","text":"","code":"\nratio <- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci <- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)##       obstime    2.5 %   97.5 %\n## died 5.981922 1.194294 10.76955"},{"path":"survey-analysis.html","id":"pcaote-srvyr","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.9.2 Pcaote srvyr","text":"","code":"\nsurvey_design %>% \n  ## razão de pesquisa usada para contabilizar o tempo de observação \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )## # A tibble: 1 × 3\n##   mortality mortality_low mortality_upp\n##       <dbl>         <dbl>         <dbl>\n## 1      5.98         0.349          11.6"},{"path":"survey-analysis.html","id":"referência","chapter":"25 Analises de pesquisa de questionários (survey)","heading":"25.10 Referência","text":"Página de estatísticas da UCLAAnalise dados de questioários gratuitamentePacote srvyrPacote gtsummaryEstudo de caso da pesquisa EPIET","code":""},{"path":"survival-analysis.html","id":"survival-analysis","chapter":"26 Análise de sobrevivência","heading":"26 Análise de sobrevivência","text":"","code":""},{"path":"survival-analysis.html","id":"visão-geral-3","chapter":"26 Análise de sobrevivência","heading":"26.1 Visão Geral","text":"análise de sobrevivência centra-se na descrição, para um determinado indivíduo ou grupo de indivíduos, de um ponto definido de evento chamado falha (ocorrência de uma doença, cura de uma doença, óbito, recaída após resposta ao tratamento…) que ocorre após um período de tempo chamado tempo de falha (ou tempo de seguimento em estudos baseados em coorte/população) durante o qual os indivíduos são observados. Para determinar o tempo de falha, é então necessário definir um tempo de origem (que pode ser data de inclusão, data de diagnóstico…).O alvo de inferência para análise de sobrevivência é então o tempo entre uma origem e um evento. Na investigação médica actual, é amplamente utilizado em estudos clínicos para avaliar o efeito de um tratamento, por exemplo, ou na epidemiologia câncer para avaliar uma grande variedade de medidas de sobrevivência ao câncer.É normalmente expressa através da probabilidade de sobrevivência que é probabilidade de o evento de interesse não ter ocorrido por uma duração t.Censura: censura ocorre quando final seguimento, alguns dos indivíduos não tiveram o evento de interesse, e assim o seu verdadeiro tempo para o evento é desconhecido. Aqui focaremos principalmente na censura correta, mas para mais detalhes sobre censura e análise de sobrevivência em geral, é possível ver referências.","code":""},{"path":"survival-analysis.html","id":"preparação-16","chapter":"26 Análise de sobrevivência","heading":"26.2 Preparação","text":"","code":""},{"path":"survival-analysis.html","id":"carregar-pacotes-5","chapter":"26 Análise de sobrevivência","heading":"Carregar Pacotes","text":"Para realizar análises de sobrevivência em R, um dos pacotes mais utilizados é o pacote survival. Primeiro o instalamos e depois o carregamos, bem como os outros pacotes que serão utilizados nesta secção:Neste manual enfatizamos p_load() pacman, que instala o pacote se necessário e carrega-o para utilização. Pode também carregar os pacotes instalados com library() R base . Veja página em Introdução ao R para mais informações sobre os pacotes R.Esta página explora análises de sobrevivência usando linelist usada na maioria das páginas anteriores e na qual aplicamos algumas alterações para termos dados de sobrevivência adequados.Importar conjunto de dadosImportamos o conjunto de dados de casos de uma epidemia simulada de Ebola. Se quiser acompanhar, clique para fazer o download da linelist “limpa”  (.rds file). Importe os dados com função import() pacote rio (suporta muitos formatos de arquivos .xlsx, .csv, .rds - veja página Importar e exportar para mais detalhes).","code":"\n# importar linelist\nlinelist_case_data <- rio::import(\"linelist_cleaned.rds\")"},{"path":"survival-analysis.html","id":"gestão-e-transformação-de-dados","chapter":"26 Análise de sobrevivência","heading":"Gestão e transformação de dados","text":"Em suma, os dados de sobrevivência podem ser descritos como tendo três características seguintes:variável ou resposta dependente é o tempo de espera até à ocorrência de um evento bem definido,observações são censuradas, sentido de que para algumas unidades o evento de interesse não ocorreu momento em que os dados são analisados, eexistem preditores ou variáveis explicativas cujo efeito sobre o tempo de espera desejamos avaliar ou controlar.Assim, criaremos diferentes variáveis necessárias para respeitar essa estrutura e executar análise de sobrevivência.Definimos:um novo data frame linelist_surv para esta análiseo nosso evento de interesse como sendo “óbito” (nossa probabilidade de sobrevivência será probabilidade de estar vivo um certo tempo após o tempo de origem),o tempo de seguimento (futime) como o tempo entre o tempo de início e o tempo resultado em dias,pacientes censurados como aqueles que recuperaram ou para os quais o resultado final não é conhecido, ou seja, o evento “morte” não foi observado (evento=0).CUIDADO: Uma vez que num estudo de coorte real, informação sobre hora de origem e o fim seguimento é conhecida, dado que são observados indivíduos, removeremos observações onde data de início ou data desfecho é desconhecida. Também os casos em que data de início é posterior à data resultado serão removidos, uma vez que são considerados erradosDICA: Dado que filtrar para maior que (>) ou menor que (<) uma data pode remover linhas sem valores, aplicar o filtro nas datas erradas também removerá linhas sem datas.Depois utilizamos case_when() para criar uma coluna age_cat_small na qual existem apenas 3 categorias de idade.DICA: Podemos verificar novas colunas que criamos fazendo um resumo sobre o futime e uma tabulação cruzada entre o evento e o resultado de onde foi criado. Para além desta verificação, é um bom hábito comunicar o tempo médio de seguimento ao interpretar os resultados da análise de sobrevivência.Agora fazemos uma tabulação cruzada da nova variável “age_cat_small” e da antiga coluna “age_cat” para garantir atribuições corretasAgora revisamos 10 primeiras observações dos dados da linelist_surv, olhando para variáveis específicas (incluindo aquelas recentemente criadas).Também podemos fazer tabulações cruzadas entre colunas age_cat_small e gender para obter mais detalhes acercada distribuição dessas novas colunas por gênero. Usamos tabyl() e função adorn pacote janitor, como descrito na página Tabelas descritivas.","code":"\n#criar um novo dado chamado linelist_surv a partir do linelist_case_data\n\nlinelist_surv <-  linelist_case_data %>% \n     \n  dplyr::filter(\n       # remover observações com datas de início ou desfecho erradas ou vazias\n       date_outcome > date_onset) %>% \n  \n  dplyr::mutate(\n       # criar o evento var que é 1 se o paciente morreu e 0 se ele foi censurado correctamente\n       event = ifelse(is.na(outcome) | outcome == \"Recover\", 0, 1), \n    \n       # criar o var sobre o tempo de seguimento em dias\n       futime = as.double(date_outcome - date_onset), \n    \n       # criar uma nova variável de categoria de idade com apenas 3 níveis de estratos\n       age_cat_small = dplyr::case_when( \n            age_years < 5  ~ \"0-4\",\n            age_years >= 5 & age_years < 20 ~ \"5-19\",\n            age_years >= 20   ~ \"20+\"),\n       \n       # passo anterior criou age_cat_small var como caractere\n       # agora o converte em fator e especifica os níveis.\n       # note que os valores NA continuam a ser NA e não são colocados num nível \"desconhecido\", por exemplo,\n       # uma vez que nas análises seguintes tem de ser removidas.\n       age_cat_small = fct_relevel(age_cat_small, \"0-4\", \"5-19\", \"20+\")\n       )\nsummary(linelist_surv$futime)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1.00    6.00   10.00   11.98   16.00   64.00\n# tabulação cruzada das novas variáveis modificadas \"event\" e \"outcome\" (desfecho) \n# para garantir que o código fazia o que se pretendia\nlinelist_surv %>% \n  tabyl(outcome, event)##  outcome    0    1\n##    Death    0 1952\n##  Recover 1547    0\n##     <NA> 1040    0\nlinelist_surv %>% \n  tabyl(age_cat_small, age_cat)##  age_cat_small 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ NA_\n##            0-4 834   0     0     0     0     0     0   0   0\n##           5-19   0 852   717   575     0     0     0   0   0\n##            20+   0   0     0     0   862   554    69   5   0\n##           <NA>   0   0     0     0     0     0     0   0  71\nlinelist_surv %>% \n  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %>% \n  head(10)##    case_id age_cat_small date_onset date_outcome outcome event futime\n## 1   8689b7           0-4 2014-05-13   2014-05-18 Recover     0      5\n## 2   11f8ea           20+ 2014-05-16   2014-05-30 Recover     0     14\n## 3   893f25           0-4 2014-05-21   2014-05-29 Recover     0      8\n## 4   be99c8          5-19 2014-05-22   2014-05-24 Recover     0      2\n## 5   07e3e8          5-19 2014-05-27   2014-06-01 Recover     0      5\n## 6   369449           0-4 2014-06-02   2014-06-07   Death     1      5\n## 7   f393b4           20+ 2014-06-05   2014-06-18 Recover     0     13\n## 8   1389ca           20+ 2014-06-05   2014-06-09   Death     1      4\n## 9   2978ac          5-19 2014-06-06   2014-06-15   Death     1      9\n## 10  fc15ef          5-19 2014-06-16   2014-07-09 Recover     0     23\nlinelist_surv %>% \n  tabyl(gender, age_cat_small, show_na = F) %>% \n  adorn_totals(where = \"both\") %>% \n  adorn_percentages() %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\")##  gender         0-4          5-19           20+          Total\n##       f 482 (22.4%) 1,184 (54.9%)   490 (22.7%) 2,156 (100.0%)\n##       m 325 (15.0%)   880 (40.6%)   960 (44.3%) 2,165 (100.0%)\n##   Total 807 (18.7%) 2,064 (47.8%) 1,450 (33.6%) 4,321 (100.0%)"},{"path":"survival-analysis.html","id":"noções-básicas-de-análise-de-sobrevivência","chapter":"26 Análise de sobrevivência","heading":"26.3 Noções básicas de análise de sobrevivência","text":"","code":""},{"path":"survival-analysis.html","id":"construir-um-objeto-do-tipo-sobrevivente","chapter":"26 Análise de sobrevivência","heading":"Construir um objeto do tipo sobrevivente","text":"Utilizaremos primeiro função Surv() pacote survival para construir um objeto de sobrevivência partir das colunas de tempo e evento seguintes.O resultado de tal passo é produzir um objeto tipo Surv que condensa informação tempo e se o evento de interesse (óbito) foi observado. Este objeto acabará por ser utilizado lado direito das fórmulas modelo subsequente (ver documentação).Para rever, aqui estão primeiras 10 linhas dos dados da linelist_surv, visualizando apenas algumas colunas importantes.E aqui estão os primeiros 10 elementos survobj. Imprime essencialmente como um vetor de tempo de seguimento, com “+” para representar se uma observação foi bem censurada. Veja como os números se alinham acima e abaixo.","code":"\n# Use a sintaxe Suv() para dados censurados\nsurvobj <- Surv(time = linelist_surv$futime,\n                event = linelist_surv$event)\nlinelist_surv %>% \n  select(case_id, date_onset, date_outcome, futime, outcome, event) %>% \n  head(10)##    case_id date_onset date_outcome futime outcome event\n## 1   8689b7 2014-05-13   2014-05-18      5 Recover     0\n## 2   11f8ea 2014-05-16   2014-05-30     14 Recover     0\n## 3   893f25 2014-05-21   2014-05-29      8 Recover     0\n## 4   be99c8 2014-05-22   2014-05-24      2 Recover     0\n## 5   07e3e8 2014-05-27   2014-06-01      5 Recover     0\n## 6   369449 2014-06-02   2014-06-07      5   Death     1\n## 7   f393b4 2014-06-05   2014-06-18     13 Recover     0\n## 8   1389ca 2014-06-05   2014-06-09      4   Death     1\n## 9   2978ac 2014-06-06   2014-06-15      9   Death     1\n## 10  fc15ef 2014-06-16   2014-07-09     23 Recover     0\n#imprime os 50 primeiros elementos do vetor para ver como ele se apresenta\nhead(survobj, 10)##  [1]  5+ 14+  8+  2+  5+  5  13+  4   9  23+"},{"path":"survival-analysis.html","id":"rodando-análises-iniciais","chapter":"26 Análise de sobrevivência","heading":"Rodando análises iniciais","text":"Iniciamos então nossa análise utilizando função survfit() para produzir um objeto survfit, que se ajusta aos cálculos padrões de estimativas da curva de sobrevivência global (marginal) Kaplan Meier (KM) , que são na verdade uma função com saltos em tempos de eventos observados. O objeto final survfit contém uma ou mais curvas de sobrevivência e são criadas usando o objeto Surv como uma resposta variável na fórmula modelo.NOTA: estimativa de Kaplan-Meier é uma estimativa não paramétrica da máxima probabilidade (MLE na sigla em inglês) da função de sobrevivência. . (ver recursos para mais informações)O resumo deste objeto survfit dará o que se chama uma tabela de vida. Para cada passo seguimento (tempo) em que um evento aconteceu (em ordem ascendente):o número de pessoas que estavam em risco de desenvolver o evento (pessoas que ainda não tinham o evento nem foram censuradas: n.risk)aqueles que desenvolveram o evento (n.event)e acima exposto: probabilidade de não desenvolver o evento (probabilidade de não morrer, ou de sobreviver depois desse tempo específico)finalmente, o erro padrão e o intervalo de confiança para essa probabilidade são derivados e exibidosEncaixamos estimativas KM usando fórmula em que o objeto anteriormente Surv “survobj” é variável de resposta. “~ 1” precisa que executamos o modelo para sobrevivência global.Enquanto usamos summary() podemos adicionar opção times e especificar certos tempos em que queremos ver informações de sobrevivência.Podemos também utilizar função print(). O argumento print.rmean = TRUE é utilizado para obter o tempo médio de sobrevivência e o seu erro padrão (SE na sigla em inglês).NOTA: O tempo médio de sobrevivência restrito (RMST na sigla em inglês) é uma medida de sobrevivência específica cada vez mais utilizada na análise de sobrevivência ao câncer e que é frequentemente definida como área sob curva de sobrevivência, dado que observamos pacientes até ao tempo restrito T (mais detalhes na seção Recursos).DICA: Podemos criar o objeto surv diretamente na função survfit() e economizar uma linha de código. Ficará então: linelistsurv_quick <-  survfit(Surv(futime, event) ~ 1, data=linelist_surv).","code":"\n# encaixa nas estimativas KM usando uma fórmula onde o objeto Surv \"sobrevivente\" é a variável de resposta.\n# \"~ 1\" significa que executamos o modelo para a sobrevivência global   \nlinelistsurv_fit <-  survival::survfit(survobj ~ 1)\n\n# imprime o resumo para mais detalhes\nsummary(linelistsurv_fit)## Call: survfit(formula = survobj ~ 1)\n## \n##  time n.risk n.event survival std.err lower 95% CI upper 95% CI\n##     1   4539      30    0.993 0.00120        0.991        0.996\n##     2   4500      69    0.978 0.00217        0.974        0.982\n##     3   4394     149    0.945 0.00340        0.938        0.952\n##     4   4176     194    0.901 0.00447        0.892        0.910\n##     5   3899     214    0.852 0.00535        0.841        0.862\n##     6   3592     210    0.802 0.00604        0.790        0.814\n##     7   3223     179    0.757 0.00656        0.745        0.770\n##     8   2899     167    0.714 0.00700        0.700        0.728\n##     9   2593     145    0.674 0.00735        0.660        0.688\n##    10   2311     109    0.642 0.00761        0.627        0.657\n##    11   2081     119    0.605 0.00788        0.590        0.621\n##    12   1843      89    0.576 0.00809        0.560        0.592\n##    13   1608      55    0.556 0.00823        0.540        0.573\n##    14   1448      43    0.540 0.00837        0.524        0.556\n##    15   1296      31    0.527 0.00848        0.511        0.544\n##    16   1152      48    0.505 0.00870        0.488        0.522\n##    17   1002      29    0.490 0.00886        0.473        0.508\n##    18    898      21    0.479 0.00900        0.462        0.497\n##    19    798       7    0.475 0.00906        0.457        0.493\n##    20    705       4    0.472 0.00911        0.454        0.490\n##    21    626      13    0.462 0.00932        0.444        0.481\n##    22    546       8    0.455 0.00948        0.437        0.474\n##    23    481       5    0.451 0.00962        0.432        0.470\n##    24    436       4    0.447 0.00975        0.428        0.466\n##    25    378       4    0.442 0.00993        0.423        0.462\n##    26    336       3    0.438 0.01010        0.419        0.458\n##    27    297       1    0.436 0.01017        0.417        0.457\n##    29    235       1    0.435 0.01030        0.415        0.455\n##    38     73       1    0.429 0.01175        0.406        0.452\n#imprime o resumo de tempos específicos\nsummary(linelistsurv_fit, times = c(5,10,20,30,60))## Call: survfit(formula = survobj ~ 1)\n## \n##  time n.risk n.event survival std.err lower 95% CI upper 95% CI\n##     5   3899     656    0.852 0.00535        0.841        0.862\n##    10   2311     810    0.642 0.00761        0.627        0.657\n##    20    705     446    0.472 0.00911        0.454        0.490\n##    30    210      39    0.435 0.01030        0.415        0.455\n##    60      2       1    0.429 0.01175        0.406        0.452\n# imprimir objeto linelistsurv_fit com tempo médio de sobrevivência e sua SE.\nprint(linelistsurv_fit, print.rmean = TRUE)## Call: survfit(formula = survobj ~ 1)\n## \n##         n events rmean* se(rmean) median 0.95LCL 0.95UCL\n## [1,] 4539   1952   33.1     0.539     17      16      18\n##     * restricted mean with upper limit =  64"},{"path":"survival-analysis.html","id":"risco-acumulado","chapter":"26 Análise de sobrevivência","heading":"Risco acumulado","text":"Além da função summary(), também podemos utilizar função str() que dá mais detalhes sobre estrutura objeto survfit(). É uma lista de 16 elementos.Entre estes elementos é um importante: cumhaz, que é um vetor numérico. Este pode ser traçado para permitir mostrar o risco cumulativo, sendo o risco o índice instantâneo de ocorrência de eventos (ver referências).","code":"\nstr(linelistsurv_fit)## List of 16\n##  $ n        : int 4539\n##  $ time     : num [1:59] 1 2 3 4 5 6 7 8 9 10 ...\n##  $ n.risk   : num [1:59] 4539 4500 4394 4176 3899 ...\n##  $ n.event  : num [1:59] 30 69 149 194 214 210 179 167 145 109 ...\n##  $ n.censor : num [1:59] 9 37 69 83 93 159 145 139 137 121 ...\n##  $ surv     : num [1:59] 0.993 0.978 0.945 0.901 0.852 ...\n##  $ std.err  : num [1:59] 0.00121 0.00222 0.00359 0.00496 0.00628 ...\n##  $ cumhaz   : num [1:59] 0.00661 0.02194 0.05585 0.10231 0.15719 ...\n##  $ std.chaz : num [1:59] 0.00121 0.00221 0.00355 0.00487 0.00615 ...\n##  $ type     : chr \"right\"\n##  $ logse    : logi TRUE\n##  $ conf.int : num 0.95\n##  $ conf.type: chr \"log\"\n##  $ lower    : num [1:59] 0.991 0.974 0.938 0.892 0.841 ...\n##  $ upper    : num [1:59] 0.996 0.982 0.952 0.91 0.862 ...\n##  $ call     : language survfit(formula = survobj ~ 1)\n##  - attr(*, \"class\")= chr \"survfit\""},{"path":"survival-analysis.html","id":"traçando-curvas-kaplan-meir","chapter":"26 Análise de sobrevivência","heading":"Traçando curvas Kaplan-Meir","text":"Uma vez encaixadas estimativas KM, podemos visualizar probabilidade de estarmos vivos durante um determinado tempo utilizando função básica plot() que desenha “curva Kaplan-Meier”. Em outras palavras, curva abaixo é uma ilustração convencional da experiência de sobrevivência em todo o grupo de pacientes.Podemos verificar rapidamente o tempo de seguimento mínimo e máximo na curva.Uma maneira fácil de interpretar é dizer que tempo zero, todos os participantes ainda estão vivos e probabilidade de sobrevivência é então de 100%. Esta probabilidade diminui com o tempo, à medida que os pacientes morrem. proporção de participantes que sobrevivem nos últimos 60 dias de seguimento é de cerca de 40%.O intervalo de confiança das estimativas de sobrevivência KM também são traçados por padrão e podem ser descartados adicionando opção conf.int = FALSE ao comando plot().Uma vez que o evento de interesse é “óbito”, desenhar uma curva descrevendo os complementos das proporções de sobrevivência levará desenhar proporções de mortalidade acumulada. Isto pode ser feito com lines(), o que acrescenta informação uma parcela existente.","code":"\nplot(linelistsurv_fit, \n     xlab = \"Days of follow-up\",    # nome eixo X\n     ylab=\"Survival Probability\",   # nome eixo Y\n     main= \"Overall survival curve\" # título da figura\n     )\n# gráfico original\nplot(\n  linelistsurv_fit,\n  xlab = \"Dias de seguimento\",       \n  ylab = \"Probabilidade de Sobrevivência\",       \n  mark.time = TRUE,               # marcar eventos na curva: um \"+\" é impresso em cada evento\n  conf.int = FALSE,              # não traçar o intervalo de confiança\n  main = \"Curva geral de sobrevivência e mortalidade acumulada\"\n  )\n\n# desenhar uma curva adicional ao gráfico anterior\nlines(\n  linelistsurv_fit,\n  lty = 3,             # usar tipo de linha diferente para maior clareza\n  fun = \"event\",       # desenhar os eventos cumulativos em vez da sobrevivência\n  mark.time = FALSE,\n  conf.int = FALSE\n  )\n\n# adiciona legenda ao gráfico\nlegend(\n  \"topright\",                                       # posição da legenda\n  legend = c(\"Sobrevivência\", \"Mortalidade Acum.\"), # texto da legenda\n  lty = c(1, 3),                                    # tipos de linha a serem usados na legenda\n  cex = .85,                                        # parâmetros que definem o tamanho do texto da legenda\n  bty = \"n\"                                         # nenhum tipo de caixa a ser desenhada para a legenda\n  )"},{"path":"survival-analysis.html","id":"comparação-de-curvas-de-sobrevivência","chapter":"26 Análise de sobrevivência","heading":"26.4 Comparação de curvas de sobrevivência","text":"Para comparar sobrevivência dentro de diferentes grupos dos nossos participantes ou pacientes observados, podemos ter de olhar primeiro para suas respectivas curvas de sobrevivência e depois fazer testes para avaliar diferença entre grupos independentes. Esta comparação pode dizer respeito grupos baseados sexo, idade, tratamento, comorbidade…","code":""},{"path":"survival-analysis.html","id":"teste-de-classificação-de-registo","chapter":"26 Análise de sobrevivência","heading":"Teste de classificação de registo","text":"O teste de log-rank é um teste popular que compara toda experiência de sobrevivência entre dois ou mais grupos independentes e pode ser pensado como um teste para verificar se curvas de sobrevivência são idênticas (sobreposição) ou não (hipótese nula de não haver diferença na sobrevivência entre os grupos). função survdiff() pacote survival permite executar o teste de log-rank quando especificamos rho = 0 (que é o padrão). Os resultados teste dão uma estatística de qui-quadrado juntamente com um p-valor, uma vez que estatística de classificação logarítmica é distribuída aproximadamente como uma estatística de teste de qui-quadrado.Tentamos primeiro comparar curvas de sobrevivência por grupo de gênero. Para tal, tentamos primeiro visualizá-la (verificar se duas curvas de sobrevivência estão sobrepostas). Um novo objeto survfit será criado com uma fórmula ligeiramente diferente. Depois será criado o objeto survdiff.Ao fornecer ~ gender como o lado direito da fórmula, deixamos de traçar sobrevivência global e passamos fazê-lo por gênero.Agora podemos traçar curvas de sobrevivência por gênero. Veja ordem dos níveis de estratos na coluna gênero antes de definir suas cores e legendas.E agora podemos calcular o teste da diferença entre curvas de sobrevivência usando survdiff ()Vemos que curva de sobrevivência das mulheres e dos homens se sobrepõem e o teste log-rank não dá provas de uma diferença de sobrevivência entre mulheres e homens.Alguns outros pacotes de R permitem ilustrar curvas de sobrevivência para diferentes grupos e testar diferença de uma só vez. Utilizando função ggsurvplot() pacote survminer, podemos também incluir na nossa curva tabelas de risco impressas para cada grupo, bem como o valor p teste de log-rank.[CUIDADO: funções survminer requerem que se especifique o objeto de sobrevivência e novamente os dados utilizados para encaixar o objeto de sobrevivência. Lembre-se de fazer isto para evitar mensagens de erro não específicas].{style=“color: orange;”}Também podemos querer testar diferenças na sobrevivência pela fonte de infecção (fonte de contaminação).Neste caso, o teste de Log rank dá provas suficientes de uma diferença nas probabilidades de sobrevivência em alpha= 0,005. probabilidades de sobrevivência de pacientes que foram infectados em funerais são superiores às probabilidades de sobrevivência de pacientes que foram infectados em outros locais, sugerindo um benefício de sobrevivência.","code":"\n# criar um novo objeto do tipo survfit baseado no gênero\nlinelistsurv_fit_sex <-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)\n# padrão de cor\ncol_sex <- c(\"lightgreen\", \"darkgreen\")\n\n# cria a impressão\nplot(\n  linelistsurv_fit_sex,\n  col = col_sex,\n  xlab = \"Days of follow-up\",\n  ylab = \"Survival Probability\")\n\n# adiciona legenda\nlegend(\n  \"topright\",\n  legend = c(\"Feminino\",\"Masculino\"),\n  col = col_sex,\n  lty = 1,\n  cex = .9,\n  bty = \"n\")\n# calcula o teste da diferença entre as curvas de sobrevivência\nsurvival::survdiff(\n  Surv(futime, event) ~ gender, \n  data = linelist_surv\n  )## Call:\n## survival::survdiff(formula = Surv(futime, event) ~ gender, data = linelist_surv)\n## \n## n=4321, 218 observations deleted due to missingness.\n## \n##             N Observed Expected (O-E)^2/E (O-E)^2/V\n## gender=f 2156      924      909     0.255     0.524\n## gender=m 2165      929      944     0.245     0.524\n## \n##  Chisq= 0.5  on 1 degrees of freedom, p= 0.5\nsurvminer::ggsurvplot(\n    linelistsurv_fit_sex, \n    data = linelist_surv,          # novamente especificar o dado usado para encaixar linelistsurv_fit_sex \n    conf.int = FALSE,              # não mostrar o intervalo de confiança da estimativa KM\n    surv.scale = \"percent\",        # apresentar probabilidades no eixo Y em %\n    break.time.by = 10,            # apresentar o eixo de tempo com um incremento de 10 dias\n    xlab = \"Follow-up days\",\n    ylab = \"Survival Probability\",\n    pval = T,                      # adicionar o p-valor do teste Log-rank \n    pval.coord = c(40,.91),        # adicionar o p-valor às coordenadas especificadas\n    risk.table = T,                # imprimir a tabela de risco no fundo  \n    legend.title = \"Gender\",       # características da legenda\n    legend.labs = c(\"Female\",\"Male\"),\n    font.legend = 10, \n    palette = \"Dark2\",             # especificar paleta de cores \n    surv.median.line = \"hv\",       # desenhar linhas horizontais e verticais para a mediana de sobrevivência\n    ggtheme = theme_light()        # simplificar o plano de fundo da impressão\n)\nlinelistsurv_fit_source <-  survfit(\n  Surv(futime, event) ~ source,\n  data = linelist_surv\n  )\n\n# impressão\nggsurvplot( \n  linelistsurv_fit_source,\n  data = linelist_surv,\n  size = 1, linetype = \"strata\",   # tipos de linhas\n  conf.int = T,\n  surv.scale = \"percent\",  \n  break.time.by = 10, \n  xlab = \"Follow-up days\",\n  ylab= \"Survival Probability\",\n  pval = T,\n  pval.coord = c(40,.91),\n  risk.table = T,\n  legend.title = \"Source of \\ninfection\",\n  legend.labs = c(\"Funeral\", \"Other\"),\n  font.legend = 10,\n  palette = c(\"#E7B800\",\"#3E606F\"),\n  surv.median.line = \"hv\", \n  ggtheme = theme_light()\n)"},{"path":"survival-analysis.html","id":"análise-de-regressão-de-cox","chapter":"26 Análise de sobrevivência","heading":"26.5 Análise de regressão de Cox","text":"O modelo de riscos proporcionais de Cox é uma das técnicas de regressão mais populares para análise de sobrevivência. Outros modelos também podem ser utilizados, uma vez que o modelo Cox requer importantes pressupostos que precisam ser verificados para uma utilização adequada, tal como o pressuposto dos riscos proporcionais: ver referências.Num modelo de riscos proporcionais de Cox, medida efeito é taxa de risco ou razão de riscos(HR na sigla Hazard Ratio em inglês), que é o risco de fracasso (ou o risco de morte nosso exemplo), dado que o participante sobreviveu até um tempo específico. Normalmente, estamos interessados em comparar grupos independentes com respeito aos seus perigos, e utilizamos uma taxa de risco, que é análoga uma taxa de probabilidade estabelecimento de uma análise de regressão logística múltipla. função cox.ph() pacote survival é utilizada para se adequar ao modelo. função cox.zph() pacote survival pode ser utilizada para testar hipótese de riscos proporcionais para um ajuste modelo de regressão Cox.NOTA: probabilidade deve estar intervalo de 0 1. entanto, o perigo representa o número esperado de eventos por uma unidade de tempo.Se razão de perigo para um preditor próxima de 1, então esse preditor não afeta sobrevivência,se o HR inferior 1, então o preditor é protetor (ou seja, associado uma melhor sobrevivência),e se FC superior 1, então o preditor está associado ao aumento risco (ou diminuição da sobrevivência).","code":""},{"path":"survival-analysis.html","id":"ajuste-de-um-modelo-cox","chapter":"26 Análise de sobrevivência","heading":"Ajuste de um modelo Cox","text":"Podemos primeiro ajustar um modelo para avaliar o efeito da idade e gênero na sobrevivência. Ao imprimir apenas o modelo, temos informação sobre:os coeficientes de regressão estimados “coef” que quantificam associação entre os preditores e o resultado,sua exponencial (para interpretabilidade, exp(coef)) que produz razão de riscos HR,o seu erro padrão se(coef),o z-score: quantos erros padrão é o coeficiente estimado partir de 0,e o p-valor: probabilidade de o coeficiente estimado poder ser 0.função summary() aplicada ao objeto modelo Cox dá mais informações, tais como o intervalo de confiança HR estimado e os diferentes resultados teste.O efeito da primeira covariável “gênero” é apresentado na primeira linha. O genderm (masculino) é mostrado indicando que o primeiro nível de estratos (“f”), ou seja, o grupo feminino, é o grupo de referência para comparações dentro gênero. Assim, interpretação parâmetro de teste é dos homens em comparação com das mulheres. O p-valor indica que não havia evidências suficientes de um efeito gênero sobre o risco esperado ou de uma associação entre o gênero e mortalidade por todas causas.mesma falta de evidências é notada que diz respeito ao grupo etário.Foi interessante executar o modelo e olhar para os resultados, mas um primeiro olhar para verificar se os pressupostos de riscos proporcionais são respeitados poderia ajudar poupar tempo.NOTA: Um segundo argumento da função chamado method pode ser especificado ao calcular o modelo cox, que determina como os empates são tratados. O padrão é “efron”, e outras opções são “breslow” e “exact”.Num outro modelo, adicionamos mais fatores de risco, tais como fonte da infecção e o número de dias entre data de início e admissão. Desta vez, verificamos primeiro hipótese de riscos proporcionais antes de avançarmos.Neste modelo, incluímos um preditor contínuo (days_onset_hosp). Neste caso, interpretamos estimativas dos parâmetros como o aumento registo esperado risco relativo para cada aumento de uma unidade preditor, mantendo constantes outros preditores. Primeiro verificamos suposição de perigos proporcionais.verificação gráfica desta hipótese pode ser realizada com função ggcoxzph() pacote survminer.Os resultados modelo indicam existência de uma associação negativa entre o início da duração da admissão e mortalidade por todas causas. O risco esperado é 0,9 vezes menor numa pessoa que é admitida um dia mais tarde que outra, mantendo constante o gênero. Ou, numa explicação mais direta, um aumento de uma unidade na duração início da admissão está associado uma diminuição de 10,7% (coef *100) risco de morte.Os resultados mostram também uma associação positiva entre fonte da infecção e mortalidade por todas causas. Ou seja, há um aumento risco de morte (1,21x) para os pacientes que têm outra fonte de infecção.Podemos verificar essa relação com tabela:Teríamos de considerar e investigar porque é que esta associação existe nos dados. Uma explicação possível poderia ser que os pacientes que vivem o tempo suficiente para serem admitidos mais tarde, tem uma doença menos grave. Outra explicação talvez mais provável é que, uma vez que utilizámos um conjunto de dados falso simulado, este padrão não reflete realidade!","code":"\n# ajustando o modelo cox\nlinelistsurv_cox_sexage <-  survival::coxph(\n              Surv(futime, event) ~ gender + age_cat_small, \n              data = linelist_surv\n              )\n\n\n#imprimindo o modelo ajustado\nlinelistsurv_cox_sexage## Call:\n## survival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n##     data = linelist_surv)\n## \n##                       coef exp(coef) se(coef)      z     p\n## genderm           -0.03149   0.96900  0.04767 -0.661 0.509\n## age_cat_small5-19  0.09400   1.09856  0.06454  1.456 0.145\n## age_cat_small20+   0.05032   1.05161  0.06953  0.724 0.469\n## \n## Likelihood ratio test=2.8  on 3 df, p=0.4243\n## n= 4321, number of events= 1853 \n##    (218 observations deleted due to missingness)\n#resumo do modelo\nsummary(linelistsurv_cox_sexage)## Call:\n## survival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n##     data = linelist_surv)\n## \n##   n= 4321, number of events= 1853 \n##    (218 observations deleted due to missingness)\n## \n##                       coef exp(coef) se(coef)      z Pr(>|z|)\n## genderm           -0.03149   0.96900  0.04767 -0.661    0.509\n## age_cat_small5-19  0.09400   1.09856  0.06454  1.456    0.145\n## age_cat_small20+   0.05032   1.05161  0.06953  0.724    0.469\n## \n##                   exp(coef) exp(-coef) lower .95 upper .95\n## genderm               0.969     1.0320    0.8826     1.064\n## age_cat_small5-19     1.099     0.9103    0.9680     1.247\n## age_cat_small20+      1.052     0.9509    0.9176     1.205\n## \n## Concordance= 0.514  (se = 0.007 )\n## Likelihood ratio test= 2.8  on 3 df,   p=0.4\n## Wald test            = 2.78  on 3 df,   p=0.4\n## Score (logrank) test = 2.78  on 3 df,   p=0.4\ntest_ph_sexage <- survival::cox.zph(linelistsurv_cox_sexage)\ntest_ph_sexage##               chisq df    p\n## gender        0.454  1 0.50\n## age_cat_small 0.838  2 0.66\n## GLOBAL        1.399  3 0.71\n#cria o modelo\nlinelistsurv_cox <-  coxph(\n                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,\n                        data = linelist_surv\n                        )\n\n\n#testa o modelo de risco proporcional\nlinelistsurv_ph_test <- cox.zph(linelistsurv_cox)\nlinelistsurv_ph_test##                    chisq df       p\n## gender           0.45062  1    0.50\n## age_years        0.00199  1    0.96\n## source           1.79622  1    0.18\n## days_onset_hosp 31.66167  1 1.8e-08\n## GLOBAL          34.08502  4 7.2e-07\nsurvminer::ggcoxzph(linelistsurv_ph_test)\n#resumo do modelo\nsummary(linelistsurv_cox)## Call:\n## coxph(formula = Surv(futime, event) ~ gender + age_years + source + \n##     days_onset_hosp, data = linelist_surv)\n## \n##   n= 2772, number of events= 1180 \n##    (1767 observations deleted due to missingness)\n## \n##                      coef exp(coef)  se(coef)      z Pr(>|z|)    \n## genderm          0.004710  1.004721  0.060827  0.077   0.9383    \n## age_years       -0.002249  0.997753  0.002421 -0.929   0.3528    \n## sourceother      0.178393  1.195295  0.084291  2.116   0.0343 *  \n## days_onset_hosp -0.104063  0.901169  0.014245 -7.305 2.77e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n##                 exp(coef) exp(-coef) lower .95 upper .95\n## genderm            1.0047     0.9953    0.8918    1.1319\n## age_years          0.9978     1.0023    0.9930    1.0025\n## sourceother        1.1953     0.8366    1.0133    1.4100\n## days_onset_hosp    0.9012     1.1097    0.8764    0.9267\n## \n## Concordance= 0.566  (se = 0.009 )\n## Likelihood ratio test= 71.31  on 4 df,   p=1e-14\n## Wald test            = 59.22  on 4 df,   p=4e-12\n## Score (logrank) test = 59.54  on 4 df,   p=4e-12\nlinelist_case_data %>% \n  tabyl(days_onset_hosp, outcome) %>% \n  adorn_percentages() %>%  \n  adorn_pct_formatting()##  days_onset_hosp Death Recover   NA_\n##                0 44.3%   31.4% 24.3%\n##                1 46.6%   32.2% 21.2%\n##                2 43.0%   32.8% 24.2%\n##                3 45.0%   32.3% 22.7%\n##                4 41.5%   38.3% 20.2%\n##                5 40.0%   36.2% 23.8%\n##                6 32.2%   48.7% 19.1%\n##                7 31.8%   38.6% 29.5%\n##                8 29.8%   38.6% 31.6%\n##                9 30.3%   51.5% 18.2%\n##               10 16.7%   58.3% 25.0%\n##               11 36.4%   45.5% 18.2%\n##               12 18.8%   62.5% 18.8%\n##               13 10.0%   60.0% 30.0%\n##               14 10.0%   50.0% 40.0%\n##               15 28.6%   42.9% 28.6%\n##               16 20.0%   80.0%  0.0%\n##               17  0.0%  100.0%  0.0%\n##               18  0.0%  100.0%  0.0%\n##               22  0.0%  100.0%  0.0%\n##               NA 52.7%   31.2% 16.0%"},{"path":"survival-analysis.html","id":"gráficos-em-floresta-forest-plots","chapter":"26 Análise de sobrevivência","heading":"Gráficos em floresta (Forest plots)","text":"Podemos visualizar os resultados modelo Cox usando “forest plots” com função ggforest() pacote survminer.","code":"\nggforest(linelistsurv_cox, data = linelist_surv)"},{"path":"survival-analysis.html","id":"covariáveis-dependentes-do-tempo-em-modelos-de-sobrevivência","chapter":"26 Análise de sobrevivência","heading":"26.6 Covariáveis dependentes do tempo em modelos de sobrevivência","text":"Algumas das seções seguintes foram adaptadas com permissão de uma excelente introdução à análise de sobrevivência em R pela Dra. Emily ZaborNa última seção usamos regressão Cox para examinar associações entre covariáveis de interesse e resultados de sobrevivência. Mas estas análises dependem da covariância ser medida na linha de base, ou seja, antes tempo de seguimento evento começar.O que acontece se estiver interessado em uma covariável que é medida após o início tempo de seguimento? Ou, e se uma dessas covariáveis possa mudar ao longo tempo?Por exemplo, talvez esteja trabalhando com dados clínicos onde repetiu medidas de valores laboratoriais hospitalares que podem mudar ao longo tempo. Este é um exemplo de uma Covariável Dependente Tempo. Para resolver este problema é necessário uma configuração especial, mas felizmente o modelo cox é muito flexível e este tipo de dados também pode ser modelado com ferramentas pacote survival.","code":""},{"path":"survival-analysis.html","id":"configuração-de-covariável-dependente-do-tempo","chapter":"26 Análise de sobrevivência","heading":"Configuração de covariável dependente do tempo","text":"análise de covariáveis dependentes tempo em R requer configuração de um conjunto de dados especial. Se estiver interessado, ver o artigo mais detalhado sobre este assunto autor pacote survival Using Time Dependent Covariates Time Dependent Coefficients Cox Model.Para tal, utilizaremos um novo conjunto de dados pacote SemiCompRisks' chamadoBMT’, que inclui dados sobre 137 pacientes de transplante de medula óssea. variáveis em que nos vamos concentrar são:T1 - tempo (em dias) até à morte ou último seguimentoT1 - tempo (em dias) até à morte ou último seguimentodelta1 - indicador de óbito; 1-Óbito, 0-Vivosdelta1 - indicador de óbito; 1-Óbito, 0-VivosTA - tempo (em dias) até à doença aguda de enxerto-versus-hospedeiroTA - tempo (em dias) até à doença aguda de enxerto-versus-hospedeirodeltaA - indicador de doença aguda de enxerto-versus-hospedeiro;\n1 - desenvolveu doença aguda de enxerto-versus-hospedeiro\n0 - Nunca desenvolveu doença aguda de enxerto-versus-hospedeiro\ndeltaA - indicador de doença aguda de enxerto-versus-hospedeiro;1 - desenvolveu doença aguda de enxerto-versus-hospedeiro0 - Nunca desenvolveu doença aguda de enxerto-versus-hospedeiroVamos carregar este conjunto de dados partir pacote survival utilizando o comando R base data(), que pode ser utilizado para carregar dados que já estão incluídos num pacote R que é carregado. moldura de dados BMT irá aparecer seu ambiente R.","code":"\ndata(BMT, package = \"SemiCompRisks\")"},{"path":"survival-analysis.html","id":"adicionar-identificador-único-de-doente","chapter":"26 Análise de sobrevivência","heading":"Adicionar identificador único de doente","text":"Não existe uma coluna de ID única nos dados BMT, que é necessária para criar o tipo de conjunto de dados que desejamos. Assim, utilizamos função rowid_to_column() pacote tidyverse para criar uma nova coluna de id chamada my_id (adiciona coluna início Data Frame com ids sequenciais de linha, começando em 1). Nomeamos o data frame como bmt.O conjunto de dados tem agora este aspecto:","code":"\nbmt <- rowid_to_column(BMT, \"my_id\")"},{"path":"survival-analysis.html","id":"expandir-as-linhas-de-pacientes","chapter":"26 Análise de sobrevivência","heading":"Expandir as linhas de pacientes","text":"seguir, utilizaremos função tmerge() com funções auxiliares event() e tdc() helper para criar o conjunto de dados reestruturado. Neste caso, cada paciente pode ter máximo duas linhas, dependendo se desenvolveu doença aguda de enxerto-versus-hospedeiro durante o período de coleta de dados. Vamos chamar o nosso novo indicador para o desenvolvimento da doença aguda de enxerto-versus-hospedeiro agvhd.tmerge() cria um longo conjunto de dados com múltiplos intervalos de tempo para os diferentes valores covariados para cada pacienteevent() cria o novo indicador de evento para combinar com os intervalos de tempo recém-criadostdc() cria coluna covariada dependente tempo, agvhd, para combinar com os intervalos de tempo recém-criadosPara ver o que foi feito, vamos olhar os dados dos primeiros 5 pacientes.variáveis de interesse dado original terão essa aparência:O novo conjunto de dados para esses pacientes terá essa aparência:Agora alguns dos nossos pacientes têm duas linhas conjunto de dados correspondentes intervalos em que têm um valor diferente da nossa nova variável, agvhd. Por exemplo, o Paciente 1 tem agora duas linhas com um valor agvhd de zero tempo 0 ao tempo 67, e um valor de 1 tempo 67 ao tempo 2081.","code":"\ntd_dat <- \n  tmerge(\n    data1 = bmt %>% select(my_id, T1, delta1), \n    data2 = bmt %>% select(my_id, T1, delta1, TA, deltaA), \n    id = my_id, \n    death = event(T1, delta1),\n    agvhd = tdc(TA)\n    )\nbmt %>% \n  select(my_id, T1, delta1, TA, deltaA) %>% \n  filter(my_id %in% seq(1, 5))##   my_id   T1 delta1   TA deltaA\n## 1     1 2081      0   67      1\n## 2     2 1602      0 1602      0\n## 3     3 1496      0 1496      0\n## 4     4 1462      0   70      1\n## 5     5 1433      0 1433      0\ntd_dat %>% \n  filter(my_id %in% seq(1, 5))##   my_id   T1 delta1 tstart tstop death agvhd\n## 1     1 2081      0      0    67     0     0\n## 2     1 2081      0     67  2081     0     1\n## 3     2 1602      0      0  1602     0     0\n## 4     3 1496      0      0  1496     0     0\n## 5     4 1462      0      0    70     0     0\n## 6     4 1462      0     70  1462     0     1\n## 7     5 1433      0      0  1433     0     0"},{"path":"survival-analysis.html","id":"regressão-cox-com-covariáveis-dependentes-do-tempo","chapter":"26 Análise de sobrevivência","heading":"Regressão Cox com covariáveis dependentes do tempo","text":"Agora que remodelamos os nossos dados e acrescentamos nova variável dependente tempo aghvd , vamos encaixar um modelo simples de regressão de uma única variável cox. Podemos utilizar mesma função coxph() como antes, só precisamos alterar nossa função Surv() para especificar tanto o tempo de início como o tempo de paragem para cada intervalo utilizando os argumentos time1 = e time2 =.Novamente vamos visualizar o resultado nosso modelo cox usando função ggforest() pacote survminer.:Como se pode ver pela “forest plot”, intervalo de confiança e p-valor, não parece haver forte associação entre ocorrência de óbito e doença aguda enxerto-versus-hospedeiro contexto nosso modelo simples.","code":"\nbmt_td_model = coxph(\n  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, \n  data = td_dat\n  )\n\nsummary(bmt_td_model)## Call:\n## coxph(formula = Surv(time = tstart, time2 = tstop, event = death) ~ \n##     agvhd, data = td_dat)\n## \n##   n= 163, number of events= 80 \n## \n##         coef exp(coef) se(coef)    z Pr(>|z|)\n## agvhd 0.3351    1.3980   0.2815 1.19    0.234\n## \n##       exp(coef) exp(-coef) lower .95 upper .95\n## agvhd     1.398     0.7153    0.8052     2.427\n## \n## Concordance= 0.535  (se = 0.024 )\n## Likelihood ratio test= 1.33  on 1 df,   p=0.2\n## Wald test            = 1.42  on 1 df,   p=0.2\n## Score (logrank) test = 1.43  on 1 df,   p=0.2\nggforest(bmt_td_model, data = td_dat)"},{"path":"survival-analysis.html","id":"referências","chapter":"26 Análise de sobrevivência","heading":"26.7 Referências","text":"Survival Analysis Part : Basic concepts first analysesAnálise de sobrevivência RSurvival analysis infectious disease research: Describing events timeChapter advanced survival models PrincetonUsing Time Dependent Covariates Time Dependent Coefficients Cox ModelCheatsheet (cola) de análise de sobrevivênciaCheatsheet (cole) SurvminerPaper different survival measures cancer registry data Rcode provided supplementary materials","code":""},{"path":"tables-presentation.html","id":"tables-presentation","chapter":"27 Tabelas para apresentação","heading":"27 Tabelas para apresentação","text":"HospitalTotal de casos com desfecho conhecidoRecuperadosÓbitoTotal% de casosMediana de valores CTTotal% de casosMediana de valores CTSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22Esta seção demonstra como converter data frames resumo dos seus dados em tabelas prontas para apresentação com o uso pacote flextable. Estas tabelas podem ser inseridas em slides programa powerpoint, em páginas HTML ou documentos em formatos PDF ou Word, entre outros.É preciso compreender que, antes de usar o pacote flextable, você deve criar tabela resumida como um data frame. Você pode utilizar os métodos das Tabelas Descritivas ou Pivoteando dados, tais como: tabulações, tabulações cruzadas, pivotamento e calcular estatísticas descritivas. O data frame resultantes pode então ser utilizado na função flextable para formatar visualização.Há muitos outros pacotes R que podem ser usados para elaborar tabelas para apresentação – aqui, nós escolhemos destacar o pacote “flextable” nesta seção. Um exemplo usando o pacote knitr e sua função kable() pode ser encontrado na página de Rastreamento de Contatos. Da mesma maneira, o pacote DT é evidenciado na seção de Paineis com Shiny. Outros programas, tais como o GT e o huxtable são mencionados na página de pacotes sugeridos Pacotes sugeridos.","code":""},{"path":"tables-presentation.html","id":"preparação-17","chapter":"27 Tabelas para apresentação","heading":"27.1 Preparação","text":"","code":""},{"path":"tables-presentation.html","id":"carregando-pacotes-2","chapter":"27 Tabelas para apresentação","heading":"Carregando pacotes","text":"Instalar e carregar o pacote flextable. Neste manual, nós destacamos o p_load() pacman, o qual instala o pacote, se necessário, e o carrega para ser utilizado. Você também pode carregar os pacotes com library() presente R base. Veja seção sobre Introdução ao R para obter mais informações sobre os pacotes “R”.","code":"\npacman::p_load(\n  rio,            # importar/exportar\n  here,           # caminho do arquivo\n  flextable,      # fazer tabelas HTML \n  officer,        # Funções auxiliares para tabelas\n  tidyverse)      # visualização, resumo e gerenciamento dos dados "},{"path":"tables-presentation.html","id":"importando-dados-1","chapter":"27 Tabelas para apresentação","heading":"Importando dados","text":"Para começar, nós importamos linelist dos casos que simulam uma epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o “clean”linelist  (como arquivo .rds). Importe dados com função import() pacote rio (ele trabalho com vários tipos de arquivo, tais como: .xlsx, .csv, .rds - você pode visualizar seção Importar e exportar para outros detalhes).primeiras 50 linhas da linelist estão exibidas abaixo:","code":"\n# importar a linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"tables-presentation.html","id":"preparar-a-tabela","chapter":"27 Tabelas para apresentação","heading":"Preparar a tabela","text":"Antes de começar utilizar o pacote flextable você precisará criar sua tabela como um data frame. Veja seção em Tabelas descritivas e Pivotando dados para aprender criar um quadro de dados utilizando pacotes como janitor* e dplyr.\nVocê deverá organizar o conteúdo em linhas e colunas conforme você queira que seja exibido. Então, o conjunto de dados será passado para o comando flextable para ser exibido com cores, cabeçalhos, fontes, etc.Abaixo está um exemplo da página Tabelas descritivas de conversão dos casos na linelist dentro de um conjunto de dados que resume os resultados dos pacientes e os valores de CT (limiar de detecção, da sigla em inglês “cycle threshold”) por hospital, com uma linha de Totais na parte inferior. saída é salva como o objeto table.","code":"\ntable <- linelist %>% \n  \n  # Obter valores resumidos por grupo hospital-resultado\n  ###############################################\n  group_by(hospital, outcome) %>%                      # Dados por grupo\n  summarise(                                           # Criar novas colunas resumidas de indicadores de interessse\n    N = n(),                                           # Numero de linhas por grupo hospital-resultado   \n    ct_value = median(ct_blood, na.rm=T)) %>%          # mediana do valor de TC por grupo\n\n  \n  # add totals\n  ############\n  bind_rows(                                           # Vincular as tabelas prévias com esta mini-tabela de totais    \n  linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Agrupar somente pelo resultado, não pelo hospital    \n      summarise(\n        N = n(),                                       # Número de linhas para conjunto de dados total     \n        ct_value = median(ct_blood, na.rm=T))) %>%     # Mediana de CT para conjunto de dados total\n  \n   # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Colunas longas e amplas\n    values_from = c(ct_value, N),                      # novos valores de CT e colunas de contagem\n    names_from = outcome) %>%                          # novos nomes da colunas são de resultados\n  mutate(                                              # Adicionar novas colunas\n    N_Known = N_Death + N_Recover,                               # número com resultados conhecidos\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # porcentagem de casos de óbitos (com 1 casa decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # porcentagem dos reuperados (com 1 casa decimal)\n  select(                                              # Reordenar as colunas\n    hospital, N_Known,                                   # Colunas introdutórias\n    N_Recover, Pct_Recover, ct_value_Recover,            # Coluna dos recuperados\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Coluna de óbitos\n  arrange(N_Known)                                    # Organizar linhas da mais alta para mais baixa (linha superior a linha Total)\n\ntable  # impressão## # A tibble: 7 × 8\n## # Groups:   hospital [7]\n##   hospital            N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n##   <chr>                 <int>     <int> <chr>                  <dbl>   <int> <chr>    \n## 1 St. Mark's Materni…     325       126 38.8%                     22     199 61.2%    \n## 2 Central Hospital        358       165 46.1%                     22     193 53.9%    \n## 3 Other                   685       290 42.3%                     21     395 57.7%    \n## 4 Military Hospital       708       309 43.6%                     22     399 56.4%    \n## 5 Ausente                1125       514 45.7%                     21     611 54.3%    \n## 6 Port Hospital          1364       579 42.4%                     21     785 57.6%    \n## 7 Total                  4565      1983 43.4%                     21    2582 56.6%    \n## # ℹ 1 more variable: ct_value_Death <dbl>"},{"path":"tables-presentation.html","id":"básico-do-flextable","chapter":"27 Tabelas para apresentação","heading":"27.2 Básico do flextable","text":"","code":""},{"path":"tables-presentation.html","id":"criar-um-flextable","chapter":"27 Tabelas para apresentação","heading":"Criar um flextable","text":"Para criar e gerenciar os objetos comando flextable, passamos primeiro o conjunto de dados por meio da função flextable(). Nós salvamos os resultados como my_table.hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22Após ter feito isso, podemos progresssivamente vincular o objeto my_table por meio de outras funções de formatação flextable.Nesta página, por uma questão de clareza, nós devemos salvar tabela em níveis intermediários como my_table, e adicionando funções flextable uma uma. Se você quiser ver uma parte de todos os comandos escritos início ao fim, visite seção logo abaixo Todos os códigos juntos.sintaxe geral de cada linha de comando flextable* é seguinte:função(tabela, = X, j = X, part = \"X\"), onde:\n‘função’ pode ser uma das das muitas funções diferentes, tais como width() para determinar largura de colunas, bg() para definir cores plano de fundo, align() para ajustar o alinhamento texto centro/direita/esquerda, e assim por diante.\ntabela = é o nome seu conjunto de dados, embora não precise estar explícita, se sua data frame estiver escadeada com um pipe (%>%) à função.\npart = se refere em qual parte da tabela função deverá ser aplicada. Por exemplo, “cabeçalho”, “corpo” ou “todos”, (“header”, “body” ou “”).\n= especifica linha (row) para aplicar função, onde ‘X’ é o número da linha. Se há linhas múltiplas, por exemplo, da primeira terceira linha, pode especificar: = c(1:3). Observe que se o corpo estiver selecionado (‘body’), primeira linha começa ser contada abaixo cabeçalho.\n`j = ` especifica coluna qual aplicar função, onde 'x' é o número ou nome das colunas. Se houver colunas multiplas, por exemplo, da quinta e à sexta colunas, pode-se especificar: `j = c(5,6)`. \n‘função’ pode ser uma das das muitas funções diferentes, tais como width() para determinar largura de colunas, bg() para definir cores plano de fundo, align() para ajustar o alinhamento texto centro/direita/esquerda, e assim por diante.tabela = é o nome seu conjunto de dados, embora não precise estar explícita, se sua data frame estiver escadeada com um pipe (%>%) à função.part = se refere em qual parte da tabela função deverá ser aplicada. Por exemplo, “cabeçalho”, “corpo” ou “todos”, (“header”, “body” ou “”).= especifica linha (row) para aplicar função, onde ‘X’ é o número da linha. Se há linhas múltiplas, por exemplo, da primeira terceira linha, pode especificar: = c(1:3). Observe que se o corpo estiver selecionado (‘body’), primeira linha começa ser contada abaixo cabeçalho.`j = ` especifica coluna qual aplicar função, onde 'x' é o número ou nome das colunas. Se houver colunas multiplas, por exemplo, da quinta e à sexta colunas, pode-se especificar: `j = c(5,6)`. Você pode encontrar lista completa das funções de formatação comando flextable clique aqui ou revisar documentação inserindo ?flextable.","code":"\nmy_table <- flextable(table) \nmy_table`j = ` especifica a coluna a qual aplicar função, onde 'x' é o número ou nome das colunas. Se houver colunas multiplas, por exemplo, da quinta e à sexta colunas, pode-se especificar: `j = c(5,6)`. "},{"path":"tables-presentation.html","id":"largura-das-colunas","chapter":"27 Tabelas para apresentação","heading":"Largura das colunas","text":"Nós podemos usar função autofit(), para expandir tabela para que cada célula tenha somente uma linha de texto. função qflextable() é uma abreviação mais simples para flextable() autofit().hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22No entanto, nem sempre isto poderá ser apropriado, principalmente se houver valores muito longos dentro das células, o que significa que tabela pode não ter o tamanho da página.Por isso, podemos especificar larguras com função width (). Isto pode ser feito arredondando um pouco para saber qual valor de largura inserir. exemplo abaixo, especificamos larguras diferentes para cada coluna 1, coluna 2 e colunas 4 8.hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nmy_table %>% autofit()\nmy_table <- my_table %>% \n  width(j=1, width = 2.7) %>% \n  width(j=2, width = 1.5) %>% \n  width(j=c(4,5,7,8), width = 1)\n\nmy_table"},{"path":"tables-presentation.html","id":"cabeçalhostítulos-das-colunas","chapter":"27 Tabelas para apresentação","heading":"Cabeçalhos/Títulos das colunas","text":"Queremos cabeçalhos mais simples para facilitar interpretação conteúdo das tabelas.Para esta tabela, queremos acrescentar uma segunda camada cabeçalho para que colunas que cobrem os mesmos subgrupos possam ser agrupadas. Nós fazemos isto usando função add_header_row() com top = TRUE. Nós colocamos o novo nome de cada coluna para valores usando o comando values =, e para deixar colunas com valores vazios use \"\" que sabemos que iremos mesclar mais tarde.Nós também podemos renomear os nomes cabeçalho em um segundo nível de cabeçalho usando um comando separado set_header_labels().Finalmente, para “combinar” certos cabeçalhos das colunas cabeçalho superior, utilizamos o comando merge_at() para mesclar os cabeçalhos da coluna na linha cabeçalho superior.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nmy_table <- my_table %>% \n  \n  add_header_row(\n    top = TRUE,                # Novo cabeçalho posicionado acima da linha do cabeçalho existente\n    values = c(\"Hospital\",     # Valores dos cabeçalhos para cada coluna abaixo\n               \"Total de casos com desfecho conhecido\", \n               \"Recuperado\",    # este será o nome desta coluna e das duas seguintes \n               \"\",\n               \"\",\n               \"Óbitos\",         # este será o nome desta coluna e das duas seguintes \n               \"\",             # Deixar em branco, essa coluna sera mesclada com a coluna óbitos \n               \"\")) %>% \n    \n  set_header_labels(         # Renomear as colunas na linha original do cabeçalho\n   \n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% de casos\",\n      ct_value_Recover = \"Mediana dos valores CT\",\n      N_Death = \"Total\",\n      Pct_Death = \"% de casos\",\n      ct_value_Death = \"Mediana dos valores C\")  %>% \n  \n  merge_at(i = 1, j = 3:5, part = \"header\") %>%   # Mesclar horizontalmente colunas 3 a 5 na nova linha do cabeçalho\n  merge_at(i = 1, j = 6:8, part = \"header\")       # Mesclar horizontalmente colunas 6 a 8 na nova linha do cabeçalho\n\nmy_table  # visualizar"},{"path":"tables-presentation.html","id":"bordas-e-plano-de-fundo","chapter":"27 Tabelas para apresentação","heading":"Bordas e plano de fundo","text":"Você pode ajustar bordas, linhas internas, entre outros, com várias funções comando flextable. Freqüentemente, é mais fácil começar removendo todas bordas existentes com border_remove().Depois, você pode aplicar os temas de borda padrão com funções theme_box(), theme_booktabs(), ou theme_alafoli().Linhas verticais e horizontais poderão ser adicionadas com uma variedade de funções. Os comandos hline() e vline() , adicionam linhas uma linha ou coluna especificada, respectivamente. Dentro de cada uma, você deve especificar part = como “” (tudo), “body” (corpo da tabela), ou “header” (cabeçalho). Para linhas verticais, especificar coluna para j =, e para linhas horizontais, linha para =. Outras funções como vline_right(), vline_left(), hline_top(), e hline_bottom() adicionam linhas apenas na parte externa da tabela.Em todas estas funções, o estilo atual para linha deve ser especificado para border = e deve ser saída de um comando separado utilizando função fp_border() pacote officer. Esta função vai ajudá-lo definir largura e cor da linha. Você poderá definir isto acima dos comandos da tabela, conforme apresentado script abaixo.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\n# definir estilo pa linha da borda\nborder_style = officer::fp_border(color=\"black\", width=1)\n\n# adicionar linhas de bordas na tabela\nmy_table <- my_table %>% \n\n  # Remover todas as bordas existentes\n  border_remove() %>%  \n  \n  # adicionar linhas por meio de configurações de temas pré-determinados\n  theme_booktabs() %>% \n  \n  # adcionar linhas verticais para separar seção de Recuperados e Óbitos\n  vline(part = \"all\", j = 2, border = border_style) %>%   # na coluna 2 \n  vline(part = \"all\", j = 5, border = border_style)       # na coluna 5\n\nmy_table"},{"path":"tables-presentation.html","id":"fonte-e-alinhamento","chapter":"27 Tabelas para apresentação","heading":"Fonte e Alinhamento","text":"Alinhamos todas colunas ao centro, em paralelo coluna mais à esquerda com os nomes dos hospitais, utilizando função align() de flextable**.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22Ademais, podemos aumentar o tamanho da fonte de cabeçalho e alterá-la para negrito. Também podemos alterar linha total para negrito.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22Podemos assegurar que colunas de proporção exibam somente uma casa decimal utilizando função colformat_num(). Observe que isto também poderia ter sido feito na fase de gerenciamento de dados com função round().HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nmy_table <- my_table %>% \n   flextable::align(align = \"center\", j = c(2:8), part = \"all\") \nmy_table\nmy_table <-  my_table %>%  \n  fontsize(i = 1, size = 12, part = \"header\") %>%   # ajustar o tamanho da fonte do cabeçalho\n  bold(i = 1, bold = TRUE, part = \"header\") %>%     # colocar o cabeçalho em negrito\n  bold(i = 7, bold = TRUE, part = \"body\")           # ajustar a linha de totais para negrito\n\nmy_table\nmy_table <- colformat_num(my_table, j = c(4,7), digits = 1)\nmy_table"},{"path":"tables-presentation.html","id":"células-mescladas","chapter":"27 Tabelas para apresentação","heading":"Células Mescladas","text":"Da mesma forma que mesclamos células horizontalmente na linha de cabeçalho, também podemos mesclar células verticalmente utilizando merge_at() e especificando linhas () e coluna (j). Aqui mesclamos os valores “Hospital” e “Total de casos com desfecho conhecido” verticalmente para lhes dar mais espaço.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nmy_table <- my_table %>% \n  merge_at(i = 1:2, j = 1, part = \"header\") %>% \n  merge_at(i = 1:2, j = 2, part = \"header\")\n\nmy_table"},{"path":"tables-presentation.html","id":"cor-do-plano-de-fundo","chapter":"27 Tabelas para apresentação","heading":"Cor do plano de fundo","text":"Para distinguir o conteúdo dos cabeçalhos da tabela, podemos acrescentar uma formatação adicional. Por exemplo, mudar cor plano de fundo. Neste exemplo, alteramos o corpo da tabela para cinza.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nmy_table <- my_table %>% \n    bg(part = \"body\", bg = \"gray95\")  \n\nmy_table "},{"path":"tables-presentation.html","id":"formatação-condicional","chapter":"27 Tabelas para apresentação","heading":"27.3 Formatação condicional","text":"Podemos destacar todos os valores em uma coluna que atendam uma determinada regra, por exemplo, onde mais de 55% dos casos morreram. Simplesmente insira os critérios argumento = ou j =, precedido por um til ~. Referencie aos nomes da coluna como são data frame, não aos valores cabeçalho que criou para exibição.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22Ou podemos destacar linha inteira que cumpra critério determinado, tais como um hospital de interesse. Para fazer isto, removeremos especificação da coluna (j) para que os critérios sejam aplicados todas colunas.HospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nmy_table %>% \n  bg(j = 7, i = ~ Pct_Death >= 55, part = \"body\", bg = \"red\") \nmy_table %>% \n  bg(., i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") "},{"path":"tables-presentation.html","id":"tbl_pres_all","chapter":"27 Tabelas para apresentação","heading":"27.4 Todos os comandos juntos","text":"Abaixo apresentamos todos os comandos abordados nesta seção:HospitalTotal de casos com desfecho conhecidoRecuperadosÓbitoTotal% de casosMediana de valores CTTotal% casesMediana de valores CTSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22","code":"\nborder_style = officer::fp_border(color=\"black\", width=1)\n\npacman::p_load(\n  rio,            # importar/exportar\n  here,           # caminho do arquivo\n  flextable,      # fazer tabelas HTML \n  officer,        # Funções auxiliares para tabelas\n  tidyverse)      # visualização, resumo e gerenciamento dos dados\n\ntable <- linelist %>% \n  # filtro\n  ########\n  #filtro(!is.na(outcome) & hospital != \"Missing\") %>%  # Remove casos com desfecho ou hospital vazios\n  \n  # Obter valores resumidos por grupo hospital-resultado\n  ###############################################\n  group_by(hospital, outcome) %>%                      # Dados por grupo\n  summarise(                                           # Criar novas colunas resumidas de indicadores de interesse\n    N = n(),                                           # Numero de linhas por grupo hospital-resultado     \n    ct_value = median(ct_blood, na.rm=T)) %>%          # mediana do valor de CT por grupo\n  \n  # Adicionando Totais\n  ############\n  bind_rows(                                           # Vincular as tabelas prévias com esta mini-tabela de totais\n    linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Agrupar somente pelo resultado, não pelo hospital    \n      summarise(\n        N = n(),                                       # Número de linhas para conjunto de dados total     \n        ct_value = median(ct_blood, na.rm=T))) %>%     # Mediana de CT para conjunto de dados total  \n  \n  # Dados dinâmicos \n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Colunas longas e largas\n    values_from = c(ct_value, N),                       # novos valores de CT e colunas de contagem\n    names_from = outcome) %>%                           # novos nomes da colunas são de resultados\n  mutate(                                              # Adicionar novas colunas\n    N_Known = N_Death + N_Recover,                               # número com resultados conhecidos\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # porcentagem de casos de óbitos (com 1 casa decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # porcentagem dos reuperados (com 1 casa decimal)\n  select(                                              # Reordenar as colunas\n    hospital, N_Known,                                   # Colunas introdutórias\n    N_Recover, Pct_Recover, ct_value_Recover,            # Coluna dos recuperados\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Coluna de óbitos\n  arrange(N_Known) %>%                                 # Organizar linhas da mais alta para mais baixa (linha superior a linha Total)\n\n  # formatação\n  ############\n  flextable() %>% \n  add_header_row(\n    top = TRUE,                # Novo cabeçalho colocado acima da linha do cabeçalho existente\n    values = c(\"Hospital\",     # Valores dos cabeçalhos para cada coluna abaixo\n               \"Total de casos com desfecho conhecido\", \n               \"Recuperados\",    \n               \"\",\n               \"\",\n               \"Óbito\",        \n               \"\",             # Deixar em branco, essa coluna sera mesclada com a coluna de óbito\n               \"\")) %>% \n    set_header_labels(         # Renomear as colunas na linha original do cabeçalho\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% de casos\",\n      ct_value_Recover = \"Mediana de valores CT\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Mediana de valores CT\")  %>% \n  merge_at(i = 1, j = 3:5, part = \"header\") %>% # Mesclar horizontalmente colunas 3 a 5 in nova linha do cabeçalho\n  merge_at(i = 1, j = 6:8, part = \"header\") %>%  \n  border_remove() %>%  \n  theme_booktabs() %>% \n  vline(part = \"all\", j = 2, border = border_style) %>%   # na coluna 2 \n  vline(part = \"all\", j = 5, border = border_style) %>%   # na coluna 5\n  merge_at(i = 1:2, j = 1, part = \"header\") %>% \n  merge_at(i = 1:2, j = 2, part = \"header\") %>% \n  width(j=1, width = 2.7) %>% \n  width(j=2, width = 1.5) %>% \n  width(j=c(4,5,7,8), width = 1) %>% \n  flextable::align(., align = \"center\", j = c(2:8), part = \"all\") %>% \n  bg(., part = \"body\", bg = \"gray95\")  %>% \n  #bg(., j=c(1:8), i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") %>% \n  bg(j = 7, i = ~ Pct_Death >= 55, part = \"body\", bg = \"red\") %>% \n  colformat_num(., j = c(4,7), digits = 1) %>%\n  bold(i = 1, bold = TRUE, part = \"header\") %>% \n  bold(i = 7, bold = TRUE, part = \"body\")## `summarise()` has grouped output by 'hospital'. You can override using the `.groups`\n## argument.\ntable"},{"path":"tables-presentation.html","id":"como-salvar-sua-tabela","chapter":"27 Tabelas para apresentação","heading":"27.5 Como salvar sua tabela","text":"Há diferentes caminhos para que sua tabela seja integrada em uma saída (output).","code":""},{"path":"tables-presentation.html","id":"como-salvar-uma-tabela-única","chapter":"27 Tabelas para apresentação","heading":"Como salvar uma tabela única","text":"Você pode exportar tabelas como arquivos para Word, PowerPoint ou HTML ou como arquivo de imagem (PNG). Para fazer isto, você pode usar uma das seguintes funções:save_as_docx()save_as_pptx()save_as_image()save_as_html()Por exemplo, abaixo salvamos nossa tabela como um documento word. Observe sintaxe primeiro argumento - você pode apenas fornecer o nome seu objeto flextable, por exemplo my_table, ou poderá dar um “nome” como apresentado seguir (o nome é “table”). Se nome, este aparecerá como o título da tabela Word. Também demonstramos comando para salvar como imagem PNG.Observe que os pacotes webshot webshot2 são necessários para “flextable” como uma imagem. imagens poderá sair com fundo transparente.Se quiser ver uma versão ‘ao vivo’ da saída flexível formato de documento pretendido, utilize print() e especifique uma das seguintes opções abaixo para preview =. O documento será aberto uma “pop-” em um programa de software especificado seu computador, mas não será salvo. Isto pode ser útil para verificar se tabela cabe numa página/slide ou para que possa copiar rapidamente dentro de outro documento. Você pode, por exemplo, utilizar esse método com o argumento preview = definido para “pptx” ou “docx” como mostrado abaixo.","code":"\n# Editar a 'my table' como necessário para adicionar o título na tabela\n.  \nsave_as_docx(\"my table\" = my_table, path = \"file.docx\")\n\nsave_as_image(my_table, path = \"file.png\")\nprint(my_table, preview = \"docx\") # Exemplo documento do Word\nprint(my_table, preview = \"pptx\") # Exemplo Powerpoint "},{"path":"tables-presentation.html","id":"imprimir-a-tabela-no-r-markdown","chapter":"27 Tabelas para apresentação","heading":"Imprimir a tabela no R markdown","text":"Esta tabela poderá ser integrada em um documento automatizado, uma saída R markdown, se o objeto tabela chamado dentro chunk R markdown. Isto significa que tabela poderá ser atualizada como parte de um relatório em que os dados podem ser alterados, e os números podem ser atualizados.Veja detalhes na seção Relatórios com R Markdown deste manual.","code":""},{"path":"tables-presentation.html","id":"recursoa","chapter":"27 Tabelas para apresentação","heading":"27.6 Recursoa","text":"O manual completo flextable se encontra aquiO site Github pode ser encontrado aquiO manual com todas funções usadas pacote flextable poderá ser encontrada aquiUma galeria com bons modelos de tabela flextable com códigos pode ser acessada aqui","code":""},{"path":"ggplot-basics.html","id":"ggplot-basics","chapter":"28 O básico do ggplot","heading":"28 O básico do ggplot","text":"O ggplot2 é o pacote R mais popular de visualização de dados. Sua função ggplot() está centro deste pacote, e toda esta abordagem é conhecida coloquialmente como “ggplot” com imagens resultantes às vezes carinhosamente chamadas de “ggplots”. O “gg” nestes nomes reflete “gramática de gráficos” utilizados para construir figuras. O ggplot2 beneficia-se de uma grande variedade de pacotes R suplementares que melhoram ainda mais sua funcionalidade.sintaxe é significativamente diferente dos gráficos gerados pelo R base*, e tem uma curva de aprendizado associada ela. utilização ggplot2 geralmente exige que o usuário formate seus dados de uma forma altamente compatível com o “tidyverse”, o que em última análise torna utilização conjunta destes pacotes muito eficaz.Nesta página cobriremos os fundamentos da criação de gráficos com o pacote ggplot2. Veja página Dicas para o ggplot para sugestões e técnicas avançadas para tornar seus gráficos realmente bonitos.Há vários tutoriais completos de ggplot2 disponíveis na seção de recursos. Você também pode baixar esta cheat sheet (colinha) de visualização de dados site RStudio. Se você quiser inspiração para formas de visualizar criativamente seus dados, sugerimos que você revise sites como o galeria de gráficos R e Data--viz.","code":""},{"path":"ggplot-basics.html","id":"preparação-18","chapter":"28 O básico do ggplot","heading":"28.1 Preparação","text":"","code":""},{"path":"ggplot-basics.html","id":"carregar-pacotes-6","chapter":"28 O básico do ggplot","heading":"Carregar pacotes","text":"Este trecho de código mostra o carregamento dos pacotes necessários para análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para utilização. Você também pode carregar os pacotes instalados com library() R base*. Veja página em Introdução ao R para mais informações sobre os pacotes R.","code":"\npacman::p_load(\n  tidyverse,      # inclui ggplot2 e outras ferramentas de manipular dados\n  ggforce,        # extensão ggplot\n  rio,            # importar/exportar\n  here,           # localizador de arquivos\n  stringr         # trabalhando com caracteres\n)"},{"path":"ggplot-basics.html","id":"importar-datos-1","chapter":"28 O básico do ggplot","heading":"Importar datos","text":"Importamos o conjunto de dados de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar,  clique para baixar linelist “limpa”  (como arquivo .rds). Importe seus dados com função import() pacote rio (ele aceita muitos tipos de arquivos como .xlsx, .rds, .csv - veja página Importar exportar para detalhes).primeiras 50 linhas da linelist são exibidas abaixo. Vamos nos concentrar nas variáveis contínuas age, wt_kg (peso em quilos), ct_blood (valores de CT) e days_onset_hosp (diferença entre data de início e hospitalização).","code":"\nlinelist <- rio::import(\"linelist_cleaned.rds\")"},{"path":"ggplot-basics.html","id":"limpeza-geral","chapter":"28 O básico do ggplot","heading":"Limpeza geral","text":"Ao preparar os dados para traçar o gráfico, é melhor fazer com que os dados adiram aos padrões de dados “arrumados” (inglês tidy) na medida possível. Como conseguir isto é explicado com mais detalhes nas páginas de gerenciamento de dados deste manual, tais como Dados de limpeza e principais funções.Algumas maneiras simples de prepararmos nossos dados para torná-los melhores para visualização podem incluir tornar o conteúdo dos dados melhor para exibição - o que não necessariamente equivale melhor para manipulação de dados. Por exemplo:Substituir os valores NA em uma coluna tipo caracteres pela string “Desconhecido”.Substituir os valores NA em uma coluna tipo caracteres pela string “Desconhecido”.Considerar converter coluna para classe fator para que seus valores tenham níveis em uma ordem específica.Considerar converter coluna para classe fator para que seus valores tenham níveis em uma ordem específica.Limpar algumas colunas para que os valores adequados à manipulações (“data friendly”), tais como valores que possuam sublinhado (“underline”), por exemplo, sejam alterados para texto normal ou padrão título (ver Caracteres e strings)Limpar algumas colunas para que os valores adequados à manipulações (“data friendly”), tais como valores que possuam sublinhado (“underline”), por exemplo, sejam alterados para texto normal ou padrão título (ver Caracteres e strings)Aqui estão alguns exemplos disso em ação.","code":"\n#faça uma versão visualizaçãi das colunas com nomes mais amigáveis \n\nlinelist <- linelist %>%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # m para Male\n                            gender == \"f\" ~ \"Female\",      # f para Femimino,\n                            is.na(gender) ~ \"Desconhecido\"),    # NA para Desconhecido\n    \n    outcome_disp = replace_na(outcome, \"Desconhecido\")          # substituir na por \"Desconhecido\" \n  )"},{"path":"ggplot-basics.html","id":"pivoteamento-para-mais-longo","chapter":"28 O básico do ggplot","heading":"Pivoteamento para “mais longo”","text":"Por uma questão de estrutura de dados, para ggplot2 muitas vezes também queremos pivotar nossos dados para formatos mais longos. Leia mais sobre isto na página em Pivoteando dados.Por exemplo, digamos que queremos fazer um gráfico de dados que estão em um formato “largo”, como para cada caso na linelist e seus sintomas. Abaixo criamos uma mini-linelist chamada symptoms_data que contém apenas colunas case_id e sintomas.Veja como são primeiras 50 linhas desta mini-linelist - veja como elas são formatadas de forma “larga” com cada sintoma como uma coluna:Se quisermos traçar um gráfico com o número de casos com sintomas específicos, estamos limitados pelo fato de que cada sintoma é uma coluna específica. Entretanto, podemos pivotar colunas de sintomas para um formato mais longo como este:Aqui estão primeiras 50 linhas. Observe que o caso tem 5 fileiras - uma para cada sintoma possível. novas colunas nome_sintoma e sintoma_esta_presente são o resultado pivoteamento. Note que este formato pode não ser muito útil para outras operações, mas é útil para criação gráfico.","code":"\nsymptoms_data <- linelist %>% \n  rename(tosse=cough,\n         febre=fever, \n         vômito=vomit,\n         dores=aches,\n         calafrio=chills) %>%  #traduzindo\n  select(c(case_id, febre, calafrio, tosse, dores, vômito)) \nsymptoms_data_long <- symptoms_data %>%    # comece com a \"mini\" linelist chamada symptoms_data\n  \n  pivot_longer(\n    cols = -case_id,                       # pivote todas as colunas exceto case_id \n    names_to = \"nome_sintoma\",             # dê o nome para a nova coluna que contém os sintomas \n    values_to = \"sintoma_esta_presente\") %>%  # dê o nome para a coluna que diz se o sintoma está presente \n\n  \n  mutate(sintoma_esta_presente = replace_na(sintoma_esta_presente, \"desconhecido\")) # converte NA para \"desconhecido\""},{"path":"ggplot-basics.html","id":"básico-do-ggplot","chapter":"28 O básico do ggplot","heading":"28.2 Básico do ggplot","text":"“Gramática dos gráficos” - ggplot2A criação de gráficos com o ggplot2 é baseada na “adição” de camadas de gráficos e de design uns sobre os outros, com cada comando adicionado aos anteriores com um símbolo de mais (+). O resultado é um objeto tipo gráfico com várias camadas que pode ser salvo, modificado, impresso, exportado, etc.Os objetos de ggplot podem ser altamente complexos, mas ordem básica das camadas geralmente será assim:Comece com o comando de base ggplot() - isto “abre” o ggplot e permite que funções subseqüentes sejam adicionadas com +. Tipicamente, o conjunto de dados também é especificado neste comandoAdicionar camadas “geom” - estas funções visualizam os dados como geometrias (formas), por exemplo, como um gráfico de barras, gráfico de linhas, gráfico de dispersão, histograma (ou uma combinação!). Todas estas funções começam com geom_ como um prefixo.Adicione elementos de desenho ao gráfico, como etiquetas de eixos, título, fontes, tamanhos, esquemas de cores, legendas ou rotação de eixos.Um exemplo simples de código esqueleto é o seguinte. Vamos explicar cada componente nas seções abaixo.","code":"\n# plote os dados das colunas do objeto my_data como pontos vermelhos\n\n\nggplot(data = my_data)+                   # use a base de dados \"my_data\"\n  geom_point(                             # adicione uma camada de pontos \n\n    mapping = aes(x = col1, y = col2),    # mapeie as colunas para os eixos\n    color = \"red\")+                       # outras especificações para o geom\n  labs()+                                 # aqui você pode adicionar títulos, rótulos dos eixos, etc. \n  theme()                                 # aqui você pode ajustar a cor, fonte, tamanho, de elementos que não são orindos dos dados (eixo, título, etc.) "},{"path":"ggplot-basics.html","id":"ggplot","chapter":"28 O básico do ggplot","heading":"28.3 ggplot()","text":"O comando de abertura de qualquer gráfico ggplot2 é ggplot(). Este comando simplesmente cria uma tela em branco sobre qual se pode adicionar camadas. Ele “abre” o caminho para que outras camadas sejam adicionadas com um símbolo +.Normalmente, o comando ggplot() inclui o dados = argumento para o gráfico. Isto define o conjunto de dados padrão ser utilizado para camadas subsequentes gráfico.Este comando terminará com um + após seus parênteses de fechamento. Isto deixa o comando “aberto”. O ggplot só será executado/aparecerá quando o comando completo incluir uma camada final sem um + final.","code":"\n# Isso irá criar um gráfco que é um painel em branco \nggplot(data = linelist)"},{"path":"ggplot-basics.html","id":"geoms","chapter":"28 O básico do ggplot","heading":"28.4 Geoms","text":"Uma tela em branco certamente não é suficiente - precisamos criar geometrias (formas) partir de nossos dados (por exemplo, gráficos de barra, histogramas, gráficos de dispersão, gráficos de caixa).Isto é feito adicionando camadas “geoms” ao comando inicial ggplot(). Há muitas funções ggplot2 que criam “geoms”. Cada uma destas funções começa com “geom_”, portanto, vamos nos referir elas genericamente como geom_XXXX(). Há mais de 40 geoms em ggplot2 e muitos outros criados por fãs e contribuidores. Veja-os na galeria ggplot2. Alguns geoms comuns estão listados abaixo:Histogramas - geom_histogram()Gráficos de barras - geom_bar() ou geom_col() (veja “Bar plot” seção)Diagrama de caixas - geom_boxplot()Pontos (por exemplo, gráficos de dispersão) - geom_point()Gráficos de linhas - geom_line() ou geom_path()Linhas de tendência - geom_smooth()Em um gráfico você pode exibir um ou vários geoms. Cada um é adicionado aos comandos anteriores ggplot2 com um +, e eles são plotados sequencialmente de forma que os geoms posteriores sejam plotados sobre os anteriores.","code":""},{"path":"ggplot-basics.html","id":"ggplot_basics_mapping","chapter":"28 O básico do ggplot","heading":"28.5 Mapeando dados ao gráfico","text":"maioria das “funções geom” devem ser informadas que usar para criar suas formas - portanto, você deve dizer-lhes como devem mapear (atribuir) colunas em seus dados aos componentes gráfico como os eixos, cores das formas, tamanhos das formas, etc. Para maioria dos geoms, os componentes essenciais que devem ser mapeados para colunas nos dados são o eixo x, e (se necessário) o eixo y.Este “mapeamento” ocorre com o argumento mapping =. Os mapeamentos que você fornece ao mapping devem ser envolvidos na função aes(), assim você escreveria algo como mapping = aes(x = col1, y = col2), como mostrado abaixo.Abaixo, comando ggplot(), os dados são definidos como o caso linelist. argumento mapping = aes() coluna age é mapeada para o eixo x, e coluna wt_kg é mapeada para o eixo y.Depois de um +, os comandos de plotagem continuam. Uma forma é criada com função “geom” geom_point(). Este geom herda os mapeamentos comando ggplot() anterior - ele conhece atribuições eixo-coluna e procede para visualizar essas relações como pontos na área gráfico.Como outro exemplo, os seguintes comandos utilizam os mesmos dados, um mapeamento um pouco diferente e um geom diferente. função geom_histogram() requer apenas uma coluna mapeada para o eixo x, pois contagens eixo y são geradas automaticamente.","code":"\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\n# o nome dos eixos fica automaticamente com o nome da variável na base\n# que está em inglês. É possível traduzir na base ou usando a camada\n# labs() para escrever o nome dos eixos como se quer\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()"},{"path":"ggplot-basics.html","id":"as-estéticas-do-gráfico","chapter":"28 O básico do ggplot","heading":"As estéticas do gráfico","text":"Na terminologia ggplot, uma “estética” gráfico tem um significado específico. Ela se refere uma propriedade visual de dados plotados. Note que “estético” aqui se refere aos dados que estão sendo plotados em geometrias/formas - não ao display ao redor, como títulos, etiquetas de eixos, cor de fundo, que você pode associar com palavra “estética”. ggplot, esses detalhes são chamados de “themes” (temas) e são ajustados dentro de um comando theme() (veja esta seção).Portanto, os objetos aesthetics podem ser cores, tamanhos, transparências, posição, etc. dos dados traçados. Nem todos os geoms terão mesmas opções de aesthetics, mas muitos podem ser usados pela maioria dos geoms. Aqui estão alguns exemplos:shape = Mostra um ponto de geom_point() como um círculo, estrela, triângulo…shape = Mostra um ponto de geom_point() como um círculo, estrela, triângulo…fill = cor de preenchimento (ex. de uma barra ou boxplot)fill = cor de preenchimento (ex. de uma barra ou boxplot)color = linha exterior de uma barra ou boxplot, ou cor ponto se usar o geom_point()color = linha exterior de uma barra ou boxplot, ou cor ponto se usar o geom_point()size = tamanho (ex. grossura da linha, tamanho ponto)size = tamanho (ex. grossura da linha, tamanho ponto)alpha = Transparencia (1 = opaco, 0 = invisível)alpha = Transparencia (1 = opaco, 0 = invisível)binwidth = Largura das classes histogramabinwidth = Largura das classes histogramawidth = Largura das barras gráfico de barraswidth = Largura das barras gráfico de barraslinetype = Tipo de linha (ex. sólida, tracejada, pontilhada)linetype = Tipo de linha (ex. sólida, tracejada, pontilhada)esses objetos gráfico podem ser atribuídos valores de duas maneiras:Atribuindo um valor estático (por exemplo, color = \"blue\") ser aplicado em todas observações plotadasAtribuído uma coluna de dados (por exemplo, “color = hospital”) de tal forma que exibição de cada observação depende de seu valor nessa coluna","code":""},{"path":"ggplot-basics.html","id":"configurar-para-um-valor-estático","chapter":"28 O básico do ggplot","heading":"Configurar para um valor estático","text":"Se você quiser que estética objeto gráfico seja estática, ou seja - para ser mesma para cada observação nos dados, você escreve sua atribuição dentro geom desejado mas fora de qualquer mapping = aes(). Essas atribuições poderiam ser size = 1 ou color = \"blue\". Aqui estão dois exemplos:primeiro exemplo, o mapping = aes() está comando ggplot() e os eixos são mapeados para colunas de idade e peso nos dados. estética gráfico color =, size =, e alpha = (transparência) são atribuídos valores estáticos. Para maior clareza, isto é feito na função geom_point(), pois você pode adicionar outras geometrias posteriormente que levariam valores diferentes.primeiro exemplo, o mapping = aes() está comando ggplot() e os eixos são mapeados para colunas de idade e peso nos dados. estética gráfico color =, size =, e alpha = (transparência) são atribuídos valores estáticos. Para maior clareza, isto é feito na função geom_point(), pois você pode adicionar outras geometrias posteriormente que levariam valores diferentes.segundo exemplo, o histograma requer apenas o eixo x mapeado para uma coluna. O histograma binwidth =, color =, fill = (cor de preenchimento), e alpha = são novamente definidos dentro geom para valores estáticos.segundo exemplo, o histograma requer apenas o eixo x mapeado para uma coluna. O histograma binwidth =, color =, fill = (cor de preenchimento), e alpha = são novamente definidos dentro geom para valores estáticos.","code":"\n# gráfico de dispersão\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # configurar mapeamento dos dados e eixos \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)   # configurar a estética estática dos pontos\n\n# histograma\nggplot(data = linelist, mapping = aes(x = age))+       # configurar mapeamento dos dados e eixos \n\n  geom_histogram(              # mostra o histograma\n    binwidth = 7,                # largura das classes\n    color = \"red\",               # cor da linha da classe\n    fill = \"blue\",               # cor de preenchimento da barra\n    alpha = 0.1)                 # transparência da barra"},{"path":"ggplot-basics.html","id":"responsivo-a-valores-de-uma-coluna","chapter":"28 O básico do ggplot","heading":"Responsivo a valores de uma coluna","text":"alternativa é mapear os argumentos da estética de um gráfico uma coluna (variável) seus dados. Nesta abordagem, exibição deste aesthetics dependerá valor desta observação naquela coluna dos dados. Se os valores da coluna forem contínuos, escala de exibição (legenda) para aquele aesthetics será contínua. Se os valores da coluna forem discretos, legenda exibirá cada valor e os dados plotados aparecerão “agrupados” de forma distinta (leia mais na seção agrupamento desta página).Para conseguir isso, você mapeia esse aesthetics gráfico para um nome de coluna (não entre aspas). Isto deve ser feito *em uma função mapping = aes() (nota: há vários lugares código que você pode fazer estas atribuições de mapeamento, como discutido abaixo)).Dois exemplos estão abaixo.primeiro exemplo, aesthetics color = (de cada ponto) é mapeada para coluna age - e uma escala de cores apareceu na legenda! Por enquanto, basta observar que escala existe - mostraremos como modificá-la em seções posteriores.segundo exemplo, duas novas aesthetics gráfico também são mapeados para colunas (color = e size =), enquanto aesthetics gráfico shape = e alpha = são mapeados para valores estáticos fora de qualquer função mapping = aes().Nota: Os argumentos referentes aos eixos são sempre atribuídos colunas dos dados (não valores estáticos), e isto é sempre feito dentro de mapping = aes().Torna-se importante acompanhar camadas e aesthetics de seus gráficos à medida que vão ficando mais complexos - por exemplo, gráficos com múltiplos geoms. exemplo abaixo, aesthetic size = é atribuída duas vezes - uma para geom_point() e outra para geom_smooth() - ambas vezes como um valor estático.","code":"\n# gráfico de dispersão\n\nggplot(data = linelist,   # escolha os dados\n       mapping = aes(     # mapeie as aesthetics para coluna de valores\n         x = age,           # mapeie o eixo x para idade (coluna age)       \n\n         y = wt_kg,         # mapeie o eixo y para peso (wt_kg)      \n\n         color = age) # mapeie a cor segundo a idade\n\n       )+     \n  geom_point()         # mostre como pontos\n\n# gráfico de dispersão\nggplot(data = linelist,   # escolha os dados\n       mapping = aes(     # mapeie as aesthetics para coluna de valores\n         x = age,           # mapeie o eixo x para idade (coluna age)    \n\n         y = wt_kg,         # mapeie o eixo y para peso (wt_kg) \n\n         color = age,       # mapeie a cor segundo a idade\n\n         size = age))+      # mapeie o tamanho segundo a idade\n\n  geom_point(             # mostre como pontos\n    shape = \"diamond\",      # pontos como losangos (diamantes)\n    alpha = 0.3)            # transparência do ponto a 30%\nggplot(data = linelist,\n       mapping = aes(           # mapeia a aesthetics para as colunas\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # addiciona pontos para cada linha de dados\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # adiciona uma linha de tendência \n\n    method = \"lm\",              # com um método linear\n    size = 2)                   # tamanho (grossura da linha) de 2"},{"path":"ggplot-basics.html","id":"ggplot_basics_map_loc","chapter":"28 O básico do ggplot","heading":"Onde incluir os atributos de mapeamento","text":"O mapeamento das aesthetics dentro de mapping = aes() pode ser escrito em vários lugares em seus comandos para criar o gráfico, podendo até mesmo ser escrito mais de uma vez. Isto pode ser escrito comando superior ggplot(), e/ou para cada geom individual abaixo. nuances incluem:atribuições de mapeamento feitas primeiro comando ggplot() serão herdadas como padrão em qualquer geom abaixo, da mesma forma como x = e y = são herdadasOutros mapeamentos feitos dentro de um geom se aplicam somente esse geomDa mesma forma, o parâmetro data = (inglês dados) especificado primeiro comando ggplot() será aplicado por padrão qualquer geom abaixo, mas você também poderia especificar dados novos para cada geom (mas isto é mais complicado).Assim, cada um dos seguintes comandos irá criar o mesmo gráfico:","code":"\n# Esses comandos irão criar o mesmo gráfico\n\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))"},{"path":"ggplot-basics.html","id":"ggplotgroups","chapter":"28 O básico do ggplot","heading":"Grupos","text":"Você pode facilmente agrupar os dados e “plotar por grupo”. Na verdade, você já fez isso!Atribua coluna de “agrupamento” à aesthetic apropriada gráfico, dentro de um mapping = aes(). Acima, demonstramos isso utilizando valores contínuos quando atribuímos o ponto size = à coluna age (idade). Entretanto, isto funciona da mesma forma para colunas discretas/categóricas.Por exemplo, se você quiser que os pontos sejam exibidos por gênero, você definiria mapping = aes(color = gender). Uma legenda aparece automaticamente. Esta atribuição pode ser feita dentro comando mapping = aes() ggplot() topo (e ser herdada pelo geom), ou pode ser definida em um mapping = aes() separado dentro geom. Ambas abordagens são mostradas abaixo:Observe que, dependendo geom, será necessário utilizar argumentos diferentes para agrupar os dados. Para geom_point() você provavelmente utilizará color =, shape = ou size =. Enquanto para geom_bar() é mais provável que você utilize fill =. Isto depende apenas geom e tipo de aesthetic gráfico que você deseja usar para refletir os agrupamentos.Para sua informação - forma mais básica de agrupar os dados é utilizando apenas o argumento group = dentro mapping = aes(). Entretanto, isto por si só não mudará cores, o preenchimento ou formas. Tampouco criará uma legenda. entanto, os dados são agrupados, de modo que exibições estatísticas poderão ser afetadas.Para ajustar ordem dos grupos em um gráfico, veja página Dicas para o ggplot ou página em Fatores. Há muitos exemplos de gráficos agrupados nas seções abaixo sobre plotagem de dados contínuos e categóricos.","code":"\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n# Este código alternativo produz o mesmo gráfico \nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)"},{"path":"ggplot-basics.html","id":"ggplot_basics_facet","chapter":"28 O básico do ggplot","heading":"28.6 Facetas / Pequenos-Múltiplos","text":"Facetas, ou “pequenos-múltiplos”, são usadas para dividir uma parcela em uma figura de vários painéis, com um painel (“faceta”) por grupo de dados. O mesmo tipo de gráfico é criado várias vezes, cada um usando um subgrupo mesmo conjunto de dados.O Facetamento (Faceting) é uma funcionalidade que vem com ggplot2, portanto legendas e eixos dos “painéis” de faceta são automaticamente alinhados. Há outros pacotes discutidos na página Dicas para o ggplot que são usados para combinar gráficos completamente diferentes (cowplot e patchwork) em uma única figura.O facetamento é feito com uma das seguintes funções ggplot2:facet_wrap() Para mostrar um painel diferente para cada nível de uma variável única. Um exemplo disso poderia ser mostrar uma curva epidêmica diferente para cada hospital de uma região. facetas são ordenadas alfabeticamente, menos que variável seja um fator com outra ordenação definida.Você pode invocar certas opções para determinar o layout das facetas, por exemplo nrow = 1 ou ncol = 1 para controlar o número de linhas ou colunas dentro das quais facetas estão dispostas.facet_grid() Isto é utilizado quando se deseja trazer uma segunda variável para disposição das facetas. Aqui cada painel de uma “grade” (grid) mostra interseção entre os valores em duas colunas. Por exemplo, curvas epidêmicas para cada combinação hospital-idade com hospitais ao longo topo (colunas) e faixas etárias ao longo dos lados (linhas).“nrow” e “ncol” não são relevantes, pois os subgrupos são apresentados em um gridCada uma destas funções aceita uma sintaxe de fórmula para especificar (s) coluna(s) de faceta(s). Ambas aceitam até duas colunas, uma de cada lado de um til `~’.Para facet_wrap() na maioria das vezes você escreverá apenas uma coluna precedida por um til ~ como facet_wrap(~hospital). Entretanto, você pode escrever duas colunas facet_wrap(outcome ~ hospital) - cada combinação única será exibida em um painel separado, mas não serão dispostas em um grid. Os cabeçalhos mostrarão termos combinados e estes não terão uma lógica específica para colunas vs. linhas. Se você estiver fornecendo apenas uma variável facetada, um ponto . é utilizado como um espaço reservado outro lado da fórmula - veja os exemplos de código.Para facet_wrap() na maioria das vezes você escreverá apenas uma coluna precedida por um til ~ como facet_wrap(~hospital). Entretanto, você pode escrever duas colunas facet_wrap(outcome ~ hospital) - cada combinação única será exibida em um painel separado, mas não serão dispostas em um grid. Os cabeçalhos mostrarão termos combinados e estes não terão uma lógica específica para colunas vs. linhas. Se você estiver fornecendo apenas uma variável facetada, um ponto . é utilizado como um espaço reservado outro lado da fórmula - veja os exemplos de código.Para facet_grid() você também pode especificar uma ou duas colunas para fórmula (grid linhas ~ colunas). Se você quiser especificar apenas uma, você pode colocar um ponto . outro lado til como facet_grid(. ~ hospital) ou facet_grid(hospital ~ .).Para facet_grid() você também pode especificar uma ou duas colunas para fórmula (grid linhas ~ colunas). Se você quiser especificar apenas uma, você pode colocar um ponto . outro lado til como facet_grid(. ~ hospital) ou facet_grid(hospital ~ .).facetas podem rapidamente conter uma quantidade avassaladora de informações - é bom garantir que você não tenha muitos níveis de cada variável que você escolher facetar. Aqui estão alguns exemplos rápidos com o conjunto de dados sobre malária (ver Baixar manual e dados) que consiste em contagens diárias de casos de malária para estabelecimentos, por faixa etária.seguir, importamos e fazemos algumas modificações rápidas para simplificar:primeiras 50 filas dos dados sobre malária estão abaixo. Observe que existe uma coluna malaria_tot, mas também colunas para contagens por faixa etária (estas serão utilizadas segundo exemplo referente ao facet_grid() ).","code":"\n# Esses dados correspondem a contagens diárias de malária, por estabelecimento-dia \nmalaria_data <- import(here(\"data\", \"malaria_facility_count_data.rds\")) %>%  # importar\n  select(-submitted_date, -Province, -newid)                                 # remove colunas desnecessárias"},{"path":"ggplot-basics.html","id":"facet_wrap","chapter":"28 O básico do ggplot","heading":"facet_wrap()","text":"momento, vamos nos concentrar nas colunas malaria_tot e District. Ignore por enquanto colunas de contagem por idade. Vamos traçar curvas epidêmicas com geom_col(), que produz uma coluna para cada dia com altura eixo y sendo especificada com o valor obtido na coluna malaria_tot (os dados já são contagens diárias, então utilizamos geom_col() - veja seção “Bar plot” abaixo).Quando adicionamos o comando facet_wrap(), especificamos um til e depois coluna para facetar sobre (neste caso, District). Você pode colocar outra coluna lado esquerdo til - isto criará uma faceta para cada combinação - mas recomendamos que você faça isto com facet_grid() em seu lugar. Neste caso de uso, uma faceta é criada para cada valor único de District.","code":"\n# Um gráfico com facetas por distrito \n\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plote a contagem como colunas \n  theme_minimal()+                              # simplifique os paineis de fundo\n  labs(                                         # aficione rótulos, títulos, etc. \n    x = \"Data dos registros\",\n    y = \"Casos de malária\",\n    title = \"Casos de malária por distrito\") +\n  facet_wrap(~District)                       # As facetas são criadas"},{"path":"ggplot-basics.html","id":"facet_grid","chapter":"28 O básico do ggplot","heading":"facet_grid()","text":"Podemos utilizar uma abordagem facet_grid() para cruzar duas variáveis. Digamos que queremos cruzar o Distrito (District) e idade (age). Bem, precisamos fazer algumas transformações de dados nas colunas de idade para obter esses dados formato “longo”, preferido pelo ggplot. Todos os grupos etários têm suas próprias colunas - queremo-los em uma única coluna chamada faixa_etaria e outra chamada num_casos. Consulte página em Pivoteamento de dados para obter mais informações sobre este processo.Agora primeiras 50 linhas dos dados aparecem assim:Quando você passa duas variáveis para facet_grid(), o mais fácil é utilizar notação de fórmula (por exemplo x ~ y) onde x corresponde às linhas e y às colunas. Aqui está o gráfico, utilizando facet_grid() para mostrar os gráficos para cada combinação das colunas faixa_etaria e District.","code":"\nmalaria_age <- malaria_data %>%\n  select(-malaria_tot) %>% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # escolha as colunas que quer pivotear para o formato longo\n    names_to = \"faixa_etaria\",      # column names become age group\n    values_to = \"num_casos\"      # values to a single column (num_casos)\n  ) %>%\n  mutate(\n    faixa_etaria = str_replace(faixa_etaria, \"malaria_rdt_\", \"\"),\n    faixa_etaria = forcats::fct_relevel(faixa_etaria, \"5-14\", after = 1))\nggplot(malaria_age, aes(x = data_date, y = num_casos)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Data dos registros\",\n    y = \"Casos de malária\",\n    title = \"Casos de malária por distrito e faixa etária\"\n  ) +\n  facet_grid(District ~ faixa_etaria)"},{"path":"ggplot-basics.html","id":"eixos-livres-ou-fixos","chapter":"28 O básico do ggplot","heading":"Eixos livres ou fixos","text":"escalas de eixos exibidas quando realizamos o facetamento é por padrão mesma (ou seja, fixa) em todas facetas. Isto é útil para comparação cruzada, mas nem sempre apropriado.Ao utilizar facet_wrap() ou facet_grid(), podemos adicionar scales = \"free_y\" para “liberar” os eixos y dos painéis para escalar adequadamente seu subconjunto de dados. Isto é particularmente útil se contagens reais forem pequenas para uma das subcategorias e se tendências forem difíceis de se observar de outra forma. Em vez de “free_y” também podemos escrever “free_x” para fazer o mesmo para o eixo x (por exemplo, para datas) ou apenas “free” para ambos os eixos. Note que em facet_grid, escala y será mesma para facetas na mesma linha, e escala x será mesma para facetas na mesma coluna.Ao utilizar somente facet_grid, podemos adicionar space = \"free_y\" ou space = \"free_x\" para que altura ou largura real da faceta seja ponderada para os valores da figura dentro. Isto só funciona se scales = \"free\" (y ou x) já estiver aplicado.","code":"\n# Eixo y livre\n\n\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plote os dados de contagem como colunas\n  theme_minimal()+                              # simplifique os painel de fundo\n  labs(                                         # adicione rótulos, título, etc.\n\n    x = \"Data de registro\",\n    y = \"Casos de malária\",\n    title = \"Casos de malária por distrito - Eixos x e y 'livres'\") +\n  facet_wrap(~District, scales = \"free\")        # as facetas são criadas"},{"path":"ggplot-basics.html","id":"ordem-dos-fatores-nas-facetas","chapter":"28 O básico do ggplot","heading":"Ordem dos fatores nas facetas","text":"Veja este post sobre como reordenar os níveis de um fator dentro de cada faceta.","code":""},{"path":"ggplot-basics.html","id":"armazenando-gráficos","chapter":"28 O básico do ggplot","heading":"28.7 Armazenando gráficos","text":"","code":""},{"path":"ggplot-basics.html","id":"salvando-gráficos-1","chapter":"28 O básico do ggplot","heading":"Salvando gráficos","text":"Por padrão, quando você executa um comando ’ggplot(), o gráfico será apresentado painel Plots RStudio. Entretanto, você também pode salvar o gráfico como um objeto utilizando o operador de atribuição<-e dando-lhe um nome. Então, ele não será exibido menos que o próprio nome objeto seja executado. Você também pode imprimi-lo envolvendo o nome gráfico comprint()`, mas isto só é necessário em certas circunstâncias, como se o gráfico criado dentro de um loop utilizado para imprimir vários gráficos de uma vez (veja página Iteração, laços e listas).","code":"\n# Atribua o gráfico a um objeto\n\n\nage_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# exiba\nage_by_wt    "},{"path":"ggplot-basics.html","id":"modificando-gráficos-salvos","chapter":"28 O básico do ggplot","heading":"Modificando gráficos salvos","text":"Uma coisa legal sobre ggplot2 é que você pode definir um gráfico (como acima), e depois adicionar camadas ele começando com seu nome. Você não precisa repetir todos os comandos que criaram o gráfico original!Por exemplo, para modificar o gráfico age_by_wt que foi definida acima, para incluir uma linha vertical aos 50 anos de idade, basta adicionar um + e começar adicionar camadas adicionais ao gráfico.","code":"\nage_by_wt+\n  geom_vline(xintercept = 50)"},{"path":"ggplot-basics.html","id":"exportando-gráficos","chapter":"28 O básico do ggplot","heading":"Exportando gráficos","text":"exportação de gráficos feitos ggplot é facilitada com função ggsave() de ggplot2. Ela pode funcionar de duas maneiras:Especifique o nome objeto gráfico, depois o caminho arquivo e o nome com extensão\nPor exemplo: ggsave(my_plot, (\"plots\", \"my_plot.png\"))\nEspecifique o nome objeto gráfico, depois o caminho arquivo e o nome com extensãoPor exemplo: ggsave(my_plot, (\"plots\", \"my_plot.png\"))Execute o comando com apenas o parâmetro caminho de arquivo, para salvar o último gráfico que foi feito\nPor exemplo: ggsave((\"plots\", \"my_plot.png\"))\nExecute o comando com apenas o parâmetro caminho de arquivo, para salvar o último gráfico que foi feitoPor exemplo: ggsave((\"plots\", \"my_plot.png\"))Você pode exportar como png, pdf, jpeg, tiff, bmp, svg, ou vários outros tipos de arquivo, especificando extensão arquivo caminho arquivo.Você também pode especificar os argumentos width =, (largura) height = (altura), e units = (ou “”, “cm”, ou “mm”). Você também pode especificar dpi = com um número para resolução da imagem ser salva (por exemplo, 300). Veja os detalhes da função digitando ?ggsave ou lendo documentação online.Lembre-se de que você pode utilizar sintaxe da função () para fornecer o caminho de arquivo desejado. Consulte página Importar e exportar para obter mais informações.","code":""},{"path":"ggplot-basics.html","id":"rótulos","chapter":"28 O básico do ggplot","heading":"28.8 Rótulos","text":"Certamente você vai querer adicionar ou ajustar os rótulos (elementos de texto) gráfico. Estes ajustes são mais facilmente feitos dentro da função labs() que é adicionada ao gráfico com + tal como os geoms eram.Dentro de labs() você pode fornecer strings para estes parâmetros:x = e y = O título eixo x e eixo y (etiquetas)title = O título principal gráficosubtitle = O subtítulo gráfico, em texto menor abaixo títulocaption = legenda gráfico, na parte inferior direita por padrãoAqui está um gráfico que fizemos anteriormente, mas com rótulos mais bonitos:Observe como na atribuição título utilizamos str_glue() pacote stringr para implantar código R dinâmico dentro texto da string. O legenda mostrará os “Dados partir de”: “data que reflete data máxima de hospitalização na linelist”. Leia mais sobre isto na página em Caracteres e strings.Uma nota sobre especificação título da legenda: Não há nenhum argumento de “título da legenda”, pois você poderia ter múltiplas escalas em sua legenda. Dentro de labs(), você pode escrever o argumento da aesthetic gráfico utilizada para criar legenda, e fornecer o título desta forma. Por exemplo, acima atribuímos color = age para criar legenda. Portanto, fornecemos color = labs() e atribuímos o título da legenda desejada (“Idade” com maiúsculo). Se você criar legenda com aes(fill = COLUMN), então em labs() você escreveria fill = para ajustar o título dessa legenda. seção sobre escalas de cores na página Dicas para o ggplot fornece mais detalhes sobre edição de legendas, e uma abordagem alternativa utilizando funções scales_().","code":"\nage_by_wt <- ggplot(\n  data = linelist,   # especifique o objeto com os dados\n  mapping = aes(     # mapeie as aesthetics para colunas desses dados\n         x = age,           # mapeie o eixo x para idade (coluna age)            \n         y = wt_kg,         # mapeie o eixo x para peso (coluna wt_kg)       \n         color = age))+     # mapeie a cor para a idade\n  geom_point()+           # mostre os dados como pontos\n  labs(\n    title = \"Distribuição de idade e peso\",\n\n    subtitle = \"Surto de Ebola fictício, 2014\",\n    x = \"Idade em anos\",\n    y = \"Peso em quilos\",\n    color = \"Idade\",\n    caption = stringr::str_glue(\"Dados como em {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt"},{"path":"ggplot-basics.html","id":"ggplot_basics_themes","chapter":"28 O básico do ggplot","heading":"28.9 Temas","text":"Uma das melhores partes ggplot2 é quantidade de controle que você tem sobre o gráfico - você pode definir qualquer coisa! Como mencionado acima, o desenho gráfico que não está relacionado às formas/geometrias dos dados são ajustados dentro da função theme(). Por exemplo, cor de fundo gráfico, presença/ausência de linhas de grade e fonte/tamanho/cor/alinhamento texto (títulos, subtítulos, legendas, texto eixo…). Estes ajustes podem ser feitos de uma de duas maneiras:*Adicionar um tema completo theme_()função para fazer ajustes de varredura - estes incluem theme_classic(), theme_minimal(), theme_dark(), theme_light()theme_grey(),theme_bw()` entre outrosAjuste cada pequeno aspecto gráfico individualmente dentro de theme()","code":""},{"path":"ggplot-basics.html","id":"temas-completos","chapter":"28 O básico do ggplot","heading":"Temas completos","text":"Como eles são bastante diretos, demonstraremos funções temáticas completas abaixo e não descreveremos mais aqui. Note que quaisquer micro-ajustes com theme() devem ser feitos após utilização de um tema completo.Escreva-os com parênteses vazios.","code":"\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema gray\")+\n  theme_gray()"},{"path":"ggplot-basics.html","id":"modifique-o-tema","chapter":"28 O básico do ggplot","heading":"Modifique o tema","text":"função theme() pode levar um grande número de argumentos, cada um dos quais edita um aspecto muito específico gráfico. Não há como cobrir todos os argumentos, mas vamos descrever o padrão geral para eles e mostrar-lhe como encontrar o nome argumento que você precisa. sintaxe básica é esta:Dentro de theme() escreva o nome argumento para o elemento gráfico que você deseja editar, como plot.title =Fornecer uma função element_() para o argumentoNa maioria das vezes, utilize element_text(), mas outros incluem element_rect() para cores de fundo de tela, ou element_blank() para remover os elementos gráficoDentro da função element_(), escreva atribuições de argumentos para fazer os ajustes finos que você desejaEssa descrição foi bastante abstrata, portanto, aqui estão alguns exemplos.O gráfico abaixo parece bastante tolo, mas serve para mostrar uma variedade de maneiras de ajustar seu gráfico.Começamos com o gráfico age_by_wt definido logo acima e acrescentamos theme_classic()Para ajustes mais finos, adicionamos theme() e incluímos um argumento para cada elemento gráfico ser ajustadoPode ser bom organizar os argumentos em seções lógicas. Para descrever apenas alguns dos utilizados abaixo:legend.position = é único sentido de aceitar valores simples como “bottom”, “top”, “left”, e “right”. Mas geralmente, os argumentos relacionados ao texto exigem que você coloque os detalhes element_text().tamanho título com element_text(size = 30).O alinhamento horizontal título com element_text(hjust = 0) (da direita para esquerda)O subtítulo está em itálico com element_text(face = \"italic\")Aqui estão alguns argumentos especialmente comuns em theme(). Você reconhecerá alguns padrões, tais como acrescentar .x' ou.y’ para aplicar mudança somente em um eixo.axis.ticks = element_blank() |Remove marcações de escalas eixo\naxis.line = element_line() |Linhas eixo (parâmetros: colour, linetype: solid dashed dotted etc)\nstrip.text = element_text() |Texto rótulo da faceta (parâmetros: colour, face, size, angle…)\nstrip.background = element_rect()|Rótulo da faceta (parâmetros: fill, colour, size…)Mas há tantos argumentos para temas! Como eu poderia lembrar de todos eles? Não se preocupe - é impossível lembrar-se de todos eles. Felizmente, existem algumas ferramentas para ajudá-lo:documentação sobre modificação tema, que tem uma lista completa.DICA: Rode theme_get() ggplot2 para listar os mais de 90 argumentos da função theme() console .DICA: Se você em algum momento quiser remover um elemento gráfico, você também o pode fazer com o theme(). Apenas passe o parâmetro element_blank() para um argumento para que ele desapareca completamente. Para legendas, configure legend.position = \"none\".","code":"\nage_by_wt + \n  theme_classic()+                                 # ajustes de tema pré-definidos\n  theme(\n    legend.position = \"bottom\",                    # move a legenda  para baixo\n    \n    plot.title = element_text(size = 30),          # ajusta o tamanho do título para 30\n    plot.caption = element_text(hjust = 0),        # alinha a Legenda da figura a esquerda\n    plot.subtitle = element_text(face = \"italic\"), # deixa subtítulo em itálico\n\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # ajusta o texto o eixo x \n    axis.text.y = element_text(size = 15),         # ajusta o texto o eixo y\n    \n    axis.title = element_text(size = 20)           # ajusta o texto de ambos os eixos\n    )     "},{"path":"ggplot-basics.html","id":"cores","chapter":"28 O básico do ggplot","heading":"28.10 Cores","text":"Por favor veja seção sobre escala de cores na página de dicas ggplot.","code":""},{"path":"ggplot-basics.html","id":"usando-o-pipe-no-ggplot2","chapter":"28 O básico do ggplot","heading":"28.11 Usando o pipe (%>%) no ggplot2","text":"Ao utilizar pipes (%>%) para limpar e transformar seus dados, é fácil passar os dados transformados em ggplot().Os pipes que passam o conjunto de dados de função para função passarão ser um símbolo de mais + assim que função ggplot() chamada. Observe que, neste caso, não há necessidade de especificar o argumento data = (data), pois este é automaticamente definido como o conjunto de dados que vinha sendo usado pipe.Esta é aparência que pode ter:","code":"\nlinelist %>%   # comece com a linelist\n rename(tosse=cough,\n         febre=fever, \n         vômito=vomit,\n         dores=aches,\n         calafrio=chills) %>%  #traduzindo o nome dos sintomas pois a base está em inglês\n  select(c(case_id, febre, calafrio, tosse, dores, vômito)) %>%   # selecione as colunas\n  \n  pivot_longer(                                                  # faça o pivotamento para ficar mais longo\n    cols = -case_id,                                  \n    names_to = \"nome_sintoma\",\n    values_to = \"sintoma_esta_presente\") %>%\n  mutate(                                                        # substitua valores faltantes\n    sintoma_esta_presente = replace_na(sintoma_esta_presente, \"desconhecido\")) %>% \n  \n  ggplot(                                                        # comece o gráfico!\n    mapping = aes(x = nome_sintoma, fill = sintoma_esta_presente))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Sintoma\",\n    y = \"Status do sintoma (proporção)\"\n  )"},{"path":"ggplot-basics.html","id":"fazer-gráficos-de-dados-contínuos","chapter":"28 O básico do ggplot","heading":"28.12 Fazer gráficos de dados contínuos","text":"Ao longo desta página, você já viu muitos exemplos de gráficos de dados contínuos. Aqui nós os consolidamos brevemente e apresentamos algumas variações.visualizações aqui abordadas incluem:Gráficos para uma variável contínua: Histograma, um gráfico clássico para apresentar distribuição de uma variável contínua.\n* Diagramas de caixa (box-plots), para mostrar os percentis 25%, 50% e 75%, pontas de cauda da distribuição e outliers (limitações importantes).\n* Gráfico Jitter, para mostrar todos os valores como pontos que estão ‘tremidos’ para que possam (principalmente) ser todos vistos, mesmo onde dois têm o mesmo valor.\n* Gráfico Violino, mostrar distribuição de uma variável contínua com base na largura simétrica ‘violino’.\n* Gráfico Sina, são uma combinação de gráficos de jitter e violino, onde são mostrados pontos individuais mas na forma simétrica da distribuição (via ggforce pacote). (Nota Tradutor: Jitter em inglês significa “agitado, nervoso” e se remete ao fato dos pontos, nesse gráfico ficarem mais “espalhados” de forma não ficarem sobrepostos )\n* Gráfico de dispersão Para duas variáveis contínuas.\n* Gráficos de calor para três variáveis contínuas (ligados à página gráficos de calor)","code":""},{"path":"ggplot-basics.html","id":"histogramas","chapter":"28 O básico do ggplot","heading":"Histogramas","text":"Os histogramas podem parecer gráficos de barras, mas são distintos porque medem distribuição de uma variável contínua. Não há espaços entre “barras”, e apenas uma coluna é fornecida ao geom_histogram().Abaixo está o código para gerar histogramas, que agrupam dados contínuos em intervalos e exibem em barras adjacentes de altura variável. Isto é feito utilizando o geom_histogram(). Ver secção “Gráfico de barra” da página básico ggplot para compreender diferença entre geom_histogram(), geom_bar(), e geom_col().Mostraremos distribuição das idades dos casos. Dentro de mapping = aes() especifique coluna de que deseja ver distribuição. Pode atribuir esta coluna ao eixo x ou ao eixo y.linhas serão atribuídas “caixas/classes” com base na sua idade numérica, e estas classes serão representadas graficamente por barras. Se especificar um número de classes com aesthetic bins =, os pontos de quebra são uniformemente espaçados entre os valores mínimo e máximo histograma. Se bins = não estiver especificado, será adivinhado um número apropriado de classes e esta mensagem será exibida após o gráfico:Se não quiser especificar um número de classes para bins =, pode, em alternativa, especificar binwidth = nas unidades eixo. Apresentamos alguns exemplos que mostram diferentes quantidades e larguras de classes:Para obter proporções suavizadas, pode utilizar geom_density():Para obter um histograma “empilhado” (de uma coluna contínua de dados), você pode fazer uma das seguintes ações:Utilize geom_histogram() com o fill = argumento dentro de aes() e atribuído à coluna de agrupamento, ouUtilize geom_freqpoly(), que provavelmente é mais fácil de ler (você ainda pode definir binwidth =)Para ver proporções de todos os valores, defina o y = after_stat(density) (utilize esta sintaxe exatamente - não alterada para seus dados). Nota: estas proporções mostrarão por grupo.Cada uma delas é mostrada abaixo (*notar utilização de color = vs. fill = em cada uma):Se você quiser se divertir, tente ‘geom_density_ridges’ pacote ggridges* (vinheta aqui.Leia mais em detalhes sobre histogramas tidyverse página em geom_histogram().","code":"## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n# A) Histograma regular\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram()+\n  labs(title = \"A) Histograma padrão (30 classes)\")\n\n# B) Mais classes\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Ajustado para 50 classes\")\n\n# C) Menos classes\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Ajustado para 5 classes\")\n\n\n# D) Mais classes\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) Largura da classe = 1\")\n# Frequencia com eixos de proporção, suavizadas. \nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Densidade proporcional\")\n\n# Frequência empilhada com eixo proporcional, suavizada \n\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \" Densidades proporcionais 'empilhada'\")\n# Histograma *empilhado*\n\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"histograma 'empilhado'\")\n\n# Frequência\nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Polígono de frequência\")\n\n# Freqüência com eixo de proporção \nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Polígono de frequência proporcional\")\n\n# Freqüência com eixo de proporção , suavizado\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, suavizado com geom_density()\")"},{"path":"ggplot-basics.html","id":"box-plots","chapter":"28 O básico do ggplot","heading":"Box plots","text":"Os bos-plots são comuns, mas têm limitações importantes. Elas podem obscurecer distribuição real - por exemplo, uma distribuição bi-modal. Veja este galeria de gráficos R e este artigo data--viz para mais detalhes. Entretanto, eles exibem bem faixa inter-quartil e aberturas - de modo que podem ser sobrepostos em cima de outros tipos de gráficos que mostram distribuição em mais detalhes.Abaixo lembramos os vários componentes de um boxplot:Ao utilizar geom_boxplot() para criar diagrama de caixas (box-plot), você geralmente mapeia apenas um eixo (x ou y) dentro de aes(). O eixo especificado determina se parcelas são horizontais ou verticais.Na maioria dos geoms, você cria um gráfico por grupo mapeando uma estética como color = ou fill = para uma coluna dentro de aes(). Entretanto, para box-plots, isso é conseguido atribuindo coluna de agrupamento ao eixo não atribuído (x ou y). Abaixo está o código para um boxplot de todos os valores de idade conjunto de dados, e o segundo é o código para exibir um box plot para cada sexo (não-faltante) conjunto de dados. Observe que os valores NA (ausentes) aparecerão como um gráfico de caixa separado, menos que seja removido. Neste exemplo, também definimos o fill para coluna outcome, para que cada gráfico seja de uma cor diferente - mas isto não é necessário.Para obter o código para adicionar um boxplot às bordas de um gráfico de dispersão (gráficos “marginais”) veja página [Dicas para o ggplot].","code":"\n# A) Boxplot geral\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # apenas o y é mapeado\n  labs(title = \"A) Boxplot geral\")\n\n# B) Box plot por grupo\nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # remove a legenda\n  labs(title = \"B) Box plot por sexo\")      "},{"path":"ggplot-basics.html","id":"gráficos-violino-jitter-sina","chapter":"28 O básico do ggplot","heading":"Gráficos: Violino, jitter, sina","text":"code creating violin plots (geom_violin) jitter plots (geom_jitter) show distributions. can specify fill color also determined data, inserting options within aes().Você pode combinar os dois utilizando função geom_sina() pacote ggforce. Esse gráfico traça os pontos gráfico jitter na forma gráfico de violino. Quando sobrepostos (ajustando transparências), isto pode ser mais fácil de interpretar visualmente.","code":"\n# A) Gráfico de jitter por grupo\n\nggplot(data = linelist %>% drop_na(outcome),      # remove valores faltantes\n       mapping = aes(y = age,                     # variável contínua escolhida\n           x = outcome,                           # variável de agrupamento\n           color = outcome))+                     # variável para cor\n  geom_jitter()+                                  # criar o gráfico ´Jitter\n  labs(title = \"A) Um grafico 'jitter' por gênero\" )  \n\n\n\n# B) Gráfico de violino\nggplot(data = linelist %>% drop_na(outcome),       # remove valores faltantes\n       mapping = aes(y = age,                      # Variável contínua\n           x = outcome,                            # Variável de agrupamento\n           fill = outcome))+                       # variável de cor para preenchimento\n  geom_violin()+                                   # criar o gráfico de violino\n  labs(title = \"B) Gráfico de violino por gênero\")    \n# Um gráfico Sina por grupo\nggplot(\n  data = linelist %>% drop_na(outcome), \n  aes(y = age,           # variável numérica\n      x = outcome)) +    # variável de agrupamento\n  geom_violin(\n    aes(fill = outcome), # mapeie o preenchimento (cor do fundo do violino) segundo uma coluna\n    color = \"white\",     # borda exterior branca\n    alpha = 0.2)+        # transparencia\n  geom_sina(\n    size=1,                # Mude o tamanho do \"jitter\"\n    aes(color = outcome))+ # cor dos pontos\n  scale_fill_manual(       # defina as cores de preenchimento do violino\n    values = c(\"Death\" = \"#bf5300\", #óbito\n              \"Recover\" = \"#11118c\")) + # recuperado\n  scale_color_manual(      # defina as cores de preenchimento dos pontos\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # Remove o fundo cinza\n  theme(legend.position = \"none\") +                # Remove legendas desnecessárias\n  labs(title = \"Gráfico Sina e Violino por gênero, com formtações extras\")      "},{"path":"ggplot-basics.html","id":"duas-variáveis-contínuas","chapter":"28 O básico do ggplot","heading":"Duas variáveis contínuas","text":"Seguindo uma sintaxe semelhante, geom_point() permitirá traçar duas variáveis contínuas uma contra outra em uma gráfico de dispersão. Isto é útil para mostrar os valores reais ao invés de suas distribuições. Um gráfico básico de dispersão de idade vs peso é mostrado em (). Em (B) utilizamos novamente facet_grid() para mostrar relação entre duas variáveis contínuas na linelist.","code":"\n#Gráfico de dispersão básico para idade e peso\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Gráfico de dispesão para idade e peso\")\n\n# Gráfico de dispersão de peso e idade por gênero e desfecho para o Ebola \nggplot(data = linelist %>% drop_na(gender, outcome), # filtro mantém apenas gênero e desfecho não faltantes\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Gráfico de dispersão do peso por idade facetado para gênero e desfecho\")+\n  facet_grid(gender ~ outcome) "},{"path":"ggplot-basics.html","id":"três-variáveis-contínuas","chapter":"28 O básico do ggplot","heading":"Três variáveis contínuas","text":"Você pode exibir três variáveis contínuas utilizando o argumento fill = para criar um gráfico de calor. cor de cada “célula” irá refletir o valor da terceira coluna contínua de dados. Veja página Dicas para o ggplot e página em Gráficos de calor para mais detalhes e vários exemplos.Existem maneiras de fazer gráficos 3D em R, mas para epidemiologia aplicada, estes são freqüentemente difíceis de interpretar e, portanto, menos úteis para tomada de decisões.","code":""},{"path":"ggplot-basics.html","id":"gráficos-de-dados-categóricos","chapter":"28 O básico do ggplot","heading":"28.13 Gráficos de dados categóricos","text":"Dados categóricos podem ser variáveis tipo caractere ou variáveis lógicas (TRUE/FALSE. VERDADEIRO/FALSO), ou ainda fatores (veja página Fatores).","code":""},{"path":"ggplot-basics.html","id":"preparação-19","chapter":"28 O básico do ggplot","heading":"Preparação","text":"","code":""},{"path":"ggplot-basics.html","id":"estrutura-dos-dados","chapter":"28 O básico do ggplot","heading":"Estrutura dos dados","text":"primeira coisa entender sobre seus dados categóricos é se eles em sua forma bruta existem observações como uma lista de casos, ou como um quadro resumido ou agregados que contém contagens ou proporções. O estado de seus dados terá impacto na função de gráficos que você utiliza:Se seus dados forem observações em bruto com uma linha por observação, você provavelmente utilizará geom_bar()Se seus dados já estiverem agregados em contagens ou proporções, você provavelmente utilizará geom_col()","code":""},{"path":"ggplot-basics.html","id":"classe-da-coluna-e-ordenamento-dos-valores","chapter":"28 O básico do ggplot","heading":"Classe da coluna e ordenamento dos valores","text":"Em seguida, examine classe das colunas que você deseja traçar. Examinamos hospital, primeiro com função class() R base, e com tabyl() pacote janitor.Podemos ver que os valores dentro são caracteres, pois se tratam de nomes de hospitais, e por padrão são ordenados alfabeticamente. Existem também “outros” e “faltam” valores, que preferimos que sejam últimas subcategorias ao apresentarmos subdivisões. Portanto, transformamos esta coluna em um fator e reordenamos. Isto é tratado com mais detalhes na página Fatores.","code":"\n# Veja a classe da coluna hospital - podemos ver que é um caracter\nclass(linelist$hospital)## [1] \"character\"\n# Veja os valores e proporções dentro dessa coluna \"hospital\" \nlinelist %>% \n  tabyl(hospital)##                              hospital    n    percent\n##                               Ausente 1469 0.24949049\n##                      Central Hospital  454 0.07710598\n##                     Military Hospital  896 0.15217391\n##                                 Other  885 0.15030571\n##                         Port Hospital 1762 0.29925272\n##  St. Mark's Maternity Hospital (SMMH)  422 0.07167120\n# Converte para fator e define a ordem dos níveis para que \"Other\" (outros) e \"Missing\" (faltantes) sejam os últimos a aparecer \nlinelist <- linelist %>% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `hospital = fct_relevel(...)`.\n## Caused by warning:\n## ! 1 unknown level in `f`: Missing\nlevels(linelist$hospital)## [1] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [3] \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Other\"                                \"Ausente\""},{"path":"ggplot-basics.html","id":"ggplot_basics_bars","chapter":"28 O básico do ggplot","heading":"geom_bar()","text":"Utilize geom_bar() se você quiser que altura da barra (ou altura dos componentes da barra empilhada) reflita o número de linhas relevantes nos dados. Essas barras terão espaços entre elas, menos que aesthetic largura ( width = ) esteja ajustada.Forneça apenas uma atribuição de coluna de um eixo (tipicamente eixo x). Se você fornecer x e y, você receberá Error: stat_count() só pode ter uma estética x ou y.Você pode criar barras empilhadas, adicionando uma atribuição de fill = coluna dentro de mapping = aes().O eixo oposto será intitulado “count” por padrão, pois representa o número de linhasA seguir, designamos o resultado para o eixo y, mas poderia ser igualmente fácil eixo x. Se você tiver valores de caracteres mais longos, às vezes pode parecer melhor virar barras para o lado e colocar legenda embaixo. Isto pode ter impacto na forma como os níveis seu fator são ordenados - neste caso os revertemos com fct_rev() para colocar “” e “Missing” na parte inferior.","code":"\n# A) Desfecho em todos os casos\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Número de casos por hospital\",\n       y = \"Hospital\")\n\n\n# B) Desfecho em todos os casos por hospital\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Número de casos de Ebola recuperados e de óbitos,   por hospital\",\n       y = \"Hospital\")"},{"path":"ggplot-basics.html","id":"geom_col","chapter":"28 O básico do ggplot","heading":"geom_col()","text":"Utilize geom_col() se você quiser que altura da barra (ou altura dos componentes da barra empilhados) reflita os valores pré-calculados que existem nos dados. Muitas vezes, estas são contagens sumárias ou “agregadas”, ou proporções.Forneça atribuições de colunas para ambos eixos para geom_col(). Normalmente, sua coluna eixo x é discreta e sua coluna eixo y é numérica.Digamos que temos este conjunto de dados “resultados”:Abaixo está o código utilizando geom_col para criar gráficos de barras simples para mostrar distribuição dos resultados dos pacientes com Ebola. Com o geom_col, tanto x como y precisam ser especificados. Aqui x é variável categórica ao longo eixo x, e y é coluna de proporções geradas proporcao.Para mostrarmos detalhamentos por hospital, precisaríamos que nossa tabela contivesse mais informações e que estivesse em formato “longo”. Criamos esta tabela com freqüências das categorias combinadas outcome (Desfecho) e hospital (ver página Agrupando dados para dicas de agrupamento).Criamos então o ggplot com alguma formatação adicional:Rotação eixo: Trocamos o eixo com coord_flip() para que pudéssemos ler os nomes dos hospitais.Colunas lado lado: Acrescentou o argumento position = \"dodge\" para que barras de óbitos e recuperação sejam apresentadas lado lado em vez de empilhadas. Note que barras empilhadas são o padrão.Largura da coluna: Largura especificada, de modo que colunas são agora metade da largura normal.Ordem das colunas: Inverteu ordem das categorias eixo y para que ‘’ (Outros) e ‘Missing’ (Faltantes) estejam na parte inferior, com scale_x_discrete(limits=rev). Note que utilizamos isso em vez de scale_y_discrete porque o hospital é indicado argumento ‘x’ de ’aes()`, mesmo que visualmente esteja eixo y. Fazemos isso porque ggplot parece apresentar categorias ao contrário, menos que digamos lhe o contrário.Outros detalhes: Etiquetas/títulos e cores adicionadas dentro de labs e scale_fill_color respectivamente.Note que proporções são binárias, por isso podemos preferir abandonar “recuperação” e apenas mostrar proporção de quem morreu. Isto é apenas para fins ilustrativos.Se utilizar geom_col() com dados de datas (por exemplo, uma epicurva partir de dados agregados) - você vai querer ajustar o argumento width = (largura) para remover linhas de “espaço” entre barras. Se utilizar o conjunto de dados diário, ajuste width = 1. Se semanal, ajuste width = 7. Os meses não são possíveis de serem visualizados dessa forma, porque cada mês tem um número de dias diferente.","code":"## # A tibble: 2 × 3\n##   outcome        n proporcao\n##   <chr>      <int>     <dbl>\n## 1 Recuperado   796      43.8\n## 2 Óbito       1022      56.2\n# Desfecho em todos os casos\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proporcao)) +\n  labs(subtitle = \"Número de casos recuperados e óbitos de Ebola\")\noutcomes2 <- linelist %>% \n  drop_na(outcome) %>% \n  count(hospital, outcome) %>%  # obtém contagens para hospital e desfecho \n\n  group_by(hospital) %>%        # Agrupa para que proporção esteja fora do total do hospital \n  mutate(proportion = n/sum(n)*100) # Calcula as proporções\n\n\nhead(outcomes2) # Veja uma prévia dos dados## # A tibble: 6 × 4\n## # Groups:   hospital [3]\n##   hospital                             outcome     n proportion\n##   <fct>                                <chr>   <int>      <dbl>\n## 1 St. Mark's Maternity Hospital (SMMH) Death     199       61.2\n## 2 St. Mark's Maternity Hospital (SMMH) Recover   126       38.8\n## 3 Port Hospital                        Death     785       57.6\n## 4 Port Hospital                        Recover   579       42.4\n## 5 Central Hospital                     Death     193       53.9\n## 6 Central Hospital                     Recover   165       46.1\n# Desfecho em todos os casos por hospital\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # apresenta os dados calculados previamente\n      y = fct_rev(hospital),          # reordenas os níveis do fator, colocando na base os desejados \n      fill = outcome),                # empilhados por desfecho\n    width = 0.5)+                     # barras mais finas (valores menores que 1)\n  theme_minimal() +                   # Tema mínimo\n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Número de casos recuperados e óbitos por Ebola, por hospital\",\n       fill = \"Desfecho\",             # título da legenda\n       y = \"Contagem\",                # título do eixo y\n       x = \"Hospital de admissão\")+   # título do eixo x\n  scale_fill_manual(                 # escolhendo as cores manualmente\n    values = c(\"Death\"= \"#3B1c8C\",   # para óbito\n               \"Recover\" = \"#21908D\" )) # para recuperado"},{"path":"ggplot-basics.html","id":"geom_histogram","chapter":"28 O básico do ggplot","heading":"geom_histogram()","text":"Os histogramas podem parecer gráficos de barras, mas são distintos porque medem distribuição de uma variável contínua. Não há espaços entre “barras”, e apenas uma coluna é fornecida para geom_histogram(). Há argumentos específicos para histogramas como bin_width = e breaks = para especificar como os dados devem ser cdivididos em classes. seção acima sobre dados contínuos e página sobre Curvas Epidemiológicas fornecem detalhes adicionais.","code":""},{"path":"ggplot-basics.html","id":"recursos-14","chapter":"28 O básico do ggplot","heading":"28.14 Recursos","text":"Há uma enorme quantidade de ajuda online, especialmente com o ggplot. Veja:Cheat sheet (cola) ggplot2Outra cheat sheetPágina básico ggplot tidyversePlatando variáveis contínuasR Data Science pages visualização de dadosgráficos para comunicação","code":""},{"path":"ggplot-tips.html","id":"ggplot-tips","chapter":"29 Dicas do ggplot","heading":"29 Dicas do ggplot","text":"Nesta página, iremos abordar dicas e truques para criar gráficos inteligentes e bonitos com o ggplot. Para aprender os fundamentos ggplot, veja página sobre básico ggplot.Existem diversos tutoriais sobre o ggplot2 disponíveis na seção de Recursos ao final deste capítulo. Você também pode baixar essa colinha sobre visualização de dados com o ggplot site RStudio. Nós recomendamos fortemente que você busque inspiração de gráficos na galeria de gráficos R e Data--viz.","code":""},{"path":"ggplot-tips.html","id":"preparando-o-ambiente-r-1","chapter":"29 Dicas do ggplot","heading":"29.1 Preparando o ambiente R","text":"","code":""},{"path":"ggplot-tips.html","id":"carregue-os-pacotes-5","chapter":"29 Dicas do ggplot","heading":"Carregue os pacotes","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar os pacotes instalados utilizando função library(), R base. Para mais informações sobre pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  tidyverse,      # inclue ggplot2 e outros pacotes\n  rio,            # importar/exportar\n  here,           # localizador de arquivos\n  stringr,        # trabalhando com caracteres\n  scales,         # transforme números\n  ggrepel,        # etiquetas colocadas de forma inteligente\n  gghighlight,    # destaque uma parte do gráfico\n  RColorBrewer    # escalas de cores\n)"},{"path":"ggplot-tips.html","id":"importe-os-dados-4","chapter":"29 Dicas do ggplot","heading":"Importe os dados","text":"Nesta página, nós importamos um conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para baixar linelist “limpa” (.rds file). Importe os dados com função import(), pacote rio (ela trabalha com uma variedade de tipos de arquivos, como .xlsx, .csv, .rds - veja página Importar e exportar para detalhes).primeiras 50 linhas da linelist são mostradas abaixo.","code":"\nlinelist <- rio::import(\"linelist_cleaned.rds\")"},{"path":"ggplot-tips.html","id":"ggplot_tips_colors","chapter":"29 Dicas do ggplot","heading":"29.2 Escalas para as cores, preenchimentos, eixos, etc.","text":"ggplot2, quando aparência dos dados gráfico (ex.: tamanho, cor, formato, preenchimento, eixo gráfico) é mapeada para colunas nos dados, visualização exata pode ser ajustada com o comando de “escala” correspondente. Nesta seção, nós explicamos alguns ajustes comuns de escalas.","code":""},{"path":"ggplot-tips.html","id":"esquemas-de-cores","chapter":"29 Dicas do ggplot","heading":"29.2.1 Esquemas de cores","text":"Uma coisa que pode ser inicialmente difícil de entender com o ggplot2, é o controle dos esquemas de cores. Observe que esta seção discute cor dos objetos gráfico (geometrias/formatos), como pontos, barras, linhas, bases, etc. Para ajustar cor de textos adicionais, títulos, ou plano de fundo, veja seção Temas da página sobre Básico ggplot.Para controlar “cor” dos objetos gráfico, você irá ajustar o argumento color = (cor exterior item) ou o fill = (cor interior item). Uma exceção esse padrão é o geom_point(), em que você realmente só consegue ajustar color =, que ajusta cor ponto inteiro (interior e exterior).Ao ajustar cor ou preenchimento (fill), você pode utilizar o nome das cores reconhecidas pelo R, como \"red\" (vermelho) (veja lista completa ou digite ?colors), ou um código hexadecimal específico para uma cor, como \"#ff0505\".Como explicado na seção mapeando os dados para o gráfico, da página Básico ggplot, aspectos estéticos como fill = e color = podem ser definidos fora comando mapping = aes(), ou dentro dele. Se fora de aes(), o valor atribuído deve ser estático (ex.: color = \"blue\") e irá ser aplicado para todos os dados colocados gráfico pelo geom. Se dentro, aparência estética deve ser mapeada para uma variável, como color = hospital, e expressão irá variar de acordo com o valor desta linha nos dados. Alguns exemplos:","code":"\n# histograma - \nggplot(data = linelist, mapping = aes(x = age))+       # ajuste os dados e eixos\n  geom_histogram(              # mostre o histograma\n    binwidth = 7,                # largura dos containers\n    color = \"red\",               # cor da linha dos containers\n    fill = \"lightblue\")          # cor interior dos containers (preenchimento)\n# Cor estática para pontos e para a linha\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(color = \"purple\")+\n  geom_vline(xintercept = 50, color = \"orange\")+\n  labs(title = \"Cor estática para os pontos e linha\")\n\n# Cor mapeada para uma coluna contínua\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = temp))+         \n  labs(title = \"Cor mapeada para uma coluna contínua\")\n\n# Cor mapeada para uma coluna discreta\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = gender))+         \n  labs(title = \"Cor mapeada para uma coluna discreta\")\n\n# gráfico de barras, preenchimento com uma coluna discreta, cor para um valor estático\nggplot(data = linelist, mapping = aes(x = hospital))+     \n  geom_bar(mapping = aes(fill = gender), color = \"yellow\")+         \n  labs(title = \"Preenchimento mapeado para uma coluna discreta, cor estática\")"},{"path":"ggplot-tips.html","id":"ggplot_tips_scales","chapter":"29 Dicas do ggplot","heading":"Escalas","text":"Quando você mapear uma coluna para uma aparência estética gráfico (ex.: x =, y =, fill =, color =…), seu gráfico irá ganhar uma escala/legenda. Veja acima como escala pode ter valores contínuos, discretos, datas, etc. dependendo na classe da coluna atribuída. Se você tiver múltiplas estéticas mapeadas para colunas, seu gráfico terá múltiplas escalas.Você pode controlar escalas com função scales_() apropriada. funções de escala ggplot() têm 3 partes, que são escritas assim: scale_AESTHETIC_METHOD().primeira parte, scale_(), é fixa.segunda parte, o AESTHETIC, deve ser estética que você quer ajustar escala para (_fill_, _shape_, _color_, _size_, _alpha_…) - opções aqui também incluem _x_ e _y_.terceira parte, o METHOD, será ou _discrete(), continuous(), _date(), _gradient(), ou _manual(), de acordo com classe da coluna e como você quer controlar ela. Existem outras classes, mas estes são frequentemente os mais utilizados.Certifique-se de utilizar função correta para escala! contrário, seu comando de escala não mudará nada gráfico. Se você tiver múltiplas escalas, pode utilizar múltiplas funções de escala para ajusta-las! Por exemplo:","code":""},{"path":"ggplot-tips.html","id":"argumentos-de-escala","chapter":"29 Dicas do ggplot","heading":"Argumentos de escala","text":"Cada tipo de escala possui seus próprios argumentos, embora existam alguns em comum. Busque uma função R, como ?scale_color_discrete, para ver documentação dos argumentos dessa função.Para escalas contínuas, utilize breaks = para fornecer uma sequência de valores com seq() (use =, =, e = como mostrado exemplo abaixo). Ajuste expand = c(0,0) para eliminar espaços extras ao redor dos eixos (isto pode ser utilizado em qualquer escala _x_ ou _y_).Para escalas discretas, você pode ajustar ordem de aparecimento dos fatores com breaks = e também ajustar os rótulos desses fatores com o argumento labels =. Forneça um vetor de caractere para cada um desses argumentos (veja exemplos abaixo). Você também pode excluir NA facilmente ao ajustar na.translate = FALSE.nuances de escalas de datas são abordados mais extensivamente na página Curvas epidêmicas.","code":""},{"path":"ggplot-tips.html","id":"ajustes-manuais","chapter":"29 Dicas do ggplot","heading":"Ajustes manuais","text":"Um dos truques mais úteis é utilizar funções que alteram escalas de forma “manual”, de forma explicitamente atribuir cores conforme você desejar. Estas são funções com sintaxe scale_xxx_manual() (ex.: scale_colour_manual() ou scale_fill_manual()). Cada um dos argumentos seguir são utilizados exemplo abaixo.Atribua cores para os valores dos dados com o argumento values =Especifique uma cor para NA com na.value =Mude como os valores são escritos na legenda com o argumento labels =Mude o título da legenda com name =seguir, nós criamos um gráfico de barras, mostramos como ele é por padrão, e, então, mostramos como fica após ajustarmos três escalas - escala contínua eixo y, escala discreta eixo x, e o ajuste manual preenchimento (cor interior das barras).","code":"\n# PADRÃO - sem ajuste de escalas\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Padrão - sem ajuste de escalas\")\n# ESCALAS AJUSTADAS\nggplot(data = linelist)+\n  \n  geom_bar(mapping = aes(x = outcome, fill = gender), color = \"black\")+\n  \n  theme_minimal()+                   # simplifique o fundo do gráfico\n  \n  scale_y_continuous(                # escala contínua para o eixo y (contagens)\n    expand = c(0,0),                 # sem espaços extras\n    breaks = seq(from = 0,\n                 to = 3000,\n                 by = 500))+\n  \n  scale_x_discrete(                   # escala discreta para o eixo x (gênero)\n    expand = c(0,0),                  # sem espaços extras\n    drop = FALSE,                     # mostre todos os níveis de factor (mesmo que não estejam nos dados)\n    na.translate = FALSE,             # remove desfechos clínicos desconhecidos (NA) do gráfico\n    labels = c(\"Died\", \"Recovered\"))+ # Mude a visualização dos valores\n    \n  \n  scale_fill_manual(                  # Especifique manualmente o preenchimento (cor interior da barra)\n    values = c(\"m\" = \"violetred\",     # valores de referência nos dados para atribuir cores\n               \"f\" = \"aquamarine\"),\n    labels = c(\"m\" = \"Homem\",          # renomeie a legenda (use \"=\" para fazer atribuições e evitar erros)\n              \"f\" = \"Mulher\",\n              \"Desconhecido\"),\n    name = \"Gênero\",                  # título da legenda\n    na.value = \"grey\"                 # atribua uma cor para dados em branco\n  )+\n  labs(title = \"Com as escalas ajustadas\") # Ajuste o título da legenda do preenchimento"},{"path":"ggplot-tips.html","id":"escalas-contínuas-dos-eixos","chapter":"29 Dicas do ggplot","heading":"Escalas contínuas dos eixos","text":"Quando os dados são mapeados para os eixos gráfico, estes também podem ser ajustados com comandos de escala. Um exemplo simples é ajustar visualização de um eixo (ex.: eixo y) que é mapeado para uma coluna com dados contínuos.caso de querermos ajustar quebras ou visualização dos valores gráfico, podemos utilizar o scale_y_continuous(), ggplot. Como observado acima, utilize o argumento breaks = para fornecer uma sequência de valores que irão servir como “quebras” na escala. Estes são os intervalos em que os números serão mostrados. Para este argumento, você pode fornecer um vetor c() contendo os valores dos intervalos desejados, ou você pode fornecer uma sequência regular de números utilizando função seq() R base. Esta função aceita =, =, e =.","code":"\n# PADRÃO - sem ajuste da escala\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Padrão - sem ajuste da escala\")\n\n# \nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  scale_y_continuous(\n    breaks = seq(\n      from = 0,\n      to = 3000,\n      by = 100)\n  )+\n  labs(title = \"Intervalo do eixo y ajustado\")"},{"path":"ggplot-tips.html","id":"mostre-as-porcentagens","chapter":"29 Dicas do ggplot","heading":"Mostre as porcentagens","text":"Caso os seus dados originais sejam proporções, você pode facilmente mostra-los como porcentagens com “%” ao adicionar labels = scales::percent nos seus comandos de escala, como mostrado abaixo.Embora uma alternativa seria converter os valores para caracteres, e, então, adicionar o “%” como caracter final, esta abordagem irá causar problemas uma vez que seus dados não serão mais variáveis numéricas contínuas.","code":"\n# Proporções originais do eixo y\n#############################\nlinelist %>%                                   # inicie com a linelist\n  group_by(hospital) %>%                       # agrupe os dados por hospital\n  summarise(                                   # crie uma coluna de resumo dos dados\n    n = n(),                                     # total de casos (linhas) em um grupo\n    deaths = sum(outcome == \"Death\", na.rm=T),   # número de mortes nos grupos\n    prop_death = deaths/n) %>%                   # proporção de mortes por grupo\n  ggplot(                                      # inicie o gráfico\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+ \n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Mostre as proporções originais do eixo y\")\n\n\n\n# Mostre as proporções do eixo y como porcentagens\n########################################\nlinelist %>%         \n  group_by(hospital) %>% \n  summarise(\n    n = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T),\n    prop_death = deaths/n) %>% \n  ggplot(\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+\n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Mostre o eixo y como porcentagem (%)\")+\n  scale_y_continuous(\n    labels = scales::percent                    # mostre as proporções como porcentagens\n  )"},{"path":"ggplot-tips.html","id":"escala-logarítmica","chapter":"29 Dicas do ggplot","heading":"Escala logarítmica","text":"Para transformar um eixo contínuo em uma escala logarítmica, adicione trans = \"log2\" comando da escala. Para os propósitos deste exemplo, criamos um quadro de dados de regiões com seus respectivos preparedness_index e valores de casos acumulados.Os casos acumulados para região “” são drasticamente maiores que todas outras regiões. Em circunstâncias como esta, você pode optar por mostrar o eixo y utilizando uma escala logarítmica, de forma que o leitor possa ver diferenças entre regiões com menos casos acumulados.","code":"\nplot_data <- data.frame(\n  region = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"),\n  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),\n  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)\n)\n\nplot_data##   region preparedness_index cases_cumulative\n## 1      A                8.8               15\n## 2      B                7.5               45\n## 3      C                3.4               80\n## 4      D                3.6               20\n## 5      E                2.1               21\n## 6      F                7.9                7\n## 7      G                7.0               51\n## 8      H                5.6               30\n## 9      I                1.0             1442\n# Eixo y original\npreparedness_plot <- ggplot(data = plot_data,  \n       mapping = aes(\n         x = preparedness_index,\n         y = cases_cumulative))+\n  geom_point(size = 2)+            # pontos para cada região\n  geom_text(\n    mapping = aes(label = region),\n    vjust = 1.5)+                  # adicione os rótulos em texto\n  theme_minimal()\n\npreparedness_plot                  # visualize o gráfico original\n\n\n# visualize o eixo y transformado\npreparedness_plot+                   # inicie com o gráfico salvo acima\n  scale_y_continuous(trans = \"log2\") # adicione a transformação para o eixo y"},{"path":"ggplot-tips.html","id":"escalas-em-gradiente","chapter":"29 Dicas do ggplot","heading":"Escalas em gradiente","text":"O preenchimento de escadas em gradiente de cores pode envolver detalhes adicionais. Normalmente, os ajustes padrões são bons, mas você pode querer ajustar os valores, limites de corte, etc.Para demonstrar como ajustar uma escala contínua de cor, nós iremos utilizar um conjunto de dados da página Rastreamento de contatos, que contém idades dos casos e dos seus casos-fonte.Abaixo, produzimos um arquivo “raster” de um gráfico de densidade de calor. Não iremos discorrer sobre como criar o gráfico (veja o link parágrafo acima), mas sim como ajustar escala de cor. Veja mais sobre função stat_density2d() ggplot2 aqui. Observe como escala fill é contínua.seguir, mostramos algumas variações na escala de preenchimento:Agora veremos alguns exemplos de como ajustar os pontos de quebra da escala:scale_fill_gradient() aceita duas cores (alta/baixa)scale_fill_gradientn() aceita um vetor com qualquer quantidade de cores para values = (valores intermediários serão intercalados)Use scales::rescale() para ajustar como cores serão posicionadas decorrer gradiente; ele reajusta o seu vetor de posições para ser entre 0 e 1.","code":"\ncase_source_relationships <- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %>% \n  select(source_age, target_age) \ntrans_matrix <- ggplot(\n    data = case_source_relationships,\n    mapping = aes(x = source_age, y = target_age))+\n  stat_density2d(\n    geom = \"raster\",\n    mapping = aes(fill = after_stat(density)),\n    contour = FALSE)+\n  theme_minimal()\ntrans_matrix\ntrans_matrix + scale_fill_viridis_c(option = \"plasma\")\ntrans_matrix + \n  scale_fill_gradient(     # escala de gradiente com 2 cores\n    low = \"aquamarine\",    # valor baixo\n    high = \"purple\",       # valor alto\n    na.value = \"grey\",     # valor para NA\n    name = \"Densidade\")+     # Título da legenda\n  labs(title = \"Especifique manualmente as cores para valores altos/baixos\")\n\n# 3+ cores na escala\ntrans_matrix + \n  scale_fill_gradientn(    # escala de 3-cores (baixo/médio/alto)\n    colors = c(\"blue\", \"yellow\",\"red\") # forneça cores no vetor\n  )+\n  labs(title = \"Escala de 3 cores\")\n\n# Uso de rescale() para ajustar a posição de cores na escala\ntrans_matrix + \n  scale_fill_gradientn(    # forneça qualquer número de cores\n    colors = c(\"blue\", \"yellow\",\"red\", \"black\"),\n    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # a posições para as cores é reescalado entre 0 e 1\n    )+\n  labs(title = \"Cores não são posicionadas igualmente\")\n\n# uso de limites para os valores de corte que recebem a cor de preenchimento\ntrans_matrix + \n  scale_fill_gradientn(    \n    colors = c(\"blue\", \"yellow\",\"red\"),\n    limits = c(0, 0.0002))+\n  labs(title = \"Restrinja os limites dos valores, resultando em um espaço cinza\")"},{"path":"ggplot-tips.html","id":"paletas-de-cores","chapter":"29 Dicas do ggplot","heading":"Paletas de cores","text":"","code":""},{"path":"ggplot-tips.html","id":"colorbrewer-e-viridis","chapter":"29 Dicas do ggplot","heading":"Colorbrewer e Viridis","text":"Geralmente, se você quiser paletas pré-definidas, pode usar funções scale_xxx_brewer ou scale_xxx_viridis_y.funções ‘brewer’ colorem partir das paletas colorbrewer.org.funções ‘viridis’ colorem das paletas viridis (amigável para deficientes visuais!), que “fornece mapas de cores que são uniformes, tanto nas cores quanto preto-e-branco. Elas também foram desenhadas para serem percebidas por usuários com formas comuns de cegueiras de cor.” (leia mais aqui e aqui). Defina se paleta é discreta, contínua, ou contida ao especificar isto final da função (ex.: discreta é scale_xxx_viridis_d).É recomendado que você teste cores de seu gráfico neste simulador de daltonismo. Se você tiver um esquema de cores vermelho/verde, tente um esquema “quente-frio” (vermelho-azul) lugar, como descrito aquiAqui é um exemplo da página Básico ggplot, utilizando diferentes esquemas de cores.","code":"\nsymp_plot <- linelist %>%                                         # inicie com a linelist\n  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # selecione as colunas\n  pivot_longer(                                                  # faça o pivoteamento longo\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %>%\n  mutate(                                                        # substitua os campos em branco\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %>% \n  ggplot(                                                        # inicie o ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  theme(legend.position = \"bottom\")+\n  labs(\n    x = \"Sintoma\",\n    y = \"Status do sintoma (proporção)\"\n  )\n\nsymp_plot  # visualize com as cores padrão\n\n#################################\n# visualize com cores especificadas manualmente\nsymp_plot +\n  scale_fill_manual(\n    values = c(\"yes\" = \"black\",         # defina as cores de forma explícita\n               \"no\" = \"white\",\n               \"unknown\" = \"grey\"),\n    breaks = c(\"yes\", \"no\", \"unknown\"), # ordene os fatores corretamente\n    name = \"\"                           # configure a legenda para não ter título\n\n  ) \n\n#################################\n# visualize com as cores discretas do pacote viridis\nsymp_plot +\n  scale_fill_viridis_d(\n    breaks = c(\"yes\", \"no\", \"unknown\"),\n    name = \"\"\n  )"},{"path":"ggplot-tips.html","id":"altere-a-ordem-das-variáveis-discretas","chapter":"29 Dicas do ggplot","heading":"29.3 Altere a ordem das variáveis discretas","text":"Geralmente, alterar ordem em que variáveis discretas aparecem gráfico é difícil de entender para novatos ggplot2. Entretanto, ao compreender o mecanismo que o ggplot2 usa para trabalhar com variáveis discretas, fica mais fácil de entender como alterar. geral, se uma variável discreta é utilizada, ela é automaticamente convertida para classe factor- que, por padrão, ordena os factors por ordem alfabética. Para trabalhar com isso, você simplesmente precisa reordenar os níveis de factor para refletirem na ordem que você gostaria que eles aparecessem gráfico. Para informações mais detalhadas sobre como reordenar objetos da classe factor, veja seção sobre factor neste guia.Nós podemos utilizar um exemplo comum com grupos de idade - por padrão, o grupo de 5-9 anos será colocado meio dos grupos ordenados (considerando ordem alfanumérica), mas nós podemos movê-lo para atrás grupo de 0-4 anos gráfico ao renivelar os factors.","code":"\nggplot(\n  data = linelist %>% drop_na(age_cat5),                         # remova as linhas em que age_cat5 está ausente\n  mapping = aes(x = fct_relevel(age_cat5, \"5-9\", after = 1))) +  # renivele os factors\n\n  geom_bar() +\n  \n  labs(x = \"Grupo de idade\", y = \"Número de hospitalizações\",\n       title = \"Quantidade total de hospitalizações por grupo de idade\") +\n  \n  theme_minimal()"},{"path":"ggplot-tips.html","id":"pacote-ggthemr","chapter":"29 Dicas do ggplot","heading":"29.3.0.1 Pacote ggthemr","text":"Adicionalmente, considere utilizar o pacote ggthemr, que pode ser baixado Github utilizando essas instruções. Ele oferece paletas de cores muito agradáveis estéticamente, mas tenha ciência de que estas geralmente possuem um número máximo de valores, o que é um fator limitante caso você queira mais de 7 ou 8 cores.","code":""},{"path":"ggplot-tips.html","id":"linhas-de-contorno","chapter":"29 Dicas do ggplot","heading":"29.4 Linhas de contorno","text":"Gráficos de contorno são úteis quando você tem muitos pontos que podem se sobrepor (“overplotting”). Iremos utilizar os dados sobre fontes dos casos utilizados acima para fazer um gráfico, mas de forma mais simples utilizando stat_density2d() e stat_density2d_filled() para produzir níveis discretos de contorno - como um mapa topográfico. Veja mais sobre estatísticas utilizadas aqui.","code":"\ncase_source_relationships %>% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d()+\n  geom_point()+\n  theme_minimal()+\n  labs(title = \"stat_density2d() + geom_point()\")\n\n\ncase_source_relationships %>% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d_filled()+\n  theme_minimal()+\n  labs(title = \"stat_density2d_filled()\")"},{"path":"ggplot-tips.html","id":"distribuições-marginais","chapter":"29 Dicas do ggplot","heading":"29.5 Distribuições marginais","text":"Para mostrar distribuições nas extremidades de um gráfico de dispersão criado com geom_point(), você pode utilizar o pacote ggExtra e sua função ggMarginal(). Salve seu ggplot original como um objeto, e então o utilize com ggMarginal(), como mostrado abaixo. Aqui estão os argumentos chave:Você precisa especificar type = como “histogram”, “density” “boxplot”, “violin”, ou “densigram”.Por padrão, gráficos de dispersão marginal irão aparecer para ambos eixos. Você pode ajustar margins = para “x” ou “y” se quiser apenas um deles.Outros argumentos opcionais incluem fill = (cor da barra), color = (cor da linha), size = (tamanho gráfico relativo ao tamanho da margem, de forma que números maiores criam um gráfico de dispersão marginal menor).Você pode fornecer outros argumentos específicos para os eixos em xparams = e yparams =. Por exemplo, para obter diferentes tamanhos dos containers histograma, como mostrado abaixo.Os gráficos de dispersão marginal podem refletir os grupos (colunas que foram atribuídas color = seu mapa estético ggplot()). Se este o caso, ajuste os argumentos groupColour = ou groupFill =, ggMarginal(), para TRUE, como mostrado abaixo.Leia mais neste resumo, na galeria de gráficos em R ou documentação da função R, com ?ggMarginal.Para adicionar histogramas marginais, utilize type = \"histogram\". Opcionalmente, você pode ajustar groupFill = TRUE para obter histogramas empilhados.Gráfico de densidade marginal com valores agrupados/coloridos:Coloque o argumento size = para ajustar o tamanho relativo gráfico de dispersão marginal. Números menores criam gráficos de dispersão marginal maiores. Você também ajusta color =. seguir, um diagrama de caixa (boxplot) marginal, com demonstração argumento margins =, de forma que apareça apenas em um eixo:","code":"\n# Instale/carregue o pacote ggExtra\npacman::p_load(ggExtra)\n\n# Gráfico básico de distribuição de peso e idade\nscatter_plot <- ggplot(data = linelist)+\n  geom_point(mapping = aes(y = wt_kg, x = age)) +\n  labs(title = \"Gráfico de distribuição de peso e idade\")\n# com histogramas\nggMarginal(\n  scatter_plot,                     # adicione histogramas marginais\n  type = \"histogram\",               # especifique histogram\n  fill = \"lightblue\",               # preenchimento das barras\n  xparams = list(binwidth = 10),    # outros parâmetros para a dispersão marginal do eixo x\n  yparams = list(binwidth = 5))     # outros parâmetros para a dispersão marginal do eixo y\n# Gráfico de dispersão, colorido de acordo com o desfecho clínico (outcome) do paciente\n# Coluna de desfecho é atribuída como cor no ggplot. groupFill no ggMarginal ajustado para TRUE\nscatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+\n  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +\n  labs(title = \"Gráfico de dispersão por peso e idade\")+\n  theme(legend.position = \"bottom\")\n\nggMarginal(scatter_plot_color, type = \"density\", groupFill = TRUE)\n# com boxplot \nggMarginal(\n  scatter_plot,\n  margins = \"x\",      # mostre apenas o gráfico de dispersão marginal do eixo x\n  type = \"boxplot\")   "},{"path":"ggplot-tips.html","id":"rotulagem-inteligente","chapter":"29 Dicas do ggplot","heading":"29.6 Rotulagem inteligente","text":"ggplot2, também é possível adicionar texto aos gráficos. Entretanto, limitação disto é sobreposição dos rótulos de texto com os dados gráfico, ficando com aparência confusa e difícil de interpretar. Não existe forma ideal de lidar com issso pacote básico, mas existe um complemento ggplot2, chamado de ggrepel, que lida com isso de forma bem simples!O pacote ggrepel fornece duas novas funções, geom_label_repel() e geom_text_repel(), que substituem geom_label() e geom_text(). Simplesmente utilize estas funções, em vez das originais ggplot2, para produzir rótulos claros e bonitos. Dentro da função, mapeie estética aes() como sempre, mas inclua o argumento label =, onde você fornece coluna com os valores que quer mostrar (ex.: id paciente, ou nome, etc). Você pode criar mais rótulos complexos ao combinar colunas e linhas novas (\\n) dentro de str_glue(), como mostrado abaixo.Algumas dicas:Use min.segment.length = 0 para sempre desenhar segmentos de linhas, ou min.segment.length = Inf para nunca desenhá-losUse size = fora de aes() para ajustar o tamanho textoUse force = para mudar o grau de repulsão entre os rótulos e seus respectivos pontos (padrão é 1)Inclua fill = dentro de aes() para ter os rótulos coloridos de acordo com os valores\nletra “” pode aparecer na legenda - adicione guides(fill = guide_legend(override.aes = aes(color = NA)))+ para removê-la\nletra “” pode aparecer na legenda - adicione guides(fill = guide_legend(override.aes = aes(color = NA)))+ para removê-laVeja esse detalhado tutorial para mais detalhes.Você pode rotular apenas um subconjunto dos dados - ao utilizar sintaxe padrão ggplot() para fornecer diferentes data = para cada camada geom gráfico. Abaixo, todos os casos são colocados gráfico, mas apenas alguns são rotulados.","code":"\npacman::p_load(ggrepel)\n\nlinelist %>%                                               # comece com a linelist\n  group_by(hospital) %>%                                   # agrupe por hospital\n  summarise(                                               # crie um novo conjunto de dados com o resumo dos valores por hospital\n    n_cases = n(),                                           # número de casos por hospital\n    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # demora média por hospital\n  ) %>% \n  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # envie o quadro de dados para o ggplot\n  geom_point(size = 2)+                                    # adicione os pontos\n  geom_label_repel(                                        # adicione os rótulos dos pontos\n    mapping = aes(\n      label = stringr::str_glue(\n        \"{hospital}\\n{n_cases} casos, {delay_mean} dias\")  # como o rótulo é mostrado\n      ), \n    size = 3,                                              # tamanho do texto nos rótulos\n    min.segment.length = 0)+                               # mostre todos os segmentos de linhas\n  labs(                                                    # adicione os rótulos dos eixos\n    title = \"Tempo médio de espera para admissão, por hospital\",\n    x = \"Número de casos\",\n    y = \"Tempo médio de espera (dias)\")\nggplot()+\n  # Todos os pontos em cinza\n  geom_point(\n    data = linelist,                                   # todos os dados fornecidos para essa camada\n    mapping = aes(x = ht_cm, y = wt_kg),\n    color = \"grey\",\n    alpha = 0.5)+                                              # cinza e semi-transparente\n  \n  # Poucos pontos em preto\n  geom_point(\n    data = linelist %>% filter(days_onset_hosp > 15),  # dados filtrados nesta camada\n    mapping = aes(x = ht_cm, y = wt_kg),\n    alpha = 1)+                                                # padrão preto e não transparente\n  \n  # rótulos de pontos para alguns pontos\n  geom_label_repel(\n    data = linelist %>% filter(days_onset_hosp > 15),  # filtre os dados para os rótulos\n    mapping = aes(\n      x = ht_cm,\n      y = wt_kg,\n      fill = outcome,                                          # cor dos rótulos por desfecho\n      label = stringr::str_glue(\"Demora: {days_onset_hosp}d\")), # rótulo criado com str_glue()\n    min.segment.length = 0) +                                  # mostre os segmentos de linha para todos\n  \n  # remova a letra \"a\" de dentro das caixas de legenda\n  guides(fill = guide_legend(override.aes = aes(color = NA)))+\n  \n  # rótulos dos eixos\n  labs(\n    title = \"Casos com longa demora até admissão\",\n    y = \"peso (kg)\",\n    x = \"altura (cm)\")"},{"path":"ggplot-tips.html","id":"eixos-de-tempo","chapter":"29 Dicas do ggplot","heading":"29.7 Eixos de tempo","text":"Trabalhar com eixos de tempo ggplot pode ser cansativo, mas é mais fácil com algumas funções chave. Lembre que, ao trabalhar com tempo ou datas, você deve garantir que variáveis corretas estejam formatadas como das classes date ou datetime - veja página Trabalhando com datas para mais informações, ou página Curvas epidêmicas, na seção sobre o ggplot, para exemplos.O conjunto de funções mais útil para trabalhar com datas ggplot2 são funções de escala (scale_x_date(), scale_x_datetime(), e os seus cognatos eixo y). Estas funções permitem definir frequência dos rótulos dos eixos, e como formatar esses rótulos. Para descobrir como formatar datas, veja seção working dates novamente! Você pode utilizar os argumentos date_breaks e date_labels para especificar como datas devem aparecer:date_breaks permite especificar frequência das quebras dos eixos - você pode utilizar uma string (ex.: \"3 months\", ou “2 days\")date_breaks permite especificar frequência das quebras dos eixos - você pode utilizar uma string (ex.: \"3 months\", ou “2 days\")date_labels permite definir o formato das datas mostradas. Você pode utilizar uma string de formatação de datas (ex.: \"%b-%d-%Y\"):date_labels permite definir o formato das datas mostradas. Você pode utilizar uma string de formatação de datas (ex.: \"%b-%d-%Y\"):","code":"\n# crie uma epicurva por data de início dos sintomas, quando disponível\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    # 1 quebra a cada mês\n    date_breaks = \"1 months\",\n    # rótulos devem mostrar o mês, então a data\n    date_labels = \"%b %d\"\n  ) +\n  theme_classic()"},{"path":"ggplot-tips.html","id":"destacando","chapter":"29 Dicas do ggplot","heading":"29.8 Destacando","text":"Destacar elementos específicos em um gráfico é uma forma útil de chamar atenção para algo nos dados, enquanto também fornece informação na distribuição dos dados conjunto inteiro. Embora isto não seja feito de forma fácil ggplot2 básico, existe um pacote externo que pode ajudar nisso, conhecido como gghighlight. Ele é fácil de usar dentro da sintaxe ggplot.O pacote gghighlight utiliza função gghighlight() para realizar os destaques. Para usar esta função, forneça um argumento lógico - o que pode ter muitos desfechos, mas iremos mostrar um exemplo da distribuição de idade dos casos em nosso linelist, ao destacar pelo desfecho clínico.Isto também funciona bem com funções de facetas - ele permite produção de gráficos facetados com os dados fundo em destaque, mas que não se aplica à faceta! Abaixo, nós contamos os casos por semana e criamos uma curva epidêmica por hospital (color = e facet_wrap() ajustado para coluna hospital).","code":"\n# carregue o pacote gghighlight\nlibrary(gghighlight)\n\n# substitua os valores NA por \"unknown\" na variável de desfecho\nlinelist <- linelist %>%\n  mutate(outcome = replace_na(outcome, \"Unknown\"))\n\n# produza um histograma de todos os casos de acordo com a idade\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, fill = outcome)) +\n  geom_histogram() + \n  gghighlight::gghighlight(outcome == \"Death\")     # destaque as situações onde o desfecho do paciente foi óbito.\n# produz um histograma de todos os casos por idade\nlinelist %>% \n  count(week = lubridate::floor_date(date_hospitalisation, \"week\"),\n        hospital) %>% \n  ggplot()+\n  geom_line(aes(x = week, y = n, color = hospital))+\n  theme_minimal()+\n  gghighlight::gghighlight() +                      # destaque as situações em que o paciente morreu\n  facet_wrap(~hospital)                              # crie facetas de acordo com o desfecho"},{"path":"ggplot-tips.html","id":"criando-gráficos-de-múltiplos-conjuntos-de-dados","chapter":"29 Dicas do ggplot","heading":"29.9 Criando gráficos de múltiplos conjuntos de dados","text":"Observe que alinhar adequadamente os eixos para criar gráficos de conjuntos de dados múltilos mesmo gráfico pode ser difícil. Considere uma das seguintes estratégias:Una os dados antes de criar o gráfico, e então converta para o formato “longo” com uma coluna associando os dadosUse cowplot ou um pacote similar para combinar dois gráficos (veja abaixo)","code":""},{"path":"ggplot-tips.html","id":"combine-os-gráficos","chapter":"29 Dicas do ggplot","heading":"29.10 Combine os gráficos","text":"Dois pacotes bem úteis para combinar gráficos são o cowplot e o patchwork. Nesta página, iremos focar cowplot, e, ocasionalmente, usaremos o patchwork.Aqui está uma introdução ao cowplot. Você pode ler documentação mais extensa para cada função aqui. Nós iremos mostrar alguns dos casos de uso e funções mais comuns seguir.O pacote cowplot funciona em tandem com ggplot2 - essencialmente, você o utiliza para organizar e combinar ggplots e suas legendas em figuras compostas. Este pacote também aceita gráficos R base.Enquanto facetear (descrito na página Básico ggplot) é uma abordagem conveniente para criar gráficos, vezes não é possível obter os resultados desejados com essa abordagem. Aqui, você pode escolher combinar os gráficos ao uni-los em um gráfico maior. Existem três pacotes bem conhecidos, que são ótimos para isso - cowplot, gridExtra, e patchwork. Entretanto, estes pacotes fazem basicamente mesma coisa, de forma que iremos focar cowplot nesta seção.","code":"\npacman::p_load(\n  tidyverse,      # manipulação e visualização de dados\n  cowplot,        # combine os gráficos\n  patchwork       # combine os gráficos\n)"},{"path":"ggplot-tips.html","id":"plot_grid","chapter":"29 Dicas do ggplot","heading":"plot_grid()","text":"O pacote cowplot tem uma grande variedade de funções, mas o uso mais fácil dele é com plot_grid(). Isto é, efetivamente, uma forma de organizar gráficos pré-definidos em forma de uma rede. Nós podemos aplicar em outro exemplo com os dados de malária - aqui nós fizemos um gráfico com o total de casos por distrito, e também mostramos curva epidêmica pelo tempo.","code":"\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) \n\n# gráfico do total de casos por distrito\np1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"Distrito\",\n    y = \"Número total de casos\",\n    title = \"Quantidade total de casos de malária por distrito\"\n  ) +\n  theme_minimal()\n\n# curva epidêmica pelo tempo\np2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1) +\n  labs(\n    x = \"Data de envio dos dados\",\n    y =  \"número de casos\"\n  ) +\n  theme_minimal()\n\ncowplot::plot_grid(p1, p2,\n                  # 1 coluna e duas linhas - empilhadas uma sobre a outra\n                   ncol = 1,\n                   nrow = 2,\n                   # gráfico de cima é 2/3 da altura do segundo\n                   rel_heights = c(2, 3))"},{"path":"ggplot-tips.html","id":"combine-as-legendas","chapter":"29 Dicas do ggplot","heading":"Combine as legendas","text":"Caso os seus gráficos tenham mesma legenda, combina-las é relativamente fácil. Simplesmente use abordagem acima cowplot para combinar os gráficos, mas remova legenda de um deles (de-duplique).Caso seus gráficos tenham legendas diferentes, você precisa usar uma abordagem alternativa:Crie e salve seus gráficos sem legendas utilizando theme(legend.position = \"none\")Extraia legendas de cada gráfico utilizando get_legend(), como mostrado abaixo - mas extraia legendas dos gráficos modificados para, na verdade, mostrar legendaCombine legendas em um painel de legendasCombine os gráficos e o painel de legendasPara fins de demonstração, primeiro mostramos os dois gráficos separados, e, então organizados em uma grade com suas próprias legendas (feio e uso ineficiente de espaço):Aqui esta como os dois gráficos ficam quando combinados usando plot_grid(), mas sem combinar suas legendas:E agora nós mostramos como combinar legendas. Essencialmente, o que fazemos é criar cada gráfico sem sua legenda (theme(legend.position = \"none\"), e então definimos cada legenda dos gráficos separadamente, usando função get_legend() cowplot. Quando extraimos legenda gráfico salvo, precisamos adicionar + legenda de volta, incluindo o argumento de posição (“right”) e ajustes menores para alinhar legendas e seus títulos. Então, combinamos legendas verticalmente, e os dois gráficos com nova legenda combinada. Voilà!Esta solução foi apresentada neste post com pequenos ajustes para alinhar legendas deste post.DICA: Nota interessante - o “cow” cowplot vem nome criador pacote - Claus O. Wilke.","code":"\np1 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  labs(title = \"Casos por desfecho clínico\")\n\n\np2 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, age_cat) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(axis.text.y = element_blank())+\n  labs(title = \"Casos por idade\")\ncowplot::plot_grid(p1, p2, rel_widths = c(0.3))\n# Crie o gráfico 1 sem a legenda\np1 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(legend.position = \"none\")+\n  labs(title = \"Casos por desfecho clínico\")\n\n\n# Crie o gráfico 2 sem a legenda\np2 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, age_cat) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank()\n  )+\n  labs(title = \"Casos por idade\")\n\n\n# extraia a legenda do gráfico 1 (de gráfico1 + legenda)\nleg_p1 <- cowplot::get_legend(p1 +\n                                theme(legend.position = \"right\",        # extraia a legenda vertical\n                                      legend.justification = c(0,0.5))+ # de forma que as legendas alinhem\n                                labs(fill = \"Desfecho\"))                 # título da legenda\n# extraia a legenda do gráfico 2 (de gráfico 2 + legend)\nleg_p2 <- cowplot::get_legend(p2 + \n                                theme(legend.position = \"right\",         # extraia a legenda vertical\n                                      legend.justification = c(0,0.5))+  # de forma que as legendas alinhem\n                                labs(fill = \"Categoria de idade\"))             # título da legenda\n\n# crie um gráfico em branco para alinhar a legenda\n#blank_p <- patchwork::plot_spacer() + theme_void()\n\n# crie um painel de legendas, pode ser um sobre o outro (ou utilize o espaçados comentado acima)\nlegends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))\n\n# combine os dois gráficos e o painel de legendas criado\ncombined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))\n\ncombined  # visualize o gráfico"},{"path":"ggplot-tips.html","id":"inserção-de-gráficos","chapter":"29 Dicas do ggplot","heading":"Inserção de gráficos","text":"Você pode inserir um gráfico em outros utilizando cowplot. Aqui estão pontos para estar ciente:Defina o gráfico principal com theme_half_open(), cowplot; é recomendado colocar legenda topo ou na base gráficoDefina o gráfico ser inserido. O melhor é usar um gráfico que não precise de legenda. Você pode remover os elementos de tema deste gráfico com element_blank(), como mostrado abaixo.Os combine ao aplicar função ggdraw() gráfico principal, e então adicionando draw_plot() gráfico ser inserido, e especificando coordenadas (x e y da extremidade baixa esquerda), altura e comprimento proporcionais ao tamanho gráfico principal.Esta técnica é melhor explicada nestes dois resumos:Wilke labDocumentação draw_plot()","code":"\n# Defina o gráfico principal\nmain_plot <- ggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset, fill = hospital))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+ \n  theme_half_open()+\n  theme(legend.position = \"bottom\")+\n  labs(title = \"Curva epidêmica e desfechos clínicos por hospital\")\n\n\n# Crie o gráfico a ser inserido\ninset_plot <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n    scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n    coord_flip()+\n    theme_minimal()+\n    theme(legend.position = \"none\",\n          axis.title.y = element_blank())+\n    labs(title = \"Casos por desfecho\") \n\n\n# Combine o gráfico principal com o gráfico a ser inserido\ncowplot::ggdraw(main_plot)+\n     draw_plot(inset_plot,\n               x = .6, y = .55,    #x = .07, y = .65,\n               width = .4, height = .4)"},{"path":"ggplot-tips.html","id":"eixos-duplos","chapter":"29 Dicas do ggplot","heading":"29.11 Eixos duplos","text":"Um segundo eixo y é, frequentemente, solicitado em um gráfico ggplot2. Embora existam fortes debates sobre validade destes gráficos na comunidade de visualização de dados, em que geralmente não são recomendados, o seu chefe pode requisitá-los. Abaixo, apresentamos um método para obtê-los: utilizando o pacote cowplot para combinar dois gráficos separados.Esta abordagem envolve criar dois gráficos distintos - um com um eixo y na esquerda, e outro com o eixo y na direita. Ambos utilizarão um específico theme_cowplot() e terão o mesmo eixo x. Então, em um terceiro comando, os dois gráficos serão alinhados e sobrepostos. funcionalidades cowplot, das quais esta é apenas uma delas, são descritas em detalhes neste site.Para demonstrar esta técnica, iremos sobrepor uma curva epidêmica com uma linha de porcentagem semanal de pacientes que morreram. Nós usamos este exemplo pois o alinhamento de datas eixo x é mais complexo que, digamos, alinhar um gráfico de barras com outro gráfico. Algumas coisas serem observadas:epicurva e linha são agregadas em semanas antes de criarmos os gráficos, e os date_breaks e date_labels são idênticos - nós fizemos isto de forma que os eixos x dos dois gráficos é o mesmo quando sobrepostos.O eixo y é movido para o lado direito, gráfico 2, com o argumento position = de scale_y_continuous().Ambos gráficos fazem uso theme_cowplot()Note que existe outro exemplo dessa técnica na página Curvas epidêmicas - sobreposição da incidência acumulada acima da epicurva.Crie o primeiro gráfico\nEste é, essencialmente, uma epicurva. Nós utilizamos geom_area() apenas para demonstrar o seu uso (área abaixo de uma linha, por padrão)Crie o segundo gráfico\nCrie o segundo gráfico mostrando uma linha com porcentagem semanal de óbitos.Agora alinhamos o gráfico usando função align_plots(), especificando os alinhamentos horizontal e vertical (“hv”, poderia também ser “h”, “v”, “none”). Também especificamos o alinhamento de todos os eixos (“top”, “bottom”, “left”, e “right”) com “tblr”. O resultado é da classe list (2 elementos).Então, desenhamos os dois gráficos juntos utilizando ggdraw() (cowplot) e referenciando outras duas partes objeto aligned_plots.","code":"\npacman::p_load(cowplot)            # carregue/instale o cowplot\n\np1 <- linelist %>%                 # salve o gráfico como um objeto\n     count(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %>% \n     ggplot()+\n          geom_area(aes(x = epiweek, y = n), fill = \"grey\")+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n     theme_cowplot()+\n     labs(\n       y = \"Casos semanais\"\n     )\n\np1                                      # veja o gráfico \np2 <- linelist %>%         # salve seu gráfico como um objeto\n     group_by(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %>% \n     summarise(\n       n = n(),\n       pct_death = 100*sum(outcome == \"Death\", na.rm=T) / n) %>% \n     ggplot(aes(x = epiweek, y = pct_death))+\n          geom_line()+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n          scale_y_continuous(\n               position = \"right\")+\n          theme_cowplot()+\n          labs(\n            x = \"Semana epidemiológica de aparecimento dos sintomas\",\n            y = \"Percentual semanal de mortes\",\n            title = \"Incidência semanal de casos e percentual de mortes\"\n          )\n\np2     # veja o gráfico\naligned_plots <- cowplot::align_plots(p1, p2, align=\"hv\", axis=\"tblr\")         # alinhe os dois gráficos e os salve como uma lista\naligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # sobreponha os gráficos e salve o gráfico visualizado\naligned_plotted                                                                # visualize os gráficos sobrepostos"},{"path":"ggplot-tips.html","id":"pacotes-para-te-ajudar","chapter":"29 Dicas do ggplot","heading":"29.12 Pacotes para te ajudar","text":"Existem ótimos pacotes R desenhados especificamente para ajudar navegar ggplot2:","code":""},{"path":"ggplot-tips.html","id":"aponte-e-clique-no-ggplot2-com-equisse","chapter":"29 Dicas do ggplot","heading":"Aponte-e-clique no ggplot2 com equisse","text":"“Este complemento permite que você explore seus dados de forma interativa, ao visualiza-los com o pacote ggplot2. Ele permite desenhar gráficos de barras, curvas, gráficos de dispersão, hsitogramas, boxplots e objetos sf, e, então, exportar o gráfico e gerar o código de geração gráfico.”Instale e então o execute o pacote por meio menu RStudio ou com esquisse::esquisser().Veja página GithubDocumentação","code":""},{"path":"ggplot-tips.html","id":"dicas-diversas","chapter":"29 Dicas do ggplot","heading":"29.13 Dicas diversas","text":"","code":""},{"path":"ggplot-tips.html","id":"exibição-dos-números","chapter":"29 Dicas do ggplot","heading":"Exibição dos números","text":"Você pode desabilitar notação científica ao executar este comando antes de criar o gráfico.Ou aplicar number_format(), pacote scales, para um valor ou coluna específica, como mostrado abaixo.Use funções pacote scales para facilmente ajustar como os números são mostrados. Isto pode ser aplicado para colunas em seus dados, mas aqui são mostrados em números individuais para fins de exemplo.","code":"\noptions(scipen=999)\nscales::number(6.2e5)## [1] \"620 000\"\nscales::number(1506800.62,  accuracy = 0.1,)## [1] \"1 506 800.6\"\nscales::comma(1506800.62, accuracy = 0.01)## [1] \"1,506,800.62\"\nscales::comma(1506800.62, accuracy = 0.01,  big.mark = \".\" , decimal.mark = \",\")## [1] \"1.506.800,62\"\nscales::percent(0.1)## [1] \"10%\"\nscales::dollar(56)## [1] \"$56\"\nscales::scientific(100000)## [1] \"1e+05\""},{"path":"ggplot-tips.html","id":"recursos-extras-3","chapter":"29 Dicas do ggplot","heading":"29.14 Recursos extras","text":"Para inspiração,\ngaleria de gráficos ggplotRecomendação de formas de apresentação de dados\nCentro Europeu de Prevenção e Controle de Doenças Recomendações para apresentação de dados de vigilânciaFacetas e rotuladores\nUtilizando rotuladores para feixes de facetas\nRotuladoresAjustando ordem com factors\nfct_reorderfct_inorderComo reordenar um boxplotReordene uma variável ggplot2R para Ciência dos Dados - FactorsLegendasAjuste ordem da legendaTítulos\nAlinhamento títuloRótulosggrepelColinhas\nLindos gráficos com ggplot2","code":""},{"path":"epicurves.html","id":"epicurves","chapter":"30 Curvas epidêmicas","heading":"30 Curvas epidêmicas","text":"Uma curva epidêmica (também conhecida como “epicurva”) é uma ferramenta essencial tipicamente utilizada para visualizar padrões temporais início de doenças entre um conjunto ou epidemia de casos.análise da epicurva pode revelar tendências temporais, anomalias/valores discrepantes (“outliers”), magnitude de um surto, o período mais provável de exposição, intervalos temporais entre picos de casos, e pode até ajudar identificar o modo de transmissão de uma doença não identificada (ex.: fonte pontual, fonte comum contínua, propagação pessoa-pessoa). Uma aula online sobre interpretação de epicurvas pode ser encontrada website CDC americano.Nesta página, nós demonstraremos duas abordagens para produção de curvas epidêmicas R:O pacote incidence2, que pode produzir uma epicurva com comandos simplesO pacote ggplot2, que permite customizações avançadas através de comandos mais complexosTambém serão abordados casos de uso específico:Criar gráficos de contagem agregadaMostrar ou produzir múltiplos-pequenosAplicar médias móveisMostrar quais dados são “preliminares” ou sujeitos atrasos na notificaçãoSobreposição da incidência acumulada de casos usando um segundo eixo gráfico","code":""},{"path":"epicurves.html","id":"preparação-20","chapter":"30 Curvas epidêmicas","heading":"30.1 Preparação","text":"","code":""},{"path":"epicurves.html","id":"carregue-os-pacotes-necessários","chapter":"30 Curvas epidêmicas","heading":"Carregue os pacotes necessários","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  rio,          # importar/exportar arquivos\n  here,         # caminhos de arquivos relativos \n  lubridate,    # trabalhando com datas/semanas epidemiológicas\n  aweek,        # pacote alternativo para trabalhar com datas/semanas epidemiológicas\n  incidence2,   # epicurvas de dados em uma linelist\n  i2extras,     # suplemento para o pacote incidence2\n  stringr,      # procure e manipule strings de caracteres\n  forcats,      # trabalhando com fators\n  RColorBrewer, # paleta de cores do colorbrewer2.org\n  tidyverse     # gerenciamento de dados + gráficos no ggplot2\n) "},{"path":"epicurves.html","id":"importe-os-dados-5","chapter":"30 Curvas epidêmicas","heading":"Importe os dados","text":"Dois exemplos de conjuntos de dados são utilizados nesta seção:Lista de linhas (linelist) com casos individuais de uma simulação de epidemiaContagens agregadas por hospital da mesma epidemia simuladaOs conjuntos de dados são importados utilizando função import() pacote rio. Veja página sobre Importar e exportar para conhecer diferentes formas de importar dados.Lista de linhas de casosNós importamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser baixar os dados para acompanhar etapa-por-etapa, veja instruções na página sobre Download manual e dados. Aqui, nós assumimos que o arquivo está diretório de trabalho. Logo, nenhuma sub-pasta é especificada endereço arquivo.primeiras 50 linhas são mostradas abaixo.Casos agregados por hospitalPara atingir os propósitos deste manual, o conjunto de dados de contagens semanais de casos agregados por hospital é criado partir da linelist, com o seguinte código.primeiras 50 linhas são mostradas abaixo:","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")\n# cria os dados de contagem no R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()"},{"path":"epicurves.html","id":"ajuste-os-parâmetros","chapter":"30 Curvas epidêmicas","heading":"Ajuste os parâmetros","text":"Para produzir um relatório, você pode querer ajustar parâmetros modificáveis, como data para qual os dados são atuais (“data dos dados”). Você pode, então, referenciar o objeto data_date em seu código ao aplicar filtros ou em legendas dinâmicas.","code":"\n## ajuste a data do relatório para o relatório\n## nota: pode ser ajustada para Sys.Date() para a data atual\ndata_date <- as.Date(\"2015-05-15\")"},{"path":"epicurves.html","id":"verifique-as-datas","chapter":"30 Curvas epidêmicas","heading":"Verifique as datas","text":"Perceba que cada coluna de datas relevantes é da classe Date e tem um intervalo apropriado de valores. Você pode fazer isso simplesmente utilizando hist(), para histograma, ou range() com na.rm=TRUE, ou com o ggplot(), como mostrado abaixo.","code":"\n# cheque o intervalo das datas de início dos sintomas\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))"},{"path":"epicurves.html","id":"epicurvas-no-ggplot2","chapter":"30 Curvas epidêmicas","heading":"30.2 Epicurvas no ggplot2","text":"Utilizar o ggplot() para criar sua epicurva permite mais flexibilidade e customização. Entretanto, é necessário mais esforço e entendimento sobre como o ggplot() funciona.Diferente pacote incidence2, ggplot você precisa controlar manualmente agregação dos casos pelo tempo (em semanas, meses, etc) e os intervalos dos rótulos eixo de data. Isto precisa ser cuidadosamente gerenciado.Os exemplos abaixo utilizam um subconjunto banco de dados linelist - apenas os casos Hospital Central.Para produzir uma epicurva com o ggplot(), existem três elementos principais:Um histograma, com os casos da linelist agregados em “classes” (Nota tradutor: tradução livre de ´bins´, que em inglês significa caixa, ou container) separados por pontos “de quebra” específicosEscalas para os eixos e seus rótulosTemas para aparência gráfico, incluindo títulos, rótulos, legendas, etc.","code":"\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")"},{"path":"epicurves.html","id":"especifique-as-classes-de-casos","chapter":"30 Curvas epidêmicas","heading":"Especifique as classes de casos","text":"Aqui nós mostramos como especificar maneira em que os casos serão agregados nas classes histogramas (“barras”). É importante reconhecer que o agrupamento dos casos nessas classes histograma não será necessariamente nos mesmos intervalos das datas que irão aparecer eixo x.seguir é mostrado, provavelmente, o código mais simples para produzir epicurvas diárias ou semanais.comando global ggplot(), o conjunto de dados é fornecido em data =. partir disto, geometria histrograma é adicionada com um +. Dentro de geom_histogram(), nós mapeamos aparência gráfico de forma que coluna date_onset é mapeada para o eixo x. Também dentro de geom_histogram(), mas não dentro de aes(), nós ajustamos o binwidth = dos containers histobrama, em dias. Se essa sintaxe ggplot2 é confusa, revise página sobre básico ggplot.CUIDADO: Criar um gráfico de casos semanas ao utilizar binwidth = 7 inicia o primeiro container de 7-dias primeiro caso, que pode ser em qualquer dia da semana! Para criar semanas específicas, veja seção abaixo.Deixe-nos observar que o primeiro caso neste conjunto de dados Hospital Central teve o início dos sintomas em:Para especificar manualmente quebras das classes histograma, não utilize o argumento binwidth =, e, em vez disso, forneça um vetor de datas para breaks =.Crie o vetor de datas com função seq.Date() R base. Esta função precisa dos argumentos =, =, e =. Por exemplo, o comando abaixo retorna datas mensais começando em 15 de janeiro e terminando em 28 de junho.Este vetor pode ser fornecido para geom_histogram() como breaks =:Uma sequência semanal simples pode ser obtida ao ajustar = \"week\". Por exemplo:Uma alternativa para o fornecimento de datas específicas de início e fim, é escrever um código dinâmico de forma que classes semanais iniciem na segunda antes primeiro caso. Nós iremos utilizar estes vetores de data nos exemplos abaixo.Vamos destrinchar o código complicado mostrado acima:O valor “” (data mais antiga da sequência) é criado da seguinte forma: menor data (min() com na.rm=TRUE) na coluna date_onset é atribuída floor_date(), pacote lubridate. floor_date() é ajustada para gerar “semanas” partir da data de início dos casos da “semana” em questão, considerando que o dia de início de cada semana é segunda (week_start = 1).Da mesma forma, o valor “” (data final da sequência) é criado utilizando função inversa ceiling_date() para retornar segunda após o último caso.O argumento “” de seq.Date() pode ser ajustado para qualquer número de dias, semanas, ou meses.Utilize week_start = 7 para semanas que iniciem DomingoComo iremos utilizar estes vetores de data nesta página, nós também definimos um vetor para o surto inteiro (o vetor acima é apenas para os casos Hospital Central).Estas saídas seq.Date() podem ser usadas para criar quebras de classes histogramas, assim como quebras para os rótulos de data, que podem ser independentes das primeiras. Leia mais sobre os rótulos de datas em seções posteriores.DICA: Para um comando ggplot() mais simples, salve quebras das classes e quebras dos rótulos de datas como vetores nomeados começo, e simplesmente os forneça em breaks =.","code":"\n# diariamente \nggplot(data = central_data) +          # escolha os dados\n  geom_histogram(                      # adicione o histograma\n    mapping = aes(x = date_onset),     # mapeia a coluna de data para o eixo x\n    binwidth = 1)+                     # casos unidos por 1 dia\n  labs(title = \"Hospital Central - Diariamente\")                # título\n\n# semanal\nggplot(data = central_data) +          # escolha os dados \n  geom_histogram(                      # adicione o histograma\n      mapping = aes(x = date_onset),   # mapeia a coluna de data para o eixo x\n      binwidth = 7)+                   # casos unidos a cada 7 dias, iniciando no primeiro caso (!)\n  labs(title = \"Hospital Central - classes de 7-dias, iniciando no primeiro caso\") # título\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")## [1] \"Thursday 01 May, 2014\"\nmonthly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # exporta para o console##  [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\" \"2014-07-01\"\n##  [7] \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\" \"2014-12-01\" \"2015-01-01\"\n## [13] \"2015-02-01\" \"2015-03-01\" \"2015-04-01\" \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n# mensalmente \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # forneça um vetor pré-definido de quebras\n  labs(title = \"Classe de casos mensais\")   # título\nweekly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n# Sequência de datas semanais iniciando nas Segundas para o HOSPITAL CENTRAL\nweekly_breaks_central <- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # segunda anterior\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # segunda após o último caso\n  by   = \"week\")\n# Sequência para o surto inteiro\nweekly_breaks_all <- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # segunda antes do primeiro caso\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # segunda após o último caso\n  by   = \"week\")"},{"path":"epicurves.html","id":"exemplo-de-epicurva-semanal","chapter":"30 Curvas epidêmicas","heading":"Exemplo de epicurva semanal","text":"Abaixo esta detalhado um exemplo de código utilizado para produzir epicurvas semanais para semanas que iniciam nas segundas, com barras alinhadas, rótulos de data, e linhas de grade verticais. Esta seção é para o usuário que precisa rapidamente de um código. Para entender cada aspecto (temas, rótulos de datas, etc.) profundamente, continue para seções subsequentes. De nota:quebras dos containers histograma são definidas com seq.Date(), como explicado acima, para iniciar na segunda anterior ao primeiro caso, e para terminar na segunda posterior ao último casoO intervalo dos rótulos de data é especificado por date_breaks = dentro de scale_x_date()O intervalo de linhas da grade vertical menores entre os rótulos de data é especificado em date_minor_breaks =expand = c(0,0) nas escalas de x e y remove o excesso de espaço em cada lado dos eixos, o que também garante que os rótulos de data iniciem partir da primeira barra.","code":"\n# ALINHAMENTO TOTAL A PARTIR DAS SEGUNDAS-FEIRAS\n#############################\n# Defina a sequência de quebras semanais\nweekly_breaks_central <- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Segunda antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Segunda após último caso\n      by   = \"week\")    # containers são de 7-dias\n\n\nggplot(data = central_data) + \n  \n  # crie o histograma: especifique os pontos de quebra do container: inicie na segunda antes do primeiro caso, termine na segunda após o último caso\n  geom_histogram(\n    \n    # mapeando a estética do gráfico\n    mapping = aes(x = date_onset),  # coluna de data mapeada para o eixo x\n    \n    # quebras da classe do histograma\n    breaks = weekly_breaks_central, # quebras do container do histograma definidas anteriormente\n    \n    # barras\n    color = \"darkblue\",     # cor das linhas ao redor das barras\n    fill = \"lightblue\"      # cor do preenchimento das barras\n  )+ \n    \n  # rótulos do eixo x\n  scale_x_date(\n    expand            = c(0,0),           # remove o espaço em excesso do eixo x antes e após as barras de casos\n    date_breaks       = \"4 weeks\",        # rótulos de data e principais linhas de grade verticais aparecem a cada 3 semanas iniciando nas segundas\n    date_minor_breaks = \"week\",           # linhas de grade menores aparecem a cada semana iniciando na segunda\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # formato dos rótulos de data\n  \n  # eixo y\n  scale_y_continuous(\n    expand = c(0,0))+             # remove o excesso de espaço do eixo y abaixo de 0 (alinha o histograma nivelado com o eixo x)\n  \n  # temas estéticos\n  theme_minimal()+                # simplifique o fundo do gráfico\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # legenda no lado esquerdo\n                                face = \"italic\"), # legenda em itálico\n    axis.title = element_text(face = \"bold\"))+    # título dos eixos em negrito\n  \n  # rótulos incluindo legendas dinâmicas\n  labs(\n    title    = \"Incidência semanal de casos (Semanas iniciadas na segunda)\",\n    subtitle = \"Observe o alinhamento das barras, linhas de grade verticais, e rótulos dos eixos nas semanas iniciadas na segunda\",\n    x        = \"Semana de aparecimetno dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados neste gráfico\"))"},{"path":"epicurves.html","id":"semanas-iniciando-no-domingo","chapter":"30 Curvas epidêmicas","heading":"Semanas iniciando no domingo","text":"Para obter o gráfico acima para semanas que iniciam domingo, algumas poucas modificações são necessárias, uma vez que o date_breaks = \"weeks\" funciona apenas para semanas iniciando às segundas.Os pontos de quebra das classes histograma precisam serem ajustados para os domingos (week_start = 7)Dentro de scale_x_date(), datas de quebra similares devem ser fornecidas para breaks = e minor_breaks =, visando garantir que os rótulos de data e linhas de grade verticais alinhem nos domingos.Por exemplo, o comando scale_x_date(), para semanas iniciando nos domingos, pode ser semelhante ao seguinte:","code":"\nscale_x_date(\n    expand = c(0,0),\n    \n    # especifique o intervalo do rótulo de datas e das linhas de grade principais\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Domingo antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Domingo após o último caso\n      by   = \"4 weeks\"),\n    \n    # especifique o intervalo das linhas de grade vertical secundárias\n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Domingo antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Domingo após o último caso\n      by   = \"week\"),\n   \n    # formato do rótulo de data\n    #date_labels = \"%a\\n%d %b\\n%Y\")+         # dia, mês acima abreviado, sobre o ano com 2-dígitos\n    label = scales::label_date_short())"},{"path":"epicurves.html","id":"grupocor-por-valor","chapter":"30 Curvas epidêmicas","heading":"Grupo/cor por valor","text":"barras histograma podem ser coloridas por grupo e podem ser “empilhadas” (o inglês stacked). Para designar coluna de agrupamento, faça seguintes modificações. Veja página sobre básico ggplot para mais detalhes.Dentro mapeamento estético histograma, aes(), mapeie o nome da coluna para os argumentos group = e fill =Remova qualquer argumento de fill = fora de aes(), uma vez que irá sobrepor-se ao argumentos que estão dentroArgumentos dentro de aes() serão aplicados por grupo, enquanto qualquer argumento fora será aplicado para todas barras (ex.: você pode querer color = fora, de forma que cada barra tenha mesma borda)Aqui é mostrado como o comando aes() pode ser utilizado para agrupar e colorir barras de acordo com o gênero:seguir, ele sendo aplicado:","code":"\naes(x = date_onset, group = gender, fill = gender)\nggplot(data = linelist) +     # comece com o linelist (muitos hospitais)\n  \n  # crie o histograma: especifique os pontos de ruptura dos containers: começe na segunda anterior ao primeiro caso, e finalize na segunda após o último caso\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # ajuste os dados para serem agrupados por hospital\n      fill = hospital),       # preenchimento da barra (cor de dentro) de acordo com o hospital\n    \n    # quebras dos contentores são nas semanas iniciadas nas segundas\n    breaks = weekly_breaks_all,   # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido em código anterior\n    \n    # Cor ao redor das barras\n    color = \"black\")"},{"path":"epicurves.html","id":"ajuste-as-cores","chapter":"30 Curvas epidêmicas","heading":"Ajuste as cores","text":"Para manualmente ajustar o preenchimento de cada grupo, utilize scale_fill_manual() (nota: scale_color_manual() é diferente!).\nUse o argumetno values = para aplicar um vetor de cores.\nUse o argumetno na.value = para especificar uma cor para os valores NA.\nUse o argumento labels = para mudar o texto dos itens da legenda. Por segurança, forneça como um vetor nomeado, como c(\"old\" = \"new\", \"old\" = \"new\") ou ajuste os valores nos próprios dados.\nUse name = para dar um título adequado à legenda\nUse o argumetno values = para aplicar um vetor de cores.Use o argumetno na.value = para especificar uma cor para os valores NA.Use o argumento labels = para mudar o texto dos itens da legenda. Por segurança, forneça como um vetor nomeado, como c(\"old\" = \"new\", \"old\" = \"new\") ou ajuste os valores nos próprios dados.Use name = para dar um título adequado à legendaPara mais dicas sobre escalas de cor e paletas, veja página sobre básico ggplot.","code":"\nggplot(data = linelist)+           # inicie com a linelist (muitos hospitais)\n  \n  # crie um histograma\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # casos agrupados por hospital\n        fill = hospital),          # barras preenchidas por hospital\n    \n    # quebra dos containers\n    breaks = weekly_breaks_all,        # sequência de quebras semanais iniciadas nas segundas, como definido em código anterior\n    \n    # Cor ao redor das barras\n    color = \"black\")+              # cor da borda para cada barra\n  \n  # especificação manual das cores\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # especifique as cores de preenchimento (\"values\") - atenção à ordem!"},{"path":"epicurves.html","id":"ajuste-a-ordem-dos-níveis","chapter":"30 Curvas epidêmicas","heading":"Ajuste a ordem dos níveis","text":"ordem em que barras agrupadas estão empilhadas é melhor ajustada ao se classificar coluna de agrupamento como sendo da classe fator (Factor). Você poderá, então, designar ordem dos níveis desse fator (e os rótulos mostrados). Veja página sobre Fatores ou dicas ggplot para mais detalhes.Antes de criar o gráfico, utilize função fct_relevel() pacote forcats para converter coluna de agrupamento para classe factor, e manualmente ajustar ordem dos níveis, como detalhado na página sobre Fatores.gráfico abaixo, única diferença gráfico anterior é que coluna hospital foi consolidada como mostrado acima, e nós utilizamos guides() para reverter ordem da legenda, de forma que “Missing” está fim da legenda.DICA: Para reverter apenas ordem da legenda, adicione o seguinte comando ggplot2: guides(fill = guide_legend(reverse = TRUE)).","code":"\n# carregue o pacote forcats para trabalhar com fators\npacman::p_load(forcats)\n\n# Defina um novo conjunto de dados com o hospital como fator\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Converta para fator e ajuste \"Missing\" e \"Other\" como níveis do topo para aparecerem no topo da epicurva## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))`.\n## Caused by warning:\n## ! 1 unknown level in `f`: Missing\nlevels(plot_data$hospital) # gere os níveis em ordem## [1] \"Other\"                                \"Ausente\"                             \n## [3] \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\nggplot(plot_data) +                     # Utilize um NOVO conjunto de dados com hospital reordenado como fator\n  \n  # crie o histograma\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # casos agrupados por hospital\n        fill = hospital),               # preenchimento da barra (cor) por hospital\n    \n    breaks = weekly_breaks_all,         # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido no topo da seção sobre ggplot\n    \n    color = \"black\")+                   # cor da borda ao redor de cada barra\n    \n  # rótulos do eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o excesso de espaço do eixo x antes e após as barras de casos\n    date_breaks       = \"3 weeks\",      # rótulos aparecem a cada 3 semanas que iniciam nas segundas\n    date_minor_breaks = \"week\",         # linhas verticais aparecem a cada semana iniciada na segunda\n    label = scales::label_date_short()) + # efficient date label\n  \n  # eixo y\n  scale_y_continuous(\n    expand = c(0,0))+                   # remova o espaço em excesso do eixo y abaixo de 0\n  \n  # especificação manual das cores, atenção para a ordem!\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # temas estéticos\n  theme_minimal()+                      # simplifique o fundo do gráfico\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # legenda no lado esquerdo em itálico\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # títulos dos eixos em negrito\n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos por hospital\",\n    subtitle = \"Hospital como um factor re-ordenado\",\n    x        = \"Semana de aparecimento dos sintomas\",\n    y        = \"Casos semanais\")"},{"path":"epicurves.html","id":"ajuste-a-legenda","chapter":"30 Curvas epidêmicas","heading":"Ajuste a legenda","text":"Leia mais sobre legendas e escalas página sobre dicas ggplot. Aqui estão alguns destaques:Edite o título da legenda por meio da função de escala ou com labs(fill = \"Legend title\") (se você estiver estilizando com color =, utilize labs(color = \"\"))theme(legend.title = element_blank()) para não ter título de legendatheme(legend.position = \"top\") para legenda acima gráfico. Pode-se também escolher também “bottom” , “left”, “right” ou “none” para posições embaixo, à esqueda, à direita ou para remover legenda, respectivamente.theme(legend.direction = \"horizontal\") legenda horizontalguides(fill = guide_legend(reverse = TRUE)) para reverter ordem da legenda","code":""},{"path":"epicurves.html","id":"barras-lado-a-lado","chapter":"30 Curvas epidêmicas","heading":"Barras lado-a-lado","text":"visualização grupo de barras lado--lado (oposto à posição de barras empilhadas) é especificado dentro de geom_histogram(), com o argumento position = \"dodge\" fora de aes()(Nota tradutor: dodge vem inglês “esquivar”).Se existirem mais de dois grupos de valores, estes podem ser difíceis de ler. Em vez disso, considere utilizar um gráfico facetado (pequenos múltiplos). Para melhorar visualização gráfico neste exemplo, campos sem informação gênero foram removidos.","code":"\nggplot(central_data %>% drop_na(gender))+   # inicie com casos do Hospital Central, excluindo as linhas sem dados do gênero\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # casos agrupados por gênero\n          fill = gender),         # barras preenchidas de acordo com o gênero\n        \n        # quebras dos containers do histrograma\n        breaks = weekly_breaks_central,   # sequência de datas semanais para o surto no Central - definido no topo da seção sobre ggplot\n        \n        color = \"black\",          # cor do contorno das barras\n        \n        position = \"dodge\")+      # barras LADO-A-LADO\n                      \n  \n  # Os rótulos no eixo x\n  scale_x_date(expand            = c(0,0),         # remova os espaços em excesso abaixo do eixo x e após as barras de casos\n               date_breaks       = \"3 weeks\",      # rótulos aparecem a cada 3 semanas iniciadas nas segundas\n               date_minor_breaks = \"week\",         # linhas verticais aparecem a cada semana iniciada nas segundas\n               label = scales::label_date_short()) + # efficient label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+             # remove o espaço extra nos eixos y entre a base das barras e os rótulos\n  \n  # escala de cores e rótulos de legendas\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # especifique as cores de preenchimento (\"values\") - atenção na ordem!\n                    na.value = \"grey\" )+     \n\n  # temas estéticos\n  theme_minimal()+                                               # um conjunto de temas para simplificar o gráfico\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n        axis.title = element_text(face = \"bold\"))+               # título dos eixos em negrito\n  \n  # rótulos\n  labs(title    = \"Incidência semanal de casos, por gênero\",\n       subtitle = \"Legenda\",\n       fill     = \"Gênero\",                                      # forneça novos títulos para os eixos\n       x        = \"Semana de início dos sintomas\",\n       y        = \"Incidência semanal dos casos notificados\")"},{"path":"epicurves.html","id":"limite-dos-eixos","chapter":"30 Curvas epidêmicas","heading":"Limite dos eixos","text":"Existem duas formas de limitar extensão dos valores dos eixos.Geralmente, o método indicado é utilizar o comando coord_cartesian(), que aceita xlim = c(min, max) e ylim = c(min, max) (onde você fornece os valores mínimos e máximos). Esta ferramenta age como um “zoom” sem, na realidade, remover qualquer dado, o que é importante para estatísticas e resumos das medidas.Alternativamente, você pode ajustar os valores mínimos e máximos das datas utilizando limits = c() dentro de scale_x_date(). Por exemplo:Da mesma forma, se você quiser que o eixo x se estenda até uma data específica (ex.: data atual), mesmo que novos casos não sejam notificados, você pode utilizar:PERIGO: Tenha cuidado ao ajustar quebras ou limites da escala eixo y (ex.: 0 30 por 5: seq(0, 30, 5)). Estes números estáticos podem cortar o seu gráfico casos seus dados mudem e ultrapassem os limites!","code":"\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # escolhe uma data mínima mas deixa a data máxima em aberto.scale_x_date(limits = c(NA, Sys.Date()) # garante que o eixo da data se estenda até a data atual"},{"path":"epicurves.html","id":"rótuloslinha-de-grade-do-eixo-de-data","chapter":"30 Curvas epidêmicas","heading":"Rótulos/linha de grade do eixo de data","text":"DICA: Lembre que os rótulos eixo das datas são independentes da agregação das datas em barras, mas visualmente podem ser importantes para alinhar classes, rótulos de data, e linhas de grade verticais.Para modificar os rótulos de data e linhas de grade, utilize função scale_x_date() em uma das seguintes formas:Se suas classes histograma são dias, semanas iniciadas em segundas, meses, ou anos:\nUtilize date_breaks = para especificar o intervalo de rótulos e linhas de grade principais (ex.: “day” (dia), “week” (semana), “3 weeks” (3 semanas), “month” (mês), ou “year” (ano))\nUtilize date_minor_breaks = para especificar o intervalo das linhas de grade verticais secundárias (entre os rótulos)\nAdicione expand = c(0,0) para iniciar os rótulos na primeira barra\nUtilize date_labels = para especificar o formato dos rótulos de data - veja página sobre Datas para dicas (utilize \\n para uma nova linha)\nUtilize date_breaks = para especificar o intervalo de rótulos e linhas de grade principais (ex.: “day” (dia), “week” (semana), “3 weeks” (3 semanas), “month” (mês), ou “year” (ano))Utilize date_minor_breaks = para especificar o intervalo das linhas de grade verticais secundárias (entre os rótulos)Adicione expand = c(0,0) para iniciar os rótulos na primeira barraUtilize date_labels = para especificar o formato dos rótulos de data - veja página sobre Datas para dicas (utilize \\n para uma nova linha)Se suas classes histograma são semanas iniciadas nos domingos:\nUtilize breaks = e minor_breaks = ao fornecer uma sequência de quebras de datas para cada um\nVocê ainda pode utilizar date_labels = e expand = para formatação, como decrito acima\nUtilize breaks = e minor_breaks = ao fornecer uma sequência de quebras de datas para cada umVocê ainda pode utilizar date_labels = e expand = para formatação, como decrito acimaAlgumas notas:Veja seção de abertura ggplot para instruções sobre como criar uma sequência de datas utilizando seq.Date().Veja esta página ou página Trabalhando com datas para dicas sobre como criar rótulos de data.","code":""},{"path":"epicurves.html","id":"demonstrações","chapter":"30 Curvas epidêmicas","heading":"Demonstrações","text":"Abaixo está uma demonstração de gráficos onde cásses e os rótulos/linhas de grade gráfico estão alinhados e desalinhados:","code":"\n# classes de 7-dias + rótulos de Segunda\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # classes de 7-dias com início no primeiro caso\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remova o excesso de espaço do eixo x abaixo e após as barras de caso\n    date_breaks = \"3 weeks\",       # Segunda a cada 3 semanas\n    date_minor_breaks = \"week\",    # Semanas iniciadas na segunda\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remova o espaço em excesso abaixo do eixo x, fazendo um nivelamento\n  \n  labs(\n    title = \"DESALINHADO\",\n    subtitle = \"! CUIDADO: barras de 7-dias iniciam nas quintas-feiras no primeiro caso\\nRótulos de data e linhas de grade nas segundas-feiras\\nObserve como os traços não alinham com as barras\")\n\n\n\n# classes de 7-dias + meses\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remova o espaço em excesso abaixo e após as barras de casos\n    date_breaks = \"months\",           # primeiro do mês\n    date_minor_breaks = \"week\",       # semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento\n  \n  labs(\n    title = \"DESALINHADO\",\n    subtitle = \"! CUIDADO: Barras de 7-dias iniciam nas quintas-feiras com o primeiro caso\\nLinhas de grade principais e rótulos de data no primeiro de cada mês\\nLinhas de grade secundárias semanalmente nas segundas\\nObserve o espaçamento diferente de algumas das linhas de grade e traços desalinhados com as barras\")\n\n\n# ALINHAMENTO TOTAL NAS SEGUNDAS: especifique manualmente as quebras das classes para serem nas segundas\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebras do histograma ajustadas para 7 dias iniciando na Segunda antes do primeiro caso\n    breaks = weekly_breaks_central,    # definido anteriormente nesta página\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remova o excesso de espaço do eixo x abaixo e após as barras de caso\n    date_breaks = \"4 weeks\",           # Segunda-feira a cada 4 semanas\n    date_minor_breaks = \"week\",        # Semanas iniciadas na segunda\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça o nivelamento\n  \n  labs(\n    title = \"Segunda ALINHADAS\",\n    subtitle = \"Classes de 7-dias manualmente ajustados para iniciarem na segunda antes do primeiro caso (28 de abril)\\nRótulos de data e linhas de grade também nas segundas\")\n\n\n# ALINHAMENTO TOTAL NA SEGUNDA COM RÓTULOS DE MESES:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebras do histograma ajustaddas para 7 dias iniciando na segunda antes do primeiro caso\n    breaks = weekly_breaks_central,            # definido anteriormente nesta página\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remova o excesso de espaço no eixo x abaixo e após as barras de casos\n    date_breaks = \"months\",            # Segunda a cada 4 semanas\n    date_minor_breaks = \"week\",        # Semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça um nivelamento\n  \n  theme(panel.grid.major = element_blank())+  # Remove as linhas de grade principais )caem no primeiro dia do mês)\n          \n  labs(\n    title = \"ALINHADO nas segundas com rótulos MENSAIS\",\n    subtitle = \"Classes de 7-dias manualmente ajustado para iniciar na segunda antes do primeiro caso (28 de abril)\\nRótulo de datas no primeiro dia do mês\\nPrincipais linhas de grade mensais removidas\")\n\n\n# ALINHAMENTO TOTAL NO DOMINGO: especifique manualmente as quebras das classes E rótulos para serem nos domingos\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebra do histograma ajustadas para serem de 7 dias, iniciando no Domingo antes do primeiro caso\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # quebras dos rótulos de datas e principais linhas de grade ajustadas para ocorrerem a cada 3 semanas iniciando no domingo antes do primeiro caso\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # linhas de grade secundárias ajustadas para iniciarem semanalmente no domingo antes do primeiro caso\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento\n  \n  labs(title = \"ALINHAMENTO nos domingos\",\n       subtitle = \"Classes de 7-dias manualmente ajustados para iniciarem no domingo antes do primeiro caso (27 de abril)\\nRótulo de datas e linhas de grade manualmente ajustadas também para os domingos\")"},{"path":"epicurves.html","id":"dados-agregados","chapter":"30 Curvas epidêmicas","heading":"Dados agregados","text":"Frequentemente, ao invés de uma linelist, você inicia com contagens agregadas de unidades, distritos, etc. Você pode criar uma epicurva com o ggplot(), mas o código será levemente diferente. Esta seção irá utilizar o conjunto de dados count_data que foi importado anteriormente, na seção de preparação dos dados. Este conjunto de dados é o linelist agregado para contagens diárias por hospital. primeiras 50 linhas são mostradas abaixo.","code":""},{"path":"epicurves.html","id":"criando-um-gráfico-de-contagens-diárias","chapter":"30 Curvas epidêmicas","heading":"Criando um gráfico de contagens diárias","text":"Nós podemos criar um gráfico de uma epicurva diária destas contagens diárias. Aqui estão diferenças código:Dentro mapeamento estético aes(), especifique y = como coluna de contagem (neste caso, o nome da coluna é n_cases)Adicione o argumento stat = \"identity\" dentro de geom_histogram(), que especifica que altura da barra deve ser o valor y = , e não o número de linhas, como é o padrãoAdicione o argumento width = para evitar linhas verticais brancas entre barras. Para contagens diárias o ajuste é 1. Para contagens semanais o ajuste é 7. Para contagens mensais, linhas brancas são um problema (cada M~es possui diferente número de dias) - considere transformar seu eixo x para um factor ordenado categoricamente (meses) e utilizando geom_col().","code":"\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # para contagens diárias, ajuste width = 1 para evitar o espaço braco entre as barras\n  labs(\n    x = \"Data de notificação\", \n    y = \"Número de casos\",\n    title = \"Incidência diária de casos, a partir dos dados de contagem diária\")"},{"path":"epicurves.html","id":"criando-um-gráfico-de-contagens-semanais","chapter":"30 Curvas epidêmicas","heading":"Criando um gráfico de contagens semanais","text":"Se os seus casos já estão contados por semana, eles podem parecer como o seguinte conjunto de dados (chamado count_data_weekly):primeiras 50 linhas de count_data_weekly são mostradas abaixo. Você pode ver que contagens foram agregadas por semanas. Cada semana é mostrada pelo primeiro dia da semana (segunda-feira, por padrão).Agora crie o gráfico de forma que x = coluna da semana epidemiológica. Lembre de adicionar y = coluna de contagens para o mapeamento estético, e adicione stat = \"identity\", como explicado acima.","code":"\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # eixo x é a semana epidemiológica (variável da classe Data)\n      y = n_cases_weekly,    # altura do eixo y nas contagens de casos semanais\n      group = hospital,      # nós estamos agrupando as barras e colorindo por hospital\n      fill = hospital),\n    stat = \"identity\")+      # isto também é requerido quando criar um gráfico dos dados de contagem\n     \n  # rótulos para o eixo x\n  scale_x_date(\n    date_breaks = \"2 months\",      # rótulos a cada 2 meses\n    date_minor_breaks = \"1 month\", # linhas de grade a cada mês\n    label = scales::label_date_short())+ # label formatting\n     \n  # Escolha a paleta de cor (utiliza o pacote RColorBrewer)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Semana de início\", \n    y = \"Incidência semanal de casos\",\n    fill = \"Hospital\",\n    title = \"Incidência semanal de casos, a partir dos dados de casos agregados por hospital\")"},{"path":"epicurves.html","id":"média-móvel","chapter":"30 Curvas epidêmicas","heading":"Média móvel","text":"Veja página sobre médias móveis para uma descrição detalhada e diferentes opções. Abaixo, uma alternativa para calcular médias móveis com o pacote slider é utilizada. Nesta abordagem, média móvel é calculada conjunto de dados antes de criar os gráficos:Agregue os dados em contagens conforme necessário (diárias, semanais, etc.) (veja página Agrupando dados)Crie uma nova coluna para salvar média móvel, criada com slide_index() pacote sliderCrie um gráfico da média móvel como uma geom_line() acima (após) o histograma da epicurvaVeja este útil resumo online pacote slider","code":"\n# carregue o pacote\npacman::p_load(slider)  # slider utilizado para calcular as médias móveis\n\n# crie um conjunto de dados de contagens diárias e média móvel de 7-dias\n#######################################################\nll_counts_7day <- linelist %>%    # inicie com o objeto linelist\n  \n  ## conte os casos por dia\n  count(date_onset, name = \"new_cases\") %>%   # crie uma nova coluna com as contagens, chamada \"new_cases\"\n  drop_na(date_onset) %>%                     # remova os casos sem a informação do dia de início dos sintomas (date_onset)\n  \n  ## calcule o número médio de casos em uma janela de 7 dias\n  mutate(\n    avg_7day = slider::slide_index(    # crie uma nova coluna\n      new_cases,                       # calcule baseado nos valores da coluna new_cases\n      .i = date_onset,                 # o indexador é a coluna de date_onset, de forma que as contagens sem datas são incluídas na janela de análise\n      .f = ~mean(.x, na.rm = TRUE),    # a função utilizada é mean() com os valores em branco removidos\n      .before = 6,                     # a janela de análise é o dia e os 6-dias anteriores\n      .complete = FALSE),              # precisa ser FALSE para unlist() funcionar na próxima etapa\n    avg_7day = unlist(avg_7day))       # converta da classe \"list\" para a classe \"numeric\"\n\n\n# crie o gráfico\n######\nggplot(data = ll_counts_7day) +  # inicie com o novo conjunto de dados criado acima\n    geom_histogram(              # crie uma epicurva em histograma\n      mapping = aes(\n        x = date_onset,          # coluna de datas no eixo x\n        y = new_cases),          # a altura é o número de novos casos diários\n        stat = \"identity\",       # altura da coluna é o valor de y\n        fill=\"#92a8d1\",          # cor legal para as barras\n        colour = \"#92a8d1\",      # mesma cor para a borda das barras\n        )+ \n    geom_line(                   # crie uma linha para a média móvel\n      mapping = aes(\n        x = date_onset,          # coluna de data para o eixo x\n        y = avg_7day,            # valor de y ajustado para a coluna de média móvel\n        lty = \"Média móvel \\nde 7-dias\"), # nome da linha na legenda\n      color=\"red\",               # cor da linha\n      size = 1) +                # espessura da linha\n    scale_x_date(                # escala da data\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # label formatting\n      expand = c(0,0)) +\n    scale_y_continuous(          # escala do eixo y\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Número de casos confirmados\",\n      fill = \"Legenda\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # remove o título da legenda"},{"path":"epicurves.html","id":"facetasmúltiplos-pequenos","chapter":"30 Curvas epidêmicas","heading":"Facetas/múltiplos pequenos","text":"Como em outros ggplots, você pode criar gráficos facetados (“múltiplos pequenos”). Como explicado na página dicas ggplot deste manual, você pode utilizar tanto facet_wrap() quanto facet_grid(). Aqui, nós demonstramos com o facet_wrap(). Para epicurvas, facet_wrap() é tipicamente mais fácil, uma vez que provavelmente você só precisa facetar uma coluna.sintaxe geral é facet_wrap(rows ~ cols), em que lado esquerdo til (~) é o nome da coluna ser espalhada através das “linhas” gráfico facetado, e lado direito til é o nome de uma coluna ser espalhada através das “colunas” gráfico facetado. De forma mais simples, só utilize um nome de coluna, lado direito til: facet_wrap(~age_cat).Eixos livres\nVocê precisará decidir se escalas dos eixos para cada faceta são “fixas” para mesmas dimensões (padrão), ou “livres” (significando que irão mudar baseado nos dados dentro da faceta). Faça isso com o argumento scales = dentro de facet_wrap() ao especificar “free_x” ou “free_y”, ou “free”.Número de colunas e linhas das facetas\nIsto pode ser especificado com ncol = e nrow = dentro de facet_wrap().Ordem dos painéis\nPara alterar ordem de aparecimento, altere ordem dos níveis da coluna de factor utilizada para criar facetas.Estética\nTamanho da fonte e face, cor da tira, etc. podem ser modificados através de theme() com argumentos como:strip.text = element_text() (tamanho, cor, face, ângulo…)strip.background = element_rect() (ex.: element_rect(fill=“grey”))strip.position = (posição da tira “bottom” (embaixo), “top” (em cima), “left” (à esquerda), ou “right” (à direita))Rótulos das tiras\nRótulos dos gráficos facetados podem ser modificados por meio de “rótulos” da coluna como um factor, ou pelo uso de um “rotulador”.Crie um rotulador como este, utilizando função as_labeller() ggplot2. Então, forneça o rotulador para o argumento labeller = de facet_wrap(), como mostrado abaixo.Um exemplo de gráfico facetado - facetado pela coluna age_cat.Veja este link para mais informações sobre os rotuladores.","code":"\nmy_labels <- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n# crie o gráfico\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # argumentos dentro de aes() aplicam-se ao grupo\n      \n    color = \"black\",      # argumentos fora de aes() aplicam-se a todos os dados\n        \n    # quebras do histograma\n    breaks = weekly_breaks_central)+  # vetor pré-definido de datas (veja mais acima nesta página)\n                      \n  # Os rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remove o espaço em excesso do eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+                       # remove o espaço em excesso do eixo y entre os fundos das barras e os rótulos\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar a plotagem\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # títulos dos eixos em negrito\n  \n  # crie as facetas\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos, por categoria de idade\",\n    subtitle = \"Legenda\",\n    fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n    x        = \"Semana de início dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia entre {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico\"))"},{"path":"epicurves.html","id":"epidemia-total-no-fundo-da-faceta","chapter":"30 Curvas epidêmicas","heading":"Epidemia total no fundo da faceta","text":"Para mostrar o total da epidemia fundo de cada faceta, adicione função gghighlight() com parênteses vazios ao ggplot. Isto é pacote gghighlight. Observe que o máximo eixo y em todas facetas é agora baseado pico da epidemia inteira. Existem mais exemplos deste pacote na página sobre dicas ggplot.","code":"\nggplot(central_data) + \n  \n  # epicurvas por grupo\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo\n    \n    color = \"black\",    # argumentos fora de aes() são aplicados a todos os dados\n    \n    # quebras do histograma\n    breaks = weekly_breaks_central)+     # vetor de datas pré-definidas (veja o topo da seção sobre ggplot)\n  \n  # adicione a epidemia total em cinza em cada faceta\n  gghighlight::gghighlight()+\n  \n  # rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o espaço em excesso do eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada 1 mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+  # remove o excesso de espaço do eixo y abaixo de 0\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # títulos dos eixos em negrito\n  \n  # crie as facetas\n  facet_wrap(\n    ~age_cat,                          # cada gráfico é um valor de age_cat\n    ncol = 4,                          # número de colunas\n    strip.position = \"top\",            # posição do título/tira da faceta\n    labeller = my_labels)+             # rotulador definido acima\n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos, por categoria de idade\",\n    subtitle = \"Legenda\",\n    fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n    x        = \"Semana de início dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico\"))"},{"path":"epicurves.html","id":"uma-faceta-com-dados","chapter":"30 Curvas epidêmicas","heading":"Uma faceta com dados","text":"Se você quer ter uma caixa de faceta que contem todos os dados, duplique o conjunto de dados inteiro e trate duplicatas como um valor de facetas. Uma função “auxiliar”, CreateAllFacet(), abaixo pode auxiliar nisso (agradecimento esse post). Quando é executado, o número de linhas duplica, e então terá uma nova coluna chamada facet, em que linhas duplicadas terão o valor “”, e linhas originais terão o valor original da coluna de facetas. Agora você só precisa facetear com coluna facet.Aqui está função auxiliar. Execute ela de forma que esteja disponível para você.Agora aplique função auxiliar para o conjunto de dados, na coluna age_cat:Alterações notáveis comando ggplot() são:Os dados utilizados agora são central_data2 (duplique linhas, com nova coluna “facet”)Rotulador precisará ser atualizado, caso usadoOpcional: para obter facetas empilhadas verticalmente: coluna facetada é movida para o lado das linhas na equação e lado esquerdo é substituído por “.” (facet_wrap(facet~.)), e ncol = 1. Você também pode precisar ajustar o comprimento e altura da imagem gráfico salvo (veja ggsave() dicas ggplot).","code":"\n# Defina uma função auxiliar\nCreateAllFacet <- function(df, col){\n     df$facet <- df[[col]]\n     temp <- df\n     temp$facet <- \"all\"\n     merged <-rbind(temp, df)\n     \n     # garanta que o valor da faceta é um fator\n     merged[[col]] <- as.factor(merged[[col]])\n     \n     return(merged)\n}\n# Crie um conjunto de dados que é duplicado e com a nova coluna \"facet\" para mostrar \"all\" (todas) as categorias de idade como outro nível da faceta\ncentral_data2 <- CreateAllFacet(central_data, col = \"age_cat\") %>%\n  \n  # ajuste os níveis do fator\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `facet = fct_relevel(...)`.\n## Caused by warning:\n## ! 1 unknown level in `f`: 70+\n# verifique os níveis\ntable(central_data2$facet, useNA = \"always\")## \n##   all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  <NA> \n##   454    84    84    82    58    73    57     7     9\nggplot(central_data2) + \n  \n  # epicurvas atuais por grupo\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo\n        color = \"black\",    # argumentos fora de aes() são aplicados a todos os dados\n        \n        # quebras do histograma\n        breaks = weekly_breaks_central)+    # vetor de datas pré-definidos (veja o topo da seção sobre o ggplot)\n                     \n  # Rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o excesso de espaço no eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+  # remove o espaço em excesso do eixo y entre a base das barras e os rótulos\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # crie as facetas\n  facet_wrap(facet~. ,                            # cada gráfico é um valor da faceta\n             ncol = 1)+            \n\n  # rótulos\n  labs(title    = \"Incidência semanal de casos, por categoria de idade\",\n       subtitle = \"Legenda\",\n       fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n       x        = \"Semana de início dos sintomas\",\n       y        = \"Incidência semanal dos casos notificados\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados no gráfico\"))"},{"path":"epicurves.html","id":"dados-preliminares","chapter":"30 Curvas epidêmicas","heading":"30.3 Dados preliminares","text":"Os dados mais recentes mostrados em epicurvas precisam, frequentemente, serem marcados como preliminares, ou sujeitos à demoras na notificação. Isto pode ser feito ao adicionar uma linha vertical e/ou retângulo sobre um número específico de dias. Aqui estão duas opções:Utilize annotate():\nPara utilizar uma linha, use annotate(geom = \"segment\"). Forneça x, xend, y, e yend. Ajuste o tamanho, tipo de linha (lty), e cor.\nPara utilizar um retângulo, use annotate(geom = \"rect\"). Forneça xmin/xmax/ymin/ymax. Ajuste cor e o alfa.\nPara utilizar uma linha, use annotate(geom = \"segment\"). Forneça x, xend, y, e yend. Ajuste o tamanho, tipo de linha (lty), e cor.Para utilizar um retângulo, use annotate(geom = \"rect\"). Forneça xmin/xmax/ymin/ymax. Ajuste cor e o alfa.Agrupe os dados por status da tentativa e utilize cores diferentes para essas barrasCUIDADO: Você pode querer experimentar geom_rect() para desenhar um retângulo, mas ajustar transparência não funciona contexto de uma linelist. Esta função sobrepõe um retângulo para cada observação/linha!. Utilize ou um alfa muito baixo (ex.: 0.01), ou outra abordagem.","code":""},{"path":"epicurves.html","id":"utilizando-annotate","chapter":"30 Curvas epidêmicas","heading":"Utilizando annotate()","text":"Dentro de annotate(geom = \"rect\"), os argumentos xmin e xmax precisam ser dados como valores da classe Date (data).Note que, devido ao fato destes dados serem agregados em barras semanais, e última barra extender para segunda após o último caso, região sombreada pode parecer cobrir 4 semanasAqui é um exemplo online de annotate()mesma linha preta vertical pode ser obtida com o código abaixo, mas, utilizando geom_vline(), você perde capacidade de controlar altura:","code":"\nggplot(central_data) + \n  \n  # histograma\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # vetor de data pré-definido - veja o topo da seção sobre o ggplot\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # escalas\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove o excesso de espaço do eixo x abaixo e após as barras de casos\n    date_breaks = \"1 month\",           # Primeiro do mês\n    date_minor_breaks = \"1 month\",     # Primeiro do mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # rótulos e tema\n  labs(\n    title = \"Utilizando annotate()\\nRetângulo e linha mostrando que os dados dos últimos 21 dias são preliminares\",\n    x = \"Semana de início de sintomas\",\n    y = \"Incidência semanal de casos\")+ \n  theme_minimal()+\n  \n  # adicione um retângulo vermelho semi-transparente nos dados preliminares\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # a nota precisa ser englobada dentro de as.Date()\n    xmax  = as.Date(Inf),                                          # a nota precisa ser englobada dentro de as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alfa fácil e intuitivo para ajustar usando annotate()\n    fill  = \"red\")+\n  \n  # adicione uma linha preta vertical no topo das outras camadas\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 dias antes dos últimos dados\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # linha inicia em y = 0\n    yend  = Inf,       # linha no topo do gráfico\n    size  = 2,         # tamanho da linha\n    color = \"black\",\n    lty   = \"solid\")+   # tipo de linha ex.: \"solid\", \"dashed\"\n\n  # adicione texto no retângulo\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Sujeito à atrasos nas notificações\",\n    angle = 90)\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")"},{"path":"epicurves.html","id":"cor-das-barras","chapter":"30 Curvas epidêmicas","heading":"Cor das barras","text":"Uma abordagem alternativa pode ser ajustar cor ou exibição das dos dados preliminares. Você pode criar uma nova coluna estágio de preparação dos dados, e utiliza-la para agrupar os dados, de forma que o aes(fill = ) dos dados preliminares possa ter uma cor ou alfa diferente das outras barras.","code":"\n# adiciona uma coluna\n############\nplot_data <- central_data %>% \n  mutate(tentative = case_when(\n    date_onset >= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # preliminares e estiverem dentro dos últimos 7 dias\n    TRUE                                       ~ \"Reliable\")) # todos os demais são confiáveis\n\n# crie o gráfico\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histograma\n  geom_histogram(\n    breaks = weekly_breaks_central,   # vetor de datas pré-definido, veja o topo da página sobre o ggplot\n    color = \"black\") +\n\n  # escalas\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove o espaço em excesso do eixo x, abaixo e após as barras de casos\n    date_breaks = \"3 weeks\",           # segundas a cada 3 semanas\n    date_minor_breaks = \"week\",        # semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # label formatting\n  \n  # rótulos e temas\n  labs(title = \"Mostra os dias que possuem notificações preliminares\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove o título da legenda"},{"path":"epicurves.html","id":"etiquetas-multiníveis-de-data","chapter":"30 Curvas epidêmicas","heading":"30.4 Etiquetas multiníveis de data","text":"Se você quiser etiquetas multiníveis de datas (ex.: mês e ano) sem duplicar etiquetas de níveis mais baixos, utilize uma das abordagens abaixo:Lembre - você pode utilizar ferramentas como \\n dentro dos argumentos de date_labels ou labels para colocar partes de cada etiqueta em uma nova linha abaixo da atual. Entretanto, o código abaixo o ajuda colocar anos ou meses (por exemplo) em uma linha abaixo e apenas uma vez. Algumas notas sobre o código abaixo:Contagem de casos são agregados em semanas por razões estéticas. Veja página sobre epicurvas (parte sobre separação dos dados agregados) para mais detalhes.Uma linha geom_area() é utilizada lugar de um histograma, uma vez que abordagem de faceteamento abaixo não funciona bem com histogramas.Agregue para contagens semanaisCrie os gráficosAs técnicas acima foram adaptadas desta e desta postagem stackoverflow.com.","code":"\n# Crie o conjunto de dados de contagens de casos por semana\n#######################################\ncentral_weekly <- linelist %>%\n  filter(hospital == \"Central Hospital\") %>%   # filtre a linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %>%  \n  count(week) %>%                              # faça um resumo das contagens de casos semanais\n  drop_na(week) %>%                            # remova os casos sem a informação de onset_date\n  complete(                                    # preencha todas as semanas com nenhum caso notificado\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # converta novos campos NA (faltantes) para contagens de 0\n# crie um gráfico com a borda da caixa no ano\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # crie uma linha, especificando x e y\n            stat = \"identity\") +             # a altura da linha é o número da contagem\n  scale_x_date(date_labels=\"%b\",             # formato do rótulo de data mostra o mês\n               date_breaks=\"month\",          # rótulos de data no primeiro dia de cada mês\n               expand=c(0,0)) +              # remove o espaço em excesso em cada extremidade\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove o espaço em excesso abaixo do eixo x\n  facet_grid(~lubridate::year(week), # crie uma faceta com o ano (da coluna da classe Date (Data))\n             space=\"free_x\",                \n             scales=\"free_x\",                # eixo x se adapta para o intervalo dos dados (não é fixo)\n             switch=\"x\") +                   # etiquetas de faceta (ano) na base\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # posicionamento das etiquetas das facetas\n        strip.background = element_rect(fill = NA, # rótulos das facetas sem preenchimento e com bordas cinzas\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # sem espaço entre os painéis das facetas\n  labs(title = \"Etiquetas de ano aninhadas, com borda cinza\")\n# crie o gráfico sem a borda de caixa no ano\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # estabeleça o x e y para o gráfico inteiro\n  geom_line(stat = \"identity\",              # crie a linha, em que a altura da linha é o número da contagem\n            color = \"#69b3a2\") +            # cor da linha\n  geom_point(size=1, color=\"#69b3a2\") +     # crie pontos nos pontos de data semanais\n  geom_area(fill = \"#69b3a2\",               # preencha a área abaixo da linha\n            alpha = 0.4)+                   # preencha a transparência\n  scale_x_date(date_labels=\"%b\",            # formato do rótulo de data mostra o mês\n               date_breaks=\"month\",         # rótulos de data no primeiro dia de cada mês\n               expand=c(0,0)) +             # remova o espaço em excesso\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remova o espaço em excesso abaixo do eixo x\n  facet_grid(~lubridate::year(week),        # faça a faceta no ano (da coluna de classe Date (data))\n             space=\"free_x\",                \n             scales=\"free_x\",               # eixo x se adapta ao intervalo de dados (não é fixo)\n             switch=\"x\") +                  # rótulos da faceta (ano) na base\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # posicionamento do rótulo da faceta\n          strip.background = element_blank(),            # rótulo da faceta sem fundo\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # borda cinza para o painel da faceta\n          panel.spacing=unit(0,\"cm\"))+                   # sem espaço entre os painéis da faceta\n  labs(title = \"Etiquetas de ano aninhadas - pontos, sombreamento, e sem borda no rótulo\")"},{"path":"epicurves.html","id":"eixo-duplo","chapter":"30 Curvas epidêmicas","heading":"30.5 Eixo duplo","text":"Embora existam discussões intensas sobre validade de eixos duplos na comunidade de visualização de dados, muitos supervisores de epidemiologia ainda querem ver uma epicurva ou gráfico similar com um percentual sobreposto com um segundo eixo. Isto é discutido mais extensivamente na página dicas ggplot, mas um exemplo utilizando o método de cowplot é mostrado abaixo:Dois gráficos distintos são feitos, e então combinados com o pacote cowplot.Os gráficos precisam ter exatamente o mesmo eixo x (ajuste os limites). contrário, os dados e rótulos não serão alinhadosCada um utiliza theme_cowplot() e um deles tem o eixo y movido para o lado direito gráficoAgora, use o cowplot para sobrepor os dois gráficos. atenção precisa ser dada ao alinhamento eixo x, ao lado eixo y, e ao uso de theme_cowplot().","code":"\n# carregue o pacote\npacman::p_load(cowplot)\n\n# Crie o primeiro gráfico de histograma de uma epicurva\n#######################################\nplot_cases <- linelist %>% \n  \n  # crie o gráfico com casos por semana\n  ggplot()+\n  \n  # crie o histograma\n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # quebras das classes a cada semana, iniciando na segunda antes do primeiro caso, e indo até a segunda após o último caso\n    breaks = weekly_breaks_all)+  # vetor pré-definido de datas semanais (veja o topo da seção sobre o ggplot)\n        \n  # especifique o início e o fim do eixo da data para alinhar com o outro gráfico\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma\n  \n  # rótulos\n  labs(\n      y = \"Casos diários\",\n      x = \"Data de aparecimento dos sintomas\"\n    )+\n  theme_cowplot()\n\n\n# crie um segundo gráfico com o percentual de óbitos por semana\n###########################################\nplot_deaths <- linelist %>%                        # inicie com a linelist\n  group_by(week = floor_date(date_onset, \"week\")) %>%  # crie a coluna week (semana)\n  \n  # utilize summarise para obter o percentual semanal de casos que morreram\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %>% \n  \n  # inicie o gráfico\n  ggplot()+\n  \n  # linha com o percentual semanal de óbitos\n  geom_line(                                # crie um linha com o percentual de mortos\n    mapping = aes(x = week, y = pct_died),  # especifique o y-altura como sendo da coluna pct_died\n    stat = \"identity\",                      # ajuste a altura da linha para o valor na coluna pct_death, e não a quantidade de linhas (que é o padrão)\n    size = 2,\n    color = \"black\")+\n  \n  # Mesmos limites no eixo de datas como no outro gráfico - alinhamento perfeito\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma\n  \n  \n  # ajustes no eixo y\n  scale_y_continuous(                # ajuste o eixo y\n    breaks = seq(0,100, 10),         # ajuste os intervalos de quebra do eixo da porcentagem\n    limits = c(0, 100),              # ajuste a extensão do eixo de porcentagem\n    position = \"right\")+             # mova o eixo de porcentagem para a direita\n  \n  # rótulo do eixo y, sem rótulo no eixo x\n  labs(x = \"\",\n       y = \"Percentual de óbitos\")+      # rótulo do eixo de porcentagem\n  \n  theme_cowplot()                   # adicione isto para unir os dois gráficos\naligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"incidência-acumulada","chapter":"30 Curvas epidêmicas","heading":"30.6 Incidência acumulada","text":"Nota: Caso esteja utilizando o pacote incidence2, veja seção sobre como você pode produzir incidência acumulada com uma simples função. Esta página irá ensinar como calcular incidência acumulada e fazer um gráfico dela utilizando ggplot().Se estiver iniciando com os casos em uma linelist, crie uma nova coluna contendo o número acumulado de casos por dia em um surto utilizando função cumsum() R base:primeiras 10 linhas são mostradas abaixo:Esta coluna de casos acumulados pode então ser utilizada para fazer um gráfico com data de início dos sintomas, date_onset, utilizando geom_line():Ela também pode ser sobreposta em uma epicurva, com dois eixos, utilizando o método cowplot descrito acima e na página dicas ggplot:Agora, use cowplot para sobrepor os dois gráficos. Atenção ao alinhamento eixo x, o lado eixo y, e o uso de theme_cowplot().","code":"\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>%                # contagem de linhas por dia (salvo na coluna \"n\")\n  mutate(                         \n    cumulative_cases = cumsum(n)       # nova coluna com a quantidade de linhas acumuladas em cada data\n    )\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n# carregue o pacote\npacman::p_load(cowplot)\n\n# crie primeiro o histograma de uma epicurva\nplot_cases <- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Casos diários\",\n    x = \"Data de início dos sintomas\"\n  )+\n  theme_cowplot()\n\n# crie um segundo gráfico com uma linha de casos acumulados\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Casos acumulados\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\naligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"recursos-15","chapter":"30 Curvas epidêmicas","heading":"30.7 Recursos","text":"","code":""},{"path":"age-pyramid.html","id":"age-pyramid","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"31 Pirâmides demográficas e escalas Likert","text":"pirâmides demográficas são úteis para mostrar distribuições de idade e sexo. Um código semelhante pode ser usado para visualizar os resultados de perguntas de pesquisa tipo Likert (por exemplo “Concordo plenamente”, “Concordo”, “Neutro”, “Discordo”, “Discordo totalmente”). Nesta página, cobrimos o seguinte:Pirâmides rápidas e fáceis usando o pacote apyramidPirâmides mais personalizáveis usando ggplot()Exibindo linhas de base demográficas fundo da pirâmideUsando gráficos em estilo de pirâmide para mostrar outros tipos de dados (por exemplo, respostas perguntas de pesquisa estilo Likert)","code":""},{"path":"age-pyramid.html","id":"preparação-21","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"31.1 Preparação","text":"","code":""},{"path":"age-pyramid.html","id":"carregar-pacotes-7","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Carregar pacotes","text":"Este pedaço de código mostra o carregamento de pacotes necessários para análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() de R base. Veja página em Introdução ao R para mais informações sobre pacotes R.","code":"\npacman::p_load(rio, # para importar dados\n               here, # para localizar arquivos\n               tidyverse, # para limpar, manipular e plotar os dados (inclui o pacote ggplot2)\n               apyramid, # um pacote dedicado à criação de pirâmides de idades\n               janitor, # tabelas e dados de limpeza\n               stringr) # trabalhando com strings para títulos, legendas, etc."},{"path":"age-pyramid.html","id":"importar-dados-2","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Importar dados","text":"Para começar, importamos lista (linelist) limpa de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o linelist “clean”  (como um arquivo .rds). Importe dados com função import() pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja página Importar e exportar para detalhes).primeiras 50 linhas da linelist são exibidas abaixo.","code":"\n# import case linelist \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"age-pyramid.html","id":"limpeza","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Limpeza","text":"Para fazer uma pirâmide demográfica tradicional de idade / sexo, os dados devem primeiro ser limpos das seguintes maneiras:coluna de gênero deve ser limpa.Dependendo seu método, idade deve ser armazenada como um número ou em uma coluna de categoria de idade.Se estiver usando categorias de idade, os valores da coluna devem ser corrigidos em ordem, seja alfanumérico padrão ou definido intencionalmente pela conversão para o fator de classe.Abaixo, usamos tabyl() de janitor para inspecionar colunas gender e age_cat5.Também executamos um histograma rápido na coluna idade para garantir que esteja limpo e classificado corretamente:","code":"\nlinelist %>% \n  tabyl(age_cat5, gender)##  age_cat5   f   m NA_\n##       0-4 640 416  39\n##       5-9 641 412  42\n##     10-14 518 383  40\n##     15-19 359 364  20\n##     20-24 305 316  17\n##     25-29 163 259  13\n##     30-34 104 213   9\n##     35-39  42 157   3\n##     40-44  25 107   1\n##     45-49   8  80   5\n##     50-54   2  37   1\n##     55-59   0  30   0\n##     60-64   0  12   0\n##     65-69   0  12   1\n##     70-74   0   4   0\n##     75-79   0   0   1\n##     80-84   0   1   0\n##       85+   0   0   0\n##      <NA>   0   0  86\nhist(linelist$age)"},{"path":"age-pyramid.html","id":"pacote-apyramid","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"31.2 Pacote apyramid","text":"O pacote apyramid é um produto projeto R4Epis. Você pode ler mais sobre este pacote aqui. Ele permite que você crie rapidamente uma pirâmide de idades. Para situações mais sutis, veja seção abaixo usando ggplot(). Você pode ler mais sobre o pacote apyramid em sua página de Ajuda inserindo ?Age_pyramid em seu console R.","code":""},{"path":"age-pyramid.html","id":"dados-linelist","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Dados linelist","text":"Usando o conjunto de dados linelist limpo, podemos criar uma pirâmide de idade com um simples comando age_pyramid(). Neste comando:O argumento data = é definido como o quadro de dados (data frame) linelistO argumento age_group = (para o eixo y) é definido como o nome da coluna categórica de idade (entre aspas)O argumento split_by = (para o eixo x) é definido para coluna de gêneroA pirâmide pode ser exibida com porcentagem de todos os casos eixo x, em vez de contagens, incluindo proporcional = VERDADEIRO.Ao usar o pacote agepyramid, se coluna split_by binária (por exemplo, masculino / feminino ou sim / não), o resultado aparecerá como uma pirâmide. entanto, se houver mais de dois valores na coluna split_by (não incluindo NA), pirâmide aparecerá como um gráfico de barra facetada com barras cinza “fundo” indicando o intervalo dos dados não facetados para aquele grupo de idade. Nesse caso, os valores de split_by = aparecerão como rótulos na parte superior de cada painel de faceta. Por exemplo, abaixo está o que ocorre se split_by = é atribuído à coluna hospital.","code":""},{"path":"age-pyramid.html","id":"valores-faltantes-2","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Valores faltantes","text":"linhas que têm valores faltantes NA nas colunas split_by = ou age_group =, se codificadas como NA, não irão acionar o facetamento mostrado acima. Por padrão, essas linhas não serão mostradas. entanto, você pode especificar que eles apareçam em um gráfico de barras adjacente e como uma faixa etária separada topo, especificando na.rm = FALSE.","code":""},{"path":"age-pyramid.html","id":"proporções-cores-e-estética","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Proporções, cores e estética","text":"Por padrão, barras exibem contagens (não %), uma linha intermediária tracejada para cada grupo é mostrada e cores são verde / roxo. Cada um desses parâmetros pode ser ajustado, conforme mostrado abaixo:Você também pode adicionar comandos ggplot() adicionais ao gráfico usando sintaxe ggplot() “+” padrão, como temas estéticos e ajustes de rótulo:","code":""},{"path":"age-pyramid.html","id":"dados-agregados-1","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Dados agregados","text":"Os exemplos acima assumem que seus dados estão em um formato de linelist, com cada linha correspondendo uma observação. Se seus dados já estão agregados em contagens por categoria de idade, você ainda pode usar o pacote apyramid, conforme mostrado abaixo.Para demonstração, agregamos os dados da linelist em contagens por categoria de idade e sexo, em um formato “amplo” ou “wide”. Isso simulará como se seus dados estivessem em contagens para começar. Saiba mais sobre agrupamento de dados e pivoteamento de dados em suas respectivas páginas.… o que faz com que o conjunto de dados tenha seguinte aparência: com colunas para categoria de idade e contagens masculinas, contagens femininas e contagens ausentes.Para configurar esses dados para pirâmide de idade, vamos organizar os dados formato “longo” com função pivot_longer() de dplyr. Isso ocorre porque ggplot() geralmente prefere dados “longos”, e apyramid está usando ggplot().Em seguida, use os argumentos split_by = e count = de age_pyramid() para especificar respectivas colunas nos dados:Observe acima, que ordem dos fatores de “m” e “f” é diferente (pirâmide invertida). Para ajustar ordem, você deve redefinir o gênero nos dados agregados como um fator e ordenar os níveis conforme desejado. Veja página Fatores.","code":""},{"path":"age-pyramid.html","id":"demo_pyr_gg","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"31.3 ggplot()","text":"Usar ggplot() para construir sua pirâmide de idade permite mais flexibilidade, mas requer mais esforço e compreensão de como ggplot() funciona. Também é mais fácil cometer erros acidentalmente.Para usar ggplot() para fazer pirâmides demográficas, você cria dois gráficos de barra (um para cada gênero), converte os valores em um gráfico para negativo e, finalmente, vira os eixos x e y para exibir os gráficos de barra verticalmente, suas bases encontro meio da trama.","code":""},{"path":"age-pyramid.html","id":"preparação-22","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Preparação","text":"Essa abordagem usa coluna numérica idade, não coluna categórica de age_cat5. Portanto, vamos verificar se classe desta coluna é realmente numérica.Você poderia usar mesma lógica abaixo para construir uma pirâmide de dados categóricos usando geom_col() ao invés de geom_histogram().","code":"\nclass(linelist$age)## [1] \"numeric\""},{"path":"age-pyramid.html","id":"construindo-o-gráfico","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Construindo o gráfico","text":"Primeiro, entenda que para fazer essa pirâmide usando ggplot() abordagem é seguinte:Dentro de ggplot(), crie dois histogramas usando coluna numérica de idade. Crie um para cada um dos dois valores de agrupamento (neste caso, gêneros masculino e feminino). Para fazer isso, os dados de cada histograma são especificados em seus respectivos comandos geom_histogram(), com os respectivos filtros aplicados à linelist.Dentro de ggplot(), crie dois histogramas usando coluna numérica de idade. Crie um para cada um dos dois valores de agrupamento (neste caso, gêneros masculino e feminino). Para fazer isso, os dados de cada histograma são especificados em seus respectivos comandos geom_histogram(), com os respectivos filtros aplicados à linelist.Um gráfico terá valores de contagem positivos, enquanto o outro terá suas contagens convertidas em valores negativos - isso cria “pirâmide” com o valor 0 meio gráfico. Os valores negativos são criados usando um termo especial ggplot2 ..count.. e multiplicando por -1.Um gráfico terá valores de contagem positivos, enquanto o outro terá suas contagens convertidas em valores negativos - isso cria “pirâmide” com o valor 0 meio gráfico. Os valores negativos são criados usando um termo especial ggplot2 ..count.. e multiplicando por -1.O comando coord_flip() muda os eixos X e Y, resultando na viragem dos gráficos na vertical e na criação da pirâmide.O comando coord_flip() muda os eixos X e Y, resultando na viragem dos gráficos na vertical e na criação da pirâmide.Por último, os rótulos de valor eixo de contagem devem ser alterados para que apareçam como contagens “positivas” em ambos os lados da pirâmide (apesar dos valores subjacentes em um lado serem negativos).Por último, os rótulos de valor eixo de contagem devem ser alterados para que apareçam como contagens “positivas” em ambos os lados da pirâmide (apesar dos valores subjacentes em um lado serem negativos).Uma versão simples disso, usando geom_histogram(), está abaixo: **_ PERIGO: _** Se os limites seu eixo de contagem forem definidos muito baixos e uma barra de contagem ultrapassá-los, barra desaparecerá totalmente ou será reduzida artificialmente ! Observe isso ao analisar dados que são atualizados rotineiramente. Evite que os limites eixo de contagem se ajustem automaticamente aos seus dados, conforme abaixo. Há muitas coisas que você pode alterar / adicionar esta versão simples, incluindo:Ajuste automático da escala eixo de contagem aos seus dados (evite os erros discutidos aviso abaixo)Especifique manualmente cores e rótulos de legendaConverta contagens em porcentagensPara converter contagens em porcentagens (total), faça isso em seus dados antes de plotar. Abaixo, temos contagens de idade e gênero, então ungroup(), e então mutate() para criar novas colunas de porcentagem. Se você quiser porcentagens por gênero, pule etapa de desagrupamento.É importante ressaltar que salvamos os valores máximos e mínimos para que saibamos quais devem ser os limites da escala. Eles serão usados comando ggplot() abaixo.Finalmente, fazemos o ggplot() nos dados de porcentagem. Especificamos scale_y_continuous() para estender os comprimentos predefinidos em cada direção (positivo e “negativo”). Usamos floor() e ceiling() para arredondar decimais na direção apropriada (para baixo ou para cima) para o lado eixo.","code":"\nmax_per <- max(pyramid_data$percent, na.rm = T)\nmin_per <- min(pyramid_data$percent, na.rm = T)\n\nmax_per## [1] 10.9\nmin_per## [1] -7.1"},{"path":"age-pyramid.html","id":"compare-com-a-linha-de-base","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"Compare com a linha de base","text":"Com flexibilidade de ggplot(), você pode ter uma segunda camada de barras fundo que representam pirâmide populacional “verdadeira” ou “linha de base”. Isso pode fornecer uma boa visualização para comparar o observado com linha de base.Importe e visualize os dados populacionais (consulte página Baixar manual e dados):Primeiro, algumas etapas de gerenciamento de dados:Aqui gravamos ordem das categorias de idade que queremos que apareçam. Devido algumas peculiaridades na forma como o ggplot() é implementado, neste cenário específico é mais fácil armazená-los como um vetor de caracteres e usá-los posteriormente na função de gráfico.Combine população e os dados caso por meio da função dplyr bind_rows():Primeiro, certifique-se de que eles tenham os mesmos nomes de coluna, valores de categorias de idade e valores de gêneroFaça com que tenham mesma estrutura de dados: colunas de categoria de idade, sexo, contagens e porcentagem totalUna-os, um em cima outro (bind_rows())Revise o conjunto de dados de população alteradoAgora implemente o mesmo para linelist caso. Um pouco diferente porque começa com linhas de caso, não conta.Revise o conjunto de dados de caso alteradoAgora os dois data frames estão combinados, um em cima outro (eles têm os mesmos nomes de coluna). Podemos “nomear” cada frame de dados e usar o argumento .id = para criar uma nova coluna “data_source” que indicará de qual frame de dados cada linha se originou. Podemos usar esta coluna para filtrar ggplot().Armazene os valores percentuais máximos e mínimos, usados na função de plotagem para definir extensão da plotagem (e não encurte nenhuma barra!)Agora o gráfico é feito com ggplot():Um gráfico de barras de dados populacionais (barras mais largas e transparentes)Um gráfico de barras de dados caso (barras pequenas e mais sólidas)","code":"\n# importar os dados demográficos da população\npop <- rio::import(\"country_demographics.csv\")\n# registrar níveis corretos de gatos com idade\nage_levels <- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n# Defina a extensão do eixo percentual, usado para os limites do gráfico\nmax_per <- max(pyramid_data$percent, na.rm = T)\nmin_per <- min(pyramid_data$percent, na.rm = T)"},{"path":"age-pyramid.html","id":"escala-de-likert","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"31.4 Escala de Likert","text":"técnicas usadas para fazer uma pirâmide populacional com ggplot() também podem ser usadas para fazer gráficos de dados de pesquisa em escala Likert.Importe os dados (consulte página Baixar manual e dados se desejar).Comece com dados parecidos com estes, com uma classificação categórica de cada entrevistado (status) e suas respostas 8 perguntas em uma escala tipo Likert de 4 pontos (“Muito ruim”, “Ruim”, “Bom”, “Muito bom”).Primeiro, algumas etapas de gerenciamento de dados:Dinamizar os dados por mais tempoCrie uma nova coluna direção dependendo se resposta foi geralmente “positiva” ou “negativa”Defina ordem nível de fator para coluna status e coluna RespostaArmazene o valor de contagem máxima para que os limites gráfico sejam apropriadosAgora faça o gráfico. Como nas pirâmides de idades acima, estamos criando dois gráficos de barra e invertendo os valores de um deles para negativo.Usamos geom_bar() porque nossos dados são uma linha por observação, não contagens agregadas. Usamos o termo especial ggplot2 ..count.. em um dos gráficos de barra para inverter os valores negativos (* -1) e definimos position = \"stack\" para que os valores sejam empilhados topo de cada um.","code":"\n# importar os dados de resposta da pesquisa likert\nlikert_data <- rio::import(\"likert_data.csv\")"},{"path":"age-pyramid.html","id":"recursos-16","chapter":"31 Pirâmides demográficas e escalas Likert","heading":"31.5 Recursos","text":"Documentação pacote apyramid","code":""},{"path":"heatmaps.html","id":"heatmaps","chapter":"32 Gráficos de calor","heading":"32 Gráficos de calor","text":"Os gráficos de calor, também conhecidos como “mapas de calor” ou “blocos/ladrilhos de calor” (inglês heat tiles) , podem ser visualizações úteis ao tentar exibir 3 variáveis (eixo x, eixo y e preenchimento). Abaixo, demonstramos dois exemplos:Uma matriz visual de eventos de transmissão por idade (“quem infectou quem”)Acompanhamento de métricas de relatórios em muitas instalações / jurisdições ao longo tempo","code":""},{"path":"heatmaps.html","id":"preparação-23","chapter":"32 Gráficos de calor","heading":"32.1 Preparação","text":"","code":""},{"path":"heatmaps.html","id":"carregar-pacotes-8","chapter":"32 Gráficos de calor","heading":"Carregar pacotes","text":"Este pedaço de código mostra o carregamento de pacotes necessários para análises. Neste manual, enfatizamos p_load() pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() R base. Veja página em Introdução ao R para mais informações sobre pacotes R.Conjuntos de dadosEsta página utiliza lista de casos de um surto simulado para seção de matriz de transmissão e um conjunto de dados separado de contagens diárias de casos de malária por instalação para seção de rastreamento de métricas. Eles são carregados e limpos em suas seções individuais.","code":"\npacman :: p_load(\n  tidyverse, # manipulação e visualização de dados\n  rio, # importando dados \n  lubridate # trabalhando com datas\n  )"},{"path":"heatmaps.html","id":"matriz-de-transmissão","chapter":"32 Gráficos de calor","heading":"32.2 Matriz de transmissão","text":"Os quadrados de um mapa de calor podem ser úteis para visualizar matrizes. Um exemplo é exibir “quem infectou quem” em um surto. Isso pressupõe que você tenha informações sobre os eventos de transmissão.Observe que página Rastreamento de contato contém outro exemplo de criação de uma matriz de contato de tipo blocos/quadrados térmicos, usando um conjunto de dados diferente (talvez até mais simples) onde idades dos casos e suas fontes estão perfeitamente alinhadas na mesma linha de observação quadro de dados (data frame). Esses mesmos dados são usados para fazer um mapa de densidade na página dicas ggplot. O exemplo abaixo começa com uma linelist de caso e, portanto, envolve uma manipulação considerável de dados antes de obter um data frame que possa ser utilizado em um gráfico. Portanto, existem muitos cenários para escolher…Começamos com lista de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o “clean” linelist  (.rds file). Importe dados com função import() pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja página Importar e exportar para detalhes).primeiras 50 linhas da linelist são mostradas abaixo para demonstração:Nesta linelist:Existe uma linha por caso, conforme identificado por case_idExiste uma coluna posterior infector que contém ocase_id infectador, que também é um caso na linelist","code":"\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"heatmaps.html","id":"preparação-24","chapter":"32 Gráficos de calor","heading":"Preparação","text":"Objetivo: Precisamos alcançar um data frame de estilo “longo” que contenha uma linha por rota de transmissão de idade idade possível, com uma coluna com valores numéricos contendo proporção dessa linha de todos os eventos de transmissão observados na linelist.Isso exigirá várias etapas de manipulação de dados para alcançar:","code":""},{"path":"heatmaps.html","id":"criar-um-data-frame-dos-casos","chapter":"32 Gráficos de calor","heading":"Criar um data frame dos casos","text":"Para começar, criamos um data frame dos casos, suas idades e seus infectantes - chamamos o data frame de idades_de_caso. primeiras 50 linhas são exibidas abaixo.","code":"\ncase_ages <- linelist%>% \n  select(case_id, infector, age_cat)%>% \n  rename(\"case_age_cat\" = \"age_cat\")"},{"path":"heatmaps.html","id":"criar-um-data-frame-de-infectantes","chapter":"32 Gráficos de calor","heading":"Criar um data frame de infectantes","text":"seguir, criamos um data frame dos infectantes - momento, ele consiste em uma única coluna. Estas são IDs de infecção da linelist. Nem todos os casos têm um infectante conhecido, por isso removemos os valores ausentes. primeiras 50 linhas são exibidas abaixo.Em seguida, usamos junções para obter idades dos infectantes. Isso não é simples, pois na linelist, idades infectador não são listadas como tal. Alcançamos esse resultado juntando ‘linelist’ dos casos dos infectantes. Começamos com os infectantes e fazemos um left_join() ( ou seja, o adicionamos) com o linelist, de forma que o data frame de infectates seja “linha de base” e coluna infector id lado esquerdo se junte à coluna case_id na linelist direita.Assim, os dados registro caso infectante na linelist (incluindo idade) são adicionados à linha infectante. 50 primeiras linhas são exibidas abaixo.Em seguida, combinamos os casos e suas idades com os infectantes e suas idades. Cada um desses data frame tem coluna infector, então ela é usada para junção. primeiras linhas são exibidas abaixo:Abaixo, uma tabulação cruzada simples de contagens entre os casos e os grupos de idade dos infectantes. Rótulos foram adicionadas para maior clareza.Podemos converter esta tabela em um dataframe com data.frame() R base, que também converte automaticamente para o formato “longo”, que é desejado para o ggplot(). primeiras linhas são mostradas abaixo.Agora fazemos o mesmo, mas aplicamos prop.table() R base para tabela de forma que, em vez de contagens, obtenhamos proporções total. primeiras 50 linhas são mostradas abaixo.","code":"\ninfectors <- linelist %>% \n  select(infector) %>% \n  drop_na(infector)\ninfector_ages <- infectors%>% # começam com infectores\n  left_join(# adiciona os dados da linelist para cada infectador  \n    linelist,\n    by = c(\"infector\" = \"case_id\"))%>% # corresponde ao infector às suas informações como um caso\n  select(infector, age_cat)%>% # mantém apenas as colunas de interesse\n  rename(\"infector_age_cat\" = \"age_cat\")   # rename for clarity\nages_complete <- case_ages%>%  \n  left_join(\n    infector_ages,\n    by = \"infector\")%>% # utilizando a coluna `infector`coomo chave para a junção\n  drop_na() # excluir linhas com qualquer dado faltante## Warning in left_join(., infector_ages, by = \"infector\"): Detected an unexpected many-to-many relationship between `x` and `y`.\n## ℹ Row 1 of `x` matches multiple rows in `y`.\n## ℹ Row 6 of `y` matches multiple rows in `x`.\n## ℹ If a many-to-many relationship is expected, set `relationship = \"many-to-many\"` to\n##   silence this warning.\ntable(cases = ages_complete$case_age_cat,\n      infectors = ages_complete$infector_age_cat)##        infectors\n## cases   0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+\n##   0-4   105 156   105   114   143   117    13   0\n##   5-9   102 132   110   102   117    96    12   5\n##   10-14 104 109    91    79   120    80    12   4\n##   15-19  85 105    82    39    75    69     7   5\n##   20-29 101 127   109    80   143   107    22   4\n##   30-49  72  97    56    54    98    61     4   5\n##   50-69   5   6    15     9     7     5     2   0\n##   70+     1   0     2     0     0     0     0   0\nlong_counts <- data.frame(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat))\nlong_prop <- data.frame(prop.table(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat)))"},{"path":"heatmaps.html","id":"criar-gráfico-de-calor","chapter":"32 Gráficos de calor","heading":"Criar gráfico de calor","text":"Agora, finalmente, podemos criar o gráfico de calor com o pacote ggplot2, usando função geom_tile(). Veja página de dicas ggplot para aprender mais extensivamente sobre escalas de cor / preenchimento, especialmente função scale_fill_gradient().Na estética aes() de geom_tile() defina x e y como idade caso e idade infectanteTambém em aes() defina o argumento fill = para coluna Freq - este é o valor que será convertido para uma cor de blocoDefina uma cor de escala com scale_fill_gradient() - você pode especificar cores altas / baixas\nObserve que scale_color_gradient() é diferente! Neste caso, você quer o preenchimento\nObserve que scale_color_gradient() é diferente! Neste caso, você quer o preenchimentoComo cor é feita por meio de “preenchimento”, você pode usar o argumento fill = em labs() para alterar o título da legenda","code":"\nggplot(data = long_prop) + # usa um dataframe no formato longo, com proporções como Freq\n  geom_tile(# visualizar em quadrados\n    aes(\n      x = cases, # eixo x é a idade do caso\n      y = infectors, # eixo y é a idade do infectador\n      fill = Freq)) + # cor de cada quadrado é a coluna Freq nos dados\n  scale_fill_gradient(# ajusta a cor de preenchimento dos quadrados\n    low = \"blue\",\n    high = \"orange\")+\n  labs(# rótulos\n    x = \"Idade do caso\",\n    y = \"Idade do infectador\",\n    title = \"Quem infectou quem\",\n    subtitle = \"Matriz de frequência de eventos de transmissão\",\n    fill = \"Proporção de todos os eventos de \\ ntranmsission\" # título da legenda\n  )"},{"path":"heatmaps.html","id":"métricas-de-relatório-ao-longo-do-tempo","chapter":"32 Gráficos de calor","heading":"32.3 Métricas de relatório ao longo do tempo","text":"Frequentemente, na saúde pública, um objetivo é avaliar tendências ao longo tempo para muitas entidades (instalações, jurisdições, etc.). Uma maneira de visualizar essas tendências ao longo tempo é um gráfico de calor em que o eixo x é o tempo e eixo y estão várias entidades.","code":""},{"path":"heatmaps.html","id":"preparação-25","chapter":"32 Gráficos de calor","heading":"Preparação","text":"Começamos importando um conjunto de dados de relatórios diários da malária de muitos estabelecimentos. Os relatórios contêm uma data, província, distrito e contagens de malária. Consulte página em Baixar manual e dados para obter informações sobre como baixar esses dados. Abaixo estão primeiras 30 linhas:","code":"\nfacility_count_data <- import(\"malaria_facility_count_data.rds\")"},{"path":"heatmaps.html","id":"agregar-e-resumir","chapter":"32 Gráficos de calor","heading":"Agregar e resumir","text":"O objetivo neste exemplo é transformar contagens diárias de casos de malária total dos estabelecimentos (visto na guia anterior) em estatísticas resumidas semanais de desempenho de relatórios das instalações - neste caso proporção de dias por semana que instalação/estabelecimento relatou quaisquer dados. Para este exemplo, mostraremos dados apenas para Spring District.Para conseguir isso, faremos seguintes etapas de gerenciamento de dados:Filtre os dados conforme apropriado (por local, data)Crie uma coluna de semana usando floor_date() pacote lubridate\nEsta função retorna data de início da semana de uma determinada data, usando uma data de início especificada de cada semana (por exemplo, “Segundas”)\nEsta função retorna data de início da semana de uma determinada data, usando uma data de início especificada de cada semana (por exemplo, “Segundas”)Os dados são agrupados pelas colunas “local” e “semana” para criar unidades de análise de “semana-estabelecimento”função resumir() cria novas colunas para refletir estatísticas de resumo por grupo de semana-estabelecimento:\nNúmero de dias por semana (7 - um valor estático)\nNúmero de relatórios recebidos da semana-estabelecimento (pode ser mais de 7!)\nSoma dos casos de malária relatados pela semana-estabelecimento (apenas por interesse)\nNúmero de dias únicos na semana-estabelecimento para os quais há dados relatados\nPorcentagem dos 7 dias por semana-estabelecimento para os quais os dados foram relatados\nNúmero de dias por semana (7 - um valor estático)Número de relatórios recebidos da semana-estabelecimento (pode ser mais de 7!)Soma dos casos de malária relatados pela semana-estabelecimento (apenas por interesse)Número de dias únicos na semana-estabelecimento para os quais há dados relatadosPorcentagem dos 7 dias por semana-estabelecimento para os quais os dados foram relatadosOdata frame é unido com right_join() uma lista abrangente de todas combinações possíveis de semana-estabelecimento, para tornar o conjunto de dados completo. matriz de todas combinações possíveis é criada aplicando expand() essas duas colunas dodata frame, como está naquele momento na cadeia de pipes (representado por .). Como um right_join() é usado, todas linhas data frame expand() são mantidas e adicionadas agg_weeks se necessário. Essas novas linhas aparecem com valores resumidos NA (ausentes).Abaixo, demonstramos passo passo:Agora o conjunto de dados tem nrow(agg_weeks) linhas, quando anteriormente tinha nrow(facility_count_data).Em seguida, criamos uma coluna semana refletindo data de início da semana para cada registro. Isso é obtido com o pacote lubridate e função floor_date(), que é definida como “semana” e para semanas com início às segundas-feiras (dia 1 da semana - domingos seria 7). linhas superiores são mostradas abaixo.nova coluna da semana pode ser vista na extremidade direita quadro de dadosAgora agrupamos os dados em semana-instalação e os resumimos para produzir estatísticas por semana-instalação. Consulte página em Tabelas descritivas para dicas. O próprio agrupamento não altera o quadro de dados, mas impacta como estatísticas de resumo subsequentes são calculadas.linhas superiores são mostradas abaixo. Observe como colunas mudaram completamente para refletir estatísticas de resumo desejadas. Cada linha reflete uma semana-instalação.Por fim, executamos o comando abaixo para garantir que TODAS semanas-estabelecimento possíveis estejam presentes nos dados, mesmo que não existissem antes.Estamos usando um right_join() em si mesmo (o conjunto de dados é representado por “.”), Mas foi expandido para incluir todas combinações possíveis das colunas semana e localização_nome. Veja documentação sobre função expand() na página Pivoteando Dados. Antes de executar este código, o conjunto de dados contém linhas nrow(agg_weeks).Aqui está expanded_weeks:Antes de executar este código, agg_weeks contém linhas nrow(agg_weeks).Depois de executar este código, agg_weeks contém linhas nrow(agg_weeks).","code":"\n# Crie um conjunto de dados de resumo semanal\nagg_weeks <- facility_count_data%>% \n  \n  # filtrar os dados conforme apropriado\n  filter(\n    District == \"Spring\",\n    data_date < as.Date(\"2020-08-01\")) \nagg_weeks <- agg_weeks %>% \n  # Crie a coluna da semana a partir de data_date\n  mutate(\n    week = lubridate::floor_date(# criar uma nova coluna de semanas\n      data_date,  # date\n      unit = \"week\", # dá o início da semana\n      week_start = 1)) # semanas para começar às segundas-feiras \nagg_weeks <- agg_weeks %>%   \n\n  # Grupo em semana-estabelecimento\n  group_by(location_name, week) %>%\n  \n  # Crie colunas de estatísticas de resumo nos dados agrupados\n  summarise(\n    n_days = 7, # 7 dias por semana           \n    n_reports = dplyr::n(), # número de relatórios recebidos por semana (pode ser> 7)\n    malaria_tot = sum (malaria_tot, na.rm = T), # total de casos de malária relatados\n    n_days_reported = length(unique (data_date)), # número de dias únicos de relatórios por semana\n    p_days_reported = round(100*(n_days_reported / n_days))) # por cento de relatórios de dias\n# Crie um dataframe com todas as possibilidades de combinação semana-estabelecimento\nexpanded_weeks <- agg_weeks%>% \n  tidyr::expand(week) # expanda data frame para incluir todas as combinações possíveis de semana-estabelecimento\n# Use uma junção à direita com a lista expandida semana-estabelecimento para preencher as lacunas que faltam nos dados\nagg_weeks <- agg_weeks %>%      \n  right_join(expanded_weeks)%>% # Certifique-se de que todas as combinações possíveis de estabelecimento-semana apareçam nos dados\n  mutate(p_days_reported = replace_na(p_days_reported, 0)) # converter valores ausentes para 0                           ## Joining with `by = join_by(location_name, week)`"},{"path":"heatmaps.html","id":"criar-gráfico-de-calor-1","chapter":"32 Gráficos de calor","heading":"Criar gráfico de calor","text":"O ggplot() é feito usando geom_tile() pacote ggplot2:Semanas eixo x são transformadas em datas, permitindo o uso de scale_x_date()location_name eixo y mostrará todos os nomes de estabelecimentosO fill é p_days_reported, o desempenho para aquela semana-estabelecimento(numérico)scale_fill_gradient() é usado preenchimento numérico, especificando cores para alto, baixo e NAscale_x_date() é usado eixo x especificando rótulos cada 2 semanas e seu formatoTemas de exibição e rótulos podem ser ajustados conforme necessário","code":""},{"path":"heatmaps.html","id":"básico","chapter":"32 Gráficos de calor","heading":"Básico","text":"Um gráfico de calor básico é produzido abaixo, usando cores e escalas padrão. Como explicado acima, dentro de aes() para geom_tile() você deve fornecer uma coluna eixo x, coluna eixo y e uma coluna para o fill =. O preenchimento é o valor numérico apresentado como cor bloco.","code":"\nggplot(data = agg_weeks)+\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported))"},{"path":"heatmaps.html","id":"gráfico-limpo","chapter":"32 Gráficos de calor","heading":"Gráfico limpo","text":"Podemos fazer esse gráfico parecer melhor adicionando funções ggplot2 adicionais, conforme mostrado abaixo. Veja página em dicas ggplot para detalhes.","code":"\nggplot(data = agg_weeks)+ \n  \n  # mostrar dados como quadrados\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\") + # linhas de grade brancas\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # eixo de data\n  scale_x_date(\n    expand = c(0,0), # remove espaço extra nas laterais\n    date_breaks = \"2 weeks\", # rótulos a cada 2 semanas\n    date_labels = \"%d\\n%b\") + # formato é dia após mês (\\n em nova linha)\n  \n  # temas estéticos\n  theme_minimal() + # fundo simplificado\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1, \"cm\"), # altura da chave da legenda\n    legend.key.width = grid::unit(0.6, \"cm\"), # largura da chave da legenda\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust = 0.2), # alinhamento do texto do eixo\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size = 12, face = \"bold\"), # tamanho do título do eixo e negrito\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # legenda alinhado à direita e itálico\n    )+\n  \n  # rótulos de gráfico\n  labs(x = \"Semana\",\n       y = \"Nome da instalação\",\n       fill = \"Relatório de \\ndesempenho(%)\", # título da legenda, porque a legenda mostra preenchimento\n       title = \"Porcentagem de dias por semana em que a instalação relatou dados\",\n       subtitle = \"Estabelecimentos de saúde distritais, maio-julho de 2020\",\n       caption = \"semanas de 7 dias começando às segundas-feiras.\")"},{"path":"heatmaps.html","id":"eixo-y-ordenado","chapter":"32 Gráficos de calor","heading":"Eixo y ordenado","text":"Atualmente, instalações são ordenadas “alfanumericamente” de baixo para cima. Se você quiser ajustar ordem das facilidades eixo y, converta-em fator de classe e forneça ordem. Veja página em Fatores para dicas.Uma vez que existem muitos recursos e não queremos escrevê-los todos, tentaremos outra abordagem - ordenar os recursos em um data frame e usar coluna de nomes resultante como ordem dos níveis fator. Abaixo, coluna location_name é convertida em um fator, e ordem de seus níveis é definida com base número total de dias de relatório arquivados pela instalação/estabelecimento ao longo de todo o período de tempo.Para fazer isso, criamos um data frame que representa o número total de relatórios por instalação, organizados em ordem crescente. Podemos usar este vetor para ordenar os níveis dos fatores gráfico.Veja o data frame abaixo:Agora use uma coluna data frame acima (facility_order$location_name) para ser ordem dos níveis de fator de location_name quadro de dados agg_weeks:E agora os dados são adicionados um gráfico novamente, com location_name sendo um fator ordenado:","code":"\nfacility_order <- agg_weeks %>% \n  group_by(location_name)%>% \n  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% \n  arrange(tot_reports) # ordem crescente\nggplot(data = agg_weeks)+ \n  # mostrar dados como quadrados\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\") + # linhas de grade brancas\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # eixo de data\n  scale_x_date(\n    expand = c(0,0), # remove espaço extra nas laterais\n    date_breaks = \"2 weeks\", # rótulos a cada 2 semanas\n    date_labels = \"%d\\n%b\") + # formato é dia após mês (\\n em nova linha)\n  \n  # temas estéticos\n  theme_minimal() + # fundo simplificado\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1, \"cm\"), # altura da chave da legenda\n    legend.key.width = grid::unit(0.6, \"cm\"), # largura da chave da legenda\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust = 0.2), # alinhamento do texto do eixo\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size = 12, face = \"bold\"), # tamanho do título do eixo e negrito\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # legenda alinhado à direita e itálico\n    )+\n  \n  # rótulos de gráfico\n  labs(x = \"Semana\",\n       y = \"Nome da instalação\",\n       fill = \"Relatório de \\ndesempenho(%)\", # título da legenda, porque a legenda mostra preenchimento\n       title = \"Porcentagem de dias por semana em que a instalação relatou dados\",\n       subtitle = \"Estabelecimentos de saúde distritais, maio-julho de 2020\",\n       caption = \"semanas de 7 dias começando às segundas-feiras.\")"},{"path":"heatmaps.html","id":"valores-expostos","chapter":"32 Gráficos de calor","heading":"Valores expostos","text":"Você pode adicionar uma camada geom_text() topo dos quadrados, para exibir os números reais de cada quadrado. Esteja ciente de que isso pode não parecer muito elegante se você tiver muitos quadradinhos pequenos!O seguinte código foi adicionado: geom_text(aes(label = p_days_reported)). Isso adiciona texto cada bloco. O texto exibido é o valor atribuído ao argumento label =, que neste caso foi definido para mesma coluna numérica p_days_reported que também é usada para criar o gradiente de cor.","code":"\nggplot(data = agg_weeks)+ \n  # mostrar dados como quadrados\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\") + # linhas de grade brancas\n  \n  # texto\n  geom_text(\n    aes(\n      x = week,\n      y = location_name,\n      label = p_days_reported)) + # adicionar texto no topo do quadrado\n  \n  # escala de preenchimento\n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # eixo de data\n  scale_x_date(\n    expand = c(0,0), # remove espaço extra nas laterais\n    date_breaks = \"2 weeks\", # rótulos a cada 2 semanas\n    date_labels = \"%d\\n%b\") + # formato é dia após mês (\\n em nova linha)\n  \n  # temas estéticos\n  theme_minimal() + # fundo simplificado\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1, \"cm\"), # altura da chave da legenda\n    legend.key.width = grid::unit(0.6, \"cm\"), # largura da chave da legenda\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust = 0.2), # alinhamento do texto do eixo\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size = 12, face = \"bold\"), # tamanho do título do eixo e negrito\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # legenda alinhado à direita e itálico\n    )+\n  \n  # rótulos de gráfico\n  labs(x = \"Semana\",\n       y = \"Nome da instalação\",\n       fill = \"Relatório de \\ndesempenho(%)\", # título da legenda, porque a legenda mostra preenchimento\n       title = \"Porcentagem de dias por semana em que a instalação relatou dados\",\n       subtitle = \"Estabelecimentos de saúde distritais, maio-julho de 2020\",\n       caption = \"semanas de 7 dias começando às segundas-feiras.\")"},{"path":"heatmaps.html","id":"recursos-17","chapter":"32 Gráficos de calor","heading":"32.4 Recursos","text":"scale_fill_gradient()Galeria de gráfico R - mapa de calor","code":""},{"path":"diagrams.html","id":"diagrams","chapter":"33 Diagramas e gráficos","heading":"33 Diagramas e gráficos","text":"Esta página abrange o código para produzir:Diagramas de fluxo usando DiagrammeR e linguagem DOTDiagramas de fluxo usando DiagrammeR e linguagem DOTDiagramas aluviais/SankeyDiagramas aluviais/SankeyCronogramas de eventos\n\n\n\n## PreparaçãoCronogramas de eventos\n\n## Preparação","code":""},{"path":"diagrams.html","id":"carregar-pacotes-9","chapter":"33 Diagramas e gráficos","heading":"Carregar pacotes","text":"Este chunk mostra o carregamento dos pacotes necessárias para análises. Neste manual damos ênfase à função p_load() pacote pacman, que instala o pacote se necessário e carrega-o para utilização. Outra opção é carregar os pacotes instalados utilizando library() partir de R base. Ver página em Introdução ao R para mais informações sobre pacotes R.","code":"\npacman::p_load(\n  DiagrammeR,     # para diagrama de fluxo\n  networkD3,      # para diagrama aluvial/Sankey \n  tidyverse)      # exploração (gestão) e visualização de dados"},{"path":"diagrams.html","id":"importar-dados-3","chapter":"33 Diagramas e gráficos","heading":"Importar dados","text":"maior parte conteúdo desta página não requer um conjunto de dados. entanto, na seção diagrama de Sankey, usaremos lista de casos de uma simulação de epidemia de Ebola. Se você deseja acompanhar esta parte, clique link <ahref=‘https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rdsclass='download-button’> para baixar (como arquivo.rds). Importe os dados com import() função pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja página Importar e exportar para detalhesPara ver primeiras 50 linhas banco utilize o codigo seguir","code":"\n# importar a lista de casos\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"diagrams.html","id":"diagramas-de-fluxos","chapter":"33 Diagramas e gráficos","heading":"33.1 Diagramas de fluxos","text":"Pode-se usar o pacote R DiagrammeR para criar gráficos ou gráficos de fluxo. Esses podem ser estáticos, ou podem ser ajustados de forma dinâmica, partir das mudanças ou alterações conjunto de dados utilizado.FerramentasA função grViz() é utilizada para criar um diagrama “Graphviz”. Esta função aceita uma entrada de cadeia de caracteres contendo instruções para produção diagrama. Dentro dessa cadeia, instruções são escritas numa linguagem diferente, chamada DOT - mas muito fácil de aprender estrutura básica necessária.Estrutura básicaAbra instruções grViz(\"Especifique direcionalidade e o nome gráfico, e abra colchetes, por exemplo digraph my_flow_chart {Declaração gráfico (layout, direção de classificação)Declarações de nós (criar os nós)Declarações Bordas (fornece links entre os nós)Feche instruções }\")","code":""},{"path":"diagrams.html","id":"exemplos-simples","chapter":"33 Diagramas e gráficos","heading":"Exemplos simples","text":"seguir será usado dois exemplos simplesUm exemplo mínimo:Um exemplo mais aplicado ao contexto de saúde pública:","code":"\n# plotar o mínimo\nDiagrammeR::grViz(\"digraph {\n  \ngraph[layout = dot, rankdir = LR]\n\na\nb\nc\n\na -> b -> c\n}\")\ngrViz(\"                           # Todas as instruções estão dentro de uma grande cadeia de caracteres\ndigraph surveillance_diagram {    # 'digraph' significa 'grafico direcional', depois o nome do gráfico\n  \n  # declaração gráfica\n  #################\n  graph [layout = dot,\n         rankdir = TB,\n         overlap = true,\n         fontsize = 10]\n  \n  # nos(nodea)\n  #######\n  node [shape = circle,           # forma (shape) = circulo\n       fixedsize = true\n       width = 1.3]               # Largura dos círculos\n  \n  Primary                         # nome dos nós\n  Secondary\n  Tertiary\n\n  # edges\n  #######\n  Primary   -> Secondary [label = ' case transfer']\n  Secondary -> Tertiary [label = ' case transfer']\n}\n\")"},{"path":"diagrams.html","id":"sintaxe","chapter":"33 Diagramas e gráficos","heading":"Sintaxe","text":"Sintaxe básicaOs nomes de nós, ou declarações de borda, podem ser separados por espaços, ponto e vírgula ou novas linhas.Direção da classificaçãoUm gráfico pode ser reorientado para se mover da esquerda para direita, ajustando o rankdir argumento dentro da instrução gráfico. O padrão é TB (da cigla em inglês top--bottom - de cima para baixo), mas pode ser LR (da cigla em inglês left--right - da esquerda para direita), RL (da cigla em inglês right--left - da direita para esquerda) ou BT (da cigla em inglês bottom--top - baixo para cima).Nomes dos nósOs nomes dos nós podem ser palavras únicas, como exemplo simples acima. Para usar nomes com várias palavras ou caracteres especiais (por exemplo, parênteses, travessões), coloque o nome nó entre aspas simples (’ ’). Pode ser mais fácil ter um nome de nó curto e atribuir um rótulo label, como mostrado abaixo entre colchetes [ ]. Se você quiser ter uma nova linha nome nó, deve fazê-lo por meio de um rótulo - use \\n rótulo nó entre aspas simples, conforme mostrado abaixo.Subgrupos\nDentro das declarações de borda, podem ser criados subgrupos em ambos os lados da borda com chaves ({ }). borda aplica-se então todos os nós parêntese - é uma abreviação.Layoutsdot (set rankdir either TB, LR, RL, BT, )neatotwopicircoNós - atributos editáveislabel (Rótulo - texto, entre aspas simples, se houver várias palavras)fillcolor (Cor preenchimento - muitas cores possíveis)fontcolor (Cor da fonte - muitas cores possíveis)alpha (Alfa - transparência 0-1)shape (Formato - ellipse, oval, diamond, egg, plaintext, point, square, triangle)style (Estilo)sides (Tamanhos)peripheries (Margens)fixedsize (Tamanho fixo - h x w)height (Altura)width (Largura)distortion (Distorção)penwidth (Largura/espessura da linha - largura da borda da forma)x (deslocamento para esquerda e direita - left/righty (ddeslocamento para cima e para baixo - /downfontname (Nome da fonte)fontsize (Tamanho da fonte)icon (Ícone)Bordas - atributos editáveisarrowsize (Tamanho da seta)arrowhead (Ponta da seta - normal, box, crow, curve, diamond, dot, inv, none, tee, vee)arrowtail (Base da seta)dir (Direção)style (Estilo “dashed”, para tracejadas …)color (Cor)alpha (Alfa)headport (texto na ponta da seta)tailport (texto na da base da seta)fontname (Nome da fonte)fontsize (Tamanho da fonte)fontcolor(Cor da fonte)penwidth (Largura da linha)minlen (Comprimento minímo)Nomes das cores: usa-se valores hexadecimais ou os nomes de cores ‘X11’, consulte detalhes X11","code":""},{"path":"diagrams.html","id":"exemplos-complexos","chapter":"33 Diagramas e gráficos","heading":"Exemplos complexos","text":"O exemplo abaixo, expande o diagrama de vigilância, adicionando nomes de nós complexos, de bordas agrupadas, com cores e estiloClusters de sub-graficosPara agrupar nós em caixas de clusters, coloque-os dentro mesmo subgráfico nomeado (subgraph name {}). Para ter cada subgráfico identificado dentro de uma caixa delimitadora, comece o nome subgráfico com “cluster”, como exemplificado com 4 caixas abaixoFormas dos nósO exemplo abaixo, emprestado deste tutoriall, mostra exemplos de formas de nós (nodes) aplicadas e uma abreviatura para conexões seriais de borda","code":"    DiagrammeR::grViz(\"               # Todas as instruções estão dentro de uma grande cadeia de caracteres\n    digraph surveillance_diagram {    # 'digraph' significa 'gráfico direcional', depois vem o nome do gráfico\n      \n      # Declaração gráfica\n      #################\n      graph [layout = dot,\n             rankdir = TB,            # layout top-to-bottom (de cima para baixo)\n             fontsize = 10]\n      \n\n      # nós (em círculos)\n      #################\n      node [shape = circle,           # shape = circulos\n           fixedsize = true\n           width = 1.3]                      \n      \n      Primary   [label = 'Primary\\nFacility'] \n      Secondary [label = 'Secondary\\nFacility'] \n      Tertiary  [label = 'Tertiary\\nFacility'] \n      SC        [label = 'Surveillance\\nCoordination',\n                 fontcolor = darkgreen] \n      \n      # Bordas/margens\n      #######\n      Primary   -> Secondary [label = ' case transfer',\n                              fontcolor = red,\n                              color = red]\n      Secondary -> Tertiary [label = ' case transfer',\n                              fontcolor = red,\n                              color = red]\n      \n      # Bordas agrugapas\n      {Primary Secondary Tertiary} -> SC [label = 'case reporting',\n                                          fontcolor = darkgreen,\n                                          color = darkgreen,\n                                          style = dashed]\n}\n\")DiagrammeR::grViz(\"             # Todas as instruções estão dentro de uma grande cadeia de caracteres\ndigraph surveillance_diagram {  # 'digraph' significa 'gráfico direcional', depois vem o nome do gráfico\n      \n      # Demonstração gráfica\n      #################\n      graph [layout = dot,\n             rankdir = TB,            \n             overlap = true,\n             fontsize = 10]\n      \n\n      # nós (círculos)\n      #################\n      node [shape = circle,                  # shape = círculos\n           fixedsize = true\n           width = 1.3]                      # largura dos círculos\n      \n      subgraph cluster_passive {\n        Primary   [label = 'Primary\\nFacility'] \n        Secondary [label = 'Secondary\\nFacility'] \n        Tertiary  [label = 'Tertiary\\nFacility'] \n        SC        [label = 'Surveillance\\nCoordination',\n                   fontcolor = darkgreen] \n      }\n      \n      # nós (boxes)\n      ###############\n      node [shape = box,                     # formas dos nós (Box - Caixa)\n            fontname = Helvetica]            # fonte do texto no nó\n      \n      subgraph cluster_active {\n        Active [label = 'Active\\nSurveillance'] \n        HCF_active [label = 'HCF\\nActive Search']\n      }\n      \n      subgraph cluster_EBD {\n        EBS [label = 'Event-Based\\nSurveillance (EBS)'] \n        'Social Media'\n        Radio\n      }\n      \n      subgraph cluster_CBS {\n        CBS [label = 'Community-Based\\nSurveillance (CBS)']\n        RECOs\n      }\n\n      \n      # Bordas\n      #######\n      {Primary Secondary Tertiary} -> SC [label = 'case reporting']\n\n      Primary   -> Secondary [label = 'case transfer',\n                              fontcolor = red]\n      Secondary -> Tertiary [label = 'case transfer',\n                              fontcolor = red]\n      \n      HCF_active -> Active\n      \n      {'Social Media' Radio} -> EBS\n      \n      RECOs -> CBS\n    }\n    \")\n\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# definir os estilos globais dos nós. Podemos anulá-los em caixa, se essa for a opção escolhida.\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# Definições de bordas com as identificações dos nós\n{data1 data2}  -> process -> statistical -> results\n}\")"},{"path":"diagrams.html","id":"saídas","chapter":"33 Diagramas e gráficos","heading":"Saídas","text":"Como lidar e salvar resultadosAs saídas aparecerão painel Viewer RStudio, por padrão canto inferior direito ao lado de Files, Plots, Packages e Help.Para exportar, você pode “Salvar como imagem” ou “Copiar para área de transferência” Visualizador. O gráfico se ajustará ao tamanho especificado.","code":""},{"path":"diagrams.html","id":"figuras-parametrizadas","chapter":"33 Diagramas e gráficos","heading":"Figuras parametrizadas","text":"Aqui temos uma citação tutorial: https://mikeyharper.uk/flowcharts--r-using-diagrammer/“Figuras parametrizadas: um grande benefício de projetar figuras dentro de R é que somos capazes de conectar figuras diretamente com nossa análise, lendo os valores de R diretamente em nossos fluxogramas. Por exemplo, suponha que você tenha criado um processo de filtragem que remove valores após cada estágio de um processo, você pode ter uma figura mostrando o número de valores restantes conjunto de dados após cada estágio de seu processo. Para fazer isso, você pode usar o símbolo @@X diretamente na figura e, em seguida, referir-se ele rodapé gráfico usando [X]:, onde X é um índice numérico único.”Recomenda-se rever este este tutorial se parametrização é algo que você esteja interessado","code":""},{"path":"diagrams.html","id":"diagramas-aluviaissankey","chapter":"33 Diagramas e gráficos","heading":"33.2 Diagramas Aluviais/Sankey","text":"","code":""},{"path":"diagrams.html","id":"carregar-pacotes-10","chapter":"33 Diagramas e gráficos","heading":"Carregar pacotes","text":"Esta parte de código mostra o carregamento de pacotes necessários para análises. Neste manual enfatiza-se o p_load() pacman, que instala o pacote se necessário e carrega-o para uso. Você também pode carregar pacotes instalados usando biblioteca library() partir da base R. Consulte página sobre o [Introdução ao] (#basics) para obter mais informações sobre os pacotes R.Carregou-se o pacote networkD3 para construção diagrama, e o pacote tidyverse para etapas de preparação dos dados.","code":"\npacman::p_load(\n  networkD3,\n  tidyverse)"},{"path":"diagrams.html","id":"mapeamento-do-conjunto-de-dados","chapter":"33 Diagramas e gráficos","heading":"Mapeamento do conjunto de dados","text":"Mapeamento das ligações de um conjunto de dados. Abaixo é apresentado utilização deste pacote sobre o caso linelist. O tutorial está disponível online para consulta. Tutorial.Inicia-se obtendo contagem de casos para cada categoria etária e combinação por hospital. Os valores sem categoria de idade são removidos para maior clareza. Também foi realizado uma nova rotulagem (renomeadas), o hospital como fonte (source) e categorias de idades age_cat como alvo (target). Estes serão os dois lados diagrama aluvial.O conjunto de dados tem agora este aspecto:Agora cria-se um Data Frame, de todos os nós diagrama, sob coluna name. Isso consiste em todos os valores para hospital e age_cat. Observe que garantiu-se que todos eles pertecem classe Character antes de combiná-los. E ajustou-se colunas de ID para que fossem números em vez de rótulos:Na sequência editou-se o Data Frame links, criado anteriormente com o count(). Duas novas colunas númericas então foram adicionadas IDsource e IDtarget que irão refletir/criar os linques entre os nós. Essas colunas manterão os números das linhas (posição) dos nós tanto de origem como o destino. O 1 é subtraído, para que estes números de posição comecem em 0 (não em 1).O conjunto de dados Links agora tem este aspecto:Agora, hora de traçar o diagrama Sankey com sankeyNetwork(). Você pode ler mais sobre cada argumento correndo ?sankeyNetwork console. Note que, menos que defina iterations = 0 ordem dos seus nós pode não ser esperada.Aqui está um exemplo em que o resultado paciente também é incluído. Na etapa de preparação dos dados, é necessário calcular contagens de casos entre idade e o hospital, e separadamente entre o hospital e o resultado, e depois ligar todas estas contagens juntamente com bind_rows().Consulte: https://www.displayr.com/sankey-diagrams-r/","code":"\n# Contar por hospital e categoria de idade\nlinks <- linelist %>% \n  drop_na(age_cat) %>% \n  select(hospital, age_cat) %>%\n  count(hospital, age_cat) %>% \n  rename(source = hospital,\n         target = age_cat)\n# O nome único para os nós\nnodes <- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %>% \n    unique()\n  )\n\nnodes  # Exibir##                                    name\n## 1                               Ausente\n## 2                      Central Hospital\n## 3                     Military Hospital\n## 4                                 Other\n## 5                         Port Hospital\n## 6  St. Mark's Maternity Hospital (SMMH)\n## 7                                   0-4\n## 8                                   5-9\n## 9                                 10-14\n## 10                                15-19\n## 11                                20-29\n## 12                                30-49\n## 13                                50-69\n## 14                                  70+\n# corresponder a números e  não a nomes\nlinks$IDsource <- match(links$source, nodes$name)-1 \nlinks$IDtarget <- match(links$target, nodes$name)-1\n# traçar o diagrama\n######\np <- sankeyNetwork(\n  Links = links,\n  Nodes = nodes,\n  Source = \"IDsource\",\n  Target = \"IDtarget\",\n  Value = \"n\",\n  NodeID = \"name\",\n  units = \"TWh\",\n  fontSize = 12,\n  nodeWidth = 30,\n  iterations = 0)        # assegurar que a ordem dos nós é como nos dados\np\n# conta por hospital e categoria de idade\nage_hosp_links <- linelist %>% \n  drop_na(age_cat) %>% \n  select(hospital, age_cat) %>%\n  count(hospital, age_cat) %>% \n  rename(source = age_cat,          # renomear\n         target = hospital)\n\nhosp_out_links <- linelist %>% \n    drop_na(age_cat) %>% \n    select(hospital, outcome) %>% \n    count(hospital, outcome) %>% \n    rename(source = hospital,       # renomear\n           target = outcome)\n\n# combinar links\nlinks <- bind_rows(age_hosp_links, hosp_out_links)\n\n# Nome único para os nós\nnodes <- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %>% \n    unique()\n  )\n\n# Criar números de identificação\nlinks$IDsource <- match(links$source, nodes$name)-1 \nlinks$IDtarget <- match(links$target, nodes$name)-1\n\n# exibir\n######\np <- sankeyNetwork(Links = links,\n                   Nodes = nodes,\n                   Source = \"IDsource\",\n                   Target = \"IDtarget\",\n                   Value = \"n\",\n                   NodeID = \"name\",\n                   units = \"TWh\",\n                   fontSize = 12,\n                   nodeWidth = 30,\n                   iterations = 0)\np"},{"path":"diagrams.html","id":"cronograma-de-eventos","chapter":"33 Diagramas e gráficos","heading":"33.3 Cronograma de eventos","text":"Para fazer uma linha tempo mostrando eventos específicos, você pode usar o pacote vistime.Veja vignetteAqui está um conjunto de dados de eventos para começar","code":"\n# Carregando  o pacote\npacman::p_load(vistime,  # criando a linha do tempo\n               plotly    # para visualização interativa\n               )\np <- vistime(data)    # aplicar  o vistime\n\nlibrary(plotly)\n\n# passo 1: transformar em lista\npp <- plotly_build(p)\n\n# passo 2: Tamanho do marcador\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"markers\") pp$x$data[[i]]$marker$size <- 10\n}\n\n# passo 3: tamanho do texto\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textfont$size <- 10\n}\n\n\n# passo 4: posição do texto\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textposition <- \"right\"\n}\n\n#exibir\npp"},{"path":"diagrams.html","id":"gráficos-cíclicos-direcionados---dags","chapter":"33 Diagramas e gráficos","heading":"33.4 Gráficos cíclicos direcionados - DAGs","text":"Você pode construir um DAG manualmente usando o pacote DiagammeR e linguagem DOT conforme descrito acima.Uma outra alternativa é usar os pacotes como ggdag e daggityIntrodução DAGs ggdag vignetteCausal Inferência com dags R","code":""},{"path":"diagrams.html","id":"recursos-18","chapter":"33 Diagramas e gráficos","heading":"33.5 Recursos","text":"Muito que foi dito acima em relação à linguagem DOT é adaptado tutorial nesta páginaOutro tutorial mais aprofundado tutorial DiagammeRConsulte esta página Sankey diagrams","code":""},{"path":"combination-analysis.html","id":"combination-analysis","chapter":"34 Análise de Combinações","heading":"34 Análise de Combinações","text":"Essa análise gera um gráfico de frequência de diferentes combinações de valores e respostas. Nesse exemplo, geramos o gráfico da frequência casos exibiram várias combinações de sintomas.Esse tipo de análise também é chamada de:“Análise de respostas múltiplas” (“Multiple response analysis”)“Análise de Conjuntos” (“Sets analysis”)“Análise de Combinações” (“Combinations analysis”)gráfico de exemplo acima são mostrados cinco sintomas. Abaixo de cada barra vertical há uma linha e pontos indicando combinação de sintomas refletidos pela barra de cima. À esquerda, barras horizontais refletem frequência de cada sintoma individualmente.O primeiro método que mostraremos utiliza o pacote ggupset, e o segundo utiliza o pacote UpSetR.","code":""},{"path":"combination-analysis.html","id":"preparação-26","chapter":"34 Análise de Combinações","heading":"34.1 Preparação","text":"","code":""},{"path":"combination-analysis.html","id":"carregue-os-pacotes-r-4","chapter":"34 Análise de Combinações","heading":"Carregue os pacotes R","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  tidyverse,     # manupulação de dados e visualização\n  UpSetR,        # pacote especial para gráficos de combinção \n  ggupset)       # pacote especial para gráficos de combinção "},{"path":"combination-analysis.html","id":"importe-os-dados-6","chapter":"34 Análise de Combinações","heading":"Importe os dados","text":"Para iniciar, importaremos linelist dos casos de uma epidemia simulada Ebola. Se você quiser acompanhar, clique para baixar linelist “limpa” (como um arquivo .rds). Importe os dados com função import() pacote rio (função suporta vários tipos de arquivo como .xlsx, .csv, .rds - cheque página Importar e exportar para mais detalhes).Essa linelist inclui cinco variáveis tipo “sim/não” (“sim/”) respeito dos sintomas relatados. Nós vamos precisar transformar essas variáveis um pouco para poder utilizar o pacote ggupset para fazer nosso gráfico. Confira os dados (role para direita para ver variáveis dos sintomas).","code":"\n# importe a linelit de casos \nlinelist_sym <- import(\"linelist_cleaned.rds\")"},{"path":"combination-analysis.html","id":"reformate-os-valores","chapter":"34 Análise de Combinações","heading":"Reformate os valores","text":"Para estarmos alinhados com o formato esperado pelo pacote ggupset vamos converter os “sim” e “não” para o real nome sintoma utilizando função case_when() pacote dplyr. Caso seja “não”, definiremos o valor como vazio, então os valores serão NA ou o nome sintoma.Agora nós geramos duas colunas finais:Concatenando (unindo) todos os sintomas paciente (uma coluna de caracteres)Convertendo coluna acima para classe list, para que ela possa ser passada ao pacote ggupset para fazer o gráfico.Veja página de Caracteres e strings para aprender mais sobre função unite() pacote stringrVeja nova tabela. Note duas colunas na extremidade da direta - os valores combinados, e lista","code":"\n# criar uma coluna com todos os sintomas separados por ponto-vírgula \nlinelist_sym_1 <- linelist_sym %>% \n  rename(febre=fever, # só traduzindo\n         calafrio=chills,\n         tosse=cough,\n         dores=aches,\n         vômito = vomit) %>% \n  # converte os valores de \"yes\" e \"no\" no nome do sintoma\n  mutate(\n    febre = case_when(\n      febre == \"yes\" ~ \"febre\",          #se o valor era \"sim\", o novo valor é \"febre\"\n      TRUE           ~ NA_character_),   # se o valor era diferente de \"sim\", o novo valor é NA\n         \n    calafrio = case_when(\n       calafrio == \"yes\" ~ \"calafrio\",\n       TRUE           ~ NA_character_),\n    \n    tosse = case_when(\n      tosse == \"yes\" ~ \"tosse\",\n      TRUE           ~ NA_character_),\n         \n    dores = case_when(\n      dores == \"yes\" ~ \"dores\",\n      TRUE           ~ NA_character_),\n         \n    vômito = case_when(\n      vômito == \"yes\" ~ \"vômito\",\n      TRUE           ~ NA_character_)\n    )\nlinelist_sym_1 <- linelist_sym_1 %>% \n  unite(col = \"all_symptoms\",\n        c(febre, calafrio, tosse, dores, vômito), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %>% \n  mutate(\n    # faz uma cópia de da coluna all_symptoms, mas na classe lista (que é requisito do ggupset() no próximo passo)\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )"},{"path":"combination-analysis.html","id":"ggupset","chapter":"34 Análise de Combinações","heading":"34.2 ggupset","text":"Carregue o pacoteCrie o gráfico. Vamos começar com um ggplot() e função geom_bar(), mas depois vamos adicionar função scale_x_upset() pacote ggupset.Mais informações sobre ggupset podem ser vistas online ou offline na documentação pacote na aba de Ajuda seu RStudio após digitar ?ggupset console.","code":"\npacman::p_load(ggupset)\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"febre\", \"calafrio\", \"tosse\", \"dores\", \"vômito\"))+\nlabs(\n  title = \"Sinais e Sintomas\",\n  subtitle = \"10 combinações mais frequentes de sinais e sintomas\",\n  caption = \"Rodapé aqui\",\n  x = \"Combinação de Sintomas\",\n  y = \"Frequência na base de dados\")"},{"path":"combination-analysis.html","id":"upsetr","chapter":"34 Análise de Combinações","heading":"34.3 UpSetR","text":"O pacote UpSetR permite mais personalizações gráfico, mas pode ser mais difícil de executar.Carregue o pacoteLimpando os dadosPrecisamos converter os valores dos sintomas da linelist para 1 / 0.Agora vamos fazer o gráfico utilizando função upset() - utilizando apenas colunas de sintomas. Você deve definir quais “conjuntos” serão comparados (passe os nomes das colunas de sintomas). Ou então, utilize nsets = e order.= \"freq\" para mostrar apenas maiores X combinações.","code":"\npacman::p_load(UpSetR)\n# Make using upSetR\n\nlinelist_sym_2 <- linelist_sym %>% \n  rename(febre=fever, # só traduzindo\n         calafrio=chills,\n         tosse=cough,\n         dores=aches,\n         vômito = vomit) %>% # só traduzindo\n  # converte os valores de \"sim\" e \"não\" nos nomes dos sintomas\n  mutate(\n    febre = case_when(\n      febre == \"yes\" ~ 1,    # se o valor antigo era \"yes\", então o novo valor é 1\n      TRUE           ~ 0),   # se o valor era qualquer coisa diferente de \"yes\", o novo valor é 0\n         \n    calafrio = case_when(\n      calafrio == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    tosse = case_when(\n      tosse == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    dores = case_when(\n      dores == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    vômito = case_when(\n      vômito == \"yes\" ~ 1,\n      TRUE           ~ 0)\n    )\n# Make the plot\nUpSetR::upset(\n  select(linelist_sym_2, febre, calafrio, tosse, dores, vômito),\n  sets = c(\"febre\", \"calafrio\", \"tosse\", \"dores\", \"vômito\"),\n  order.by = \"freq\",\n  sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # cores opcionais\n  empty.intersections = \"on\",\n  # nsets = 3,\n  number.angles = 0,\n  point.size = 3.5,\n  line.size = 2, \n  mainbar.y.label = \"Combinação de sintomas\",\n  sets.x.label = \"Pacientes com Sintomas\")"},{"path":"combination-analysis.html","id":"recursos-19","chapter":"34 Análise de Combinações","heading":"34.4 Recursos","text":"Página github UpSetRUma versão em Shiny App - você pode fazer upload de seus próprios dados*documentação - difícil de interpretar","code":""},{"path":"transmission-chains.html","id":"transmission-chains","chapter":"35 Cadeias de Transmissão","heading":"35 Cadeias de Transmissão","text":"","code":""},{"path":"transmission-chains.html","id":"visão-geral-4","chapter":"35 Cadeias de Transmissão","heading":"35.1 Visão Geral","text":"ferramenta primária para manipular, analisar e visualizar dados de cadeias de transmissão e rastreamento de contatos é o pacote epicontacts, desenvolvido por membros RECON. Experimente o gráfico interativo abaixo passando o mouse sobre os nós para ver mais informações,\narrastando para movê-los e clicando para destacar os casos subjacentes.","code":""},{"path":"transmission-chains.html","id":"preparação-27","chapter":"35 Cadeias de Transmissão","heading":"35.2 Preparação","text":"","code":""},{"path":"transmission-chains.html","id":"carregue-os-pacotes-r-5","chapter":"35 Cadeias de Transmissão","heading":"Carregue os pacotes R","text":"Primeiro carregue os pacotes padrão necessários para importar e manipular os dados. Neste manual, enfatizamos o uso da função p_load(), *pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base**. Para mais informações sobre os pacotes R, veja página Introdução ao R.Você vai instalar versão de desenvolvimento epicontacts, que pode ser instalado diretamente github utilizando função p_install_github() pacote pacman. Você precisa rodar esse comando abaixo apenas uma vez, e não todas vezes que usar o pacote (daí em diante, você pode utilizar p_load() como de costume).","code":"\npacman::p_load(\n  rio, # Importação de arquivos\n  here, # Localizador de arquivos\n  tidyverse, # Gerenciamento de dados + gráficos do ggplot2\n  remotes # Instalação de pacotes do ggplot2\n)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")"},{"path":"transmission-chains.html","id":"importando-os-dados-1","chapter":"35 Cadeias de Transmissão","heading":"Importando os dados","text":"Vamos importar base de dados de casos da epidemia simulada de Ebola. Se você quiser fazer download dos dados para seguir o passo passo, veja instruções na página Baixando dados manual. base será importada utilizando função import() pacote rio. Veja página sobre Importação e exportação para aprender várias formas de importar dados.primeiras 50 linhas da linelist são mostradas abaixo. colunas de especial interesse são case_id, generation, infector, e source.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"transmission-chains.html","id":"criando-um-objeto-do-tipo-epicontacts","chapter":"35 Cadeias de Transmissão","heading":"Criando um objeto do tipo epicontacts","text":"Depois, precisamos criar um objeto epicontacts, que requer dois tipos de dados:uma linelist documentando casos onde colunas são variáveis e colunas correspondem casos únicosuma lista de arestas definindo ligações entre os casos com base em seus IDs únicos (esses podem ser contatos, eventos de transmissão, etc.)Como já temos uma linelist, precisamos apenas criar lista de arestas entre os casos, mais especificamente entre seus IDs. Podemos extrair relações de transmição da linelist ao relacionar coluna infector com coluna case_id. Nesse ponto podemos também adicionar “propriedades das arestas”, que seriam quaisquer variáveis que descrevem relação entre os dois casos, e não os casos em si. Para ilustrar, vamos adicionar uma variável location que descreve o local evento de transmissão, e uma variável de duração, que descreve duração contato em dias.código abaixo, função transmute dplyr atua de forma semelhante à mutate, com diferença que ela mantém apenas colunas que especificamos na chamada. função drop_na vai filtrar quaisquer linhas cujas colunas especificadas tenham o valor NA; nesse caso, queremos manter apenas linhas cujo transmissor (infector) é conhecido.Agora podemos criar o objeto epicontacts utilizando função make_epicontacts. Precisamos especificar qual coluna da linelist aponta para o identificador único dos casos, bem como quais colunas dos contatos apontam para os identificadores únicos dos casos envolvidos em cada relação. Essas relações são direcionadas pois transmissão vai () transmissor para () o caso, então precisamos especificar os argumentos e de acordo. Nós também definimos o argumento directed (direcionado) para TRUE, o que vai afetar operações futuro.Ao examinarmos objetos tipo epicontacts, podemos ver que coluna case_id na linelist foi renomeada para id e colunas case_id e infector nos contatos foram renomeadas para e . Isso garante consistência nas operações de manipulação, visualização e análise subsequentes.","code":"\n## gera os contatos\ncontacts <- linelist %>%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %>%\n  drop_na(infector)\n## gera o objeto epicontacts\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n## visualiza o objeto epicontacts\nepic## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 5,888 cases in linelist; 3,800 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 5,888 × 30\n##    id     generation date_infection date_onset date_hospitalisation date_outcome\n##    <chr>       <dbl> <date>         <date>     <date>               <date>      \n##  1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n##  2 8689b7          4 NA             2014-05-13 2014-05-14           2014-05-18  \n##  3 11f8ea          2 NA             2014-05-16 2014-05-18           2014-05-30  \n##  4 b8812a          3 2014-05-04     2014-05-18 2014-05-20           NA          \n##  5 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6 be99c8          3 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8 369449          4 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9 f393b4          4 NA             2014-06-05 2014-06-06           2014-06-18  \n## 10 1389ca          4 NA             2014-06-05 2014-06-07           2014-06-09  \n## # ℹ 5,878 more rows\n## # ℹ 24 more variables: outcome <chr>, gender <chr>, age <dbl>, age_unit <chr>,\n## #   age_years <dbl>, age_cat <fct>, age_cat5 <fct>, hospital <chr>, lon <dbl>,\n## #   lat <dbl>, infector <chr>, source <chr>, wt_kg <dbl>, ht_cm <dbl>,\n## #   ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\n## \n##   // contacts\n## \n## # A tibble: 3,800 × 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f547d6 5fe599 Community         3\n##  2 f90f5f b8812a Nosocomial        4\n##  3 11f8ea 893f25 Nosocomial        8\n##  4 aec8ec be99c8 Nosocomial        5\n##  5 893f25 07e3e8 Community         7\n##  6 133ee7 369449 Community         7\n##  7 996f3a 2978ac Community         2\n##  8 133ee7 57a565 Community         5\n##  9 37a6f6 fc15ef Community         7\n## 10 9f6884 2eaa9a Nosocomial        4\n## # ℹ 3,790 more rows"},{"path":"transmission-chains.html","id":"manipulando","chapter":"35 Cadeias de Transmissão","heading":"35.3 Manipulando","text":"","code":""},{"path":"transmission-chains.html","id":"subsetting-subconjuntos","chapter":"35 Cadeias de Transmissão","heading":"Subsetting (subconjuntos)","text":"O método subset() dos objetos epicontacts permitem, entre outras coisas, filtrar redes baseadas nas propriedades da linelist (“node attributes”) e da base de contatos (“edge attributes”). Esses valores devem ser passados como listas nomeadas ao argumento respectivo. Por exemplo, código abaixo estamos mantendo apenas os casos masculinos da linelist que possuem data da infecção entre abril e julho de 2014 (datas são especificadas como intervalos), e relações de transmissão que ocorreram hospital.Podemos utilizar função thin para filtrar linelist para incluir casos encontrados nos contatos definindo o argumento = \"linelist\", ou filtrar os contatos para incluir casos enontrados na linelist definindo o argumento = \"contacts\". código abaixo, vamos continuar filtrando o objeto epicontacts para manter apenas relações de transmissão que envolvam os casos masculinos infectados entre abril e julho que já filtramos acima. Podemos ver que apenas duas relações de transmissão se encaixam nessa especificação.Além de gerar os subconjuntos partir dos atributos dos nós (node) e arestas (edges), redes podem ser aparadas para incluir apenas componentes que estejam conectados com certos nós. O argumento cluster_id recebe um vetor dos IDs dos casos e retorna uma linelist dos indivíduos que estão relacionados, direta ou indiretamente, esses IDs. código abaixo, podemos ver que um total de 13 casos da linelist estão envolvididos nos agrupamentos (clusters) contendo 2ae019 e 71577a.O método subset() para os objetos epicontacts também permite filtrar pelo tamanho agrupamento utilizando os argumentos cs, cs_min e cs_max. código abaixo, estamos mantendo apenas os casos relacionados aos agrupamentos com 10 casos ou mais, e podemos ver que 271 casos da linelist estão envolvidos nesses agrupamentos.","code":"\nsub_attributes <- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ),\n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 69 cases in linelist; 1,961 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 69 × 30\n##    id     generation date_infection date_onset date_hospitalisation date_outcome\n##    <chr>       <dbl> <date>         <date>     <date>               <date>      \n##  1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n##  2 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  3 2978ac          4 2014-05-30     2014-06-06 2014-06-08           2014-06-15  \n##  4 57a565          4 2014-05-28     2014-06-13 2014-06-15           NA          \n##  5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17           2014-07-09  \n##  6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29           2014-07-09  \n##  7 f327be          6 2014-06-14     2014-07-12 2014-07-13           2014-07-14  \n##  8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14           2014-07-16  \n##  9 a47529          5 2014-06-13     2014-07-17 2014-07-18           2014-07-26  \n## 10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20           2014-08-01  \n## # ℹ 59 more rows\n## # ℹ 24 more variables: outcome <chr>, gender <chr>, age <dbl>, age_unit <chr>,\n## #   age_years <dbl>, age_cat <fct>, age_cat5 <fct>, hospital <chr>, lon <dbl>,\n## #   lat <dbl>, infector <chr>, source <chr>, wt_kg <dbl>, ht_cm <dbl>,\n## #   ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\n## \n##   // contacts\n## \n## # A tibble: 1,961 × 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f90f5f b8812a Nosocomial        4\n##  2 11f8ea 893f25 Nosocomial        8\n##  3 aec8ec be99c8 Nosocomial        5\n##  4 9f6884 2eaa9a Nosocomial        4\n##  5 8e104d ddddee Nosocomial        1\n##  6 ab634e 99e8fa Nosocomial        7\n##  7 beb26e 959170 Nosocomial        4\n##  8 567136 8ebf6e Nosocomial        8\n##  9 894024 e56412 Nosocomial        7\n## 10 36e2e7 6d788e Nosocomial        6\n## # ℹ 1,951 more rows\nsub_attributes <- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)## [1] 3\nsub_id <- subset(epic, cluster_id = c(\"2ae019\", \"71577a\"))\nnrow(sub_id$linelist)## [1] 13\nsub_cs <- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)## [1] 271"},{"path":"transmission-chains.html","id":"acessando-os-ids","chapter":"35 Cadeias de Transmissão","heading":"Acessando os IDs","text":"função get_id() recupera informações dos IDs dos casos na base de dados, e pode ser parametrizada como:linelist: IDs nos dados da linelistcontacts: IDs na base de contatos (“” e “” combinados): IDs na coluna “” da base de contatosto IDs na coluna “” da base de contatosall: IDs que aparecem em qualquer coluna e em qualquer basecommon: IDs que aparecem tanto na linelist quanto nos contatosPor exemplo, quais são os primeiros dez IDs na base de contatos?Quantos IDs são encontratos tanto na linelist quanto nos contatos?","code":"\ncontacts_ids <- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)##  [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\" \"9f6884\"\n## [10] \"4802b1\"\nlength(get_id(epic, \"common\"))## [1] 4352"},{"path":"transmission-chains.html","id":"visualização","chapter":"35 Cadeias de Transmissão","heading":"35.4 Visualização","text":"","code":""},{"path":"transmission-chains.html","id":"geração-de-gráficos-básicos","chapter":"35 Cadeias de Transmissão","heading":"Geração de gráficos básicos","text":"Todas visualizações dos objetos epicontacts são tratadas pela função plot. Primeiro vamos filtrar o objeto epicontacts para incluir apenas os casos com datas de início em junho de 2014 utilizando função subset, e então, incluir apenas os contatos relacionados esses casos com função thin.Podemos criar o gráfico básico e interativo de forma muito simples, como mostrado seguir:Você pode mover os nós arrastando-os, passar o mouse sobre eles para mais informações ou clicar neles para destacar os casos conectados.Existem inúmeros argumentos para fazer modificações esse gráfico. Iremos cobrir os principais aqui, mas confira documentação via ?vis_epicontacts (função chamada ao utilizar plot em um objeto epicontacts) para ver uma descrição completa dos argumentos da função.","code":"\n## subconjunto (subset) do objeto epicontacts\nsub <- epic %>%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %>%\n  thin(\"contacts\")\n## cria o gráfico do objeto epicontacts\nplot(\n  sub,\n  width = 700,\n  height = 700\n)"},{"path":"transmission-chains.html","id":"visualizando-atributos-dos-nós","chapter":"35 Cadeias de Transmissão","heading":"Visualizando atributos dos nós","text":"Cor, forma e tamanho dos nós podem ser mapeados uma dada coluna na linelist utilizando respectivamente os argumentos node_color, node_shape e node_size. Isso é parecido com sintaxe da função aes, que você deve reconhecer, pacote ggplot2.cores, formas e tamanhos dos nós podem ser especificados da seguinte forma:Cores: via argumento col_pal, seja pelo fornecimento de uma lista nomeda, para especificação manual da cada cor, como fizemos abaixo, ou pelo fornecimento de uma função de paleta de cor tal como colorRampPalette(c(\"black\", \"red\", \"orange\")), que irá fornecer um degradê de cores entre especificadas.Cores: via argumento col_pal, seja pelo fornecimento de uma lista nomeda, para especificação manual da cada cor, como fizemos abaixo, ou pelo fornecimento de uma função de paleta de cor tal como colorRampPalette(c(\"black\", \"red\", \"orange\")), que irá fornecer um degradê de cores entre especificadas.Formas: passando uma lista nomeada ao argumento shapes, especificando uma forma para cada elemento único da coluna da linelist especificado pelo argumento node_shape. Veja codeawesome para formas disponíveis.Formas: passando uma lista nomeada ao argumento shapes, especificando uma forma para cada elemento único da coluna da linelist especificado pelo argumento node_shape. Veja codeawesome para formas disponíveis.Tamanho: passando um intervalo de tamanhos dos nós para o argumento size_range.Tamanho: passando um intervalo de tamanhos dos nós para o argumento size_range.Aqui vemos um exemplo, onde cor representa o desfecho, forma representa o gênero e tamanho idade:","code":"\nplot(\n  sub,\n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"visualizando-atributos-das-arestas","chapter":"35 Cadeias de Transmissão","heading":"Visualizando atributos das arestas","text":"Edge color, width linetype can mapped given column contacts dataframe using edge_color, edge_width edge_linetype arguments. specific colors widths edges can specified follows:\nCor, espessura e tipo de linha das arestas podem ser mepeados uma dada coluna dataframe de contatos utilizando, respectivamente, os argumentos edge_color, edge_width e edge_linetype. cores e espessuras, em específico, podem ser passadas como abaixo:Cores: via argumento edge_col_pal, da mesma maneira utilizada para col_pal.Cores: via argumento edge_col_pal, da mesma maneira utilizada para col_pal.Espessuras passando um intervalo de espessura para o argumento width_range.Espessuras passando um intervalo de espessura para o argumento width_range.Aqui temos um exemplo:","code":"\nplot(\n  sub,\n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = \"location\",\n  edge_linetype = \"location\",\n  edge_width = \"duration\",\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"eixo-temporal","chapter":"35 Cadeias de Transmissão","heading":"Eixo Temporal","text":"Também podemos visualizar rede ao longo eixo temporal ao mapear o argumento x_axis alguma coluna na linelist. exemplo abaixo, o eixo x representa data de início dos sintomas. Também especificamos o argumento arrow_size para nos certificar que setas não serão muito grandes, e definimos label = FALSE para deixar figura menos congestionada.Existem inúmeros outros argumentos para especificar como essa rede pode ser visualizada ao longo de um eixo temporal, você pode conferi-los via ?vis_temporal_interactive (função que é chamada ao utilizar plot em um objeto epicontacts com o argumento x_axis especificado). Vamos ver algumas formas abaixo.","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"especificando-a-forma-de-uma-árvore-de-transmissão","chapter":"35 Cadeias de Transmissão","heading":"Especificando a forma de uma árvore de transmissão","text":"árvores de transmissão podem assumir duas formas principais, especificadas utilizando o argumento network_shape. primeira é forma branching como mostrada acima, em que uma aresta reta conecta dois nós. Essa é representação mais intuitiva, entanto pode resultar em arestas sobrepostas em uma rede densamente conectada. segunda forma é um rectangle, que produz uma árvore que se parece com uma filogenia. Por exemplo:Cada caso pode ser associado uma posição vertical única ao se modificar o argumento position_dodge. posição dos casos não-conectados (ex: sem nenhum contato reportado) é especificada utilizando o argumento unlinked_pos.posição dos nós pais em relação aos nós filhos pode ser especificada utilizando o argumento parent_pos. opção padrão é posicionar o nó pai meio, porém ele pode ser posicionado na parte de baixo (parent_pos = 'bottom') ou na parte de cima (parent_pos = 'top').","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"salvando-os-gráficos-e-figuras","chapter":"35 Cadeias de Transmissão","heading":"Salvando os gráficos e figuras","text":"Você pode salvar um mapa como um arquivo html interativo e auto-contido com função visSave pacote VisNetwork:Salvar essas saídas de redes como imagens, infelizmente não é tão simples e requer que você salve o arquivo como html e depois tire um screenshot arquivo utilizando o pacote webshot. código abaixo, estamos convertendo o arquivo html salvo acima em um PNG:","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %>%\n  visNetwork::visSave(\"network.html\")\nwebshot(url = \"network.html\", file = \"network.png\")"},{"path":"transmission-chains.html","id":"linhas-do-tempo","chapter":"35 Cadeias de Transmissão","heading":"Linhas do Tempo","text":"Você também pode incluir linhas tempo à rede, que são representadas eixo x de cada caso. Elas pode ser utilizadas para visualizar locais dos casos, por exemplo, ou o tempo até o desfecho. Para gerar uma linha tempo, precisamos criar um data frame de pelo menos 3 colunas, indicadno o ID caso, data de início “evento” e data de fim “evento”. Você também pode adicionar inúmeras outras colunas que depois podem ser mapeadas para propriedades de nós ou arestas da linha tempo. código abaixo,nós geramos uma linha tempo que vai da data de início dos sintomas até data desfecho, e mantemos variáveis desfecho e hospital que utilizamos para definir forma e cor nó. Note que você pode ter, por caso, mais que uma linha dataframe ou evento na linha tempo, por exemplo, se um caso transferido entre multiplos hospitais.Depois, passamos o elemento da linha tempo para o argumento timeline. Podemos mapear os atributos da linha tempo cores, formas e tamanhos da mesma forma que definimos nas seções anteriores, exceto que temos dois nós: os nós de início de fim de cada timeline, que possuem argumentos separados. Por exemplo, tl_start_node_color define qual coluna da linha tempo está mapeada à cor nó de início, enquanto tl_end_node_shape define qual coluna da linha tempo está mapeada à forma nó final. Também podemos mapear cor, tamanho, tipo de linha e rótulos à aresta da linha tempo via argumentos tipo tl_edge_*.Confira ?vis_temporal_interactive (função chamada ao criar um gráfico de um objeto epicontacts) para documentação detalhada dos argumentos. Cada argumento está anotado código abaixo:","code":"\n## cria a linha do tempo\ntimeline <- linelist %>%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n## define as formas\nshapes <- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## define cores\ncolours <- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## gera o gráfico\nplot(\n  sub,\n  ## mapeia a coordenada x à data de início\n  x_axis = \"date_onset\",\n  ## rede na forma retangular\n  network_shape = \"rectangle\",\n  ## mapeia a forma dos nós à coluna de gênero\n  node_shape = \"gender\",\n  ## não queremos mapear o cor do nó a nenhuma coluna - esse argumento é importante\n  ## pois o padrão é mapear ao id do nó, o que vai bagunçar o esquema de cores\n  node_color = NULL,\n  ## define o tamanho do nó dos casos como 30 (como não é uma característica dos dados, node_size não\n  ## é mapeado para nenhum coluna, mas interpretado como o real tamanho do nó)\n  node_size = 30,\n  ## define a espessura da relação como 4 (como não é uma característica dos dados, edge_width não\n  ## é mapeado para nenhum coluna, mas interpretado como a real espessura da aresta)\n  edge_width = 4,\n  ## passa o objeto da linha do tempo\n  timeline = timeline,\n  ## mapeia a forma do nó final à coluna de desfecho do objeto da linha do tempo\n  tl_end_node_shape = \"outcome\",\n  ## define o tamanho do nó final como 15 (como não é uma característica dos dados, esse\n  ## argumento não é mapeado para nenhum coluna, mas interpretado como o real\n  ## tamanho do nó)\n  tl_end_node_size = 15,\n  ## mapeia a cor da aresta da linha do tempo à coluna hospital\n  tl_edge_color = \"hospital\",\n  ## define a espessura da aresta da linha do tempo como 2 (como não é uma característica dos dados, esse\n  ## argumento não é mapeado para nenhum coluna, mas interpretado como a real\n  ## espessura da aresta)\n  tl_edge_width = 2,\n  ## mapeia os rótulos das arestas à variável hospital\n  tl_edge_label = \"hospital\",\n  ## especifica a forma para cada atributo dos nós (definido acima)\n  shapes = shapes,\n  ## especifica a paleta de cor (definido acima)\n  col_pal = colours,\n  ## define o tamanho da seta para 0.5\n  arrow_size = 0.5,\n  ## utiliza as duas colunas na legenda\n  legend_ncol = 2,\n  ## define o tamanho da fonte\n  font_size = 15,\n  ## define a o formato da data\n  date_labels = c(\"%d %b %Y\"),\n  ## não exibe os rótulos de ID abaixo dos nós\n  label = FALSE,\n  ## especifica a altura\n  height = 1000,\n  ## especifica a espessura\n  width = 1200,\n  ## garante que cada nó dos casos tenha um coordenada y única - isso é muito importante\n  ## para linhas do tempo, caso contrário você terá linhas do tempo sobrepostas para\n  ## casos diferentes\n  position_dodge = TRUE\n)## Warning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed as ID\n## not found in linelist or start/end date is NA"},{"path":"transmission-chains.html","id":"análise","chapter":"35 Cadeias de Transmissão","heading":"35.5 Análise","text":"","code":""},{"path":"transmission-chains.html","id":"resumindo","chapter":"35 Cadeias de Transmissão","heading":"Resumindo","text":"Podemos ter uma visão gerão de algumas propriedades da rede utilizando função summary.Por exemplo, podemos ver que apenas 57% dos contatos possuem ambos os casos na linelist; isso significa que nós não temos dados da linelist sobre um número significativo de casos envolvidos nessas cadeias de transmissão.","code":"\n## resume o objeto epicontacts\nsummary(epic)## \n## /// Overview //\n##   // number of unique IDs in linelist: 5888\n##   // number of unique IDs in contacts: 5511\n##   // number of unique IDs in both: 4352\n##   // number of contacts: 3800\n##   // contacts with both cases in linelist: 56.868 %\n## \n## /// Degrees of the network //\n##   // in-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n## \n##   // out-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n## \n##   // in and out degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   0.000   1.000   1.000   1.078   1.000   7.000 \n## \n## /// Attributes //\n##   // attributes in linelist:\n##  generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n## \n##   // attributes in contacts:\n##  location duration"},{"path":"transmission-chains.html","id":"características-por-pares","chapter":"35 Cadeias de Transmissão","heading":"Características por pares","text":"função get_pairwise() permite o processamento de variáveis na linelist de acordo com cada par na base de dados de contatos. Para o seguinte exemplo, data de início da doença é extraída da linelist para calcular diferença entre data de início para cada par. O valor produzido partir dessa comparação representa o intervalo serial (si)get_pairwise() vai interpretar classe da coluna sendo utilizada para comparação e vai ajustar o seu método de comparar os valores de acordo. Para números e datas (como si exemplo acima), função vai subtrair os valores. Quando aplicado colunas de caracteres ou categóricas, get_pairwise() vai colar (paste) os valores. Pelo fato da função também permitir processamentos arbitrários (veja o argumento “f”), essas combinações discretas podem ser facilmente tabuladas e analisadas.Aqui observamos uma associação significativa entra relações de transmissão e gênero.","code":"\nsi <- get_pairwise(epic, \"date_onset\")\nsummary(si)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    5.00    9.00   11.01   15.00   99.00    1820\ntibble(si = si) %>%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.## Warning: Removed 1820 rows containing non-finite values (`stat_bin()`).\nhead(get_pairwise(epic, \"gender\"), n = 10)##  [1] \"f -> m\" NA       \"m -> m\" NA       \"m -> f\" \"f -> f\" NA       \"f -> m\" NA      \n## [10] \"m -> f\"\nget_pairwise(epic, \"gender\", f = table)##            values.to\n## values.from   f   m\n##           f 464 516\n##           m 510 468\nfisher.test(get_pairwise(epic, \"gender\", f = table))## \n##  Fisher's Exact Test for Count Data\n## \n## data:  get_pairwise(epic, \"gender\", f = table)\n## p-value = 0.03758\n## alternative hypothesis: true odds ratio is not equal to 1\n## 95 percent confidence interval:\n##  0.6882761 0.9892811\n## sample estimates:\n## odds ratio \n##  0.8252575"},{"path":"transmission-chains.html","id":"identificando-agrupamentoss","chapter":"35 Cadeias de Transmissão","heading":"Identificando agrupamentoss","text":"função get_clusters() pode ser utilizada para identificar componentes conectados em um objeto epicontacts. Primeiro, utilizamos para recuperar um data.frame contendo informação dos agrupamentos:Let us look largest clusters. , add cluster information epicontacts object subset keep largest clusters:\nVamos dar uma olhada nos maiores agrupamentos. Para isso, vamos adicionar informações de agrupamentos ao objeto epicontacts e depois fazer um subconjunto para manter apenas os maiores agrupamentos:","code":"\nclust <- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)## \n##    1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n## 1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\nepic <- get_clusters(epic)\nmax_size <- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))"},{"path":"transmission-chains.html","id":"calculando-graus","chapter":"35 Cadeias de Transmissão","heading":"Calculando graus","text":"O grau de um nó corresponde ao seu número de arestas ou conexões com outros nós. get_degree() disponibiliza um método fácil para calcular esse valor para redes de epicontacts. Um grau alto nesse contexo indica um indivíduo que esteve em contato com vários outros. O argumento type indica que nós queremos contar tanto o grau de entrada (-degree) quanto o de saída (-degree) e o argumento only_linelist indica que queremos calcular apenas o grau para os casos que estejam na linelist.Quais os primeiros 10 indivíduos com maior quantidade de contatos?Qual o número médio de contatos?","code":"\ndeg_both <- get_degree(epic, type = \"both\", only_linelist = TRUE)\nhead(sort(deg_both, decreasing = TRUE), 10)## 916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n##      7      6      6      6      5      5      5      5      5      5\nmean(deg_both)## [1] 1.078473"},{"path":"transmission-chains.html","id":"recursos-20","chapter":"35 Cadeias de Transmissão","heading":"35.6 Recursos","text":"\npágina epicontacts\ndisponibiliza uma visão geral das funções pacote e inclui algumas outras vignettes mais aprofundadas.páginad github pode ser utilizada para registrar\nproblemas (issues) e solicitar funcionalidades.","code":""},{"path":"phylogenetic-trees.html","id":"phylogenetic-trees","chapter":"36 Árvores filogenéticas","heading":"36 Árvores filogenéticas","text":"","code":""},{"path":"phylogenetic-trees.html","id":"visão-geral-5","chapter":"36 Árvores filogenéticas","heading":"36.1 Visão Geral","text":"Árvores filogenéticas são utilizados para visualizar e descrever relação e evolução dos organismos com base sequenciamento de seu código genético.Elas podem ser construídos partir de seqüências genéticas usando métodos baseados na distância (como o método de união de vizinhos) ou métodos baseados em caracteres (como o método de máxima verossimilhança e o método Baysiano de Monte Carlo via Cadeias de Markov ). O sequenciamento de próxima geração (NGS) tornou-se mais acessível e está se tornando mais amplamente utilizado na saúde pública para descrever patógenos causadores de doenças infecciosas. Os dispositivos portáteis de seqüenciamento diminuem o tempo de retorno e mantêm promessas de disponibilizar dados para o apoio à investigação de surtos em tempo real. Os dados da NGS podem ser usados para identificar origem ou fonte de uma variante de surto e sua propagação, bem como determinar presença de genes de resistência antimicrobiana. Para visualizar relação genética entre amostras, é construída uma árvore filogenética.Nesta página aprenderemos como utilizar o pacote ggtree, que permite visualização combinada de árvores filogenéticas com dados adicionais de amostras sob forma de um data frame. Isto nos permitirá observar padrões e melhorar compreensão da dinâmica surto.","code":""},{"path":"phylogenetic-trees.html","id":"preparação-28","chapter":"36 Árvores filogenéticas","heading":"36.2 Preparação","text":"","code":""},{"path":"phylogenetic-trees.html","id":"carregar-pacotes-11","chapter":"36 Árvores filogenéticas","heading":"Carregar pacotes","text":"Este trecho de código mostra o carregamento dos pacotes necessárias. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para utilização. Você também pode carregar os pacotes instalados com library() R base. Veja página em Introdução ao R para mais informações sobre os pacotes R.","code":"\npacman::p_load(\n  rio,             # importar/exportar\n  here,            # caminhos relativos dos arquivos\n  tidyverse,       # manipulações e visualizações gerais de dados\n  ape,             # para importar e exportar dados de árvores filogenéticas\n  ggtree,          # para visualizar dados de árvores filogenéticas \n  treeio,          # para visualizar dados de árvores filogenéticas \n  ggnewscale)      # adicionar camadas de esquema de cores "},{"path":"phylogenetic-trees.html","id":"importar-dados-4","chapter":"36 Árvores filogenéticas","heading":"Importar dados","text":"Os dados para esta página podem ser baixados com instruções na página Baixar manual e dados.Há vários formatos diferentes nos quais uma árvore filogenética pode ser armazenada (por exemplo, Newick, NEXUS, Phylip). Um muito comum é o formato de arquivo Newick (.nwk), que é o padrão para representar árvores em formato legível por computador. Isto significa que uma árvore inteira pode ser expressa em formato de string como “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);”, listando todos os nós e ápices e relação (comprimento ramo) entre si.Nota: É importante entender que o arquivo de árvore filogenética em si não contém dados de sequenciamento, mas é meramente o resultado das distâncias genéticas entre seqüências. Portanto, não podemos extrair dados de seqüenciamento de um arquivo de árvore.Primeiro, utilizamos função read.tree() pacote ape para importar um arquivo de árvore filogenética Newick em formato .txt, e armazená-lo em uma lista de objetos da classe “phylo”. Se necessário, utilize função () pacote para especificar o caminho relativo arquivo.Nota: Neste caso, árvore newick é salva como um arquivo .txt para facilitar o manuseio e o download Github.Inspecionamos nosso objeto árvore e vemos que ele contém 299 ápices/pontas (ou amostras) e 236 nós.Segundo, importamos uma tabela armazenada como um arquivo .csv com informações adicionais para cada amostra sequenciada, como sexo, país de origem e atributos de resistência antimicrobiana, utilizando função import() pacote rio:Abaixo estão primeiras 50 linhas de observação dos dados:","code":"\ntree <- ape::read.tree(\"Shigella_tree.txt\")\ntree## \n## Phylogenetic tree with 299 tips and 236 internal nodes.\n## \n## Tip labels:\n##   SRR5006072, SRR4192106, S18BD07865, S18BD00489, S17BD08906, S17BD05939, ...\n## Node labels:\n##   17, 29, 100, 67, 100, 100, ...\n## \n## Rooted; includes branch lengths.\nsample_data <- import(\"sample_data_Shigella_tree.csv\")"},{"path":"phylogenetic-trees.html","id":"limpar-e-inspecionar","chapter":"36 Árvores filogenéticas","heading":"Limpar e inspecionar","text":"Nós limpamos e inspecionamos nossos dados: fim de atribuir os dados da amostra correta à árvore filogenética, os valores na coluna Sample_ID data frame sample_data precisam corresponder aos valores tip.labels arquivo tree:Verificamos formatação das tip.labels arquivo tree observando primeiras 6 entradas utilizando com head() R base.Também nos certificamos de que primeira coluna em nosso data frame “Sample_data” seja “Sample_ID”. Olhamos os nomes das colunas de nosso data frame utilizando colnames() dm R base.Olhamos para os Sample_IDs data frame para ter certeza de que formatação é mesma que na tip.label (por exemplo, todas letras são maiúsculas, sem sublinhados extras `_’ entre letras e números, etc.)Também podemos comparar se todas amostras estão presentes arquivo “tree” e vice-versa, gerando um vetor lógico de VERDADEIRO ou FALSO onde elas coincidem ou não. Estas não são impressas aqui, por simplicidade.Podemos usar estes vetores para mostrar qualquer identificação de amostra que não esteja na árvore (não há nenhuma).Após inspeção, podemos ver que o formato Sample_ID data frame corresponde ao formato dos nomes das amostras nas tip.labels. Estas não precisam ser classificadas na mesma ordem para serem combinadas.Estamos prontos para ir!","code":"\nhead(tree$tip.label) ## [1] \"SRR5006072\" \"SRR4192106\" \"S18BD07865\" \"S18BD00489\" \"S17BD08906\" \"S17BD05939\"\ncolnames(sample_data)   ##  [1] \"Sample_ID\"                  \"serotype\"                  \n##  [3] \"Country\"                    \"Continent\"                 \n##  [5] \"Travel_history\"             \"Year\"                      \n##  [7] \"Belgium\"                    \"Source\"                    \n##  [9] \"Gender\"                     \"gyrA_mutations\"            \n## [11] \"macrolide_resistance_genes\" \"MIC_AZM\"                   \n## [13] \"MIC_CIP\"\nhead(sample_data$Sample_ID) # novamente inspecionamos os primeiros 6 usando head()## [1] \"S17BD05944\" \"S15BD07413\" \"S18BD07247\" \"S19BD07384\" \"S18BD07338\" \"S18BD02657\"\nsample_data$Sample_ID %in% tree$tip.label\n\ntree$tip.label %in% sample_data$Sample_ID\nsample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]## character(0)"},{"path":"phylogenetic-trees.html","id":"visualização-simples-da-árvore","chapter":"36 Árvores filogenéticas","heading":"36.3 Visualização simples da árvore","text":"","code":""},{"path":"phylogenetic-trees.html","id":"diferente-layouts-para-a-árvore","chapter":"36 Árvores filogenéticas","heading":"Diferente layouts para a árvore","text":"ggtree* oferece muitos formatos de layout diferentes e alguns podem ser mais adequados para seu propósito específico que outros. Abaixo estão algumas demonstrações. Para outras opções, veja este livro online.Aqui estão alguns exemplos de layouts de árvores:","code":"\nggtree(tree)                                            # árvore linear simples\nggtree(tree,  branch.length = \"none\")                   # árvore linear simples com todas as pontas alinhadas\nggtree(tree, layout=\"circular\")                         # árvore circular simples\nggtree(tree, layout=\"circular\", branch.length = \"none\") # árvore circular simples com todas as pontas alinhadas"},{"path":"phylogenetic-trees.html","id":"árvore-simples-com-dados-de-amostras","chapter":"36 Árvores filogenéticas","heading":"Árvore simples com dados de amostras","text":"O operador %<+%* é utilizado para conectar o data frame sample_data ao arquivo tree.\nanotação mais fácil de sua árvore é adição dos nomes das amostras nas pontas, assim como coloração dos pontos da ponta e, se desejado, dos ramos:Aqui está um exemplo de uma árvore circular:Você pode exportar seu gráfico de árvore com ggsave() como qualquer outro objeto ggplot’. Escrito desta forma, ggsave() salva última imagem produzida para o caminho arquivo que você especificar. Lembre-se de que você pode utilizar () e caminhos de arquivo relativos para salvar facilmente em subpastas, etc.","code":"\nggtree(tree, layout = \"circular\", branch.length = 'none') %<+% sample_data + # %<+% unifica o datarframe com os dados de amostras à arvore\n  aes(color = (Belgium))+                       # colore os ramos de acordo com a variável no seu dataframe c\n  scale_color_manual(\n    name = \"Sample Origin\",                      # nome do seu esquema de cotes (irá aparecer assim na legenda) \n    breaks = c(\"Yes\", \"No\"),                     # as diferentes opções na sua variável\n    labels = c(\"NRCSS Belgium\", \"Other\"),        # como você quer que as diferentes opções sejam nomeadas na sua legenda, permite formatação \n    values = c(\"blue\", \"black\"),                  # a cor que você atribuir à variável\n    na.value = \"black\")+                        # colore valores NA como preto também\n  new_scale_color()+                             # permite adicionar um novo esquema de cores para uma nova variável\n    geom_tippoint(\n      mapping = aes(color = Continent),          # cor das pontas por continente. Você pode mudar o formato adicionando \"shape = \"\n      size = 1.5)+                               # define o tamanho do ponto na ponta \n  scale_color_brewer(\n    name = \"Continent\",                    # nome do seu esquema de cotes (irá aparecer assim na legenda) \n    palette = \"Set1\",                      #  escolhemos uma paleta de cores do pacote Brewer \n    na.value = \"grey\")+                    # para valores NA escolhemos o cinza \n  geom_tiplab(                             # adiciona o nome da amostra para a ponta do ramo \n    color = 'black',                       # (adiciona quantas linhas de texto desejar, mas talvez precise ajustar o valor de partida para coloca-los proximos uns aos outros. \n    offset = 1,\n    size = 1,\n    geom = \"text\",\n    #align = TRUE\n    )+\n  ggtitle(\"Árvore filogenética de Shigella sonnei\")+       # título do seu gráfico\n  theme(\n    axis.title.x = element_blank(), # remove título de eixo x\n    axis.title.y = element_blank(), # remove título de eixo y\n    legend.title = element_text(    # define o tamanho da fonte e formata a o título da legenda\n      face = \"bold\",\n      size = 12),   \n    legend.text=element_text(       # define o tamanho da fonte e formata o texto da legenda\n      face = \"bold\",\n      size = 10),  \n    plot.title = element_text(      # define o tamanho da fonte e formata o título do gráfico\n      size = 12,\n      face = \"bold\"),  \n    legend.position = \"bottom\",     # define a posição da legenda\n    legend.box = \"vertical\",        # define o posicionamento da legenda\n    legend.margin = margin())   \nggsave(\"example_tree_circular_1.png\", width = 12, height = 14)"},{"path":"phylogenetic-trees.html","id":"manipulação-da-árvore","chapter":"36 Árvores filogenéticas","heading":"36.4 Manipulação da árvore","text":"Às vezes você pode ter uma árvore filogenética muito grande e só está interessado em uma parte da árvore. Por exemplo, se você produziu uma árvore incluindo amostras históricas ou internacionais para obter uma grande visão geral de onde seu conjunto de dados pode se encaixar quadro geral. Mas então, para olhar mais de perto seus dados, você quer inspecionar apenas aquela parte da árvore maior.Como o arquivo filogenético da árvore é apenas saída da análise sequencial de dados, não podemos manipular ordem dos nós e ramos próprio arquivo. Estes já foram determinados em análises anteriores partir dos dados brutos NGS. entanto, somos capazes de fazer zoom em partes, esconder partes e até mesmo subdividir parte da árvore.","code":""},{"path":"phylogenetic-trees.html","id":"aumentar-o-zoom","chapter":"36 Árvores filogenéticas","heading":"Aumentar o zoom","text":"Se você não quiser “cortar” sua árvore, mas apenas inspecionar parte dela mais de perto, você pode ampliar para ver uma parte específica.Primeiro, plotamos árvore inteira em formato linear e adicionamos etiquetas numéricas cada nó da árvore.Para aumentar o zoom para um ramo em particular (à direita), utilize viewClade() objeto ggtree p e forneça o número nó para obter uma visão mais detalhada:","code":"\np <- ggtree(tree,) %<+% sample_data +\n  geom_tiplab(size = 1.5) + # adicionamos rótulos às pontas de todos os ramos como nome da amostra no arquivo \n  geom_text2(\n    mapping = aes(subset = !isTip,\n                  label = node),\n    size = 5,\n    color = \"darkred\",\n    hjust = 1,\n    vjust = 1)                            # adiciona rótulos em todos os nós\n\np  # printa\nviewClade(p, node = 452)"},{"path":"phylogenetic-trees.html","id":"colapsando-ramos","chapter":"36 Árvores filogenéticas","heading":"Colapsando ramos","text":"entanto, podemos querer ignorar este ramo e podemos colapsa-lo naquele mesmo nó (nó nº 452) utilizando collapse(). Esta árvore é definida como p_collapsed.Para maior clareza, quando imprimimos p_collapsed', adicionamos umgeom_point2()` (um diamante azul) nó ramo colapsado.","code":"\np_collapsed <- collapse(p, node = 452)\np_collapsed\np_collapsed + \ngeom_point2(aes(subset = (node == 452)),  # adicionamos um símbolo ao nó colapsado \n            size = 5,                     # define o tamanho do símbolo  \n            shape = 23,                   # define a forma do símbolo  \n            fill = \"steelblue\")           # define a cor do símbolo ## Warning in geom_point(stroke = stroke, shape = shape, ...): Ignoring unknown\n## aesthetics: subset## Warning: Removed 83 rows containing missing values (`geom_point()`)."},{"path":"phylogenetic-trees.html","id":"subdividindo-uma-árvore","chapter":"36 Árvores filogenéticas","heading":"Subdividindo uma árvore","text":"Se quisermos fazer uma mudança mais permanente e criar uma árvore nova e reduzida para trabalhar com ela, podemos separar parte dela com tree_subset(). Então você pode salvá-la como novo arquivo newick tree ou arquivo .txt.Primeiro, inspecionamos os nós de árvore e os rótulos das pontas fim de decidir como subdividi-la.Agora, digamos que decidimos dividir árvore nó 528 (manter apenas pontas dentro deste ramo após o nó 528) e salvamos como um novo objeto sub_tree1:Vamos dar uma olhada na árvore subconjunto 1 (subset tree 1):Você também pode dividir com base em uma amostra específica, especificando quantos nós “para trás” você deseja incluir. Vamos subdividir mesma parte da árvore com base em uma amostra, neste caso S17BD07692, retrocedendo 9 nós e salvamos como um novo objeto sub_tree2:Vamos dar uma olhada na árvore subconjunto 2:Você também pode salvar sua nova árvore como um tipo Newick ou mesmo um arquivo de texto utilizando função write.tree() pacote ape:","code":"\nggtree(\n  tree,\n  branch.length = 'none',\n  layout = 'circular') %<+% sample_data +               # adicionamos os dados das amostras usando o operdor  %<+% \n  geom_tiplab(size = 1)+                                # rotula as pontas dos ramos com o nome da amostra \n  geom_text2(\n    mapping = aes(subset = !isTip, label = node),\n    size = 3,\n    color = \"darkred\") +                                # rotula todos os nós na árvore \n theme(\n   legend.position = \"none\",                            # remove a legenda completamente\n   axis.title.x = element_blank(),\n   axis.title.y = element_blank(),\n   plot.title = element_text(size = 12, face=\"bold\"))\nsub_tree1 <- tree_subset(\n  tree,\n  node = 528)                                            # subdividimos a árvore no nó 528 \nggtree(sub_tree1) +\n  geom_tiplab(size = 3) +\n  ggtitle(\"Subset tree 1\")\nsub_tree2 <- tree_subset(\n  tree,\n  \"S17BD07692\",\n  levels_back = 9) #  levels_back define quantos nós você quer retroceder da ponta da amostra  \nggtree(sub_tree2) +\n  geom_tiplab(size =3)  +\n  ggtitle(\"Subset tree 2\")\n# salvar no formato .nwk \nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')\n\n# salvar no formato .txt \nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')"},{"path":"phylogenetic-trees.html","id":"rotacionando-nós-em-uma-árvore","chapter":"36 Árvores filogenéticas","heading":"Rotacionando nós em uma árvore","text":"Como mencionado anteriormente, não podemos mudar ordem das pontas ou nós na árvore, pois isto se baseia em sua relação genética e não está sujeito manipulação visual. Mas podemos girar ramos em torno dos nós se isso facilitar nossa visualização.Primeiro, traçamos nossa nova árvore “sub_tree2” com etiquetas de nós para escolher o nó que queremos manipular e armazená-lo como um objeto tipo gráfico ggtree p.Podemos então manipular os nós aplicando ggtree::rotate() ou ggtree::flip():\nNota: para ilustrar quais nós estamos manipulando, aplicamos primeiro função geom_hilight() de ggtree para destacar amostras nos nós em que estamos interessados e armazenar esse objeto ggtree em um novo objeto p1.Agora podemos girar o nó 37 objeto p1 para que amostras nó 38 se movam para o topo. Armazenamos árvore rotacionada em um novo objeto p2.Ou podemos usar função flip() para rotacuonar o nó 36 objeto p1 e mudar o nó 37 para o topo e o nó 39 para o fundo. Armazenamos árvore invertida em um novo objeto p3.","code":"\np <- ggtree(sub_tree2) +  \n  geom_tiplab(size = 4) +\n  geom_text2(aes(subset=!isTip, label=node), # rotula todos os nós em uma árvore\n             size = 5,\n             color = \"darkred\", \n             hjust = 1, \n             vjust = 1) \np\np1 <- p + geom_hilight(  # destaca o nó 39 em azul, \"extend =\" nos permite definir a cor do bloco \n  node = 39,\n  fill = \"steelblue\",\n  extend = 0.0017) +  \ngeom_hilight(            # destaca o nó 37 em amarelo \n  node = 37,\n  fill = \"yellow\",\n  extend = 0.0017) +               \nggtitle(\"Árvore Original\")\n\n\np1 # printa\np2 <- ggtree::rotate(p1, 37) + \n      ggtitle(\"Nó 37 rotacionado\")\n\n\np2   # printa\np3 <- ggtree::flip(p1, 39, 37) +\n      ggtitle(\"Nó 36 rotacionado\")\n\n\np3   # printa"},{"path":"phylogenetic-trees.html","id":"examplo-de-sub-árvore-com-informações-das-amostras","chapter":"36 Árvores filogenéticas","heading":"Examplo de sub-árvore com informações das amostras","text":"Digamos que estamos investigando o conjunto de casos com expansão clonal que ocorreram em 2017 e 2018 nó 39 de nossa sub-árvore. Acrescentamos o ano de isolamento da linhagem, bem como o histórico de viagem e cor por país para ver origem de outras linhagens intimamente relacionadas:Nossa observação aponta para um evento de importação de cepas da Ásia, que então circularam na Bélgica ao longo dos anos e parecem ter causado nosso último surto.","code":"\nggtree(sub_tree2) %<+% sample_data +     # Usamos o operador %<+% para juntar com sample_data\n  geom_tiplab(                          # rotula as pontas dos ramos com  os nomes das amotras \n    size = 2.5,\n    offset = 0.001,\n    #align = TRUE\n    ) + \n  theme_tree2()+\n  xlim(0, 0.015)+                       # configura os limite do eixo x \n  geom_tippoint(aes(color=Country),     # colore a ponta de acordo com o continente  \n                size = 1.5)+ \n  scale_color_brewer(\n    name = \"Country\", \n    palette = \"Set1\", \n    na.value = \"grey\")+\n  geom_tiplab(                          #  adiciona o ano de isolamento como um rótulo de texto nas pontas a\n    aes(label = Year),\n    color = 'blue',\n    offset = 0.0045,\n    size = 3,\n    linetype = \"blank\" ,\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  geom_tiplab(                          # adiciona histórico de viagem nas pontas em vermelho \n    aes(label = Travel_history),\n    color = 'red',\n    offset = 0.006,\n    size = 3,\n    linetype = \"blank\",\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  ggtitle(\"Árvore filogenética de de estirpes de Belgian S. sonnei com histórico de viagens\")+  # adiciona título \n  xlab(\"distância genética (0.001 = 4 nucleotídeos de diferença)\")+   # adiciona legenda do eixo x\n  theme(\n    axis.title.x = element_text(size = 10),\n    axis.title.y = element_blank(),\n    legend.title = element_text(face = \"bold\", size = 12),\n    legend.text = element_text(face = \"bold\", size = 10),\n    plot.title = element_text(size = 12, face = \"bold\"))"},{"path":"phylogenetic-trees.html","id":"árvores-mais-complexas-adição-de-heatmaps-de-dados-de-amostra","chapter":"36 Árvores filogenéticas","heading":"Árvores mais complexas: adição de heatmaps de dados de amostra","text":"Podemos acrescentar informações mais complexas, como presença categórica de genes de resistência antimicrobiana e valores numéricos para resistência realmente medida antimicrobianos na forma de um mapa térmico usando função ggtree::gheatmap().Primeiro precisamos traçar nossa árvore (esta pode ser linear ou circular) e armazená-la em um novo objeto de traçado ggtree p: Utilizaremos sub-árvore da parte 3).Em segundo lugar, preparamos nossos dados. Para visualizar diferentes variáveis com novos esquemas de cores, nós subdividimos nosso dataframe para variável desejada. É importante adicionar o Sample_ID como nomes das linhas, caso contrário, ele não pode fazer correspondência dos dados com árvore tip.labels:Em nosso exemplo, queremos analisar o gênero e mutações que poderiam conferir resistência à Ciprofloxacina, um importante antibiótico de primeira linha utilizado para tratar infecções por Shigella.Criamos um dataframe para gênero:Criamos um dataframe para mutações gene gyrA, que confere resistência à Ciprofloxacina:Criamos um dataframe para concentração inibitória mínima medida (MIC) de Ciprofloxacina laboratório:Criamos um primeiro gráfico adicionando um heatmap binário para gênero à árvore filogenética e armazenando-o em um novo objeto tipo gráfico ggtree h1:Depois adicionamos informações sobre mutações gene gyrA, que conferem resistência ao Ciprofloxacina:Nota: presença de mutações cromossômicas pontuais nos dados WGS foi previamente determinada usando ferramenta PointFinder desenvolvida por Zankari et al. (ver referência na seção de referências adicionais)Primeiro, atribuímos um novo esquema de cores ao nosso objeto tipo gráfico existente emh1 e o armazenamos em um objeto agora h2. Isto nos permite definir e mudar cores para nossa segunda variável heatmap.Depois adicionamos segunda camada heatmap ao h2 e armazenamos os gráficos combinados em um novo objeto h3:Repetimos o processo acima, primeiro adicionando uma nova camada de escala de cor ao nosso objeto existente h3, e depois adicionando os dados contínuos sobre concentração inibitória mínima (MIC) de Ciprofloxacina para cada estirpe ao objeto resultante h4 para produzir o objeto final h5:Podemos fazer o mesmo exercício para uma árvore linear:Primeiro, adicionamos o gênero:Depois adicionamos mutações de resistência Ciprofloxacina depois de adicionar outra camada de esquema de cores:Em seguida, adicionamos concentração inibitória mínima determinada pelo laboratório (MIC):","code":"\np <- ggtree(sub_tree2, branch.length='none', layout='circular') %<+% sample_data +\n  geom_tiplab(size =3) + \n theme(\n   legend.position = \"none\",\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.title = element_text(\n      size = 12,\n      face = \"bold\",\n      hjust = 0.5,\n      vjust = -15))\np\ngender <- data.frame(\"gender\" = sample_data[,c(\"Gender\")])\nrownames(gender) <- sample_data$Sample_ID\ncipR <- data.frame(\"cipR\" = sample_data[,c(\"gyrA_mutations\")])\nrownames(cipR) <- sample_data$Sample_ID\nMIC_Cip <- data.frame(\"mic_cip\" = sample_data[,c(\"MIC_CIP\")])\nrownames(MIC_Cip) <- sample_data$Sample_ID\nh1 <-  gheatmap(p, gender,                                 # adicionamos uma camada \"heatmap\" de gênero ao gráfico\n                offset = 10,                               # \"offset\" muda o heatmap para a direita,\n                width = 0.10,                              # \"width\" define ta largura da coluna do heatmap,\n                color = NULL,                              # \"color\"  define a borda da coluna do  heatmap \n         colnames = FALSE) +                               # esconde a coluna de nomes do heatmap\n  scale_fill_manual(name = \"Gender\",                       # define o esquema de cores e a legenda do gênero \n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh1\nh2 <- h1 + new_scale_fill() \nh3 <- gheatmap(h2, cipR,  # adiciona uma segunda linha de heatmap descrevendo a mutação de resistência da Ciprofloxacina\n               offset = 12, \n               width = 0.10, \n               colnames = FALSE) +\n  scale_fill_manual(name = \"Mutações que conferem \\n resistência a Ciprofloxacina\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh3\n# Primeiro adicionamos o novo esquema de cores\nh4 <- h3 + new_scale_fill()\n\n# e então combinamos os dois em um novo gráfico:\nh5 <- gheatmap(h4, MIC_Cip,  \n               offset = 14, \n               width = 0.10,\n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC para Ciprofloxacina\",  # definimos uma cor em gradiente para a variável contínua MIC \n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0, 0.50, 1.00),\n                      na.value = \"white\") +\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh5\np <- ggtree(sub_tree2) %<+% sample_data +\n  geom_tiplab(size = 3) + # rotupa as pontas\n  theme_tree2()+\n  xlab(\"distância gentética (0.001 = 4 nucleotídeos de diferença)\")+\n  xlim(0, 0.015)+\n theme(legend.position = \"none\",\n      axis.title.y = element_blank(),\n      plot.title = element_text(size = 12, \n                                face = \"bold\",\n                                hjust = 0.5,\n                                vjust = -15))\np\nh1 <-  gheatmap(p, gender, \n                offset = 0.003,\n                width = 0.1, \n                color=\"black\", \n         colnames = FALSE)+\n  scale_fill_manual(name = \"Gender\",\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh1\nh2 <- h1 + new_scale_fill()\nh3 <- gheatmap(h2, cipR,   \n               offset = 0.004, \n               width = 0.1,\n               color = \"black\",\n                colnames = FALSE)+\n  scale_fill_manual(name = \"Mutações que conferem \\n resistência a Ciprofloxacina\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\n h3\nh4 <- h3 + new_scale_fill()\nh5 <- gheatmap(h4, MIC_Cip, \n               offset = 0.005,  \n               width = 0.1,\n               color = \"black\", \n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC para Ciprofloxacina\",\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0,0.50,1.00),\n                      na.value = \"white\")+\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 8),\n        legend.box = \"horizontal\", legend.margin = margin())+\n  guides(shape = guide_legend(override.aes = list(size = 2)))## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh5"},{"path":"phylogenetic-trees.html","id":"resources","chapter":"36 Árvores filogenéticas","heading":"36.5 Resources","text":"http://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors\nhttps://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html\nhttps://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html\nhttps://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.htmlEa Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: novel web tool WGS-based detection antimicrobial resistance associated chromosomal point mutations bacterial pathogens, Journal Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217","code":""},{"path":"interactive-plots.html","id":"interactive-plots","chapter":"37 Gráficos interativos","heading":"37 Gráficos interativos","text":"visualização de dados é cada vez mais necessária para questionamento público. Consequentemente, criação de gráficos interativos torna-se algo comum. Há várias formas de torná-los interativos, sendo duas mais comuns: plotly e shiny.Nesta página iremos focar na conversão de um gráfico já existente ggplot() em um gráfico interativo, utilizando o plotly. Para saber mais sobre o shiny, veja na capítulo Paineis com Shiny. Importante lembrar que este formato de gráfico interativo tem limitações, utilizados apenas em documentos R Markdown em formato HTML*, não sendo possível em documentos com formatos em PDF ou Word.exemplo abaixo, tem-se um gráfico de curva epidêmica, que foi transformado para ser interativo, usando integração de ggplot2 e plotly(Passe o mouse sobre o grafico, amplie ou clique nos itens na legenda).","code":""},{"path":"interactive-plots.html","id":"preparação-29","chapter":"37 Gráficos interativos","heading":"37.1 Preparação","text":"","code":""},{"path":"interactive-plots.html","id":"carregando-os-pacotes","chapter":"37 Gráficos interativos","heading":"Carregando os pacotes","text":"Esta parte de código(chunk) mostra o carregamento de pacotes necessários para análises, com destaque p_load() pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar utilizando função library() - “R base”. Para mais informações sobre pacotes consulte o capítulo Introdução ao R.","code":"\npacman::p_load(\n  rio,       # importar e exportar dados\n  here,      # especificar caminho dos dados\n  lubridate, # trabalhar dados\n  plotly,    # graficos interativos\n  scales,    # percents\n  tidyverse, # manuseio e visualização\n  incidence2,# gráfico epicurva\n  magrittr)  # pipe %>%\n# Verificar a versão do R, o pacote pacman e o rio  foi construido na versão 4.1.2"},{"path":"interactive-plots.html","id":"comece-com-um-ggplot","chapter":"37 Gráficos interativos","heading":"Comece com um ggplot()","text":"Nessa seção, assumimos que que você está começando com um gráfico ggplot() que pretende tornar interativo. Vamos contruir então, vários gráficos usando o linelist de casos, exemplo utilizado em outros capítulos deste manual.","code":""},{"path":"interactive-plots.html","id":"importar-os-dados-1","chapter":"37 Gráficos interativos","heading":"Importar os dados","text":"Para começar, importe lista de casos (limpa/organizada) de uma epidemia simulada de Ebola. Se quiser acompanhar o script, <ahref=‘https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds’ class=‘download-button’> clique para baixar linelist “limpa” (como arquivo .rds). Importe dados com função import() pacote rio (ele lida com vários tipos de arquivos como .xlsx, .csv, .rds - veja página Importar e exportar para mais detalhes).primeiras 50 linhas da lista de linhas são exibidas abaixo.","code":"\n# Importar os casos linelist (Ébola)\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"interactive-plots.html","id":"gráfico-com-ggplotly","chapter":"37 Gráficos interativos","heading":"37.2 Gráfico com ggplotly()","text":"função ggplotly() pacote plotly facilita conversão de um ggplot() para ser interativo. Só precisa salvar o seu ggplot() e na sequência direciona-lo para função ggplotly().Abaixo, é traçada uma linha simples gráfico representando proporção de casos que morreram em uma determinada semana:Para começar, necessário cria um conjunto de dados resumido de cada semana epidemiológica e porcentagem de casos com desfecho conhecido que morreram.Aqui estão primeiras 50 linhas conjunto weekly_deaths.Na sequência criamos o gráfico com ggplot2, usando o geom_line().Para torná-lo interativo, basta passar esse gráfico para ggplotly(), como abaixo. Passe o mouse sobre linha para mostrar os valores x e y. Você pode ampliar o gráfico e arrastá-lo. Você também pode ver os ícones canto superior direito gráfico. Em ordem, eles permitem que você:Baixar visualização atual como uma imagem PNGAmpliar com uma caixa de seleçãoGire, ou mova-se pelo gráfico clicando e arrastandoAmpliar, reduzir ou retornar ao zoom padrãoRedefinir os eixos para os padrõesAtive/desative “Spike Lines” que são linhas pontilhadas ponto interativo que se estendem até os eixos x e yAjustes para mostrar os dados quando você não está navegando na linhaDados agrupados também funcionam com o ggplotly(). Abaixo, é feita uma epicurva semanal, agrupada por resultado. barras empilhadas são interativas. Tente clicar nos diferentes itens da legenda (eles irão aparecer/desaparecer).","code":"\nweekly_deaths <- linelist %>%\n  group_by(epiweek = floor_date(date_onset, \"week\")) %>%  # criar e agrupar dados por coluna *epiweek*\n  summarise(                                              # criar um novo da Data Frame resumido\n    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # número de casos por grupo(com resultados conhecidos)\n    n_death  = sum(outcome == \"Death\", na.rm=T),          # número de casos que foram a óbitos\n    pct_death = 100*(n_death / n_known_outcome)           # percentual de casos que foram a obitos com resultados conhecidos\n  )\ndeaths_plot <- ggplot(data = weekly_deaths)+            # começar com o registro de óbito semanal\n  geom_line(mapping = aes(x = epiweek, y = pct_death))  # criar a linha no gráfico\n\ndeaths_plot   # visualizar\ndeaths_plot %>% plotly::ggplotly()\n#Produzir a curva com o pacote incidence2 verificar se tem instalado\np <- incidence2::incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"weeks\",\n  groups = outcome) %>% #não esquecer de chamar o pacote %>% (magrittr)\n  plot(fill = outcome)\n# Gráfico interativo \np %>% plotly::ggplotly() "},{"path":"interactive-plots.html","id":"modificações","chapter":"37 Gráficos interativos","heading":"37.3 Modificações","text":"","code":""},{"path":"interactive-plots.html","id":"tamanho-do-arquivo","chapter":"37 Gráficos interativos","heading":"Tamanho do arquivo","text":"Ao exportar em HTML gerado pelo R Markdown (como este livro!), você irá desejar o gráfico com o menor tamanho de dados possível (sem efeitos colaterais negativos na maioria dos casos). Para isso, basta direcionar plotagem interativa para partial_bundle(), também plotly.","code":"\np <- p %>% \n  plotly::ggplotly() %>%\n  plotly::partial_bundle()"},{"path":"interactive-plots.html","id":"botões","chapter":"37 Gráficos interativos","heading":"Botões","text":"Alguns dos botões em uma plotagem padrão são supérfluos e podem ser uma distração, então você pode removê-los. Você pode fazer isso simplesmente direcionando saída config() plotly e especificando quais botões devem ser removidos. exemplo abaixo, os nomes dos botões serem removidos foram expecificados previamente e fornecido o argumento modeBarButtonsToRemove =. Também definiu-se remoção logotipo plotly com o displaylogo = FALSE.","code":"\n##Esses botões são distrações e podem ser removidos\nplotly_buttons_remove <- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',\n                              'zoomOut2d','autoScale2d','hoverClosestCartesian',\n                              'toggleSpikelines','hoverCompareCartesian')\n\np <- p %>%          # redefinir o grafico interativo com esses botões\n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)"},{"path":"interactive-plots.html","id":"gráfico--blocos-de-calor","chapter":"37 Gráficos interativos","heading":"37.4 Gráfico -Blocos de calor","text":"Você pode tornar quase qualquer gráfico ggplot() interativo, incluindo o gráfico de calor. exemplo, seguir mostra proporção de dias por semana que certas instalações reportaram dados de malária à sua província.Aqui está o código, embora não descrito em profundidade neste tópico.Abaixo, o gráfico foi transformado modo interativo e o tamanho arquivo, assim como os botões modificados para formas mais simples.–>\n","code":"\n# Importar os dados de malária\nfacility_count_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\"))\n\n# Dados agregados por semana para o distrito durante a primavera\nagg_weeks <- facility_count_data %>% \n  filter(District == \"Spring\",\n         data_date < as.Date(\"2020-08-01\")) %>% \n  mutate(week = aweek::date2week(\n    data_date,\n    start_date = \"Monday\",\n    floor_day = TRUE,\n    factor = TRUE)) %>% \n  group_by(location_name, week, .drop = F) %>%\n  summarise(\n    n_days          = 7,\n    n_reports       = n(),\n    malaria_tot     = sum(malaria_tot, na.rm = T),\n    n_days_reported = length(unique(data_date)),\n    p_days_reported = round(100*(n_days_reported / n_days))) %>% \n  ungroup(location_name, week) %>% \n  right_join(tidyr::expand(., week, location_name)) %>% \n  mutate(week = aweek::week2date(week))\n\n# Criar gráfico\nmetrics_plot <- ggplot(agg_weeks,\n       aes(x = week,\n           y = location_name,\n           fill = p_days_reported))+\n  geom_tile(colour=\"white\")+\n  scale_fill_gradient(low = \"orange\", high = \"darkgreen\", na.value = \"grey80\")+\n  scale_x_date(expand = c(0,0),\n               date_breaks = \"2 weeks\",\n               date_labels = \"%d\\n%b\")+\n  theme_minimal()+ \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),\n    legend.key.width  = grid::unit(0.6,\"cm\"),\n    axis.text.x = element_text(size=12),\n    axis.text.y = element_text(vjust=0.2),\n    axis.ticks = element_line(size=0.4),\n    axis.title = element_text(size=12, face=\"bold\"),\n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),\n    plot.caption = element_text(hjust = 0, face = \"italic\")\n    )+\n  labs(x = \"Semana\",\n       y = \"Nome do Estabelecimento\",\n       fill = \"Performance de \\n reporte (%)\",\n       title = \"Porcentagem de dia por semana que o estabelecimento \\n reportou dados\",\n       subtitle = \"Estabelecimento de saúdes distritais, Abril-Maio 2019\",\n       caption = \"Semanas de 7 diad começando às segundas\")\n\nmetrics_plot # mostrar gráfico\nmetrics_plot %>% \n  plotly::ggplotly() %>% \n  plotly::partial_bundle() %>% \n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)"},{"path":"interactive-plots.html","id":"recursos-21","chapter":"37 Gráficos interativos","heading":"37.5 Recursos","text":"Plotly não é apenas para R, também funciona bem com Python (e qualquer linguagem de ciência de dados, por ser construído em JavaScript). Você pode ler mais sobre o tema Website plotly","code":""},{"path":"rmarkdown.html","id":"rmarkdown","chapter":"38 Relatórios com R Markdown","heading":"38 Relatórios com R Markdown","text":"R Markdown é uma ferramenta amplamente usada para criar produtos automatizados, reproduzíveis e compartilháveis, como relatórios. É possível criar produtos estáticos ou interativos, em MS Word, pdf, html, powerpoint, entre outros formatos.Um script de R Markdown intercala código em R e texto de modo que o script se torna o seu output final. é possível criar um documento completamente formatado, incluindo o texto (que pode ser dinâmico para mudar de acordo com os seus dados), tabelas, figuras, itens enumerados ou não, bibliografia, etc.Esses documentos podem ser produzidos para serem atualizados com base em uma rotina (por exemplo, relatórios diários de vigilância) ou rodarem com subconjuntos dos seus dados, como relatórios para cada jurisdição de uma agência.Outras páginas nesse livro expandem esse assunto:página Organização de relatórios de rotina demonstra como aplicar uma rotina à produção de relatórios com pastas geradas automaticamente com seus metadados de tempo (timestamps).página Dashboards R Markdown explica como formatar um relatório R Markdown como um painel (dashboard).Em outra nota, o projeto R4Epis tem desenvolvido templates de scripts R Markdown para surtos comuns e cenários de pesquisa encontrados em locais projeto MSF (Médicos Sem Fronteiras).","code":""},{"path":"rmarkdown.html","id":"preparação-30","chapter":"38 Relatórios com R Markdown","heading":"38.1 Preparação","text":"Ideias preliminares ao R MarkdownPara explicar alguns dos conceitos e pacotes envolvidos:Markdown é uma “linguagem” que permite escrever um documento usando texto comum, que pode ser convertido para html e outros formatos. Não é específico de R e arquivos escritos nessa “linguagem” tem extensão ‘.md’.R Markdown: é uma variação de markdown que é específica de R - permite escrever um documento usando markdown para produzir código, mas também incluir código em R e expor seus resultados.rmarkdown - o pacote: é usado pelo R para renderizar o arquivo .Rmd para exportação desejada. Seu foco é converter sintaxe markdown (texto), então também precisamos de…knitr: Esse pacote R lerá os blocos de código, executá-los e costurá-los (inglês knit, tricotar) de volta ao documento.Pandoc: Finalmente, pandoc converte o objeto final em um documento word/pdf/powerpoint, etc. É um software separado R, mas é instalado automaticamente com o RStudio.(Fonte: https://rmarkdown.rstudio.com/authoring_quick_tour.html):InstalaçãoPara criar um produto R Markdown, é necessário ter os seguintes instalados:O pacote rmarkdown (knitr será automaticamente instalado também)Pandoc, que deve ter vindo instalado com RStudio. Se você não está usando RStudio, é possível baixar o Pandoc aqui: http://pandoc.org.Se quiser gerar um arquivo PDF (um pouquinho mais complicado), será necessário instalar o LaTeX. Para usuários de R Markdown que nunca instalaram o LaTeX antes, recomendamos que instale o TinyTeX (https://yihui.name/tinytex/). Para isso, use os seguintes comandos:","code":"\npacman::p_load(tinytex)     # instala o pacote tinytex\ntinytex::install_tinytex()  # Comando de R para instalar o software TinyTeX"},{"path":"rmarkdown.html","id":"começando","chapter":"38 Relatórios com R Markdown","heading":"38.2 Começando","text":"","code":""},{"path":"rmarkdown.html","id":"instalação-do-pacote-rmarkdown-para-r","chapter":"38 Relatórios com R Markdown","heading":"Instalação do pacote rmarkdown para R","text":"Instale o pacote rmarkdown. Neste livro enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para ser usado. É possível também carregar pacotes instalados com library() R base. Vera pagina em Introdução ao R para mais informação sobre os pacotes de R.","code":"\npacman::p_load(rmarkdown)"},{"path":"rmarkdown.html","id":"começando-um-novo-arquivo-rmd","chapter":"38 Relatórios com R Markdown","heading":"Começando um novo arquivo Rmd","text":"Rstudio, abra um novo arquivo R markdown, começando em ‘Arquivo’, depois ‘Novo arquivo’, depois em ‘R markdown…’.Rstudio lhe dará opções de output para selecionar. exemplo abaixo, escolhemos “HTML” porque queremos criar um documento html. O título e o nome autor não são importantes. Se o tipo documento de saída desejado não é nenhum desses, não se preocupe - é possível escolher qualquer um e alterar posteriormente.Isso abrirá um novo script .Rmd.","code":""},{"path":"rmarkdown.html","id":"importante-saber","chapter":"38 Relatórios com R Markdown","heading":"Importante saber","text":"O diretório de trabalhoO diretório de trabalho de um arquivo markdown é o local onde o próprio arquivo Rmd é salvo. Por exemplo, se o projeto R estiver dentro de ~/Documents/projectX e o próprio arquivo Rmd estiver em uma subpasta~/Documents/projectX/markdownfiles/markdown.Rmd, o código read.csv(\"data.csv\") Dentro markdown irá procurar por um arquivo csv na pasta markdownfiles, e não na pasta raiz projeto onde os scripts dentro dos projetos normalmente procurariam automaticamente.Para se referir arquivos em outro lugar, você precisará usar o caminho completo arquivo ou usar o pacote . O pacote define o diretório de trabalho para pasta raiz projeto R e é explicado em detalhes nas páginas Projetos R e Importar e exportar)(#importing) deste manual. Por exemplo, para importar um arquivo chamado “data.csv” de dentro da pasta projectX, o código seria import((“data.csv”)).Observe que o uso de setwd() em scripts R Markdown não é recomendado - ele se aplica apenas ao trecho de código em que está escrito.Trabalhando em uma unidade vs seu computadorComo o R Markdown pode ter problemas de pandoc ao ser executado em uma unidade de rede compartilhada, é recomendado que sua pasta esteja em sua máquina local, por exemplo, em um projeto em ‘Meus Documentos’. Se você usa Git (muito recomendado!), Isso será familiar. Para obter mais detalhes, consulte páginas manual em R em unidades de rede e Erros e ajuda.","code":""},{"path":"rmarkdown.html","id":"componentes-do-r-markdown","chapter":"38 Relatórios com R Markdown","heading":"38.3 Componentes do R Markdown","text":"Um documento R Markdown pode ser editado RStudio da mesma forma que um script R padrão. Quando você inicia um novo script R Markdown, o RStudio tenta ser útil mostrando um modelo que explica diferentes seções de um script R Markdown.seguir está o que aparece ao iniciar um novo script Rmd destinado produzir uma saída html (conforme seção anterior).Como você pode ver, existem três componentes básicos em um arquivo Rmd: YAML, texto Markdown e blocos de código R.Eles irão criar e se tornar saída seu documento. Veja o diagrama abaixo:","code":""},{"path":"rmarkdown.html","id":"metadados-yaml","chapter":"38 Relatórios com R Markdown","heading":"Metadados YAML","text":"Referido como ‘metadados YAML’ ou apenas ‘YAML’, isso está topo documento R Markdown. Esta seção script dirá ao seu arquivo Rmd que tipo de saída produzir, preferências de formatação e outros metadados, como título documento, autor e data. Existem outros usos não mencionados aqui (mas mencionados em ‘Produção de uma saída’). Observe que o recuo é importante; tabulações não são aceitas, mas espaços, sim.Esta seção deve começar com uma linha contendo apenas três traços --- e deve fechar com uma linha contendo apenas três traços ---. Os parâmetros YAML vêm em pares chave: valor. colocação dos dois pontos em YAML é importante - os pares chave: valor são separados por dois pontos (e não sinais de igual!).O YAML deve começar com metadados para o documento. ordem desses parâmetros YAML primários (não recuados) não importa. Por exemplo:can use R code YAML values writing -line code (preceded r within back-ticks) also within quotes (see example date:).image , clicked default output html file, can see YAML says output: html_document. However can also change say powerpoint_presentation word_document even pdf_document.Você pode usar o código R em valores YAML escrevendo-o como código -line (precedido por r dentro de crases), mas também entre aspas (veja o exemplo acima para date:).Na imagem acima, como clicamos que nossa saída padrão seria um arquivo html, podemos ver que o YAML diz output: html_document. entanto, também podemos alterar isso para dizer powerpoint_presentationouword_document ou mesmo pdf_document.","code":"title: \"My document\"\nauthor: \"Me\"\ndate: \"2023-10-22\""},{"path":"rmarkdown.html","id":"texto","chapter":"38 Relatórios com R Markdown","heading":"38.3.1 Texto","text":"Esta é narrativa seu documento, incluindo os títulos e cabeçalhos. Ele é escrito na linguagem “markdown”, que é usada em muitos softwares diferentes.Abaixo estão principais maneiras de escrever este texto. Consulte documentação mais extensa disponível na “cheatsheet” R Markdown site RStudio.","code":""},{"path":"rmarkdown.html","id":"novas-linhas","chapter":"38 Relatórios com R Markdown","heading":"Novas linhas","text":"Exclusivamente R Markdown, para iniciar uma nova linha, insira dois espaços final da linha anterior e pressione Enter / Return.","code":""},{"path":"rmarkdown.html","id":"case","chapter":"38 Relatórios com R Markdown","heading":"Case","text":"Cerque seu texto normal com esses caracteres para alterar como ele aparece na saída.Sublinhados (_text_) ou asterisco único (*texto*) para itálicoAsteriscos duplos (**texto**) para texto em negritoCrases (text) para exibir o texto como códigoA aparência real da fonte pode ser definida usando modelos específicos (especificados nos metadados YAML; consulte guias de exemplo).","code":""},{"path":"rmarkdown.html","id":"cor","chapter":"38 Relatórios com R Markdown","heading":"38.3.1.1 Cor","text":"Não existe um mecanismo simples para alterar cor texto R Markdown. Uma solução alternativa, SE sua saída um arquivo HTML, é adicionar uma linha HTML ao texto markdown. O código HTML abaixo imprimirá uma linha de texto em vermelho negrito.[PERIGO: Este é um aviso.] {style = “color: red;”}","code":"<span style=\"color: red;\">**_DANGER:_** This is a warning.<\/span>  "},{"path":"rmarkdown.html","id":"títulos-e-cabeçalhos","chapter":"38 Relatórios com R Markdown","heading":"Títulos e cabeçalhos","text":"Um símbolo hash (#) em uma parte texto de um script R Markdown cria um título. Isso é diferente de um pedaço de código R script, qual um símbolo hash é um mecanismo para comentar / anotar / desativar, como em um script R normal.Diferentes níveis de título são estabelecidos com diferentes números de símbolos hash início de uma nova linha. Um símbolo de hash é um título ou cabeçalho principal. Dois símbolos hash são um título de segundo nível. Os cabeçalhos de terceiro e quarto níveis podem ser feitos com mais símbolos hash sucessivamente.","code":"# First-level heading / title\n\n## Second level heading  \n\n### Third-level heading"},{"path":"rmarkdown.html","id":"marcadores-e-numeração","chapter":"38 Relatórios com R Markdown","heading":"Marcadores e numeração","text":"Use asteriscos (*) para criar uma lista de marcadores. Conclua frase anterior, insira dois espaços, Enter/Return duas vezes e, em seguida, inicie seus marcadores. Inclua um espaço entre o asterisco e o texto marcador. Após cada marcador, insira dois espaços e pressione Enter/Return. Os submarcadores funcionam da mesma maneira, mas são recuados. Os números funcionam da mesma maneira, mas em vez de um asterisco, escreva 1), 2), etc. Abaixo está aparência texto script R Markdown.","code":"Here are my bullets (there are two spaces after this colon):  \n\n* Bullet 1 (followed by two spaces and Enter/Return)  \n* Bullet 2 (followed by two spaces and Enter/Return)  \n  * Sub-bullet 1 (followed by two spaces and Enter/Return)  \n  * Sub-bullet 2 (followed by two spaces and Enter/Return)  \n  "},{"path":"rmarkdown.html","id":"comente-o-texto","chapter":"38 Relatórios com R Markdown","heading":"Comente o texto","text":"Você pode “comentar” o texto R Markdown da mesma forma que pode usar o “#” para comentar uma linha código R em um bloco R. Basta destacar o texto e pressionar Ctrl+Shift+c (Cmd+Shift+c para Mac). O texto será circundado por setas e ficará verde. Ele não aparecerá na sua saída.","code":""},{"path":"rmarkdown.html","id":"blocos-de-código","chapter":"38 Relatórios com R Markdown","heading":"Blocos de código","text":"seções script que são dedicadas à execução código R são chamadas de “blocos”. É aqui que você pode carregar pacotes, importar dados e realizar o gerenciamento e visualização de dados reais. Pode haver muitos blocos de código, então eles podem ajudá-lo organizar seu código R em partes, talvez intercaladas com texto. Note: Esses ‘pedaços’ parecerão ter uma cor de fundo ligeiramente diferente da parte narrativa documento.Cada pedaço é aberto com uma linha que começa com três crases e chaves que contêm parâmetros para o pedaço ({}). O pedaço termina com mais três crases.Você pode criar um novo bloco digitando-o você mesmo, usando o atalho de teclado “Ctrl+Alt+” (ou Cmd+Shift+r Mac) ou clicando ícone verde ‘inserir um novo bloco de código’ topo seu editor de script.Algumas notas sobre o conteúdo das chaves {}:Eles começam com ‘r’ para indicar que o nome idioma dentro bloco é RApós o r, você pode opcionalmente escrever um “nome” de trecho – eles não são necessários, mas podem ajudá-lo organizar seu trabalho. Observe que se você nomear seus blocos, você deve SEMPRE usar nomes exclusivos ou então R reclamará quando você tentar renderizar.chaves também podem incluir outras opções, escritas como tag = value, como:eval = FALSE para não executar o código Recho = FALSE para não imprimir o código-fonte R trecho documento de saídaaviso = FALSO para não imprimir avisos produzidos pelo código Rmensagem = FALSO para não imprimir nenhuma mensagem produzida pelo código Rincluir = VERDADEIRO / FALSO se incluir saídas em partes (por exemplo, gráficos) documentoout.width = e .height = - fornecer estilo .width =\"75%\"fig.align = \"center\" ajustar como uma figura é alinhada na páginafig.show = 'hold' se o seu pedaço imprimir várias figuras e você quiser que elas sejam impressas lado lado (par com .width = c(\"33%\", \"67%\"). Também pode ser definido como fig.show = 'asis' para mostrá-los abaixo código que os gera,'hide' para ocultar ou 'animate' para concatenar múltiplos em uma animação.Um cabeçalho de bloco deve ser escrito em uma linhaTente evitar pontos, sublinhados e espaços. Use hifens ( - ) se precisar de um separador.Leia mais extensivamente sobre opções knitr aqui.Algumas das opções acima podem ser configuradas com apontar e clicar usando os botões de configuração canto superior direito bloco. Aqui, você pode especificar quais partes pedaço você deseja que o documento renderizado inclua, saber, o código, saídas e os avisos. Isso sairá como preferências escritas dentro das chaves, por exemplo, echo = FALSE se você especificar que deseja ‘Mostrar apenas saída’.Também há duas setas canto superior direito de cada fragmento, que são úteis para executar o código dentro de um fragmento ou todo o código em blocos anteriores. Passe o mouse sobre eles para ver o que fazem.Para que opções globais sejam aplicadas todos os fragmentos script, você pode configurar isso em seu primeiro bloco de código R script. Por exemplo, para que apenas saídas sejam mostradas para cada bloco de código e não o código em si, você pode incluir este comando fragmento de código R:","code":"\nknitr::opts_chunk$set(echo = FALSE) "},{"path":"rmarkdown.html","id":"código-r-no-texto","chapter":"38 Relatórios com R Markdown","heading":"Código R no texto","text":"Você também pode incluir código R mínimo dentro de crases. Dentro dos crases, comece o código com “r” e um espaço, para que o RStudio saiba avaliar o código como código R. Veja o exemplo abaixo.O exemplo abaixo mostra vários níveis de título, marcadores e usa o código R para data atual (Sys.Date ()) para avaliar em uma data impressa.O exemplo acima é simples (mostrando data atual), mas usando mesma sintaxe, você pode exibir valores produzidos por códigos R mais complexos (por exemplo, para calcular o mínimo, mediana, o máximo de uma coluna). Você também pode integrar objetos R ou valores que foram criados em blocos de código R anteriormente script.Como exemplo, o script abaixo calcula proporção de casos com menos de 18 anos, usando funções tidyverse, e cria os objetos less18,total e less18prop. Este valor dinâmico é inserido texto subsequente. Vemos como fica quando imprimimos um documento Word.","code":""},{"path":"rmarkdown.html","id":"imagens","chapter":"38 Relatórios com R Markdown","heading":"38.3.2 Imagens","text":"Você pode incluir imagens em seu R Markdown de duas maneiras:Se o acima não funcionar, tente usar knitr::include_graphics()(lembre-se, o caminho seu arquivo pode ser escrito usando o pacote )","code":"![](\"path/to/image.png\")  \nknitr::include_graphics(\"path/to/image.png\")\nknitr::include_graphics(here::here(\"path\", \"to\", \"image.png\"))"},{"path":"rmarkdown.html","id":"tabelas","chapter":"38 Relatórios com R Markdown","heading":"38.3.3 Tabelas","text":"Crie uma tabela usando hifens ( - ) e barras ( | ). O número de hifens antes/entre barras permite o número de espaços na célula antes que o texto comece quebrar.O código acima produz tabela abaixo:","code":"Column 1 |Column  2 |Column 3\n---------|----------|--------\nCell A   |Cell B    |Cell C\nCell D   |Cell E    |Cell F"},{"path":"rmarkdown.html","id":"seções-com-guias","chapter":"38 Relatórios com R Markdown","heading":"38.3.4 Seções com guias","text":"Para saídas HTML, você pode organizar seções em “guias”. Basta adicionar .tabset nas chaves {}que são colocadas * após um título *. Quaisquer subtítulos abaixo desse título (até outro título mesmo nível) aparecerão como guias nas quais o usuário pode clicar. Leia mais aquiVocê pode adicionar uma opção adicional .tabset-pills após .tabset para dar às próprias guias uma aparência de pastilha. Esteja ciente de que, ao visualizar saída HTML com guias, funcionalidade de pesquisa Ctrl+f pesquisará apenas guias “ativas”, não guias ocultas.","code":""},{"path":"rmarkdown.html","id":"estrutura-do-arquivo","chapter":"38 Relatórios com R Markdown","heading":"38.4 Estrutura do arquivo","text":"Existem várias maneiras de estruturar seu R Markdown e quaisquer scripts R associados. Cada um tem vantagens e desvantagens:R Markdown independente - tudo o que é necessário para o relatório é importado ou criado dentro R MarkdownFonte de outros arquivos - Você pode executar scripts R externos com o comando source() e usar suas saídas RmdScripts filhos - um mecanismo alternativo para source()Utilizar um “runfile” - Executar comandos em um script R antes de renderizar o R Markdown","code":""},{"path":"rmarkdown.html","id":"rmd-independente-.não-numerado","chapter":"38 Relatórios com R Markdown","heading":"38.4.1 Rmd independente {.não numerado}","text":"Para um relatório relativamente simples, você pode optar por organizar seu script R Markdown de forma que seja “independente” e não envolva nenhum script externo.Tudo que você precisa para executar o markdown R é importado ou criado dentro arquivo Rmd, incluindo todos os pedaços de código e carregamento de pacote. Esta abordagem “independente” é apropriada quando você não precisa fazer muito processamento de dados (por exemplo, traz um arquivo de dados limpo ou semilimpeza) e renderização R Markdown não demora muito.Neste cenário, uma organização lógica script R Markdown pode ser:Defina opções globais knitrCarregar pacotesImportar dadosDados processoProduza resultados (tabelas, gráficos, etc.)Salve saídas, se aplicável (.csv, .png, etc.)","code":""},{"path":"rmarkdown.html","id":"fonte-de-outros-arquivos","chapter":"38 Relatórios com R Markdown","heading":"Fonte de outros arquivos","text":"Uma variação da abordagem “independente” é fazer com que os pedaços de código R Markdown “originem” (executem) outros scripts R. Isso pode tornar seu script R Markdown menos confuso, mais simples e mais fácil de organizar. Também pode ajudar se você deseja exibir os valores finais início relatório. Nesta abordagem, o script final R Markdown simplesmente combina saídas pré-processadas em um documento.Uma maneira de fazer isso é fornecendo os scripts R (caminho e nome arquivo com extensão) para o comando R base source().Observe que ao usar source() dentro R Markdown, os arquivos externos ainda serão executados durante o curso de renderização de seu arquivo Rmd. Portanto, cada script é executado sempre que você renderiza o relatório. Portanto, ter esses comandos source() dentro R Markdown não acelera seu tempo de execução, nem ajuda muito na eliminação de bugs, pois o erro produzido ainda será impresso ao produzir o R Markdown.Uma alternativa é utilizar opção child = knitr. EXPLIQUE MAIS FAZERVocê deve estar ciente dos vários ambientes R. Os objetos criados dentro de um ambiente não estarão necessariamente disponíveis para o ambiente usado pelo R Markdown.","code":"\nsource(\"your-script.R\", local = knitr::knit_global())\n# or sys.source(\"your-script.R\", envir = knitr::knit_global())"},{"path":"rmarkdown.html","id":"runfile","chapter":"38 Relatórios com R Markdown","heading":"Runfile","text":"Esta abordagem envolve utilização script R que contém o (s) comando (s) render() para pré-processar objetos que alimentam o markdown R.Por exemplo, você pode carregar os pacotes, carregar e limpar os dados e até mesmo criar os gráficos de interesse antes de render(). Essas etapas podem ocorrer script R ou em outros scripts originados via source. Contanto que esses comandos ocorram na mesma sessão RStudio e os objetos sejam salvos ambiente, os objetos podem ser chamados dentro conteúdo Rmd. Em seguida, o próprio markdown R será usado apenas para etapa final - para produzir saída com todos os objetos pré-processados. Isso é muito mais fácil de corrigir se algo der errado.Essa abordagem é útil pelos seguintes motivos:Mensagens de erro mais informativas - essas mensagens serão geradas partir script R, não R Markdown. R Erros de Markdown tendem dizer qual pedaço teve um problema, mas não revelam qual linha.Se aplicável, você pode executar longas etapas de processamento antes comando render() - elas serão executadas apenas uma vez.exemplo abaixo, temos um script R separado qual pré-processamos um objeto data ambiente R e então renderizamos o “create_output.Rmd” usando render().","code":"\ndata <- import(\"datafile.csv\") %>%       # Load data and save to environment\n  select(age, hospital, weight)          # Select limited columns\n\nrmarkdown::render(input = \"create_output.Rmd\")   # Create Rmd file"},{"path":"rmarkdown.html","id":"estrutura-da-pasta","chapter":"38 Relatórios com R Markdown","heading":"38.4.2 Estrutura da pasta","text":"O fluxo de trabalho também diz respeito à estrutura geral da pasta, como ter uma pasta de ‘saída’ para documentos e figuras criados e pastas de ‘dados’ ou ‘entradas’ para dados limpos. Não entramos em maiores detalhes aqui, mas verifique página Organizando relatórios de rotina.","code":""},{"path":"rmarkdown.html","id":"produzindo-o-documento","chapter":"38 Relatórios com R Markdown","heading":"38.5 Produzindo o documento","text":"Você pode produzir o documento das seguintes maneiras:Manualmente pressionando o botão “Knit” na parte superior editor de script RStudio (rápido e fácil)Execute o comando render() (executado fora script R Markdown)","code":""},{"path":"rmarkdown.html","id":"opção-1-botão-knit","chapter":"38 Relatórios com R Markdown","heading":"38.5.1 Opção 1: Botão “Knit”","text":"Quando você tiver o arquivo Rmd aberto, pressione o ícone / botão ‘Knit’ na parte superior arquivo.R Studio mostrará o progresso em uma guia ‘R Markdown’ perto console R. O documento será aberto automaticamente quando concluído.O documento será salvo na mesma pasta que seu script markdown R e com o mesmo nome de arquivo (exceto extensão). Obviamente, isso não é ideal para o controle de versão (será sobrescrito cada vez que você exportar, menos que movido manualmente), pois você pode precisar renomear o arquivo (por exemplo, adicionar uma data).Este é o botão de atalho RStudio para função render() de rmarkdown. Essa abordagem é compatível apenas com um R markdown autocontido, onde todos os componentes necessários existem ou são originados arquivo.","code":""},{"path":"rmarkdown.html","id":"opção-2-comando-render","chapter":"38 Relatórios com R Markdown","heading":"Opção 2: comando render()","text":"Outra maneira de produzir saída R Markdown é rodar função render() (pacote rmarkdown). Você deve executar este comando fora script R Markdown - ou em um script R separado (geralmente chamado de “arquivo de execução”) ou como um comando independente R Console.Tal como acontece com “knit”, configurações padrão salvarão saída Rmd na mesma pasta script Rmd, com o mesmo nome de arquivo (além da extensão arquivo). Por exemplo, “my_report.Rmd” quando exportado criará “my_report.docx” se você estiver exportando para um documento Word. entanto, usando render() você tem opção de usar configurações diferentes. render() pode aceitar argumentos, incluindo:output_format = Este é o formato de saída para converter (por exemplo, \"html_document\", \"pdf_document\", \"word_document\" ou \"\"). Você também pode especificar isso YAML dentro script R Markdown.output_file = Este é o nome arquivo de saída (e caminho arquivo). Isso pode ser criado por meio de funções R como () ou str_glue() conforme demonstrado abaixo.output_dir = Este é um diretório de saída (pasta) para salvar o arquivo. Isso permite que você escolha uma alternativa diferente diretório em que o arquivo Rmd é salvo.output_options = Você pode fornecer uma lista de opções que irão sobrescrever aquelas script YAML (por exemplo)output_yaml = Você pode fornecer o caminho para um arquivo .yml que contém especificações YAMLparams = Veja seção sobre parâmetros abaixoVeja lista completa aquiComo um exemplo, para melhorar o controle de versão, o comando seguir salvará o arquivo de saída dentro de uma subpasta ‘outputs’, com data atual nome arquivo. Para criar o nome arquivo, função str_glue() pacote stringr é usada para ‘colar’ strings estáticas (escritas de forma simples) com código R dinâmico (escrito entre colchetes). Por exemplo, se 10 de abril de 2021, o nome arquivo abaixo será “Report_2021-04-10.docx”. Veja página em Caracteres e strings para mais detalhes sobre str_glue().À medida que o arquivo é renderizado, o console RStudio mostrará o andamento da renderização em até 100% e uma mensagem final para indicar que renderização foi concluída.","code":"\nrmarkdown::render(input = \"my_report.Rmd\")\nrmarkdown::render(\n  input = \"create_output.Rmd\",\n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\")) "},{"path":"rmarkdown.html","id":"opções-3-pacote-reportfactory","chapter":"38 Relatórios com R Markdown","heading":"Opções 3: pacote reportfactory","text":"O pacote R reportfactory oferece um método alternativo de organização e compilação de relatórios R Markdown voltados para cenários onde você executa relatórios rotineiramente (por exemplo, diariamente, semanalmente …). Facilita compilação de vários arquivos R Markdown e o organização de seus resultados. Em essência, ele fornece uma “fábrica” partir da qual você pode executar os relatórios R Markdown, obter pastas com carimbo de data e hora automaticamente para saídas e ter controle de versão “leve”.Leia mais sobre esse fluxo de trabalho na página Organização de relatórios de rotina.","code":""},{"path":"rmarkdown.html","id":"relatórios-parametrizados","chapter":"38 Relatórios com R Markdown","heading":"38.6 Relatórios parametrizados","text":"Você pode usar parametrização para tornar um relatório dinâmico, de modo que possa ser executado com uma configuração específica (por exemplo, uma data ou local específico ou com certas opções de knit). Abaixo, nos concentramos básico, mas há mais detalhes online sobre relatórios parametrizados.Usando lista de linha Ebola como exemplo, digamos que queremos executar um relatório de vigilância padrão para cada hospital cada dia. Mostramos como fazer isso usando parâmetros.Importante: relatórios dinâmicos também são possíveis sem estrutura formal de parâmetros (sem params:), usando objetos R simples em um script R adjacente. Isso é explicado final desta seção.","code":""},{"path":"rmarkdown.html","id":"configurando-parâmetros","chapter":"38 Relatórios com R Markdown","heading":"Configurando parâmetros","text":"Você tem várias opções para especificar valores de parâmetro para sua saída R Markdown.","code":""},{"path":"rmarkdown.html","id":"opção-1-defina-os-parâmetros-em-yaml","chapter":"38 Relatórios com R Markdown","heading":"Opção 1: Defina os parâmetros em YAML","text":"Edite o YAML para incluir uma opção params:, com declarações recuadas para cada parâmetro que você deseja definir. Neste exemplo, criamos os parâmetros data ehospital, para os quais especificamos valores. Esses valores estão sujeitos alterações cada vez que o relatório é executado. Se você usar o botão “Knit” para produzir saída, os parâmetros terão esses valores padrão. Da mesma forma, se você usar render() os parâmetros terão esses valores padrão, menos que seja especificado de outra forma comando render().Em segundo plano, esses valores de parâmetro estão contidos em uma lista somente leitura chamada params. Assim, você pode inserir os valores dos parâmetros código R da mesma forma que faria com outro objeto / valor R em seu ambiente. Simplesmente digite params$ seguido nome parâmetro. Por exemplo, params$hospital para representar o nome hospital (“Hospital Central” por padrão).Observe que os parâmetros também podem conter valores true ou false e, portanto, podem ser incluídos nas opções knitr para um bloco R. Por exemplo, você pode definir {r, eval = params$run} em vez de {r, eval = FALSE}, e agora se o trecho é executado ou não depende valor de um parâmetro run:.Observe que para os parâmetros que são datas, eles serão inseridos como uma string. Portanto, para que params$date seja interpretado código R, ele provavelmente precisará ser empacotado com .Date() ou uma função semelhante para converter para classe Date.","code":"---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: Central Hospital\n---"},{"path":"rmarkdown.html","id":"opção-2-defina-os-parâmetros-em-render","chapter":"38 Relatórios com R Markdown","heading":"Opção 2: Defina os parâmetros em render()","text":"Como mencionado acima, uma alternativa para pressionar o botão “Knit” para produzir saída é executar função render() partir de um script separado. Neste último caso, você pode especificar os parâmetros serem usados naquela renderização para o argumento params = de render().Observe que quaisquer valores de parâmetro fornecidos aqui irão sobrescrever seus valores padrão se escritos dentro YAML. Escrevemos os valores entre aspas, pois neste caso eles devem ser definidos como valores de caractere / string.O comando abaixo renderiza “monitoramento_report.Rmd”, especifica um nome de arquivo de saída dinâmica e pasta, e fornece uma list() de dois parâmetros e seus valores para o argumento params =.","code":"\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = list(date = \"2021-04-10\", hospital  = \"Central Hospital\"))"},{"path":"rmarkdown.html","id":"opção-3-defina-os-parâmetros-usando-uma-interface-gráfica-do-usuário","chapter":"38 Relatórios com R Markdown","heading":"Opção 3: Defina os parâmetros usando uma interface gráfica do usuário","text":"Para uma sensação mais interativa, você também pode usar Interface Gráfica Usuário (GUI) para selecionar manualmente os valores dos parâmetros. Para fazer isso, podemos clicar menu suspenso ao lado botão ‘Knit’ e escolher ‘Knit com parâmetros’.Um pop-aparecerá permitindo que você digite valores para os parâmetros que são estabelecidos YAML documento.Você pode conseguir o mesmo por meio de um comando render() especificando params = \"ask \", como demonstrado abaixo.entanto, digitar valores nesta janela pop-está sujeito erros e erros ortográficos. Você pode preferir adicionar restrições aos valores que podem ser inseridos nos menus suspensos. Você pode fazer isso adicionando YAML várias especificações para cada entrada params:.label: é como o título para aquele menu suspenso específicovalue: é o valor padrão (inicial)input: definido como select para o menu suspensochoices: Dê os valores elegíveis menu suspensoAbaixo, essas especificações são escritas para o parâmetro hospital.Ao exportar (através botão ‘knit com parâmetros’ ou por render()), janela pop-terá opções suspensas para selecionar.","code":"rmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = “ask”)---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: \n  label: “Town:”\n  value: Central Hospital\n  input: select\n  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]\n---"},{"path":"rmarkdown.html","id":"exemplo-parametrizado","chapter":"38 Relatórios com R Markdown","heading":"Exemplo parametrizado","text":"O código seguir cria parâmetros para data ehospital, que são usados R Markdown como params$date e params$hospital, respectivamente.Na saída relatório resultante, veja como os dados são filtrados para o hospital específico e o título gráfico se refere ao hospital e à data corretos. Usamos o arquivo “linelist_cleaned.rds” aqui, mas seria particularmente apropriado se própria lista de linha também tivesse um carimbo de data para alinhar com data parametrizada.Exportar isso produz saída final com fonte e o layout padrão.","code":""},{"path":"rmarkdown.html","id":"parametrização-sem-params","chapter":"38 Relatórios com R Markdown","heading":"Parametrização sem params","text":"Se você estiver renderizando um arquivo R Markdown com render() de um script separado, você pode criar o impacto da parametrização sem usar funcionalidade params:.Por exemplo, script R que contém o comando render(), você pode simplesmente definir hospital e date como dois objetos R (valores) antes comando render(). R Markdown, você não precisaria ter uma seção params: YAML, e nos referiríamos ao objeto date ao invés de params$date e hospital ao invés deparams$hospital.Seguir essa abordagem significa que você não pode “tricotar com parâmetros”, usar GUI ou incluir opções de knit dentro dos parâmetros. entanto, permite um código mais simples, o que pode ser vantajoso.","code":"\n# This is a R script that is separate from the R Markdown\n\n# define R objects\nhospital <- \"Central Hospital\"\ndate <- \"2021-04-10\"\n\n# Render the R markdown\nrmarkdown::render(input = \"create_output.Rmd\") "},{"path":"rmarkdown.html","id":"reiterando-relatórios","chapter":"38 Relatórios com R Markdown","heading":"38.7 Reiterando relatórios","text":"Podemos querer executar um relatório várias vezes, variando os parâmetros de entrada, para produzir um relatório para cada jurisdição / unidade. Isso pode ser feito usando ferramentas para iteração, que são explicadas em detalhes na página Iteração, loops e listas. opções incluem o pacote purrr ou o uso de um loop conforme explicado abaixo.Abaixo, usamos um simples loop para gerar um relatório de vigilância para todos os hospitais de interesse. Isso é feito com um comando (em vez de alterar manualmente o parâmetro hospital um por vez). O comando para renderizar os relatórios deve existir em um script separado fora relatório Rmd. Este script também conterá objetos definidos para “fazer um loop” - data de hoje e um vetor de nomes de hospitais para fazer o loop.Em seguida, alimentamos esses valores um de cada vez comando render() usando um loop, que executa o comando uma vez para cada valor vetor hospitais. letra representa posição índice (1 4) hospital que está sendo usado nessa iteração, de modo que hospital_list[1] seria “Hospital Central”. Esta informação é fornecida em dois lugares comando render():Para o nome arquivo, de forma que o nome arquivo da primeira iteração, se produzido em 10 de abril de 2021, seria “Report_Central Hospital_2021-04-10.docx”, salvo na subpasta ‘output’ diretório de trabalho.Para params = tal que o Rmd use o nome hospital internamente sempre que o valor params$hospital é chamado (por exemplo, para filtrar o conjunto de dados para o hospital específico apenas). Neste exemplo, quatro arquivos seriam criados - um para cada hospital.<! - output_file = paste0 (“output / Report_”, hospital_list [], refdate, “.docx”) -><! - O texto dentro da marcação precisaria então se referir hospital_list [] e refdate. ->","code":"\nhospitals <- c(\"Central Hospital\",\n                \"Military Hospital\", \n                \"Port Hospital\",\n                \"St. Mark's Maternity Hospital (SMMH)\") \nfor(i in 1:length(hospitals)){\n  rmarkdown::render(\n    input = \"surveillance_report.Rmd\",\n    output_file = str_glue(\"output/Report_{hospitals[i]}_{Sys.Date()}.docx\"),\n    params = list(hospital  = hospitals[i]))\n}       "},{"path":"rmarkdown.html","id":"modelos","chapter":"38 Relatórios com R Markdown","heading":"38.8 Modelos","text":"Usando um documento de modelo que contém qualquer formatação desejada, você pode ajustar estética de como saída Rmd ficará. Você pode criar, por exemplo, um arquivo MS Word ou PowerPoint que contenha páginas / slides com dimensões, marcas d’água, planos de fundo e fontes desejados.","code":""},{"path":"rmarkdown.html","id":"documentos-do-word","chapter":"38 Relatórios com R Markdown","heading":"38.8.1 Documentos do Word","text":"Para criar um modelo, inicie um novo documento Word (ou use uma saída existente com formatação que mais lhe convier) e edite fontes definindo os Estilos. Em Estilo, os títulos 1, 2 e 3 referem-se aos vários níveis de cabeçalho de redução (# Cabeçalho 1, ## Cabeçalho 2 e ### Cabeçalho 3 respectivamente). Clique com o botão direito estilo e clique em ‘modificar’ para alterar formatação da fonte, bem como o parágrafo (por exemplo, você pode introduzir quebras de página antes de certos estilos que podem ajudar com o espaçamento). Outros aspectos documento Word, como margens, tamanho da página, cabeçalhos, etc., podem ser alterados como um documento Word normal qual você está trabalhando diretamente.","code":""},{"path":"rmarkdown.html","id":"documentos-do-powerpoint","chapter":"38 Relatórios com R Markdown","heading":"38.8.2 Documentos do PowerPoint","text":"Como acima, crie um novo conjunto de slides ou use um arquivo PowerPoint existente com formatação desejada. Para outras edições, clique em ‘Exibir’ e ‘Slide Master’. partir daqui, você pode alterar aparência slide ‘mestre’ editando formatação texto nas caixas de texto, bem como dimensões plano de fundo / página para página geral.Infelizmente, editar arquivos PowerPoint é um pouco menos flexível:Um cabeçalho de primeiro nível (# Cabeçalho 1) se tornará automaticamente o título de um novo slide,Um texto de ## Header 2 não aparecerá como uma legenda, mas como um texto dentro da caixa de texto principal slide (menos que você encontre uma maneira de manipular visualização mestre).Plotagens e tabelas geradas irão automaticamente para novos slides. Você precisará combiná-los, por exemplo, função patchwork para combinar ggplots, de modo que apareçam na mesma página. Veja esta postagem blog sobre como usar o pacote patchwork para colocar várias imagens em um slide.Veja o pacote officer para uma ferramenta para trabalhar mais fundo com apresentações em PowerPoint.","code":""},{"path":"rmarkdown.html","id":"integração-de-modelos-no-yaml","chapter":"38 Relatórios com R Markdown","heading":"Integração de modelos no YAML","text":"Uma vez que um modelo é preparado, o detalhe disso pode ser adicionado YAML Rmd abaixo da linha de ‘output’ e abaixo de onde o tipo de documento é especificado (que vai para uma linha separada). Nota reference_doc pode ser usado para modelos de slides PowerPoint.É mais fácil salvar o modelo na mesma pasta onde está o arquivo Rmd (como exemplo abaixo) ou em uma subpasta.","code":"---\ntitle: Surveillance report\noutput: \n word_document:\n  reference_docx: \"template.docx\"\nparams:\n date: 2021-04-10\n hospital: Central Hospital\ntemplate:\n \n---"},{"path":"rmarkdown.html","id":"formatando-arquivos-html","chapter":"38 Relatórios com R Markdown","heading":"Formatando arquivos HTML","text":"Os arquivos HTML não usam modelos, mas podem ter os estilos configurados YAML. HTMLs são documentos interativos e são particularmente flexíveis. Cobrimos algumas opções básicas aqui.Índice: Podemos adicionar um índice com toc: true abaixo, e também especificar que ele permanece visível (“floats”) conforme você rola, com toc_float: true.Índice: Podemos adicionar um índice com toc: true abaixo, e também especificar que ele permanece visível (“floats”) conforme você rola, com toc_float: true.Temas: Podemos nos referir alguns temas pré-fabricados, que vêm de uma biblioteca de temas Bootswatch. exemplo abaixo, usamos cerulean. Outras opções incluem: diário, plano, escuro, legível, laboratório espacial, unido, cosmo, lúmen, papel, arenito, simplex e yeti. original, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, e yetiTemas: Podemos nos referir alguns temas pré-fabricados, que vêm de uma biblioteca de temas Bootswatch. exemplo abaixo, usamos cerulean. Outras opções incluem: diário, plano, escuro, legível, laboratório espacial, unido, cosmo, lúmen, papel, arenito, simplex e yeti. original, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, e yetiRealçar: Configurar isso muda aparência texto destacado (por exemplo, código dentro dos pedaços que são mostrados). Os estilos suportados incluem default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark, e textmate.Realçar: Configurar isso muda aparência texto destacado (por exemplo, código dentro dos pedaços que são mostrados). Os estilos suportados incluem default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark, e textmate.Aqui está um exemplo de como integrar opções acima YAML.Abaixo estão dois exemplos de saídas HTML, ambas com índices flutuantes, mas diferentes temas e estilos de destaque selecionados:","code":"---\ntitle: \"HTML example\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    theme: cerulean\n    highlight: kate\n    \n---"},{"path":"rmarkdown.html","id":"conteúdo-dinâmico","chapter":"38 Relatórios com R Markdown","heading":"38.9 Conteúdo dinâmico","text":"Em uma saída HTML, o conteúdo seu relatório pode ser dinâmico. Abaixo estão alguns exemplos:","code":""},{"path":"rmarkdown.html","id":"tabelas-1","chapter":"38 Relatórios com R Markdown","heading":"38.9.1 Tabelas","text":"Em um relatório HTML, você pode imprimir quadros / tabelas de dados de forma que o conteúdo seja dinâmico, com filtros e barras de rolagem. Existem vários pacotes que oferecem esse recurso.Para fazer isso com o pacote DT, como é usado em todo este manual, você pode inserir um trecho de código como este:função datatable() imprimirá o quadro de dados fornecido como uma tabela dinâmica para o leitor. Você pode definir rownames = FALSE para simplificar o lado esquerdo da tabela. filter = \"top\" fornece um filtro para cada coluna. argumento option() forneça uma lista de outras especificações. Abaixo, incluímos dois: pageLength = 5 define o número de linhas que aparecem como 5 (linhas restantes podem ser visualizadas através das setas), e scrollX = TRUE habilita uma barra de rolagem na parte inferior da tabela (para colunas que se estendem muito para direita).Se seu conjunto de dados muito grande, considere mostrar apenas primeiras X linhas envolvendo o quadro de dados em head().","code":""},{"path":"rmarkdown.html","id":"widgets-html","chapter":"38 Relatórios com R Markdown","heading":"Widgets HTML","text":"[HTML widgets R] (http://www.htmlwidgets.org/) são uma classe especial de pacotes R que permitem maior interatividade utilizando bibliotecas JavaScript. Você pode embuti-los nas saídas HTML R Markdown.Alguns exemplos comuns desses widgets incluem:Plotly (usado nesta página manual e na página Gráficos interativos)visNetwork (usado na página Cadeias de transmissão deste manual)Folheto (usado na página Noções básicas de GIS deste manual)dygraphs (úteis para mostrar dados de séries temporais de forma interativa)DT (datatable()) (usado para mostrar tabelas dinâmicas com filtro, classificação, etc.)função ggplotly() de plotly é particularmente fácil de usar. Veja página Gráficos interativos.","code":""},{"path":"rmarkdown.html","id":"recursos-22","chapter":"38 Relatórios com R Markdown","heading":"38.10 Recursos","text":"Mais informações podem ser encontradas em:https://bookdown.org/yihui/rmarkdown/https://rmarkdown.rstudio.com/articles_intro.htmlUma boa explicação de markdown vs knitr vs Rmarkdown está aqui: https://stackoverflow.com/questions/40563479/relationship--r-markdown-knitr-pandoc--bookdown","code":""},{"path":"reportfactory.html","id":"reportfactory","chapter":"39 Organização de relatórios de rotina","heading":"39 Organização de relatórios de rotina","text":"Esta página cobre o pacote reportfactory, que é um acompanhamento uso R Markdown para relatórios.Em cenários onde você executa relatórios rotineiramente (diariamente, semanalmente, etc.), isso facilita compilação de vários arquivos R Markdown e organização de seus resultados. Em essência, ele fornece uma “fábrica” partir da qual você pode executar os relatórios R Markdown, obter pastas com carimbo de data e hora automaticamente para saídas e ter controle de versão “leve”.reportfactory é um dos pacotes desenvolvidos pelo RECON (R Epidemics Consortium). Aqui está o site e Github.","code":""},{"path":"reportfactory.html","id":"preparação-31","chapter":"39 Organização de relatórios de rotina","heading":"39.1 Preparação","text":"","code":""},{"path":"reportfactory.html","id":"carregar-pacotes-12","chapter":"39 Organização de relatórios de rotina","heading":"Carregar pacotes","text":"De dentro RStudio, instale versão mais recente pacote reportfactory Github.Você pode fazer isso através pacote pacman com p_load_current_gh () que forçará instalação da última versão Github. Forneça cadeia de caracteres “reconverse/reportfactory”, que especifica organização Github (reconverse) e o repositório (reportfactory). Você também pode usar install_github () pacote remotes, como alternativa.","code":"\n# Instale e carregue a última versão do pacote do Github\npacman::p_load_current_gh(\"reconverse/reportfactory\")\n#remotes::install_github(\"reconverse/reportfactory\") # alternative"},{"path":"reportfactory.html","id":"nova-fábrica","chapter":"39 Organização de relatórios de rotina","heading":"39.2 Nova fábrica","text":"Para criar uma nova fábrica, execute função new_factory(). Isso criará uma nova pasta de projeto R independente. Por padrão:fábrica será adicionada ao seu diretório de trabalhoO nome projeto de fábrica R será denominado “new_factory.Rproj”Sua sessão RStudio irá “mover-se” para este projeto ROlhando dentro da fábrica, você pode ver que subpastas e alguns arquivos foram criados automaticamente.pasta report_sources manterá seus scripts R Markdown, que geram seus relatóriosA pasta * outputs * conterá os resultados relatório (por exemplo, HTML, Word, PDF, etc.)pasta scripts pode ser usada para armazenar outros scripts R (por exemplo, que são fornecidos por seus scripts Rmd)pasta data pode ser usada para armazenar seus dados (subpastas “brutas” e “limpas” estão incluídas)Um arquivo ., para que você possa usar o pacote para chamar arquivos em subpastas por sua relação com esta pasta raiz (consulte página Projetos R para obter detalhes)Um arquivo gitignore foi criado caso de você vincular este projeto R um repositório Github (consulte Controle de versão e colaboração com Github)Um arquivo README vazio, se você usar um repositório Github **_ CUIDADO: _** dependendo da configuração seu computador, arquivos como “.” podem existir, mas são invisíveis. Das configurações padrão, abaixo estão várias que você pode querer ajustar dentro comando new_factory ():factory = - Fornece um nome para pasta de fábrica (o padrão é “new_factory”)path = - Designa um caminho de arquivo para nova fábrica (o padrão é o diretório de trabalho)report_sources = Fornece um nome alternativo para subpasta que contém os scripts R Markdown (o padrão é “report_sources”)outputs = Fornece um nome alternativo para pasta que contém os resultados relatório (o padrão é “outputs”)Veja ?New_factory para uma lista completa dos argumentos.Quando você cria nova fábrica, sua sessão R é transferida para o novo projeto R, então você deve carregar novamente o pacote reportfactory.Agora você pode executar o comando factory_overview() para ver estrutura interna (todas pastas e arquivos) na fábrica.seguinte “árvore” das pastas e arquivos da fábrica é impressa console R. Observe que na pasta “dados” existem subpastas para dados “brutos” e “limpos” e dados CSV de exemplo. Também existe “example_report.Rmd” na pasta “report_sources”.","code":"\n# Isso criará a fábrica no diretório de trabalho\nnew_factory()\npacman::p_load(reportfactory)\nfactory_overview() # imprime visão geral da fábrica para o console"},{"path":"reportfactory.html","id":"crie-um-relatório","chapter":"39 Organização de relatórios de rotina","heading":"39.3 Crie um relatório","text":"De dentro projeto R de fábrica, crie um relatório R Markdown como faria normalmente e salve-o na pasta “report_sources”. Consulte página R Markdown para obter instruções. Para fins de exemplo, adicionamos o seguinte à fábrica:Um novo script de markdown R intitulado “daily_sitrep.Rmd”, salvo na pasta “report_sources”Dados para o relatório (“linelist_cleaned.rds”), salvos na subpasta “clean” dentro da pasta “data”Podemos ver usando factory_overview() nosso R Markdown na pasta “report_sources” e o arquivo de dados na pasta de dados “clean” (destacado):Abaixo está uma captura de tela início R Markdown “daily_sitrep.Rmd”. Você pode ver que o formato de saída é definido como HTML, por meio cabeçalho YAML output: html_document.Neste script simples, existem comandos para:Carregar os pacotes necessáriosImportar os dados de lista de linha usando um caminho de arquivo pacote (leia mais na página em Importar e exportar)Imprima uma tabela de resumo de casos e exporte-com export() como um arquivo .csvImprima uma epicurva e exporte-com ggsave() como um arquivo .pngVocê pode revisar apenas lista de relatórios R Markdown na pasta “report_sources” com este comando:","code":"\nlinelist <- import(here(\"data\", \"clean\", \"linelist_cleaned.rds\"))\nlist_reports()"},{"path":"reportfactory.html","id":"compilar","chapter":"39 Organização de relatórios de rotina","heading":"39.4 Compilar","text":"Em uma fábrica de relatórios, “compilar” um relatório R Markdown significa que o script .Rmd será executado e saída será produzida (conforme especificado script YAML, por exemplo, como HTML, Word, PDF, etc).fábrica criará automaticamente uma pasta com carimbo de data e hora para saídas na pasta “saídas”.O próprio relatório e todos os arquivos exportados produzidos pelo script (por exemplo, csv, png, xlsx) serão salvos nesta pasta. Além disso, o próprio script Rmd será salvo nesta pasta, então você tem um registro dessa versão script.Isso contrasta com o comportamento normal de um R Markdown “knitado” ou “tricotado”, que salva saídas local script Rmd. Esse comportamento padrão pode resultar em pastas lotadas e confusas. fábrica visa melhorar organização quando é necessário executar relatórios com frequência.","code":""},{"path":"reportfactory.html","id":"compilar-por-nome","chapter":"39 Organização de relatórios de rotina","heading":"Compilar por nome","text":"Você pode compilar um relatório específico executando compile_reports() e fornecendo o nome script Rmd (sem extensão .Rmd) para reports =. Para simplificar, você pode pular o reports = e apenas escrever o nome R Markdown entre aspas, como abaixo.Este comando compilaria apenas o relatório “daily_sitrep.Rmd”, salvando o relatório HTML e exportações da tabela .csv e epicurva .png para uma subpasta com carimbo de data e hora específica para o relatório, dentro da pasta “outputs”.Observe que se você optar por fornecer extensão .Rmd, deverá digitar corretamente extensão conforme ela é salva nome arquivo (.rmd vs. .Rmd).Observe também que, ao compilar, você pode ver vários arquivos aparecerem temporariamente na pasta “report_sources” - mas eles irão desaparecer em breve, pois são transferidos para pasta “outputs” correta.","code":""},{"path":"reportfactory.html","id":"compilar-por-número","chapter":"39 Organização de relatórios de rotina","heading":"Compilar por número","text":"Você também pode especificar o script Rmd para compilar, fornecendo um número ou vetor de números para relatórios =. Os números devem estar alinhados com ordem em que os relatórios aparecem quando você executa list_reports().","code":"\n# Compile o segundo e o quarto Rmds na pasta \"report_sources\"\ncompile_reports(reports = c(2, 4))"},{"path":"reportfactory.html","id":"compilar-todos","chapter":"39 Organização de relatórios de rotina","heading":"Compilar todos","text":"Você pode compilar todos os relatórios R Markdown na pasta “report_sources” definindo o argumento reports = para TRUE.","code":""},{"path":"reportfactory.html","id":"compilar-da-subpasta","chapter":"39 Organização de relatórios de rotina","heading":"Compilar da subpasta","text":"Você pode adicionar subpastas à pasta “report_sources”. Para executar um relatório R Markdown de uma subpasta, simplesmente forneça o nome da pasta para subpasta =. Abaixo está um exemplo de código para compilar um relatório Rmd que reside em uma subpasta de “report_sources”.Você pode compilar todos os relatórios Rmd dentro de uma subpasta fornecendo o nome da subpasta para reports =, com uma barra final, como abaixo.","code":"\ncompile_reports(\n     reports = \"summary_for_partners.Rmd\",\n     subfolder = \"for_partners\")\ncompile_reports(reports = \"for_partners/\")"},{"path":"reportfactory.html","id":"parametrização","chapter":"39 Organização de relatórios de rotina","heading":"Parametrização","text":"Conforme observado na página em Relatórios com R Markdown, você pode executar relatórios com parâmetros especificados. Você pode passar esses parâmetros como uma lista para compile_reports() através argumento params =. Por exemplo, neste relatório fictício, há três parâmetros fornecidos para os relatórios R Markdown.","code":"\ncompile_reports(\n  reports = \"daily_sitrep.Rmd\",\n  params = list(most_recent_data = TRUE,\n                region = \"NORTHERN\",\n                rates_denominator = 10000),\n  subfolder = \"regional\"\n)"},{"path":"reportfactory.html","id":"usando-um-arquivo-de-execução","chapter":"39 Organização de relatórios de rotina","heading":"Usando um “arquivo de execução”","text":"Se você tiver vários relatórios para executar, considere criação de um script R que contenha todos os comandos de compile_reports (). Um usuário pode simplesmente executar todos os comandos neste script R e todos os relatórios serão compilados. Você pode salvar este “arquivo de execução” na pasta “scripts”.","code":""},{"path":"reportfactory.html","id":"saídas-1","chapter":"39 Organização de relatórios de rotina","heading":"39.5 Saídas","text":"Depois de termos compilado os relatórios algumas vezes, pasta “outputs” pode ter seguinte aparência (destaques adicionados para maior clareza):Dentro de “saídas”, subpastas foram criadas para cada relatório RmdDentro delas, outras subpastas foram criadas para cada compilação única\nEstes são marcados com data e hora (“2021-04-23_T11-07-36” significa 23 de abril de 2021 às 11:07:36)\nVocê pode editar o formato carimbo de data / hora. Veja ?Compile_reports\nEstes são marcados com data e hora (“2021-04-23_T11-07-36” significa 23 de abril de 2021 às 11:07:36)Você pode editar o formato carimbo de data / hora. Veja ?Compile_reportsDentro de cada pasta compilada de data / hora, saída relatório é armazenada (por exemplo, HTML, PDF, Word) junto com o script Rmd (controle de versão!) e quaisquer outros arquivos exportados (por exemplo, table.csv, epidemic_curve.png)Aqui está uma visão dentro de uma das pastas com carimbo de data / hora, para o relatório “daily_sitrep”. O caminho arquivo é destacado em amarelo para ênfase.Finalmente, abaixo está uma captura de tela da saída relatório HTML.Você pode usar list_outputs() para revisar uma lista das saídas.","code":""},{"path":"reportfactory.html","id":"diversos","chapter":"39 Organização de relatórios de rotina","heading":"39.6 Diversos","text":"","code":""},{"path":"reportfactory.html","id":"knit","chapter":"39 Organização de relatórios de rotina","heading":"39.6.1 Knit","text":"Você ainda pode “tricotar” um de seus relatórios R Markdown pressionando o botão “Knit”, se desejar. Se você fizer isso, como padrão, saídas aparecerão na pasta onde o Rmd foi salvo - pasta “report_sources”. Nas versões anteriores reportfactory, ter qualquer arquivo não-Rmd em “report_sources” impedia compilação, mas não é mais o caso. Você pode executar compile_reports() e nenhum erro ocorrerá.","code":""},{"path":"reportfactory.html","id":"scripts-2","chapter":"39 Organização de relatórios de rotina","heading":"Scripts","text":"Incentivamos você utilizar pasta “scripts” para armazenar “arquivos de execução” ou scripts .R originados de seus scripts .Rmd. Consulte página em R Markdown para dicas sobre como estruturar seu código em vários arquivos.","code":""},{"path":"reportfactory.html","id":"extras","chapter":"39 Organização de relatórios de rotina","heading":"Extras","text":"Com reportfactory, você pode usar função list_deps() para listar todos os pacotes necessários em todos os relatórios em toda fábrica.Com reportfactory, você pode usar função list_deps() para listar todos os pacotes necessários em todos os relatórios em toda fábrica.Há um pacote de acompanhamento em desenvolvimento chamado rfextras que oferece mais funções auxiliares para auxiliá-lo na construção de relatórios, como:\nload_scripts() - origina / carrega todos os scripts .R em uma determinada pasta (pasta “scripts” por padrão)\nfind_latest() - encontra versão mais recente de um arquivo (por exemplo, o conjunto de dados mais recente)\nHá um pacote de acompanhamento em desenvolvimento chamado rfextras que oferece mais funções auxiliares para auxiliá-lo na construção de relatórios, como:load_scripts() - origina / carrega todos os scripts .R em uma determinada pasta (pasta “scripts” por padrão)find_latest() - encontra versão mais recente de um arquivo (por exemplo, o conjunto de dados mais recente)","code":""},{"path":"reportfactory.html","id":"recursos-23","chapter":"39 Organização de relatórios de rotina","heading":"39.7 Recursos","text":"Veja o pacote reportfactory página GithubVeja o pacote rfextras página Github","code":""},{"path":"flexdashboard.html","id":"flexdashboard","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40 Painéis (Dashboards) com R Markdown","text":"Esta página cobrirá o uso básico pacote flexdashboard. Este pacote permite que você formate facilmente saída R Markdown como um painel com painéis e páginas. O conteúdo painel pode ser texto, figuras / tabelas estáticas ou gráficos interativos.Vantagens flexdashboard:Requer um mínimo de codificação R fora padrão - com muito pouca prática, você pode criar rapidamente um painelO painel geralmente pode ser enviado por e-mail para colegas como um arquivo HTML independente - nenhum servidor é necessárioVocê pode combinar flexdashboard com shiny, ggplotly e outros “widgets html” para adicionar interatividadeDesvantagens flexdashboard:Menos personalização em comparação com o uso de shiny sozinho para criar um painelTutoriais muito abrangentes sobre o uso flexdashboard que informaram esta página podem ser encontrados na seção Recursos. Abaixo descrevemos os principais recursos e damos um exemplo de construção de um painel para explorar um surto, usando os dados da lista de linha caso.","code":""},{"path":"flexdashboard.html","id":"preparação-32","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.1 Preparação","text":"","code":""},{"path":"flexdashboard.html","id":"carregar-pacotes-13","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Carregar pacotes","text":"Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() de base R. Veja página em Introdução ao R para mais informações sobre pacotes R.","code":"\npacman :: p_load(\n  rio, # importação / exportação de dados     \n  here, # localize arquivos\n  tidyverse, # gerenciamento e visualização de dados\n  flexdashboard, # versões de painel de relatórios R Markdown\n  shiny, # figuras interativas\n  plotly # figuras interativas\n)"},{"path":"flexdashboard.html","id":"importar-dados-5","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Importar dados","text":"Importamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o “clean” linelist  (.rds file). Importe dados com função import() pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja página Importar e exportar para detalhes).primeiras 50 linhas da linelist são exibidas abaixo.","code":"\n# importar a linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"flexdashboard.html","id":"criar-novo-r-markdown","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.2 Criar novo R Markdown","text":"Depois de instalar o pacote, crie um novo arquivo R Markdown clicando em Arquivo> Novo arquivo> R Markdown.Na janela que se abre, selecione “modelo” (template) e selecione o modelo “Flex Dashboard”. Em seguida, você será solicitado nomear o documento. exemplo desta página, nomearemos nosso R Markdown como “outbreak_dashboard.Rmd”.","code":""},{"path":"flexdashboard.html","id":"o-script","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.3 O script","text":"O script é um script R Markdown e, portanto, tem os mesmos componentes e organização descritos na página Relatórios com R Markdown. Nós os revisamos brevemente e destacamos diferenças de outros formatos de saída R Markdown.","code":""},{"path":"flexdashboard.html","id":"yaml","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"YAML","text":"topo script está o cabeçalho “YAML”. Isso deve começar com três traços --- e deve fechar com três traços ---. Os parâmetros YAML vêm em pares chave: valor. O recuo e colocação dos dois pontos em YAML são importantes - os pares chave: valor são separados por dois pontos (e não sinais de igual!).O YAML deve começar com metadados para o documento. ordem desses parâmetros YAML primários (não recuados) não importa. Por exemplo:Você pode usar o código R em valores YAML escrevendo-o como código -line (precedido por r dentro de crases), mas também entre aspas (veja o exemplo acima para date:).Um parâmetro YAML necessário é output:, que especifica o tipo de arquivo ser produzido (por exemplo, html_document,pdf_document, word_document oupowerpoint_presentation). Para flexdashboard este valor de parâmetro é um pouco confuso - ele deve ser definido como output: flexdashboard :: flex_dashboard. Observe os dois pontos simples e duplos e o sublinhado. Este parâmetro de saída YAML é frequentemente seguido por dois pontos adicionais e subparâmetros indentados (veja os parâmetros orientação: e vertical_layout: abaixo).Conforme mostrado acima, recuos (2 espaços) são usados para subparâmetros. Neste caso, não se esqueça de colocar dois pontos adicionais após o primário, como chave: valor:.Se apropriado, os valores lógicos devem ser fornecidos em YAML em letras minúsculas (true,false, null). Se dois pontos fizerem parte seu valor (por exemplo, título), coloque o valor entre aspas. Veja os exemplos nas seções abaixo.","code":"\ntitle: \"Meu documento\"\nauthor: \"Eu\"\ndate: \"` r Sys.Date() `\"\ntitle: \"Meu painel\"\nauthor: \"Eu\"\ndate: \"` r Sys.Date() `\"\noutput:\n  flexdashboard::flex_dashboard:\n    orientation: rows\n    vertical_layout: scroll"},{"path":"flexdashboard.html","id":"blocos-de-código-1","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Blocos de código","text":"Um script R Markdown pode conter vários “pedaços” (chunks) de código - essas são áreas script onde você pode escrever código R de várias linhas e funcionam como mini scripts R.Os trechos de código são criados com três marcas invertidas e chaves com um “r” minúsculo dentro. O pedaço é fechado com três crases. Você pode criar um novo bloco digitando-o você mesmo, usando o atalho de teclado “Ctrl+Alt+” (ou Cmd+Shift+r Mac) ou clicando ícone verde ‘inserir um novo bloco de código’ topo seu editor de script. Muitos exemplos são fornecidos seguir.","code":""},{"path":"flexdashboard.html","id":"texto-narrativo","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Texto narrativo","text":"Fora de um “bloco” de código R, você pode escrever um texto narrativo. Conforme descrito na página em Relatórios com R Markdown, você pode colocar o texto em itálico circundando-o com um asterisco (*) ou em negrito circundando-o com dois asteriscos (**). Lembre-se de que os marcadores e os esquemas de numeração são sensíveis novas linhas, recuo e acabamento de uma linha com dois espaços.Você também pode inserir o código R nas próprias linhas de texto (-line), conforme descrito na página Relatórios com R Markdown, circundando o código com crases e iniciando o comando com “r”: `1 + 1`(veja o exemplo com data acima).","code":""},{"path":"flexdashboard.html","id":"títulos","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Títulos","text":"Diferentes níveis de título são estabelecidos com diferentes números de símbolos hash ou jogo da velha, conforme descrito na página Relatórios com R Markdown.Em flexdashboard, um título principal (#) cria uma “página” painel. Títulos de segundo nível (##) criam uma coluna ou uma linha dependendo seu parâmetro orientação: (veja os detalhes abaixo). Títulos de terceiro nível (###) criam painéis para plotagens, gráficos, tabelas, texto, etc.","code":"# Título de primeiro nível (página)\n\n## Título de segundo nível (linha ou coluna)  \n\n### Cabeçalho de terceiro nível (painel para plot, gráfico, etc.)"},{"path":"flexdashboard.html","id":"atributos-da-seção","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.4 Atributos da seção","text":"Como em uma marcação R normal, você pode especificar atributos serem aplicados partes seu painel, incluindo opções key = value após um título, entre chaves {}. Por exemplo, em um relatório HTML R Markdown típico, você pode organizar subtítulos em guias com ## Meu título {.tabset}.Observe que esses atributos são escritos após um título em uma parte texto script. Elas são diferentes das opções knitr inseridas topo dos blocos de código R, como .height =.Os atributos de seção específicos para flexdashboard incluem:{data-orientation=} Defina para linhas oucolunas. Se o seu painel tiver várias páginas, adicione este atributo cada página para indicar orientação (mais explicado em seção de layout).{data-width =} e {data-height =} definem o tamanho relativo dos gráficos, colunas, linhas dispostas na mesma dimensão (horizontal ou vertical). Tamanhos absolutos são ajustados para melhor preencher o espaço em qualquer dispositivo de exibição graças ao mecanismo flexbox.\naltura dos gráficos também depende de você definir o parâmetro YAML vertical_layout: fill ou vertical_layout: scroll. Se configurado para rolar, altura da figura refletirá opção tradicional fig.height = fragmento código R.\nConsulte documentação de tamanho completa site flexdashboard\naltura dos gráficos também depende de você definir o parâmetro YAML vertical_layout: fill ou vertical_layout: scroll. Se configurado para rolar, altura da figura refletirá opção tradicional fig.height = fragmento código R.Consulte documentação de tamanho completa site flexdashboard{.hidden} Use isto para excluir uma página específica da barra de navegação{data-navbar =} Use isso em um título de nível de página para aninhá-lo dentro de um menu suspenso da barra de navegação. Forneça o nome (entre aspas) menu suspenso. Veja o exemplo abaixo.","code":""},{"path":"flexdashboard.html","id":"layout","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.5 Layout","text":"Ajuste o layout seu painel (dashboard) das seguintes maneiras:Adicione páginas, colunas / linhas e gráficos com títulos R Markdown (por exemplo, #, ## ou ###)Ajuste o parâmetro YAML orientation: para rows oucolumnsEspecifique se o layout preenche o navegador ou permite rolagemAdicionar guias um título de seção específico","code":""},{"path":"flexdashboard.html","id":"imagens-1","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.5.1 Imagens","text":"Os títulos de primeiro nível (#) R Markdown representarão “páginas” painel. Por padrão, páginas aparecerão em uma barra de navegação na parte superior painel.Você pode agrupar páginas em um “menu” na barra de navegação superior adicionando o atributo {data-navmenu =} ao título da página. Tenha cuidado - não inclua espaços ao redor sinal de igual, caso contrário, não funcionará!Aqui está o que o script produz:Você também pode converter uma página ou coluna em uma “barra lateral” lado esquerdo painel, adicionando o atributo {.sidebar}. Ele pode conter texto (visualizável em qualquer página) ou, se você tiver uma interatividade shiny integrada, pode ser útil manter os controles de entrada usuário, como controles deslizantes ou menus suspensos.Aqui está o que o script produz:","code":""},{"path":"flexdashboard.html","id":"orientação","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Orientação","text":"Defina o parâmetro orientation: yaml para indicar como os cabeçalhos R Markdown de segundo nível (##) devem ser interpretados - como orientation: columns ou orientação: rows.Títulos de segundo nível (##) serão interpretados como novas colunas ou linhas com base nesta configuração de orientation.Se você definir orientation: columns, os cabeçalhos de segundo nível criarão novas colunas painel. O painel abaixo possui uma página, contendo duas colunas, com um total de três painéis. Você pode ajustar largura relativa das colunas com {data-width =} conforme mostrado abaixo.Aqui está o que o script produz:Se você definir orientation: rows, os cabeçalhos de segundo nível criarão novas linhas em vez de colunas. Abaixo está o mesmo script acima, mas com orientation: rows para que os títulos de segundo nível produzam linhas em vez de colunas. Você pode ajustar altura relativa das linhas com {data-height =} conforme mostrado abaixo.Aqui está o que o script produz:Se o seu painel tiver várias páginas, você pode designar orientação de cada página específica adicionando o atributo {data -idance =} ao cabeçalho de cada página (especifique rows oucolumns sem aspas).","code":""},{"path":"flexdashboard.html","id":"tabs","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Tabs","text":"Você pode dividir o conteúdo em guias com o atributo {.tabset}, como em outras saídas HTML R Markdown.Basta adicionar este atributo após o título desejado. Os subtítulos sob esse título serão exibidos como guias. Por exemplo, script de exemplo abaixo da coluna 2 à direita (##) é modificado para que curva epidêmica e os painéis da tabela (###) sejam exibidos em guias.Você pode fazer o mesmo com linhas se sua orientação linhas.Aqui está o que o script produz:","code":""},{"path":"flexdashboard.html","id":"adicionando-conteúdo","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.6 Adicionando conteúdo","text":"Vamos começar construir um painel (dashboard). Nosso painel simples terá 1 página, 2 colunas e 4 painéis. Vamos construir os painéis peça por peça para demonstração.Você pode incluir facilmente saídas R padrão, como texto, ggplots e tabelas (consulte página Tabelas para apresentação). Simplesmente codifique-os dentro de um fragmento de código R, como faria para qualquer outro script R Markdown.Observação: você pode baixar o script Rmd finalizado e saída painel HTML - consulte página Baixar manual e dados.","code":""},{"path":"flexdashboard.html","id":"texto-1","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Texto","text":"Você pode digitar o texto Markdown e incluir o código -line como para qualquer outra saída R Markdown. Consulte página Relatórios com R Markdown para obter detalhes.Neste painel (dashboard), incluímos um painel de texto de resumo que inclui um texto dinâmico mostrando última data de hospitalização e o número de casos relatados surto.","code":""},{"path":"flexdashboard.html","id":"tabelas-2","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Tabelas","text":"Você pode incluir blocos de código R que imprimem saídas, como tabelas. Mas saída terá uma aparência melhor e responderá ao tamanho da janela se você usar função kable() knitr para exibir suas tabelas. funções flextable podem produzir tabelas que são reduzidas / cortadas.Por exemplo, abaixo, alimentamos linelist() por meio de um comando count() para produzir uma tabela de resumo de casos por hospital. Por fim, tabela é direcionada para knitr :: kable() e o resultado tem uma barra de rolagem à direita. Você pode ler mais sobre como personalizar sua tabela com kable() e kableExtra [aqui] (https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html).Aqui está o que o script produz:Se você deseja mostrar uma tabela dinâmica que permite ao usuário filtrar, classificar e / ou clicar nas “páginas” quadro de dados, use o pacote DT e sua função datatable(), como código abaixo.O código de exemplo abaixo, linelist quadro de dados é impressa. Você pode definir rownames = FALSE para conservar espaço horizontal efilter = \"top\"para ter filtros topo de cada coluna. Uma lista de outras especificações pode ser fornecida para options =. Abaixo, definimos pageLength = para que 5 linhas apareçam e scrollX = para que o usuário possa usar uma barra de rolagem na parte inferior para rolar horizontalmente. O argumento class = 'white-space: nowrap' garante que cada linha seja uma linha (não várias linhas). Você pode ler sobre outros argumentos e valores possíveis aqui ou inserindo ?Datatable","code":"\nDT :: datatable(linelist, \n              rownames = FALSE,\n              options = list(pageLength = 5, scrollX = TRUE),\n              class = 'white-space: nowrap' )"},{"path":"flexdashboard.html","id":"gráficos","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Gráficos","text":"Você pode imprimir gráficos em um painel de controle como faria em um script R. Em nosso exemplo, usamos o pacote incidence2 para criar uma “epicurva” por faixa etária com dois comandos simples (consulte página Curvas epidêmicas). entanto, você pode usar ggplot() e imprimir um gráfico da mesma maneira.Aqui está o que o script produz:","code":""},{"path":"flexdashboard.html","id":"gráficos-interativos","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Gráficos interativos","text":"Você também pode passar um ggplot padrão ou outro objeto de gráfico para ggplotly() pacote plotly (consulte página Gráficos Interativos). Isso tornará seu gráfico interativo, permitirá que o leitor “amplie” e mostre o valor de cada ponto de dados (neste cenário, o número de casos por semana e faixa etária na curva).Aqui está aparência disso painel (gif). Essa funcionalidade interativa ainda funcionará mesmo se você enviar por e-mail o painel como um arquivo estático (não online em um servidor).","code":"\nage_outbreak <- incidence(linelist, date_onset, \"week\", groups = age_cat)\nplot(age_outbreak, fill = age_cat, col_pal = muted, title = \"\") %>% \n  plotly::ggplotly()"},{"path":"flexdashboard.html","id":"ferramentas-widgets-html","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Ferramentas (Widgets) HTML","text":"HTML widgets R são uma classe especial de pacotes R que permitem maior interatividade utilizando bibliotecas JavaScript. Você pode incorporá-los nas saídas R Markdown (como um flexdashboard) e nos painéis Shiny.Alguns exemplos comuns desses widgets incluem:Plotly (usado nesta página manual e na página Gráficos interativos)visNetwork (usado na página Cadeias de transmissão deste manual)  Leaflet (usado na página Noções básicas de GIS deste manual)  dygraphs (úteis para mostrar dados de séries temporais de forma interativa)  DT (datatable()) (usado para mostrar tabelas dinâmicas com filtro, classificação, etc.)Abaixo, demonstramos como adicionar uma cadeia de transmissão epidêmica que usa visNetwork ao painel. O script mostra apenas o novo código adicionado à seção “Coluna 2” script R Markdown. Você pode encontrar o código na página Cadeias de transmissão deste manual.Aqui está o que o script produz:","code":""},{"path":"flexdashboard.html","id":"organização-de-código","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.7 Organização de código","text":"Você pode optar por ter todo o código dentro script R Markdown flexdashboard. Como alternativa, para ter um script de painel mais limpo e conciso, você pode optar por chamar códigos / figuras que são hospedados ou criados em scripts R externos. Isso é descrito com mais detalhes na página Relatórios com R Markdown.","code":""},{"path":"flexdashboard.html","id":"shiny-1","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.8 Shiny","text":"integração pacote R shiny pode tornar seus painéis (dashboards) ainda mais reativos à entrada usuário. Por exemplo, você pode fazer com que o usuário selecione uma jurisdição ou um intervalo de datas e os painéis reajam à sua escolha (por exemplo, filtrar os dados exibidos). Para incorporar reatividade shiny ao flexdashboard, você só precisa fazer algumas alterações script R Markdown flexdashboard.Você pode usar shiny para produzir aplicativos / painéis sem flexdashboard também. página manual em Dashboards Shiny oferece uma visão geral dessa abordagem, incluindo instruções sobre sintaxe shiny, estrutura de arquivo de aplicativo e opções para compartilhamento / publicação (incluindo opções de servidor gratuitas). Essa sintaxe e dicas gerais também se traduzem contexto flexdashboard.Incorporar shiny em flexdashboard é, entanto, uma mudança fundamental em seu flexdashboard. Ele não produzirá mais uma saída HTML que você pode enviar por e-mail e qualquer pessoa pode abrir e visualizar. Em vez disso, será um “aplicativo”. O botão “Knit” na parte superior script será substituído por um ícone “Executar documento”, que abrirá uma instância painel interativo localmente em seu computador.Compartilhar seu painel agora exigirá que você:Envie o script Rmd para o visualizador, ele o abre em R computador e executa o aplicativo ouO aplicativo / painel é hospedado em um servidor acessível ao visualizadorPortanto, há benefícios em integrar shiny, mas também complicações. Se o compartilhamento fácil por e-mail uma prioridade e você não precisar de recursos reativos shiny, considere interatividade reduzida oferecida por ggplotly() conforme demonstrado acima.Abaixo, damos um exemplo muito simples usando o mesmo “outbreak_dashboard.Rmd” acima. documentação extensa sobre integração Shiny flexdashboard está disponível online aqui.","code":""},{"path":"flexdashboard.html","id":"configurações-1","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Configurações","text":"Habilite shiny em um flexdashboard adicionando o parâmetro YAML runtime: shiny mesmo nível de indentação queoutput:, como abaixo:Também é conveniente habilitar uma “barra lateral” para conter os widgets de entrada shiny que coletarão informações usuário. Como explicado acima, crie uma coluna e indique opção {.sidebar} para criar uma barra lateral lado esquerdo. Você pode adicionar texto e pedaços R contendo os comandos shiny entrada dentro desta coluna.Se seu aplicativo / painel está hospedado em um servidor e pode ter vários usuários simultâneos, nomeie o primeiro fragmento de código R como global. Inclua os comandos para importar / carregar seus dados neste bloco. Esse fragmento com nome especial é tratado de maneira diferente e os dados importados dentro dele são importados apenas uma vez (não continuamente) e estão disponíveis para todos os usuários. Isso melhora velocidade de inicialização aplicativo.","code":"---\ntitle: \"Painel de controle do Outbreak (demonstração Shiny)\"\noutput: \n  flexdashboard::flex_dashboard:\n    orientation: columns\n    vertical_layout: fill\nruntime: shiny\n---"},{"path":"flexdashboard.html","id":"exemplo-trabalhado","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Exemplo trabalhado","text":"Aqui, adaptamos o script flexdashboard “outbreak_dashboard.Rmd” para incluir shiny. Adicionaremos capacidade de o usuário selecionar um hospital em um menu suspenso e fazer com que curva de epidemia reflita apenas os casos desse hospital, com um título de gráfico dinâmico. Fazemos o seguinte:Adicione runtime: shiny ao YAMLRenomeie o trecho de configuração como globalCrie uma barra lateral contendo:\nCódigo para criar um vetor de nomes de hospitais exclusivos\nUm comando selectInput() (menu suspenso shiny) com escolha de nomes de hospitais. seleção é salva como hospital_choice, que pode ser referenciada código posterior comoinput$hospital_choice\nCódigo para criar um vetor de nomes de hospitais exclusivosUm comando selectInput() (menu suspenso shiny) com escolha de nomes de hospitais. seleção é salva como hospital_choice, que pode ser referenciada código posterior comoinput$hospital_choiceO código da curva epidêmica (coluna 2) está dentro de renderPlot({}), incluindo:\nUm filtro conjunto de dados restringindo coluna hospital ao valor atual de input$hospital_choice\nUm título de um gráfico dinâmico que incorpora input$hospital_choice\nUm filtro conjunto de dados restringindo coluna hospital ao valor atual de input$hospital_choiceUm título de um gráfico dinâmico que incorpora input$hospital_choiceObserve que qualquer código que faça referência um valor input$ deve estar dentro de uma função render({}) (para ser reativo).Aqui está o topo script, incluindo YAML, parte global e barra lateral:Aqui está Coluna 2, com o gráfico de epicurva reativa:E aqui está o painel:","code":""},{"path":"flexdashboard.html","id":"outros-exemplos","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"Outros exemplos","text":"Para ler um exemplo relacionado à saúde de um Shiny - flexdashboard usando interatividade shiny e o widget de mapeamento de leaflet, consulte este capítulo livro online Dados de saúde geoespaciais: Modelagem e Visualização com R-INLA e Shiny.","code":""},{"path":"flexdashboard.html","id":"compartilhamento","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.9 Compartilhamento","text":"Os painéis que não contêm elementos Shiny produzirão um arquivo HTML (.html), que pode ser enviado por e-mail (se o tamanho permitir). Isso é útil, pois você pode enviar o relatório de “painel” e não precisa configurar um servidor para hospedá-lo como um site.Se você tiver incorporado shiny, não poderá enviar uma saída por e-mail, mas pode enviar o próprio script para um usuário R ou hospedar o painel em um servidor conforme explicado acima.","code":""},{"path":"flexdashboard.html","id":"recursos-24","chapter":"40 Painéis (Dashboards) com R Markdown","heading":"40.10 Recursos","text":"Excelentes tutoriais que informaram esta página podem ser encontrados abaixo. Se você revisar isso, provavelmente dentro de uma hora poderá ter seu próprio painel.https://bookdown.org/yihui/rmarkdown/dashboards.htmlhttps://rmarkdown.rstudio.com/flexdashboard/https://rmarkdown.rstudio.com/flexdashboard/using.htmlhttps://rmarkdown.rstudio.com/flexdashboard/examples.html","code":""},{"path":"shiny-basics.html","id":"shiny-basics","chapter":"41 Painéis com Shiny","heading":"41 Painéis com Shiny","text":"Os painéis costumam ser uma ótima maneira de compartilhar resultados de análises com outras pessoas. Produzir um painel com shiny requer um conhecimento relativamente avançado da linguagem R, mas oferece uma personalização e possibilidades incríveis.<! – Uma das maiores desvantagens R é sua usabilidade para pessoas que são novas ou não têm experiência com linguagens de programação. Embora essas habilidades sejam muito valiosas, maioria das pessoas descobrirá que isso representa uma barreira para o compartilhamento de análises, especialmente em ambientes multidisciplinares. Requer algum trabalho para manter uma instalação R, e nem todos se sentirão confortáveis executando um código compartilhado, mesmo que seja bem documentado e fácil de ler. Isso é especialmente verdadeiro quando os usuários precisam alterar os parâmetros código! –>Recomenda-se que alguém que esteja aprendendo painéis com shiny tenha bom conhecimento de transformação e visualização de dados e se sinta confortável para depurar código e escrever funções. Trabalhar com painéis não é intuitivo quando você está começando e às vezes é difícil de entender, mas é uma ótima habilidade de aprender e fica muito mais fácil com prática!Esta página fornecerá uma breve visão geral de como fazer painéis com shiny e suas extensões.\nPara um método alternativo de tornar os painéis mais rápidos, fáceis, mas talvez menos personalizáveis, consulte página flextable (Painéis com R Markdown).","code":""},{"path":"shiny-basics.html","id":"preparação-33","chapter":"41 Painéis com Shiny","heading":"41.1 Preparação","text":"","code":""},{"path":"shiny-basics.html","id":"carregar-pacotes-14","chapter":"41 Painéis com Shiny","heading":"Carregar pacotes","text":"Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() R base. Veja página em Introdução ao R para mais informações sobre pacotes R.Começamos instalando o pacote R shiny:","code":"\npacman::p_load(\"shiny\")"},{"path":"shiny-basics.html","id":"importar-dados-6","chapter":"41 Painéis com Shiny","heading":"Importar dados","text":"Se você gostaria de acompanhar esta página, consulte esta seção Baixar manual e dados. Existem links para baixar os scripts R e arquivos de dados que produzem o aplicativo Shiny final.Se você tentar reconstruir o aplicativo usando esses arquivos, esteja ciente da estrutura de pastas projeto R que é criada durante demonstração (por exemplo, pastas para “dados” e para “funções”).","code":""},{"path":"shiny-basics.html","id":"a-estrutura-de-um-aplicativo-shiny","chapter":"41 Painéis com Shiny","heading":"41.2 A estrutura de um aplicativo shiny","text":"","code":""},{"path":"shiny-basics.html","id":"estruturas-de-arquivo-básicas","chapter":"41 Painéis com Shiny","heading":"Estruturas de arquivo básicas","text":"Para entender shiny, primeiro precisamos entender como funciona estrutura de arquivos de um aplicativo! Devemos fazer um novo diretório antes de começar. Na verdade, isso pode ser facilitado escolhendo Novo projeto em Rstudio e escolhendo Shiny Web Application. Isso criará estrutura básica de um aplicativo shiny para você.Ao abrir este projeto, você notará que já existe um arquivo .R chamado app.R. É essencial que tenhamos uma das duas estruturas básicas de arquivo:Um arquivo chamado app.R, ouDois arquivos, um denominado ui.R e o outro server.RNesta página, usaremos primeira abordagem de ter um arquivo chamado app.R. Aqui está um script de exemplo:Se você abrir este arquivo, você notará que dois objetos são definidos - um chamado ui e outro chamado servidor. Esses objetos devem ser definidos em todos os aplicativos shiny e são centrais para estrutura próprio aplicativo! Na verdade, única diferença entre duas estruturas de arquivo descritas acima é que na estrutura 1, ui e server são definidos em um arquivo, enquanto na estrutura 2 eles são definidos em arquivos separados. Nota: nós também podemos (e devemos se tiver um aplicativo maior) ter outros arquivos .R em nossa estrutura que podemos source() em nosso aplicativo.","code":"\n# um exemplo de app.R\n\nlibrary(shiny)\n\nui <- fluidPage(\n\n    # Título do aplicativo\n    titlePanel(\"Meu aplicativo\"),\n\n    # Barra lateral com um widget de entrada deslizante\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"input_1\")\n        ),\n\n        # Mostrar um gráfico \n        mainPanel(\n           plotOutput(\"my_plot\")\n        )\n    )\n)\n\n# Defina a lógica do servidor necessária para desenhar um histograma\nserver <- function(input, output) {\n     \n     plot_1 <- reactive({\n          plot_func(param = input_1)\n     })\n     \n    output$my_plot <- renderPlot({\n       plot_1()\n    })\n}\n\n\n# Execute o aplicativo \nshinyApp(ui = ui, server = server)"},{"path":"shiny-basics.html","id":"o-servidor-e-a-ui","chapter":"41 Painéis com Shiny","heading":"O servidor e a ui","text":"Em seguida, precisamos entender o que os objetos server e ui realmente . Simplificando, esses são dois objetos que estão interagindo entre si sempre que o usuário interage com o aplicativo shiny.O elemento UI de um aplicativo shiny é, em um nível básico, o código R que cria uma interface HTML. Isso significa tudo o que é exibido na IU de um aplicativo. Isso geralmente inclui:“Widgets” - menus suspensos, caixas de seleção, controles deslizantes etc. com os quais o usuário pode interagirPlots, tabelas, etc - saídas que são geradas com o código RAspectos de navegação de um aplicativo - guias, painéis, etc.Texto genérico, hiperlinks, etc.Elementos HTML e CSS (abordado posteriormente)O mais importante entender sobre IU é que ela recebe entradas usuário e exibe saídas servidor. Não há código ativo em execução na interface usuário qualquer momento - todas alterações vistas na interface usuário são passadas pelo servidor (mais ou menos). Portanto, temos que fazer nossos gráficos, downloads, etc servidorO servidor aplicativo shiny é onde todo o código está sendo executado assim que o aplicativo é inicializado. maneira como isso funciona é um pouco confusa. função de servidor irá efetivamente reagir à interface usuário com IU e executar pedaços de código em resposta. Se coisas mudarem servidor, elas serão repassadas para interface usuário, onde mudanças podem ser vistas. É importante ressaltar que o código servidor será executado não consecutivamente (ou é melhor pensar dessa forma). Basicamente, sempre que uma entrada da interface usuário afetar um pedaço de código servidor, ela será executada automaticamente e essa saída será produzida e exibida.Isso tudo provavelmente parece muito abstrato por agora, então teremos que mergulhar em alguns exemplos para ter uma ideia clara de como isso realmente funciona.","code":""},{"path":"shiny-basics.html","id":"antes-de-começar-a-construir-um-aplicativo","chapter":"41 Painéis com Shiny","heading":"Antes de começar a construir um aplicativo","text":"Antes de começar construir um aplicativo, é extremamente útil saber o que você deseja construir. Uma vez que sua IU será escrita em código, você não pode realmente visualizar o que está construindo, menos que esteja visando algo específico. Por esse motivo, é extremamente útil olhar muitos exemplos de aplicativos shiny para ter uma ideia que você pode fazer - ainda melhor se você puder olhar o código-fonte por trás desses aplicativos! Alguns ótimos recursos para isso são:galeria de aplicativos RstudioDepois de ter uma ideia que é possível, também é útil mapear como você quer que o seu fique - você pode fazer isso papel ou em qualquer software de desenho (PowerPoint, MS Paint etc.). É útil começar de forma simples para seu primeiro aplicativo! Também não há vergonha em usar o código que você encontra online de um bom aplicativo como modelo para o seu trabalho - é muito mais fácil que construir algo zero!","code":""},{"path":"shiny-basics.html","id":"construindo-uma-iu","chapter":"41 Painéis com Shiny","heading":"41.3 Construindo uma IU","text":"Ao construir nosso aplicativo, é mais fácil trabalhar na IU primeiro, para que possamos ver o que estamos fazendo e não correr o risco de o aplicativo falhar devido erros servidor. Como mencionado anteriormente, geralmente é bom usar um modelo ao trabalhar na IU. Existem vários layouts padrão que podem ser usados com o shiny que estão disponíveis pacote base shiny, mas é importante notar que também há várias extensões de pacote como shinydashboard. Usaremos um exemplo da base shiny para começar.Uma IU shiny é geralmente definida como uma série de funções aninhadas, na seguinte ordemUma função que define o layout geral (mais básica é fluidPage(), mas há mais disponíveis)Painéis dentro layout, como:\numa barra lateral (sidebarPanel())\num painel “principal” (mainPanel())\numa guia (tabPanel())\numa “coluna” genérica (coluna())\numa barra lateral (sidebarPanel())um painel “principal” (mainPanel())uma guia (tabPanel())uma “coluna” genérica (coluna())Ferramentas (Widgets) e saídas - podem conferir entradas para o servidor (widgets) ou saídas servidor (saídas)\nOs widgets geralmente são estilizados como xxxInput(), por exemplo selectInput ()\nsaídas são geralmente estilizadas como xxxOutput(), por exemplo plotOutput()\nOs widgets geralmente são estilizados como xxxInput(), por exemplo selectInput ()saídas são geralmente estilizadas como xxxOutput(), por exemplo plotOutput()Vale pena reafirmar que eles não podem ser visualizados facilmente de forma abstrata, então é melhor dar uma olhada em um exemplo! Vamos considerar criação de um aplicativo básico que visualiza os dados de contagem de nossas instalações para malária por distrito. Esses dados têm muitos parâmetros diferentes, então seria ótimo se o usuário final pudesse aplicar alguns filtros para ver os dados por faixa etária / distrito como achar melhor! Podemos usar um layout shiny muito simples para começar - o layout da barra lateral. Este é um layout onde os widgets são colocados em uma barra lateral à esquerda e o gráfico é colocado à direita.Vamos planejar nosso aplicativo - podemos começar com um seletor que nos permite escolher o bairro onde queremos visualizar os dados, e outro para nos permitir visualizar faixa etária que nos interessa. Nosso objetivo é usar esses filtros para mostrar uma epicurva que reflete esses parâmetros. Então, para isso, precisamos:Dois menus suspensos que nos permitem escolher o distrito que desejamos e faixa etária em que estamos interessados.Uma área onde podemos mostrar nossa epicurva resultante.Isso pode ser parecido com isto:Quando app.R é executado com o código de IU acima (sem nenhum código ativo na parte server de app.R), o layout aparece assim - observe que não haverá um gráfico se não houver servidor para renderizá-lo, mas nossas entradas estão funcionando!Esta é uma boa oportunidade para discutir como os widgets funcionam - observe que cada widget está aceitando um inputId, umlabel e uma série de outras opções que são específicas para o tipo de widget. Este inputId é extremamente importante - esses são os IDs usados para passar informações da IU para o servidor. Por esse motivo, eles devem ser exclusivos. Você deve fazer um esforço para nomeá-los de algo sensato e específico para o que estão interagindo em casos de aplicativos maiores.Você deve ler documentação cuidadosamente para obter detalhes completos sobre o que cada um desses widgets faz. Os widgets passarão tipos específicos de dados para o servidor, dependendo tipo de widget, e isso precisa ser totalmente compreendido. Por exemplo, selectInput() passará um tipo de caractere para o servidor:Se selecionarmos Spring para o primeiro widget aqui, ele passará o objeto de caractere \"Spring\" para o servidor.Se selecionarmos dois itens menu suspenso, eles aparecerão como um vetor de caracteres (por exemplo, c(\" Spring \",\" Bolo \")).Outros widgets irão passar diferentes tipos de objetos para o servidor! Por exemplo:numericInput() passará um objeto de tipo numérico para o servidorcheckboxInput() passará um objeto de tipo lógico para o servidor (TRUE ouFALSE)Também vale pena notar o vetor nomeado que usamos para os dados de idade aqui. Para muitos widgets, usar um vetor nomeado como escolhas exibirá os nomes vetor como opções de exibição, mas passará o valor selecionado vetor para o servidor. Ou seja, aqui, alguém pode selecionar “15+” menu suspenso e IU passará \"malaria_rdt_15\" para o servidor - que por acaso é o nome da coluna em que estamos interessados!Existem muitos widgets que você pode usar para fazer muitas coisas com seu aplicativo. Os widgets também permitem que você carregue arquivos em seu aplicativo e baixe saídas. Existem também algumas extensões shiny excelentes que fornecem acesso mais widgets que o básico shiny - o pacote shinyWidgets é um ótimo exemplo disso. Para ver alguns exemplos, você pode ver os seguintes links:galeria de widgets shiny de baseshinyWidgets gallery","code":"\nlibrary(shiny)\n\nui <- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = TRUE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)"},{"path":"shiny-basics.html","id":"carregando-dados-em-nosso-aplicativo","chapter":"41 Painéis com Shiny","heading":"41.4 Carregando dados em nosso aplicativo","text":"próxima etapa desenvolvimento de nosso aplicativo é colocar o servidor em funcionamento. Para fazer isso, entanto, precisamos colocar alguns dados em nosso aplicativo e descobrir todos os cálculos que faremos. Um aplicativo shiny não é simples de depurar, já que geralmente não fica claro de onde vêm os erros, então é ideal para fazer com que todo o nosso processamento de dados e código de visualização funcionem antes de começarmos fazer o próprio servidor.Portanto, como queremos fazer um aplicativo que mostra curvas epi que mudam com base na entrada usuário, devemos pensar sobre o código de que precisaríamos para executá-lo em um script R normal. Precisamos:Carregue nossos pacotesCarregue nossos dadosTransforme nossos dadosDesenvolva uma função para visualizar nossos dados com base nas entradas usuárioEsta lista é bastante direta e não deve ser muito difícil de fazer. Agora é importante pensar sobre quais partes desse processo precisam ser feitas apenas uma vez e quais partes precisam ser executadas em resposta às entradas usuário. Isso ocorre porque os aplicativos shiny geralmente executam algum código antes de serem executados, o que é executado apenas uma vez. Isso ajudará desempenho de nosso aplicativo se o máximo de nosso código puder ser movido para esta seção. Para este exemplo, só precisamos carregar nossos dados / pacotes e fazer transformações básicas uma vez, para que possamos colocar esse código fora servidor. Isso significa que única coisa de que precisaremos servidor é o código para visualizar nossos dados. Vamos desenvolver todos esses componentes em um script primeiro. entanto, como estamos visualizando nossos dados com uma função, também podemos colocar o código para função fora servidor para que nossa função esteja ambiente quando o aplicativo executado!Primeiro, vamos carregar nossos dados. Como estamos trabalhando com um novo projeto e queremos torná-lo limpo, podemos criar um novo diretório chamado data e adicionar nossos dados de malária nele. Podemos executar o código abaixo em um script de teste que excluiremos ao limpar estrutura de nosso aplicativo.Será mais fácil trabalhar com esses dados se usarmos padrões de dados organizados, então também devemos transformar em um formato de dados mais longo, em que faixa etária é uma coluna e os casos é outra coluna. Podemos fazer isso facilmente usando o que aprendemos na página Pivoteando dados.E com isso terminamos de preparar nossos dados! Isso cruza os itens 1, 2 e 3 de nossa lista de coisas desenvolver para nosso “script de teste R”. última e mais difícil tarefa será construir uma função para produzir uma epicurva baseada em parâmetros definidos pelo usuário. Como mencionado anteriormente, é altamente recomendado que qualquer pessoa que esteja aprendendo algo shiny primeiro dê uma olhada na seção sobre programação funcional (Escrevendo funções) para entender como isso funciona!Ao definir nossa função, pode ser difícil pensar sobre quais parâmetros queremos incluir. Para programação funcional com shiny, cada parâmetro relevante geralmente terá um widget associado ele, então pensar sobre isso geralmente é bem fácil! Por exemplo, em nosso aplicativo atual, queremos ser capazes de filtrar por distrito e ter um widget para isso, para que possamos adicionar um parâmetro de distrito para refletir isso. Nós não temos nenhuma funcionalidade de aplicativo para filtrar por instalação (por enquanto), portanto, não precisamos adicionar isso como um parâmetro. Vamos começar criando uma função com três parâmetros:O conjunto de dados principalO distrito de escolhaA faixa etária de escolhaNão entraremos em muitos detalhes sobre essa função, pois é relativamente simples em como funciona. Uma coisa se notar, entretanto, é que tratamos os erros retornando NULL quando, de outra forma, resultaria em um erro. Isso ocorre porque quando um servidor shiny produz um objeto NULL em vez de um objeto de gráfico, nada será mostrado na interface usuário! Isso é importante, pois, caso contrário, os erros geralmente farão com que seu aplicativo pare de funcionar.Outra coisa se notar é o uso operador %% ao avaliar entrada district. Como mencionado acima, isso pode chegar como um vetor de caracteres com vários valores, então usar %% é mais flexível que dizer, ==.Vamos testar nossa função!Com nossa função funcionando, agora temos que entender como tudo isso vai se encaixar em nosso aplicativo shiny. Mencionamos o conceito de código de inicialização antes, mas vamos ver como podemos realmente incorporar isso à estrutura de nosso aplicativo. Podemos fazer isso de duas maneiras!Coloque este código em seu arquivo app.R início script (acima da IU), ouCrie um novo arquivo diretório seu aplicativo chamado global.R e coloque o código de inicialização neste arquivo.É importante notar neste ponto que geralmente é mais fácil, especialmente com aplicativos maiores, usar segunda estrutura de arquivo, pois permite separar sua estrutura de arquivo de uma forma simples. Vamos desenvolver totalmente um script global.R agora. Pode ser assim:Fácil! Um grande recurso shiny é que ele entenderá para que servem os arquivos chamados app.R, server.R, ui.R e global.R, portanto, não há necessidade de conectá-los entre si por meio de qualquer código. Portanto, apenas por ter esse código em global.R diretório, ele será executado antes de iniciarmos nosso aplicativo!Devemos também observar que melhoraria organização de nosso aplicativo se movêssemos função de plotagem para seu próprio arquivo - isso será especialmente útil à medida que os aplicativos se tornam maiores. Para fazer isso, poderíamos criar outro diretório chamado funcs e colocar essa função em um arquivo chamado plot_epicurve.R. Poderíamos então ler essa função por meio seguinte comando em global.RObserve que você deve sempre especificar local = TRUE em aplicativos shiny, uma vez que afetará o fornecimento quando / se o aplicativo publicado em um servidor.","code":"\npacman::p_load(\"tidyverse\", \"lubridate\")\n\n# dados lidos\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %>% \n  as_tibble()\n\nprint(malaria_data)## # A tibble: 3,038 × 10\n##    location_name data_date  submitted_date Province District `malaria_rdt_0-4`\n##    <chr>         <date>     <date>         <chr>    <chr>                <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring                  11\n##  2 Facility 2    2020-08-11 2020-08-12     North    Bolo                    11\n##  3 Facility 3    2020-08-11 2020-08-12     North    Dingo                    8\n##  4 Facility 4    2020-08-11 2020-08-12     North    Bolo                    16\n##  5 Facility 5    2020-08-11 2020-08-12     North    Bolo                     9\n##  6 Facility 6    2020-08-11 2020-08-12     North    Dingo                    3\n##  7 Facility 6    2020-08-10 2020-08-12     North    Dingo                    4\n##  8 Facility 5    2020-08-10 2020-08-12     North    Bolo                    15\n##  9 Facility 5    2020-08-09 2020-08-12     North    Bolo                    11\n## 10 Facility 5    2020-08-08 2020-08-12     North    Bolo                    19\n## # ℹ 3,028 more rows\n## # ℹ 4 more variables: `malaria_rdt_5-14` <int>, malaria_rdt_15 <int>,\n## #   malaria_tot <int>, newid <int>\nmalaria_data <- malaria_data%>%\n  select (-newid)%>%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\nprint(malaria_data)## # A tibble: 12,152 × 7\n##    location_name data_date  submitted_date Province District age_group  cases_reported\n##    <chr>         <date>     <date>         <chr>    <chr>    <chr>               <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_r…             11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_r…             12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_r…             23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_t…             46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_r…             11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_r…             10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_r…              5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_t…             26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_r…              8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_r…              5\n## # ℹ 12,142 more rows\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  if (!(\"All\" %in% district)) {\n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal () +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nplot_epicurve(malaria_data, district = \"Bolo\", agegroup = \"malaria_rdt_0-4\")\n# global.R script\n\npacman::p_load(\"tidyverse\", \"lubridate\", \"shiny\")\n\n# dados lidos\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %>% \n  as_tibble()\n\n# limpe os dados e gire por mais tempo\nmalaria_data <- malaria_data%>%\n  select (-newid)%>%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\n\n# define a função de criação de um gráfico\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  # criar título do enredo\n  if (!(\"All\" %in% district)) {            \n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  # filtro para faixa etária\n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal () +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nsource(here(\"funcs\", \"plot_epicurve.R\"), local = TRUE)"},{"path":"shiny-basics.html","id":"desenvolvendo-um-servidor-de-aplicativos","chapter":"41 Painéis com Shiny","heading":"41.5 Desenvolvendo um servidor de aplicativos","text":"Agora que temos maior parte nosso código, só precisamos desenvolver nosso servidor. Esta é parte final de nosso aplicativo e provavelmente mais difícil de entender. O servidor é uma grande função R, mas é útil pensar nele como uma série de funções menores ou tarefas que o aplicativo pode executar. É importante entender que essas funções não são executadas em uma ordem linear. Há uma ordem para eles, mas não é totalmente necessário entender quando se começa com o shiny. Em um nível muito básico, essas tarefas ou funções serão ativadas quando houver uma mudança nas entradas usuário que afete, menos que o desenvolvedor tenha configurado para que se comportem de maneira diferente. Novamente, tudo isso é bastante abstrato, mas vamos primeiro examinar os três tipos básicos de objetos shinyFontes reativas - este é outro termo para entradas usuário. O servidor shiny tem acesso às saídas da IU por meio dos widgets que programamos. Cada vez que os valores para estes são alterados, isso é passado para o servidor.Fontes reativas - este é outro termo para entradas usuário. O servidor shiny tem acesso às saídas da IU por meio dos widgets que programamos. Cada vez que os valores para estes são alterados, isso é passado para o servidor.Condutores reativos - são objetos que existem apenas dentro servidor shiny. Na verdade, não precisamos deles para aplicativos simples, mas eles produzem objetos que só podem ser vistos dentro servidor e usados em outras operações. Eles geralmente dependem de fontes reativas.Condutores reativos - são objetos que existem apenas dentro servidor shiny. Na verdade, não precisamos deles para aplicativos simples, mas eles produzem objetos que só podem ser vistos dentro servidor e usados em outras operações. Eles geralmente dependem de fontes reativas.Resultados (Endpoints) - são saídas que são passadas servidor para IU. Em nosso exemplo, essa seria curva epi que estamos produzindo.Resultados (Endpoints) - são saídas que são passadas servidor para IU. Em nosso exemplo, essa seria curva epi que estamos produzindo.Com isso em mente vamos construir nosso servidor passo passo. Mostraremos nosso código de IU novamente aqui apenas para referência:partir desta IU de código, temos:Duas entradas:\nSeletor de distrito (com um inputId de select_district)\nSeletor de faixa etária (com um inputId de select_agegroup)\nSeletor de distrito (com um inputId de select_district)Seletor de faixa etária (com um inputId de select_agegroup)Uma saída:\nepicurva (com outputId de malaria_epicurve)\nepicurva (com outputId de malaria_epicurve)Conforme declarado anteriormente, esses nomes exclusivos que atribuímos às nossas entradas e saídas são cruciais. Eles devem ser exclusivos e são usados para passar informações entre interface usuário e o servidor. Em nosso servidor, acessamos nossas entradas através da sintaxe input $ inputID e saídas e passadas para interface usuário através da sintaxeoutput $ output_name Vamos dar uma olhada em um exemplo, porque novamente é difícil entender de outra forma!O servidor para um aplicativo simples como esse é bastante direto! Você notará que o servidor é uma função com três parâmetros - input, output e session - isso não é tão importante entender agora, mas é importante seguir esta configuração! Em nosso servidor, temos apenas uma tarefa - isso renderiza um gráfico com base em nossa função que criamos anteriormente e nas entradas servidor. Observe como os nomes dos objetos de entrada e saída correspondem exatamente aos da interface usuário.Para entender os fundamentos de como o servidor reage às entradas usuário, você deve observar que saída saberá (por meio pacote subjacente) quando entradas mudam e execute novamente esta função para criar um gráfico sempre que mudam. Observe que também usamos função renderPlot() aqui - esta é uma de uma família de funções específicas de classe que passam esses objetos para uma saída da interface usuário. Existem várias funções que se comportam de maneira semelhante, mas você precisa garantir que função usada corresponda à classe de objeto que você está passando para interface usuário! Por exemplo:renderText() - envia texto para interface usuáriorenderDataTable - envia uma tabela interativa para interface usuário.Lembre-se de que eles também precisam corresponder à função de saída usada na ui - então renderPlot() é pareado com plotOutput(), e renderText() é pareado com textOutput().Então, finalmente criamos um aplicativo funcional! Podemos executá-lo pressionando o botão Executar aplicativo canto superior direito da janela script Rstudio. Você deve observar que pode optar por executar seu aplicativo em seu navegador padrão (em vez de Rstudio), que refletirá com mais precisão aparência aplicativo para outros usuários.É divertido notar que console R, o aplicativo está “ouvindo”! É tal da reatividade!<! – FAZER: ADICIONE ALGO AO BAIXAR UM ARQUIVO ZIP APLICATIVO? –>","code":"\nui <- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = TRUE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\nserver <- function(input, output, session) {\n  \n  output$malaria_epicurve <- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n}"},{"path":"shiny-basics.html","id":"adicionando-mais-funcionalidades","chapter":"41 Painéis com Shiny","heading":"41.6 Adicionando mais funcionalidades","text":"Neste ponto, finalmente temos um aplicativo em execução, mas temos muito poucas funcionalidades. Até agora só vimos “ponta iceberg” que shiny pode fazer, então há muito mais para aprender! Vamos continuar construir nosso aplicativo existente, adicionando alguns recursos extras. Algumas coisas que podem ser interessantes de adicionar são:Algum texto explicativoUm botão de download para nosso gráfico - isso forneceria ao usuário uma versão de alta qualidade da imagem que está gerando aplicativoUm seletor para instalações específicasOutra página painel - isso pode mostrar uma tabela de nossos dados.Isso é muito acrescentar, mas podemos usá-lo para aprender sobre um monte de recursos shiny diferentes caminho. Há muito o que aprender sobre shiny (ele pode ficar muito avançado, mas esperamos que, assim que os usuários tiverem uma ideia melhor de como usá-lo, eles possam se sentir mais confortáveis usando fontes externas de aprendizagem também).","code":""},{"path":"shiny-basics.html","id":"adicionando-texto-estático","chapter":"41 Painéis com Shiny","heading":"Adicionando texto estático","text":"Vamos primeiro discutir adição de texto estático ao nosso aplicativo shiny. Adicionar texto ao nosso aplicativo é extremamente fácil, uma vez que você tenha um domínio básico sobre ele. Visto que o texto estático não muda aplicativo shiny (se você gostaria que ele mudasse, você pode usar funções de renderização de texto servidor!), todo o texto estático shiny é geralmente adicionado na interface usuário aplicativo. Não examinaremos isso em grandes detalhes, mas você pode adicionar vários elementos diferentes à sua interface usuário (e até mesmo alguns personalizados) fazendo interface de R com HTML e css.HTML e css são linguagens que estão explicitamente envolvidas design da interface usuário. Não precisamos entender isso muito bem, mas HTML cria objetos na IU (como uma caixa de texto ou uma tabela) e css geralmente é usado para alterar o estilo e estética desses objetos. O Shiny tem acesso uma grande variedade de HTML tags - presentes para objetos que se comportam de uma maneira específica, como cabeçalhos, parágrafos de texto, quebras de linha, tabelas, etc. Podemos usar alguns desses exemplos como este:h1() - esta é uma tag de header, que tornará o texto fechado automaticamente maior, e mudará os padrões conforme eles pertencem à face da fonte, cor etc. (dependendo tema geral seu aplicativo). Você pode acessar_menos e menor_subtítulo com h2() até h6() também. O uso se parece com:\nh1(\" meu cabeçalho - seção 1\")\nh1() - esta é uma tag de header, que tornará o texto fechado automaticamente maior, e mudará os padrões conforme eles pertencem à face da fonte, cor etc. (dependendo tema geral seu aplicativo). Você pode acessar_menos e menor_subtítulo com h2() até h6() também. O uso se parece com:h1(\" meu cabeçalho - seção 1\")p() - esta é uma tag de parágrafo, que tornará o texto fechado semelhante ao texto em um corpo de texto. Este texto será quebrado automaticamente e terá um tamanho relativamente pequeno (os rodapés podem ser menores, por exemplo). Pense nisso como o corpo texto de um documento Word. O uso se parece com:\np(\" Este é um corpo de texto maior onde estou explicando função meu aplicativo\")\np() - esta é uma tag de parágrafo, que tornará o texto fechado semelhante ao texto em um corpo de texto. Este texto será quebrado automaticamente e terá um tamanho relativamente pequeno (os rodapés podem ser menores, por exemplo). Pense nisso como o corpo texto de um documento Word. O uso se parece com:p(\" Este é um corpo de texto maior onde estou explicando função meu aplicativo\")tags$b() e tags$() - são usadas para criar tags $b() em negrito e tags$() em itálico com qualquer texto que esteja incluído!tags$b() e tags$() - são usadas para criar tags $b() em negrito e tags$() em itálico com qualquer texto que esteja incluído!tags$ul(), tags$ol() e tags$li() - são tags usadas na criação de * listas *. Todos eles são usados na sintaxe abaixo e permitem ao usuário criar uma lista ordenada (tags$ol(); ou seja, numerada) ou lista não ordenada (tags$ul(), ou seja, marcadores). tags$li() é usado para denotar itens na lista, independentemente tipo de lista usado. Por exemplo:tags$ul(), tags$ol() e tags$li() - são tags usadas na criação de * listas *. Todos eles são usados na sintaxe abaixo e permitem ao usuário criar uma lista ordenada (tags$ol(); ou seja, numerada) ou lista não ordenada (tags$ul(), ou seja, marcadores). tags$li() é usado para denotar itens na lista, independentemente tipo de lista usado. Por exemplo:br() e hr() - essas tags criam quebras de linha e linhas horizontais (com uma quebra de linha) respectivamente. Use-os para separar seções de seu aplicativo e texto! Não há necessidade de passar nenhum item para essas tags (os parênteses podem permanecer vazios).br() e hr() - essas tags criam quebras de linha e linhas horizontais (com uma quebra de linha) respectivamente. Use-os para separar seções de seu aplicativo e texto! Não há necessidade de passar nenhum item para essas tags (os parênteses podem permanecer vazios).div() - esta é uma tag genérica que pode conter qualquer coisa, e pode ser nomeada qualquer coisa. Depois de progredir com o design da interface usuário, você pode usá-los para compartimentar sua interface usuário, fornecer estilos específicos seções específicas e criar interações entre o servidor e os elementos da interface usuário. Não entraremos em detalhes, mas vale pena estar ciente deles!div() - esta é uma tag genérica que pode conter qualquer coisa, e pode ser nomeada qualquer coisa. Depois de progredir com o design da interface usuário, você pode usá-los para compartimentar sua interface usuário, fornecer estilos específicos seções específicas e criar interações entre o servidor e os elementos da interface usuário. Não entraremos em detalhes, mas vale pena estar ciente deles!Note que cada um desses objetos pode ser acessado através de tags$... ou para alguns, apenas função. Estes são efetivamente sinônimos, mas pode ajudar usar o estilo tags$... se você preferir ser mais explícito e não sobrescrever funções acidentalmente. Esta também não é, de forma alguma, uma lista exaustiva de tags disponíveis. Há uma lista completa de todas tags disponíveis em shiny aqui e ainda mais podem ser usadas inserindo HTML diretamente em sua interface usuário!Se você se sentir confiante, também pode adicionar quaisquer elementos de estilo css às suas tags HTML com o argumento style em qualquer um deles. Não entraremos em detalhes sobre como isso funciona, mas uma dica para testar mudanças estéticas em uma IU é usar o modo inspetor HTML em cromo (seu aplicativo shiny que você está executando navegador) e editar o estilo dos objetos você mesmo!Vamos adicionar algum texto ao nosso aplicativo","code":"\ntags$ol(\n  \n  tags$li(\"Item 1\"),\n  \n  tags$li(\"Item 2\"),\n  \n  tags$li(\"Item 3\")\n  \n)\nui <- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         h4 (\"Opções\"),\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = TRUE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do plot que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n    tags$ul(\n      tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n      tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n      tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n      tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n      tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n      tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n      tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n    )\n    \n  )\n)\n)"},{"path":"shiny-basics.html","id":"adicionando-um-link","chapter":"41 Painéis com Shiny","heading":"Adicionando um link","text":"Para adicionar um link para um site, use tags$() com o link e exiba o texto conforme mostrado abaixo. Para ter um parágrafo independente, coloque-o dentro de p(). Para ter apenas algumas palavras de uma frase ligada, divida frase em partes e use tags$() para parte com hiperlink. Para garantir que o link seja aberto em uma nova janela navegador, adicione target =\" _blank\" como um argumento.","code":"\ntags$a(href = \"www.epiRhandbook.com\", \"Visite nosso site!\")"},{"path":"shiny-basics.html","id":"adicionando-um-botão-de-download","chapter":"41 Painéis com Shiny","heading":"Adicionando um botão de download","text":"Vamos passar para o segundo dos três recursos. Um botão de download é algo bastante comum para adicionar um aplicativo e é bastante fácil de fazer. Precisamos adicionar outro widget à nossa interface usuário e precisamos adicionar outra saída ao nosso servidor para anexar ele. Também podemos introduzir condutores reativos neste exemplo!Vamos atualizar nossa interface usuário primeiro - isso é fácil, pois o shiny vem com um widget chamado downloadButton() - vamos dar ele um inputId e um rótulo.Observe que também adicionamos uma tag hr() - isso adiciona uma linha horizontal separando nossos widgets de controle de nossos widgets de download. Esta é outra das tags HTML que discutimos anteriormente.Agora que temos nossa interface usuário pronta, precisamos adicionar o componente servidor. Os downloads são feitos servidor com função downloadHandler(). Semelhante ao nosso gráfico, precisamos anexá-lo uma saída que tenha o mesmo inputId botão de download. Esta função leva dois argumentos - nome arquivo e conteúdo - ambos são funções. Como você pode adivinhar, filename é usado para especificar o nome arquivo baixado, e content é usado para especificar o que deve ser baixado. content contém uma função que você usaria para salvar dados localmente - então se você estivesse baixando um arquivo csv você poderia usar rio :: export(). Já que estamos baixando um gráfico, usaremos ggplot2 :: ggsave(). Vamos ver como o programamos (não o adicionaremos ao servidor ainda).Observe que função content sempre recebe um argumento file, que colocamos onde o nome arquivo de saída é especificado. Você também pode notar que estamos repetindo código aqui - estamos usando nossa função plot_epicurve() duas vezes neste servidor, uma para o download e uma vez para imagem exibida aplicativo. Embora isso não afete maciçamente o desempenho, isso significa que o código para gerar este gráfico terá que ser executado quando o usuário alterar os widgets especificando o distrito e faixa etária, e novamente quando você quiser fazer o download gráfico. Em aplicativos maiores, decisões subótimas como esta irão desacelerar coisas cada vez mais, então é bom aprender como tornar nosso aplicativo mais eficiente neste sentido. O que faria mais sentido é se tivéssemos uma maneira de executar o código epicurva quando os distritos / grupos de idade são alterados, e permitir que isso seja usado pelas funções renderPlot() e downloadHandler(). É aqui que entram os condutores reativos!Condutores reativos são objetos que são criados servidor shiny de uma forma reativa, mas não são emitidos - eles podem apenas ser usados por outras partes servidor. Existem vários tipos diferentes de condutores reativos, mas examinaremos os dois básicos.1.reactive()- este é o condutor reativo mais básico - ele reagirá sempre que qualquer entrada usada dentro dele mudar (então nossos widgets de distrito / faixa etária)\n2. eventReactive() - este condutor reativo funciona da mesma forma que reactive(), exceto que o usuário pode especificar quais entradas fazem com que ele seja executado novamente. Isso é útil se o seu condutor reativo demorar muito para processar, mas isso será explicado mais tarde.Vejamos os dois exemplos:Quando usamos configuração eventReactive(), podemos especificar quais entradas fazem com que esse pedaço de código seja executado - isso não é muito útil para nós momento, então podemos deixar por enquanto. Observe que você pode incluir várias entradas com c()Vamos ver como podemos integrar isso em nosso código de servidor:Você pode ver que estamos apenas chamando saída de nosso reativo, que definimos em ambas funções de download e de renderização de gráficos. Uma coisa notar, e que muitas vezes confunde pessoas, é que você precisa usar os resultados dos reativos como se fossem funções - então você deve adicionar parênteses vazios final deles (ou seja, malaria_plot() está correto, e malaria_plot não está). Agora que adicionamos essa solução, nosso aplicativo está um pouco mais arrumado, mais rápido e mais fácil de alterar, pois todo o nosso código que executa função da epicurva está em um só lugar.","code":"\nui <- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # linha horizontal\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Baixar plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do plot que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n        tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n        tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n        tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n        tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n        tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n        tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n      )\n      \n    )\n    \n  )\n)\nserver <- function(input, output, session) {\n  \n  output$malaria_epicurve <- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n  output $ download_epicurve <- downloadHandler (\n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\nmalaria_plot_r <- reactive({\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\n\n# só funciona quando o seletor de distrito muda!\nmalaria_plot_er <- eventReactive(input$select_district, {\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  })\n  \n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output $ download_epicurve <- downloadHandler (\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}"},{"path":"shiny-basics.html","id":"adicionando-um-seletor-de-instalação","chapter":"41 Painéis com Shiny","heading":"Adicionando um seletor de instalação","text":"Vamos passar para o nosso próximo recurso - um seletor para instalações específicas. Implementaremos outro parâmetro em nossa função para que possamos informar isso como um argumento de nosso código. Vamos ver como fazer isso primeiro - ele apenas opera com os mesmos princípios que os outros parâmetros que já configuramos. Vamos atualizar e testar nossa função.Vamos testar:Com todas instalações em nossos dados, não está muito claro quais instalações correspondem quais distritos - e o usuário final também não saberá. Isso pode tornar o uso aplicativo pouco intuitivo. Por esse motivo, devemos fazer com que opções de instalação na IU mudem dinamicamente à medida que o usuário muda o distrito - para que uma filtre outra! Uma vez que temos tantas variáveis que estamos usando nas opções, também podemos querer gerar algumas de nossas opções para interface usuário em nosso arquivo global.R _ partir dos dados_. Por exemplo, podemos adicionar este fragmento de código global.R depois de lermos nossos dados em:Vamos dar uma olhada neles:Podemos passar essas novas variáveis para interface usuário sem nenhum problema, pois elas são visíveis globalmente pelo servidor e pela interface usuário! Vamos atualizar nossa IU:Observe como agora estamos informando variáveis para nossas escolhas em vez de codificá-las permanentemente na interface usuário! Isso pode tornar nosso código mais compacto também! Por último, teremos que atualizar o servidor. Será fácil atualizar nossa função para incorporar nossa nova entrada (só temos que passá-la como um argumento para nosso novo parâmetro), mas devemos lembrar que também queremos que interface usuário seja atualizada dinamicamente quando o usuário muda o distrito selecionado. É importante entender aqui que podemos alterar os parâmetros e o comportamento dos widgets enquanto o aplicativo está em execução, mas isso precisa ser feito servidor. Precisamos entender uma nova forma de saída para o servidor para aprender como fazer isso.funções que precisamos entender como fazer isso são conhecidas como funções de observador e são semelhantes às funções reativas modo como se comportam. entanto, eles têm uma diferença fundamental:funções reativas não afetam diretamente saídas e produzem objetos que podem ser vistos em outros locais servidorAs funções observador podem afetar saídas servidor, mas fazem isso por meio de efeitos colaterais de outras funções. (Eles também podem fazer outras coisas, mas esta é sua função principal na prática)Semelhante às funções reativas, existem dois tipos de funções de observador, e eles são divididos pela mesma lógica que divide funções reativas:observe() - esta função é executada sempre que qualquer entrada usada dentro dela mudaobserveEvent() - esta função é executada quando uma entrada especificada pelo usuário mudaTambém precisamos entender funções fornecidas de forma shiny que atualizam widgets. Eles são bastante simples de executar - eles primeiro pegam o objeto sessão da função servidor (isso não precisa ser entendido por enquanto), e então o inputId da função ser alterado. Em seguida, passamos novas versões de todos os parâmetros que já são obtidos por selectInput() - eles serão atualizados automaticamente widget.Vejamos um exemplo isolado de como poderíamos usar isso em nosso servidor. Quando o usuário muda o distrito, queremos filtrar nossa tabela de instalações por distrito e atualizar opções para refletir apenas aquelas que estão disponíveis naquele distrito (e uma opção para todas instalações)E é isso! podemos adicioná-lo ao nosso servidor, e esse comportamento agora funcionará. Esta é aparência de nosso novo servidor:","code":"\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\", facility = \"All\") {\n  \n  if (!(\"All\" %in% district)) {\n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n    if(! (\"All\" %in% facility)) {\n    data <- data %>%\n      filter(location_name == facility)\n    \n    plot_title_facility <- facility\n    \n  } else {\n    \n    plot_title_facility <- \"todas as instalações\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal () +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}; {plot_title_facility}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}## `summarise()` has grouped output by 'location_name'. You can override using the\n## `.groups` argument.\nall_districts## [1] \"All\"     \"Spring\"  \"Bolo\"    \"Dingo\"   \"Barnard\"\ninstallation_list## # A tibble: 65 × 2\n##    location_name District\n##    <chr>         <chr>   \n##  1 Facility 1    Spring  \n##  2 Facility 10   Bolo    \n##  3 Facility 11   Spring  \n##  4 Facility 12   Dingo   \n##  5 Facility 13   Bolo    \n##  6 Facility 14   Dingo   \n##  7 Facility 15   Barnard \n##  8 Facility 16   Barnard \n##  9 Facility 17   Barnard \n## 10 Facility 18   Bolo    \n## # ℹ 55 more rows\nui <- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              choices = all_districts,\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # seletor para instalação\n         selectInput(\n           inputId = \"select_facility\",\n           label = \"Selecionar Instalação\",\n           choices = c(\"All\", facility_list$location_name),\n           selecionado = \"All\"\n         ),\n         \n         # linha horizontal\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Baixar plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do gráfico que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n        tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n        tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n        tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n        tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n        tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n        tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n      )\n      \n    )\n    \n  )\n)\nobserve({\n  \n  if (input$select_district == \"All\") {\n    new_choices <- facility_list$location_name\n  } else {\n    new_choices <- facility_list%>%\n      filter(District == input$select_district) %>%\n      pull(location_name)\n  }\n  \n  new_choices <- c(\"All\", new_choices)\n  \n  updateSelectInput(session, inputId = \"select_facility\",\n                    choices = new_choices)\n  \n})\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices <- facility_list$location_name\n    } else {\n      new_choices <- facility_list%>%\n        filter(District == input$select_district) %>%\n        pull(location_name)\n    }\n    \n    new_choices <- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output $ download_epicurve <- downloadHandler (\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  \n}"},{"path":"shiny-basics.html","id":"adicionando-outra-guia-com-uma-tabela","chapter":"41 Painéis com Shiny","heading":"Adicionando outra guia com uma tabela","text":"Agora vamos passar para o último componente que queremos adicionar ao nosso aplicativo. Queremos separar nossa interface usuário em duas guias, uma das quais terá uma tabela interativa onde o usuário pode ver os dados com os quais está fazendo curva epidêmica. Para fazer isso, podemos usar os elementos da interface usuário, que já vêm pacote shiny, que relevantes para elaboração de guias. Em um nível básico, podemos incluir maior parte de nosso painel principal nesta estrutura geral:Vamos aplicar isso à nossa interface usuário. Também queremos usar o pacote DT aqui - este é um ótimo pacote para fazer tabelas interativas partir de dados pré-existentes. Podemos ver que está sendo usado para DT :: datatableOutput() neste exemplo.Agora nosso aplicativo está organizado em guias! Vamos fazer edições necessárias servidor também. Como não precisamos manipular nosso conjunto de dados antes de renderizá-lo, isso é na verdade muito simples - apenas renderizamos o conjunto de dados malaria_data via DT :: renderDT() para interface usuário!","code":"\n# ... o resto da interface do usuário\n\nmainPanel(\n  \n  tabsetPanel(\n    type = \"tabs\",\n    tabPanel(\n      \"Curvas epidêmicas\",\n      ...\n    ),\n    tabPanel(\n      \"Dados\",\n      ...\n    )\n  )\n)\nui <- fluidPage(\n     \n     titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n     \n     sidebarLayout(\n          \n          sidebarPanel(\n               # seletor para distrito\n               selectInput(\n                    inputId = \"select_district\",\n                    label = \"Selecionar distrito\",\n                    choices = all_districts,\n                    selecionado = \"Tudo\",\n                    múltiplo = FALSE\n               ),\n               # seletor para faixa etária\n               selectInput(\n                    inputId = \"select_agegroup\",\n                    label = \"Selecionar faixa etária\",\n                    escolhas = c(\n                         \"Todas as idades\" = \"malaria_tot\",\n                         \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                         \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                         \"15+ yrs\" = \"malaria_rdt_15\"\n                    ),\n                    selecionado = \"Tudo\",\n                    múltiplo = FALSE\n               ),\n               # seletor para instalação\n               selectInput(\n                    inputId = \"select_facility\",\n                    label = \"Selecionar Instalação\",\n                    choices = c(\"All\", facility_list$location_name),\n                    selecionado = \"All\"\n               ),\n               \n               # linha horizontal\n               hr(),\n               downloadButton(\n                    outputId = \"download_epicurve\",\n                    label = \"Baixar plot\"\n               )\n               \n          ),\n          \n          mainPanel(\n               tabsetPanel(\n                    type = \"tabs\",\n                    tabPanel(\n                         \"Curvas epidêmicas\",\n                         plotOutput(\"malaria_epicurve\")\n                    ),\n                    tabPanel(\n                         \"Dados\",\n                         DT::dataTableOutput(\"raw_data\")\n                    )\n               ),\n               br(),\n               hr(),\n               p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do gráfico que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n               tags$ul(\n                    tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n                    tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n                    tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n                    tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n                    tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n                    tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n                    tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n               )\n               \n               \n          )\n     )\n)\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices <- facility_list$location_name\n    } else {\n      new_choices <- facility_list%>%\n        filter(District == input$select_district) %>%\n        pull(location_name)\n    }\n    \n    new_choices <- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output $ download_epicurve <- downloadHandler (\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  # renderiza a tabela de dados para ui\n  output$raw_data <- DT::renderDT(\n    malaria_data\n  )\n  \n  \n}"},{"path":"shiny-basics.html","id":"compartilhando-aplicativos-shiny","chapter":"41 Painéis com Shiny","heading":"41.7 Compartilhando aplicativos shiny","text":"Agora que você desenvolveu seu aplicativo, provavelmente deseja compartilhá-lo com outras pessoas - afinal, essa é principal vantagem shiny! Podemos fazer isso compartilhando o código diretamente ou podemos publicá-lo em um servidor. Se compartilharmos o código, outros poderão ver o que você fez e construir sobre ele, mas isso negará uma das principais vantagens shiny - pode eliminar necessidade dos usuários finais de manter uma instalação R . Por esse motivo, se você estiver compartilhando seu aplicativo com usuários que não se sentem confortáveis com R, é muito mais fácil compartilhar um aplicativo que foi publicado em um servidor.Se você preferir compartilhar o código, pode fazer um arquivo .zip aplicativo, ou melhor ainda, publicar seu aplicativo github e adicionar colaboradores. Você pode consultar seção github para obter mais informações aqui.entanto, se estamos publicando o aplicativo online, precisamos trabalhar um pouco mais. Em última análise, queremos que seu aplicativo possa ser acessado por meio de um URL da web para que outras pessoas possam ter acesso rápido e fácil ele. Infelizmente, para publicar seu aplicativo em um servidor, você precisa ter acesso um servidor para publicá-lo! Existem várias opções de hospedagem quando se trata disso:shinyapps.io: este é o lugar mais fácil para publicar aplicativos shiny, pois tem menor quantidade de trabalho de configuração necessária e tem algumas licenças gratuitas, mas limitadas.shinyapps.io: este é o lugar mais fácil para publicar aplicativos shiny, pois tem menor quantidade de trabalho de configuração necessária e tem algumas licenças gratuitas, mas limitadas.RStudio Connect: esta é uma versão muito mais poderosa de um servidor R, que pode realizar muitas operações, incluindo publicação de aplicativos shiny. entanto, é mais difícil de usar e menos recomendado para usuários iniciantes.RStudio Connect: esta é uma versão muito mais poderosa de um servidor R, que pode realizar muitas operações, incluindo publicação de aplicativos shiny. entanto, é mais difícil de usar e menos recomendado para usuários iniciantes.Para os fins deste documento, usaremos shinyapps.io, pois é mais fácil para usuários iniciantes. Você pode criar uma conta gratuita aqui para começar - também existem diferentes planos de preços para licenças de servidor, se necessário. Quanto mais usuários você espera ter, mais caro seu plano de preços terá que ser, portanto, mantenha isso em consideração. Se você está procurando criar algo para um pequeno grupo de indivíduos usar, uma licença gratuita pode ser perfeitamente adequada, mas um aplicativo voltado ao público pode precisar de mais licenças.Primeiro, devemos nos certificar de que nosso aplicativo é adequado para publicação em um servidor. Em seu aplicativo, você deve reiniciar sua sessão R e garantir que ela seja executada sem executar nenhum código extra. Isso é importante, pois um aplicativo que requer carregamento de pacote ou leitura de dados não definida código aplicativo não será executado em um servidor. Observe também que você não pode ter nenhum caminho de arquivo explícito em seu aplicativo - eles serão inválidos na configuração servidor - usar o pacote resolve este problema muito bem. Finalmente, se você estiver lendo dados de uma fonte que requer autenticação usuário, como os servidores da sua organização, isso geralmente não funcionará em um servidor. Você precisará entrar em contato com seu departamento de TI para descobrir como colocar o servidor shiny na lista de permissões aqui.inscrevendo-se em uma contaDepois de ter sua conta, você pode navegar até página de tokens em Contas. Aqui você desejará adicionar um novo token - ele será usado para implantar seu aplicativo.partir daqui, você deve observar que o url da sua conta refletirá o nome seu aplicativo - portanto, se o seu aplicativo se chamar my_app, o url será anexado como xxx.io/my_app/. Escolha o nome seu aplicativo com sabedoria! Agora que você está pronto, clique em implantar - se bem-sucedido, seu aplicativo será executado url da web que você escolheu!algo sobre como fazer aplicativos em documentos?","code":""},{"path":"shiny-basics.html","id":"leitura-adicional","chapter":"41 Painéis com Shiny","heading":"41.8 Leitura adicional","text":"Até agora, cobrimos muitos aspectos shiny e mal arranhamos superfície que é oferecido ele. Embora este guia sirva como uma introdução, há muito mais coisas para aprender para entender completamente o shiny. Você deve começar fazer aplicativos e adicionar gradualmente mais e mais funcionalidades","code":""},{"path":"shiny-basics.html","id":"pacotes-de-extensão-recomendados","chapter":"41 Painéis com Shiny","heading":"41.9 Pacotes de extensão recomendados","text":"O que segue representa uma seleção de extensões shiny de alta qualidade que podem ajudá-lo obter muito mais brilho (trocadilho com o nome shiny que em inglês significa “brilhante”). Em nenhuma ordem particular:BrightWidgets - este pacote oferece muitos, muitos mais widgets que podem ser usados em seu aplicativo. Execute shinyWidgets::shinyWidgetsGallery() para ver uma seleção de widgets disponíveis com este pacote. Veja exemplos aquiBrightWidgets - este pacote oferece muitos, muitos mais widgets que podem ser usados em seu aplicativo. Execute shinyWidgets::shinyWidgetsGallery() para ver uma seleção de widgets disponíveis com este pacote. Veja exemplos aquiBrightjs - este é um excelente pacote que dá ao usuário habilidade de estender muito utilidade shiny por meio de uma série de javascript. Os aplicativos deste pacote variam de muito simples altamente avançado, mas você pode querer usá-lo primeiro para manipular interface usuário de maneiras simples, como ocultar / mostrar elementos ou habilitar / desabilitar botões. Saiba mais aquiBrightjs - este é um excelente pacote que dá ao usuário habilidade de estender muito utilidade shiny por meio de uma série de javascript. Os aplicativos deste pacote variam de muito simples altamente avançado, mas você pode querer usá-lo primeiro para manipular interface usuário de maneiras simples, como ocultar / mostrar elementos ou habilitar / desabilitar botões. Saiba mais aquiBrightdashboard - este pacote expande enormemente interface usuário disponível que pode ser usada em shiny, permitindo especificamente que o usuário crie um painel complexo com uma variedade de layouts complexos. Veja mais aquiBrightdashboard - este pacote expande enormemente interface usuário disponível que pode ser usada em shiny, permitindo especificamente que o usuário crie um painel complexo com uma variedade de layouts complexos. Veja mais aquiBrightdashboardPlus - obtenha ainda mais recursos da estrutura Brightdashboard! Veja mais aquiBrightdashboardPlus - obtenha ainda mais recursos da estrutura Brightdashboard! Veja mais aquiBrightthemes - mude o tema CSS padrão para seu aplicativo shiny com uma ampla gama de modelos predefinidos! Veja mais aquiBrightthemes - mude o tema CSS padrão para seu aplicativo shiny com uma ampla gama de modelos predefinidos! Veja mais aquiExistem também vários pacotes que podem ser usados para criar saídas interativas compatíveis com o shiny.DT é semi-incorporado em base shiny, mas fornece um grande conjunto de funções para criar tabelas interativas.DT é semi-incorporado em base shiny, mas fornece um grande conjunto de funções para criar tabelas interativas.plotly é um pacote para criação de gráficos interativos que o usuário pode manipular aplicativo. Você também pode converter seu gráfico para versões interativas via plotly::ggplotly()! Como alternativas, dygraphs e highcharter também são excelentes.plotly é um pacote para criação de gráficos interativos que o usuário pode manipular aplicativo. Você também pode converter seu gráfico para versões interativas via plotly::ggplotly()! Como alternativas, dygraphs e highcharter também são excelentes.","code":""},{"path":"shiny-basics.html","id":"recursos-recomendados","chapter":"41 Painéis com Shiny","heading":"41.10 Recursos recomendados","text":"","code":""},{"path":"writing-functions.html","id":"writing-functions","chapter":"42 Escrevendo funções","heading":"42 Escrevendo funções","text":"","code":""},{"path":"writing-functions.html","id":"preparação-34","chapter":"42 Escrevendo funções","heading":"42.1 Preparação","text":"","code":""},{"path":"writing-functions.html","id":"carregar-pacotes-15","chapter":"42 Escrevendo funções","heading":"Carregar pacotes","text":"Este “chuk” (pedaço) de código mostra o carregamento de pacotes necessários para análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote, se necessário, e carrega ele para ser utilizado. Você também pode carregar pacotes instalados com library() R base. Veja em Introdução ao R para mais informações sobre pacotes R.","code":""},{"path":"writing-functions.html","id":"importar-dados-7","chapter":"42 Escrevendo funções","heading":"Importar dados","text":"Importamos os dados de casos de uma simulação de epidemia de Ebola. Se desejar fazer o download dos dados para seguir passo passo, veja instruções na página Baixar livro e dados. O conjunto de dados é importado usando função import () pacote rio. Consulte página Importar e exportar para várias maneiras de importar dados.Também usaremos na última parte desta página alguns dados sobre gripe H7N9 de 2013.","code":""},{"path":"writing-functions.html","id":"funções-1","chapter":"42 Escrevendo funções","heading":"42.2 Funções","text":"funções são úteis na programação, pois permitem tornar os códigos mais fáceis de entender, de alguma forma mais curtos e menos sujeitos erros (dado que não haja erros na própria função).Se você chegou até aqui neste manual, significa que encontrou inúmeras funções, uma vez que R toda operação é uma chamada de função +, , , [, $, { …. Por exemplo x + y é o mesmo que '+'(x, y)R é uma das linguagens que oferece maior possibilidade de trabalhar com funções e dar ferramentas suficientes para que o usuário escreva facilmente. Não devemos pensar nas funções como fixas topo ou final da cadeia de programação, o R oferece possibilidade de usá-las como se fossem vetores e até mesmo dentro de outras funções, listas …Existem muitos recursos muito avançados sobre programação de funções e só daremos aqui uma visão para ajudá-lo começar com breves exemplos práticos. Em seguida, você é incentivado visitar os links de referências para ler mais sobre o assunto.","code":""},{"path":"writing-functions.html","id":"por-que-você-usaria-uma-função","chapter":"42 Escrevendo funções","heading":"42.3 Por que você usaria uma função?","text":"Antes de responder esta pergunta, é importante observar que você já recebeu dicas para escrever suas primeiras funções R na página Iteração, loops e listas deste manual. Na verdade, o uso de “/ else” e loops costuma ser uma parte central de muitas de nossas funções, pois ajudam ampliar aplicação nosso código, permitindo várias condições, ou iterar códigos para tarefas repetidas.Estou repetindo várias vezes o mesmo bloco de código para aplicá-lo uma variável ou dado diferente?Estou repetindo várias vezes o mesmo bloco de código para aplicá-lo uma variável ou dado diferente?Livrar-se dele irá encurtar substancialmente meu código e torná-lo executado mais rápido?Livrar-se dele irá encurtar substancialmente meu código e torná-lo executado mais rápido?É possível que o código que escrevi seja usado novamente, mas com um valor diferente em muitos lugares código?É possível que o código que escrevi seja usado novamente, mas com um valor diferente em muitos lugares código?Se resposta uma das perguntas anteriores “SIM”, provavelmente você precisará escrever uma função","code":""},{"path":"writing-functions.html","id":"como-o-r-cria-funções","chapter":"42 Escrevendo funções","heading":"42.4 Como o R cria funções?","text":"funções em R têm três componentes principais:formals (), que é lista de argumentos que controla como podemos rodar funçãoformals (), que é lista de argumentos que controla como podemos rodar funçãobody (), que é o código dentro da função, ou seja, entre colchetes ou após o parêntese, dependendo de como o escrevemosbody (), que é o código dentro da função, ou seja, entre colchetes ou após o parêntese, dependendo de como o escrevemose,environment () que ajudará localizar variáveis da função e determina como função encontra o valor.Depois de criar sua função, você pode verificar cada um desses componentes chamando função associada.","code":""},{"path":"writing-functions.html","id":"sintaxe-e-estrutura-básicas","chapter":"42 Escrevendo funções","heading":"42.5 Sintaxe e estrutura básicas","text":"Uma função precisará ser nomeada corretamente para que sua tarefa seja facilmente compreensível assim que lermos seu nome. Na verdade, este já é o caso com maioria da arquitetura R base. Funções como mean (), print (), summary () têm nomes que são muito diretosUma função precisará ser nomeada corretamente para que sua tarefa seja facilmente compreensível assim que lermos seu nome. Na verdade, este já é o caso com maioria da arquitetura R base. Funções como mean (), print (), summary () têm nomes que são muito diretosUma função precisará de argumentos, como os dados nos quais trabalhar e outros objetos que podem ser valores estáticos entre outras opçõesUma função precisará de argumentos, como os dados nos quais trabalhar e outros objetos que podem ser valores estáticos entre outras opçõesE, finalmente, uma função fornecerá uma saída com base em sua tarefa principal e nos argumentos fornecidos. Normalmente usaremos funções embutidas como print (), return () … para produzir saída. saída pode ser um valor lógico, um número, um caractere, um quadro de dados … em suma, qualquer tipo de objeto R.E, finalmente, uma função fornecerá uma saída com base em sua tarefa principal e nos argumentos fornecidos. Normalmente usaremos funções embutidas como print (), return () … para produzir saída. saída pode ser um valor lógico, um número, um caractere, um quadro de dados … em suma, qualquer tipo de objeto R.Basicamente, esta é composição de uma função:Podemos criar nossa primeira função que será chamada conter_covid19 ().Podemos então verificar os componentes de nossa função recém-criada.Agora vamos testar nossa função. Para rodar nossa função escrita, você usa da mesma forma que usa todas funções R, ou seja, escrevendo o nome da função e adicionando os argumentos necessários.Podemos escrever novamente o nome de cada argumento por razões de precaução. Mas o código deve funcionar mesmo sem especificá-los, uma vez que o R tem na memória o posicionamento de cada argumento. Portanto, desde que você coloque os valores dos argumentos na ordem correta, você pode pular escrita dos nomes dos argumentos ao rodar funções.Então, vamos ver o que acontece se um dos valores \"não\" ou diferente de \"sim\".Se fornecermos um argumento que não é reconhecido, obteremos um erro:Error conter_covid19(distanciamento_social = \"às vezes\", usar_mascara = \"sim\",  :    find function \"conter_covid19\"NOTA: Algumas funções (na maioria das vezes muito curtas e diretas) podem não precisar de um nome e podem ser usadas diretamente em uma linha de código, ou dentro de outra função, para fazer tarefa rápida. Elas são chamadas de funções anônimas. Por exemplo, abaixo está uma primeira função anônima que mantém apenas variáveis de caracteres conjunto de dados.Outra função poderia selecionar o segundo registro realizado nosso conjunto de dados. Pode ser relevante quando temos dados longitudinais com muitos registros por paciente, por exemplo, após ter solicitado por data ou visita). Nesse caso, função apropriada para escrever fora dplyr seria function (x) (x %% 2 == 0) para aplicar ao vetor contendo todos os números de linha.Um possível código R base para mesma tarefa seria:CUIDADO: Se por um lado é verdade que o uso de funções pode nos ajudar com nosso código, também pode ser demorado escrever ou mesmo consertá-las se não tiver sido pensada completamente, escrita de forma adequada ou estiver retornando erros como resultado. Por esse motivo, geralmente é recomendado escrever primeiro o código R, certificar-se de que ele faz o que pretendemos fazer e, em seguida, transformá-lo em uma função com seus três componentes principais, conforme listado acima. ","code":"\nnome_da_funcao <- function(argumento_1, argumento_2, argumento_3){\n  \n           function_task\n  \n           return(output)\n}\nconter_covid19 <- function(distanciamento_social, usar_mascara, vacinacao){\n  \n                            if(distanciamento_social == \"sim\" & usar_mascara == \"sim\" & vacinacao == \"sim\" ) \n       \n                            return(\"successo\")\n  \n  else(\"Certifique-se de que todos sejam 'sim', esta pandemia tem que acabar!\")\n}\nformals(conter_covid19)## $distanciamento_social\n## \n## \n## $usar_mascara\n## \n## \n## $vacinacao\nbody(conter_covid19)## {\n##     if (distanciamento_social == \"sim\" & usar_mascara == \"sim\" & \n##         vacinacao == \"sim\") \n##         return(\"successo\")\n##     else (\"Certifique-se de que todos sejam 'sim', esta pandemia tem que acabar!\")\n## }\nenvironment(conter_covid19)## <environment: R_GlobalEnv>\nconter_covid19(distanciamento_social = \"sim\", usar_mascara = \"sim\", vacinacao = \"sim\")## [1] \"successo\"\nconter_covid19(\"sim\", \"sim\", \"sim\")## [1] \"successo\"\nconter_covid19(distanciamento_social = \"sim\", usar_mascara = \"sim\", vacinacao = \"não\")## [1] \"Certifique-se de que todos sejam 'sim', esta pandemia tem que acabar!\"\nconter_covid19(distanciamento_social = \"às vezes\", usar_mascara = \"sim\", vacinacao = \"não\")\nlinelist %>% \n  dplyr::slice_head(n=10) %>%  # Equivalente à função \"head\" do R base, que retorna as primeiras n observações do conjunto de dados\n    select(function(x) is.character(x)) \nlinelist %>%   \n   slice_head(n=20) %>% \n   tibble::rownames_to_column() %>% # Adiciona índices de cada registro como rownames para ver claramente a seleção final\n   filter(row_number() %%2 == 0)\nlinelist_firstobs <- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]"},{"path":"writing-functions.html","id":"exemplos-2","chapter":"42 Escrevendo funções","heading":"42.6 Exemplos","text":"","code":""},{"path":"writing-functions.html","id":"retorna-tabelas-de-proporção-para-várias-colunas","chapter":"42 Escrevendo funções","heading":"Retorna tabelas de proporção para várias colunas","text":"Sim, já temos funções interessantes em muitos pacotes, permitindo resumir informações de uma forma muito fácil e agradável. Mas ainda vamos tentar fazer o nosso próprio, em nossos primeiros passos para nos acostumarmos escrever funções.Neste exemplo, queremos mostrar como escrever uma função simples evitaria que você copiasse e colasse o mesmo código várias vezes.DICA: Como mostrado acima, é muito importante comentar suas funções como você faria para programação geral. Lembre-se de que o objetivo de uma função é deixar um código pronto para ser lido, mais curto e mais eficiente. Então, deve-se ser capaz de entender o que função faz apenas lendo seu nome e encontrar mais detalhes lendo os comentários.Uma segunda opção é usar função dentro de outra, por meio de um loop para fazer o processo de uma vez:Uma maneira mais simples poderia ser usar o “apply” R base em vez de um “loop”, conforme abaixo:DICA: R é frequentemente definido como uma linguagem de programação funcional e quase sempre que você executa uma linha de código, está usando algumas funções integradas. Um bom hábito para ficar mais confortável com funções de escrita é frequentemente dar uma olhada interna em como funções básicas que você usa diariamente são criadas. O atalho para isso é selecionar o nome da função e clicar emCtrl+F2 ou fn+F2 ou Cmd+F2 (dependendo seu computador) .","code":"\nproptab_multiple <- function(my_data, var_to_tab){\n  \n  # Grava o nome de cada variável de interesse antes de fazer a tabulação\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( # Vincula os resultados das duas funções seguintes por linha\n        # Tabula a variável de interesse: fornece apenas números\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          # Calcula as proporções para cada variável de interesse e arredonda o resultado para 2 decimais\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")## [1] \"gender\"##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\nproptab_multiple(linelist, \"age_cat\")## [1] \"age_cat\"##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\nproptab_multiple(linelist, \"outcome\")## [1] \"outcome\"##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}## [1] \"gender\"\n##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\n## [1] \"age_cat\"\n##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n## [1] \"outcome\"\n##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44"},{"path":"writing-functions.html","id":"usando-purrr-escrevendo-funções-que-podem-ser-aplicadas-iterativamente","chapter":"42 Escrevendo funções","heading":"42.7 Usando purrr: Escrevendo funções que podem ser aplicadas iterativamente","text":"","code":""},{"path":"writing-functions.html","id":"modificar-a-classe-de-várias-colunas-em-um-conjunto-de-dados","chapter":"42 Escrevendo funções","heading":"Modificar a classe de várias colunas em um conjunto de dados","text":"Digamos que muitas variáveis tipo caractere nos dados originais da linelist precisem ser alteradas para “fator” para fins de análise e plotagem. Em vez de repetir etapa várias vezes, podemos apenas usar lapply () para fazer transformação de todas variáveis envolvidas em uma única linha de código.CUIDADO: lapply() retorna uma lista, portanto, seu uso pode exigir uma modificação adicional como última etapa.O mesmo passo pode ser feito usando função map_if () pacote purr","code":"\nlinelist_factor2 <- linelist %>%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %>%\n        glimpse()## List of 30\n##  $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n##  $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n##  $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA ...\n##  $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" ...\n##  $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" ...\n##  $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" ...\n##  $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n##  $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n##  $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n##  $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n##  $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n##  $ hospital            : Factor w/ 6 levels \"Ausente\",\"Central Hospital\",..: 4 1 6 5 3 5 1 1 1 1 ...\n##  $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n##  $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n##  $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n##  $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n##  $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n##  $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n##  $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n##  $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n##  $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n##  $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n##  $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n##  $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n##  $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ..."},{"path":"writing-functions.html","id":"produzir-gráficos-iterativamente-para-diferentes-níveis-de-uma-variável","chapter":"42 Escrevendo funções","heading":"Produzir gráficos iterativamente para diferentes níveis de uma variável","text":"Vamos produzir um gráfico de pizza para observar distribuição dos resultados dos pacientes na China durante o surto de H7N9 para cada província. Em vez de repetir o código para cada um deles, apenas aplicaremos uma função que criaremos.","code":"\n# Opções precisas para o uso do highchart\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n# Criar uma função chamada \"chart_outcome_province\" que leva como argumento o conjunto de dados e o nome da província para a qual plotar a distribuição do resultado.\n\nchart_outcome_province <- function(data_used, prov){\n  \n  tab_prov <- data_used %>% \n    filter(province == prov,\n           !is.na(outcome))%>% \n    group_by(outcome) %>% \n    count() %>%\n    adorn_totals(where = \"row\") %>% \n    adorn_percentages(denominator = \"col\", )%>%\n    mutate(\n        perc_outcome= round(n*100,2),\n        outcome=ifelse(outcome==\"Death\", \"Óbito\",  #só traduzindo para ficar com rótulos\n                       ifelse(outcome==\"Recover\",\"Recuperado\", outcome))) # em português\n \n\n  \n  \n  tab_prov %>%\n    filter(outcome != \"Total\") %>% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distribuição do desfecho em:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\nchart_outcome_province(flu_china,\"Zhejiang\")\nchart_outcome_province(flu_china,\"Jiangsu\")"},{"path":"writing-functions.html","id":"produzir-tabelas-iterativamente-para-diferentes-níveis-de-uma-variável","chapter":"42 Escrevendo funções","heading":"Produzir tabelas iterativamente para diferentes níveis de uma variável","text":"Aqui criaremos três indicadores para resumir em uma tabela e gostaríamos de produzir esta tabela para cada uma das províncias. Nossos indicadores são o atraso entre o início e internação, o percentual de recuperação e idade mediana dos casos.Indicadores para província de:ShanghaiIndicadoresEstimativaAtraso entre início e internação4.0Percentual de recuperação46.7Idade mediana dos casos67.0Indicadores para província de:JiangsuIndicadoresEstimativaAtraso entre início e internação6.0Percentual de recuperação71.4Idade mediana dos casos55.0","code":"\nindic_1 <- flu_china %>% \n  group_by(province) %>% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%\n  select(province, mean_delay_onset_hosp)  %>% \n  distinct()\n     \n\nindic_2 <-  flu_china %>% \n            filter(!is.na(outcome)) %>% \n            group_by(province, outcome) %>% \n            count() %>%\n            pivot_wider(names_from = outcome, values_from = n) %>% \n    adorn_totals(where = \"col\") %>% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%>% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 <-  flu_china %>% \n            group_by(province) %>% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %>% \n  select(province, median_age_cases)  %>% \n  distinct()## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `median_age_cases = median(as.numeric(age), na.rm = TRUE)`.\n## ℹ In group 11: `province = \"Shanghai\"`.\n## Caused by warning in `median()`:\n## ! NAs introduced by coercion\n# Junte os três conjuntos de dados de indicadores\n\ntable_indic_all <- indic_1 %>% \n  dplyr::left_join(indic_2, by = \"province\") %>% \n        left_join(indic_3, by = \"province\")\n\n\n# Imprima os indicadores em uma flextable\n\n\nprint_indic_prov <-  function(table_used, prov){\n  \n  # Primeiro, transforme um pouco o quadro de dados para facilitar a visualização\n indic_prov <- table_used %>%\n    filter(province==prov) %>%\n    pivot_longer(names_to = \"Indicadores\", cols = 2:4)%>% \n   mutate( indic_label = factor(Indicadores,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Atraso entre início e internação\", \"Percentual de recuperação\", \"Idade mediana dos casos\"))\n   ) %>% \n    ungroup(province) %>% \n    select(indic_label, value)\n  \n\n  tab_print <- flextable(indic_prov)  %>%\n    theme_vanilla() %>% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print <- tab_print %>% \n                  autofit()   %>%\n                  set_header_labels( \n                indic_label= \"Indicadores\", value= \"Estimativa\") %>%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %>%\n    flextable::bold(part = \"header\") %>%\n    flextable::color(color = \"white\", part = \"header\") %>% \n    add_header_lines(values = paste0(\"Indicadores para a província de:\", prov)) %>% \nbold(part = \"header\")\n \n tab_print <- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\nprint_indic_prov(table_indic_all, \"Jiangsu\")"},{"path":"writing-functions.html","id":"dicas-e-práticas-recomendadas-para-o-bom-funcionamento-das-funções","chapter":"42 Escrevendo funções","heading":"42.8 Dicas e práticas recomendadas para o bom funcionamento das funções","text":"programação de funções visa facilitar o código e facilitar sua leitura. Deve produzir o contrário. dicas abaixo irão ajudá-lo ter um código limpo e fácil de ler.","code":""},{"path":"writing-functions.html","id":"nomenclatura-e-sintaxe","chapter":"42 Escrevendo funções","heading":"Nomenclatura e sintaxe","text":"Evite usar caracteres que poderiam facilmente ter sido contemplados em outras funções já existentes em seu ambienteEvite usar caracteres que poderiam facilmente ter sido contemplados em outras funções já existentes em seu ambienteRecomenda-se que o nome da função seja curto e fácil de entenderRecomenda-se que o nome da função seja curto e fácil de entenderÉ preferível usar verbos como o nome da função e substantivos para os nomes dos argumentos.É preferível usar verbos como o nome da função e substantivos para os nomes dos argumentos.","code":""},{"path":"writing-functions.html","id":"nomes-de-coluna-e-avaliação-organizada","chapter":"42 Escrevendo funções","heading":"Nomes de coluna e avaliação organizada","text":"Se você quiser saber como fazer referência nomes de coluna fornecidos em seu código como argumentos, leia tidyverse programming guidance.Entre os tópicos cobertos estão avaliação arrumada (de tidy evaluation) e uso de embrace {{ }} “Colchetes duplos”Por exemplo, aqui está um esqueleto rápido de código modelo da página tutorial mencionado acima:","code":"\nvar_summary <- function(data, var) {\n  data %>%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %>% \n  group_by(cyl) %>% \n  var_summary(mpg)"},{"path":"writing-functions.html","id":"teste-e-tratamento-de-erros","chapter":"42 Escrevendo funções","heading":"Teste e tratamento de erros","text":"Quanto mais complicada tarefa de uma função, maior possibilidade de erros. Portanto, às vezes é necessário adicionar alguma verificação na função para ajudar entender rapidamente de onde vem o erro e encontrar uma maneira de corrigi-lo.Pode ser mais que recomendado introduzir uma verificação sobre falta de um argumento usando missing(argumento). Esta verificação simples pode retornar um valor “TRUE” (verdadeiro) ou “FALSE” (falso).Use stop() para mais erros detectáveis.Como vemos quando executamos maioria das funções integradas, existem mensagens e avisos que podem aparecer em certas condições. Podemos integrá-los na escrita de nossas funções usando funções message() e warning().Como vemos quando executamos maioria das funções integradas, existem mensagens e avisos que podem aparecer em certas condições. Podemos integrá-los na escrita de nossas funções usando funções message() e warning().Também podemos lidar com erros usando safely(), que pega uma função como um argumento e executa de maneira segura. Na verdade, função será executada sem parar se encontrar um erro. safely() retorna como resultado uma list com dois objetos, que são os resultados e o erro “pulado”.Também podemos lidar com erros usando safely(), que pega uma função como um argumento e executa de maneira segura. Na verdade, função será executada sem parar se encontrar um erro. safely() retorna como resultado uma list com dois objetos, que são os resultados e o erro “pulado”.Podemos verificar executando primeiro mean() como função e, em seguida, executando com secure ().Como dito anteriormente, comentar bem nossos códigos já é uma boa forma de termos documentação em nosso trabalho.","code":"\nconter_covid19_missing <- function(distanciamento_social, usar_mascara, vacinacao){\n  \n  if (missing(distanciamento_social)) (print(\"Por favor, forneça o arg1\"))\n  if (missing(usar_mascara)) print(\"Por favor, forneça o arg2\")\n  if (missing(vacinacao)) print(\"Por favor, forneça o arg3\")\n\n\n  if (!distanciamento_social == \"sim\" | usar_mascara ==\"sim\" | vacinacao == \"sim\" ) \n       \n       return (\"Você pode fazer melhor\")\n  \n  else(\"Certifique-se de que todos estejam 'sim', esta pandemia tem que acabar!\")\n}\n\n\nconter_covid19_missing(vacinacao = \"sim\")## [1] \"Por favor, forneça o arg1\"\n## [1] \"Por favor, forneça o arg2\"## Error in conter_covid19_missing(vacinacao = \"sim\"): argument \"distanciamento_social\" is missing, with no default\nconter_covid19_stop <- function(distanciamento_social, usar_mascara, vacinacao){\n  \n  if(!is.character(distanciamento_social)) (stop(\"arg1 deve ser um caractere, digite o valor com` sim`, `não` ou` às vezes\"))\n  \n  if (distanciamento_social == \"sim\" & usar_mascara ==\"sim\" & vacinacao == \"sim\" ) \n       \n       return (\"successo\")\n  \n  else(\"Certifique-se de que todos estejam 'sim', esta pandemia tem que acabar!\")\n}\n\n\nconter_covid19_stop(distanciamento_social=1, usar_mascara=\"sim\", vacinacao = \"não\")## Error in conter_covid19_stop(distanciamento_social = 1, usar_mascara = \"sim\", : arg1 deve ser um caractere, digite o valor com` sim`, `não` ou` às vezes\nmap(linelist, mean)## $case_id\n## [1] NA\n## \n## $generation\n## [1] 16.56165\n## \n## $date_infection\n## [1] NA\n## \n## $date_onset\n## [1] NA\n## \n## $date_hospitalisation\n## [1] \"2014-11-03\"\n## \n## $date_outcome\n## [1] NA\n## \n## $outcome\n## [1] NA\n## \n## $gender\n## [1] NA\n## \n## $age\n## [1] NA\n## \n## $age_unit\n## [1] NA\n## \n## $age_years\n## [1] NA\n## \n## $age_cat\n## [1] NA\n## \n## $age_cat5\n## [1] NA\n## \n## $hospital\n## [1] NA\n## \n## $lon\n## [1] -13.23381\n## \n## $lat\n## [1] 8.469638\n## \n## $infector\n## [1] NA\n## \n## $source\n## [1] NA\n## \n## $wt_kg\n## [1] 52.64487\n## \n## $ht_cm\n## [1] 124.9633\n## \n## $ct_blood\n## [1] 21.20686\n## \n## $fever\n## [1] NA\n## \n## $chills\n## [1] NA\n## \n## $cough\n## [1] NA\n## \n## $aches\n## [1] NA\n## \n## $vomit\n## [1] NA\n## \n## $temp\n## [1] NA\n## \n## $time_admission\n## [1] NA\n## \n## $bmi\n## [1] 46.89023\n## \n## $days_onset_hosp\n## [1] NA\nsafe_mean <- safely(mean)\nlinelist %>% \n  map(safe_mean)## $case_id\n## $case_id$result\n## [1] NA\n## \n## $case_id$error\n## NULL\n## \n## \n## $generation\n## $generation$result\n## [1] 16.56165\n## \n## $generation$error\n## NULL\n## \n## \n## $date_infection\n## $date_infection$result\n## [1] NA\n## \n## $date_infection$error\n## NULL\n## \n## \n## $date_onset\n## $date_onset$result\n## [1] NA\n## \n## $date_onset$error\n## NULL\n## \n## \n## $date_hospitalisation\n## $date_hospitalisation$result\n## [1] \"2014-11-03\"\n## \n## $date_hospitalisation$error\n## NULL\n## \n## \n## $date_outcome\n## $date_outcome$result\n## [1] NA\n## \n## $date_outcome$error\n## NULL\n## \n## \n## $outcome\n## $outcome$result\n## [1] NA\n## \n## $outcome$error\n## NULL\n## \n## \n## $gender\n## $gender$result\n## [1] NA\n## \n## $gender$error\n## NULL\n## \n## \n## $age\n## $age$result\n## [1] NA\n## \n## $age$error\n## NULL\n## \n## \n## $age_unit\n## $age_unit$result\n## [1] NA\n## \n## $age_unit$error\n## NULL\n## \n## \n## $age_years\n## $age_years$result\n## [1] NA\n## \n## $age_years$error\n## NULL\n## \n## \n## $age_cat\n## $age_cat$result\n## [1] NA\n## \n## $age_cat$error\n## NULL\n## \n## \n## $age_cat5\n## $age_cat5$result\n## [1] NA\n## \n## $age_cat5$error\n## NULL\n## \n## \n## $hospital\n## $hospital$result\n## [1] NA\n## \n## $hospital$error\n## NULL\n## \n## \n## $lon\n## $lon$result\n## [1] -13.23381\n## \n## $lon$error\n## NULL\n## \n## \n## $lat\n## $lat$result\n## [1] 8.469638\n## \n## $lat$error\n## NULL\n## \n## \n## $infector\n## $infector$result\n## [1] NA\n## \n## $infector$error\n## NULL\n## \n## \n## $source\n## $source$result\n## [1] NA\n## \n## $source$error\n## NULL\n## \n## \n## $wt_kg\n## $wt_kg$result\n## [1] 52.64487\n## \n## $wt_kg$error\n## NULL\n## \n## \n## $ht_cm\n## $ht_cm$result\n## [1] 124.9633\n## \n## $ht_cm$error\n## NULL\n## \n## \n## $ct_blood\n## $ct_blood$result\n## [1] 21.20686\n## \n## $ct_blood$error\n## NULL\n## \n## \n## $fever\n## $fever$result\n## [1] NA\n## \n## $fever$error\n## NULL\n## \n## \n## $chills\n## $chills$result\n## [1] NA\n## \n## $chills$error\n## NULL\n## \n## \n## $cough\n## $cough$result\n## [1] NA\n## \n## $cough$error\n## NULL\n## \n## \n## $aches\n## $aches$result\n## [1] NA\n## \n## $aches$error\n## NULL\n## \n## \n## $vomit\n## $vomit$result\n## [1] NA\n## \n## $vomit$error\n## NULL\n## \n## \n## $temp\n## $temp$result\n## [1] NA\n## \n## $temp$error\n## NULL\n## \n## \n## $time_admission\n## $time_admission$result\n## [1] NA\n## \n## $time_admission$error\n## NULL\n## \n## \n## $bmi\n## $bmi$result\n## [1] 46.89023\n## \n## $bmi$error\n## NULL\n## \n## \n## $days_onset_hosp\n## $days_onset_hosp$result\n## [1] NA\n## \n## $days_onset_hosp$error\n## NULL"},{"path":"writing-functions.html","id":"recursos-25","chapter":"42 Escrevendo funções","heading":"42.9 Recursos","text":"link para o livro R para Ciência de DadosCheatsheet (cola) em programação avançada em RCheatsheet (cola) Pacote purrVideo-ACM palesta por Hadley Wickham: alegria da programação funcional (como map_dbl funciona)","code":""},{"path":"directories.html","id":"directories","chapter":"43 Interações de diretório","heading":"43 Interações de diretório","text":"Nesta página, cobrimos cenários comuns onde você cria, interage, salva e importa com diretórios (pastas).","code":""},{"path":"directories.html","id":"preparação-35","chapter":"43 Interações de diretório","heading":"43.1 Preparação","text":"","code":""},{"path":"directories.html","id":"pacote-fs","chapter":"43 Interações de diretório","heading":"Pacote fs","text":"O fs é um pacote tidyverse que facilita interações de diretório, melhorando algumas das funções R base. Nas seções seguir, usaremos frequentemente funções fs.","code":"\npacman::p_load(\n  fs,             # Interações de arquivo / diretório\n  rio,            # Importar / Exportar\n  here,           # Caminhos de arquivo respectivos\n  tidyverse)      # Gerenciamento e visualização de dados"},{"path":"directories.html","id":"imprimir-diretório-como-uma-árvore-de-dendrograma","chapter":"43 Interações de diretório","heading":"Imprimir diretório como uma árvore de dendrograma","text":"Use função dir_tree() fs.Forneça o caminho da pasta arquivo para path = e decida se deseja mostrar apenas um nível (recurse = FALSE) ou todos os arquivos em todos os subníveis (recurse = TRUE). Abaixo, usamos () como uma abreviação para o projeto R e especificamos sua subpasta “data” (dados), que contém todos os dados usados para este manual de R. Nós o configuramos para exibir todos os arquivos na pasta supra citada e suas subpastas (por exemplo, “cache”, “epidemic models”, “population”, “shp”, “weather”).","code":"\nfs::dir_tree(path = here(\"data\"), recurse = TRUE)## C:/Users/neale/Documents/Applied Epi/repos/epirhandbook_pt/data\n## ├── africa_countries.geo.json\n## ├── cache\n## │   └── epidemic_models\n## │       ├── 2015-04-30\n## │       │   ├── estimated_reported_cases_samples.rds\n## │       │   ├── estimate_samples.rds\n## │       │   ├── latest_date.rds\n## │       │   ├── reported_cases.rds\n## │       │   ├── summarised_estimated_reported_cases.rds\n## │       │   ├── summarised_estimates.rds\n## │       │   └── summary.rds\n## │       ├── epinow_res.rds\n## │       ├── epinow_res_small.rds\n## │       ├── generation_time.rds\n## │       └── incubation_period.rds\n## ├── case_linelists\n## │   ├── cleaning_dict.csv\n## │   ├── fluH7N9_China_2013.csv\n## │   ├── linelist_cleaned.rds\n## │   ├── linelist_cleaned.xlsx\n## │   └── linelist_raw.xlsx\n## ├── country_demographics.csv\n## ├── covid_example_data\n## │   ├── covid_example_data.xlsx\n## │   └── covid_shapefile\n## │       ├── FultonCountyZipCodes.cpg\n## │       ├── FultonCountyZipCodes.dbf\n## │       ├── FultonCountyZipCodes.prj\n## │       ├── FultonCountyZipCodes.sbn\n## │       ├── FultonCountyZipCodes.sbx\n## │       ├── FultonCountyZipCodes.shp\n## │       ├── FultonCountyZipCodes.shp.xml\n## │       └── FultonCountyZipCodes.shx\n## ├── covid_incidence.csv\n## ├── covid_incidence_map.R\n## ├── district_count_data.xlsx\n## ├── example\n## │   ├── Central Hospital.csv\n## │   ├── district_weekly_count_data.xlsx\n## │   ├── fluH7N9_China_2013.csv\n## │   ├── hospital_linelists.xlsx\n## │   ├── linelists\n## │   │   ├── 20201007linelist.csv\n## │   │   ├── case_linelist20201006.csv\n## │   │   ├── case_linelist_2020-10-02.csv\n## │   │   ├── case_linelist_2020-10-03.csv\n## │   │   ├── case_linelist_2020-10-04.csv\n## │   │   ├── case_linelist_2020-10-05.csv\n## │   │   └── case_linelist_2020-10-08.xlsx\n## │   ├── Military Hospital.csv\n## │   ├── Missing.csv\n## │   ├── Other.csv\n## │   ├── Port Hospital.csv\n## │   └── St. Mark's Maternity Hospital (SMMH).csv\n## ├── facility_count_data.rds\n## ├── flexdashboard\n## │   ├── outbreak_dashboard.html\n## │   ├── outbreak_dashboard.Rmd\n## │   ├── outbreak_dashboard_shiny.Rmd\n## │   ├── outbreak_dashboard_test.html\n## │   └── outbreak_dashboard_test.Rmd\n## ├── fluH7N9_China_2013.csv\n## ├── gis\n## │   ├── africa_countries.geo.json\n## │   ├── covid_incidence.csv\n## │   ├── covid_incidence_map.R\n## │   ├── linelist_cleaned_with_adm3.rds\n## │   ├── population\n## │   │   ├── sle_admpop_adm3_2020.csv\n## │   │   └── sle_population_statistics_sierraleone_2020.xlsx\n## │   └── shp\n## │       ├── README.txt\n## │       ├── sle_adm3.CPG\n## │       ├── sle_adm3.dbf\n## │       ├── sle_adm3.prj\n## │       ├── sle_adm3.sbn\n## │       ├── sle_adm3.sbx\n## │       ├── sle_adm3.shp\n## │       ├── sle_adm3.shp.xml\n## │       ├── sle_adm3.shx\n## │       ├── sle_hf.CPG\n## │       ├── sle_hf.dbf\n## │       ├── sle_hf.prj\n## │       ├── sle_hf.sbn\n## │       ├── sle_hf.sbx\n## │       ├── sle_hf.shp\n## │       └── sle_hf.shx\n## ├── godata\n## │   ├── cases_clean.rds\n## │   ├── contacts_clean.rds\n## │   ├── followups_clean.rds\n## │   └── relationships_clean.rds\n## ├── likert_data.csv\n## ├── linelist_cleaned.rds\n## ├── linelist_cleaned.xlsx\n## ├── linelist_raw.xlsx\n## ├── make_evd_dataset-DESKTOP-JIEUMMI.R\n## ├── make_evd_dataset.R\n## ├── malaria_app\n## │   ├── app.R\n## │   ├── data\n## │   │   └── facility_count_data.rds\n## │   ├── funcs\n## │   │   └── plot_epicurve.R\n## │   ├── global.R\n## │   ├── malaria_app.Rproj\n## │   ├── server.R\n## │   └── ui.R\n## ├── malaria_facility_count_data.rds\n## ├── phylo\n## │   ├── sample_data_Shigella_tree.csv\n## │   ├── Shigella_subtree_2.nwk\n## │   ├── Shigella_subtree_2.txt\n## │   └── Shigella_tree.txt\n## ├── rmarkdown\n## │   ├── outbreak_report.docx\n## │   ├── outbreak_report.html\n## │   ├── outbreak_report.pdf\n## │   ├── outbreak_report.pptx\n## │   ├── outbreak_report.Rmd\n## │   ├── report_tabbed_example.html\n## │   └── report_tabbed_example.Rmd\n## ├── standardization\n## │   ├── country_demographics.csv\n## │   ├── country_demographics_2.csv\n## │   ├── deaths_countryA.csv\n## │   ├── deaths_countryB.csv\n## │   └── world_standard_population_by_sex.csv\n## ├── surveys\n## │   ├── population.xlsx\n## │   ├── survey_data.xlsx\n## │   └── survey_dict.xlsx\n## └── time_series\n##     ├── campylobacter_germany.xlsx\n##     └── weather\n##         ├── germany_weather2002.nc\n##         ├── germany_weather2003.nc\n##         ├── germany_weather2004.nc\n##         ├── germany_weather2005.nc\n##         ├── germany_weather2006.nc\n##         ├── germany_weather2007.nc\n##         ├── germany_weather2008.nc\n##         ├── germany_weather2009.nc\n##         ├── germany_weather2010.nc\n##         └── germany_weather2011.nc"},{"path":"directories.html","id":"listar-arquivos-em-um-diretório","chapter":"43 Interações de diretório","heading":"43.2 Listar arquivos em um diretório","text":"Para listar apenas os nomes dos arquivos em um diretório, você pode usar dir() R base. Por exemplo, este comando lista os nomes dos arquivos na subpasta “população” da pasta “dados” em um projeto R. O caminho de arquivo respectivo é fornecido usando () (sobre o qual você pode ler mais na página Importar e exportar).Para listar os caminhos completos dos arquivos diretório, você pode usar dir_ls() de fs. Uma alternativa é list.files() R base .Para obter todas informações de metadados sobre cada arquivo em um diretório (por exemplo, caminho, data de modificação, etc.), você pode usar dir_info() de fs.Isso pode ser particularmente útil se você deseja extrair hora da última modificação arquivo, por exemplo, se deseja importar versão mais recente. Para obter um exemplo disso, consulte página Importar e exportar.Aqui está o dataframe que retorna. Role para direita para ver todas colunas.","code":"\n# Nomes de arquivos\ndir(here(\"data\", \"gis\", \"population\"))## [1] \"sle_admpop_adm3_2020.csv\"                       \n## [2] \"sle_population_statistics_sierraleone_2020.xlsx\"\n# Caminhos de arquivos\ndir_ls(here(\"data\", \"gis\", \"population\"))## C:/Users/neale/Documents/Applied Epi/repos/epirhandbook_pt/data/gis/population/sle_admpop_adm3_2020.csv\n## C:/Users/neale/Documents/Applied Epi/repos/epirhandbook_pt/data/gis/population/sle_population_statistics_sierraleone_2020.xlsx\n# Informações do arquivo\ndir_info(here(\"data\", \"gis\", \"population\"))"},{"path":"directories.html","id":"informações-do-arquivo","chapter":"43 Interações de diretório","heading":"43.3 Informações do arquivo","text":"Para extrair informações de metadados sobre um arquivo específico, você pode usar file_info() de fs (ou file.info() R base).Aqui usamos o $ para indexar o resultado e retornar apenas o valor modify_time.","code":"\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))$modification_time## [1] \"2023-10-22 12:31:32 CEST\""},{"path":"directories.html","id":"verifique-se-existe","chapter":"43 Interações de diretório","heading":"43.4 Verifique se existe","text":"","code":""},{"path":"directories.html","id":"objetos-r","chapter":"43 Interações de diretório","heading":"Objetos R","text":"Você pode usar exists() R base para verificar se um objeto existe dentro R (forneça o nome objeto entre aspas).Observe que alguns pacotes R base usam nomes de objetos genéricos como “data” (que significa “dados” em inglês) nos bastidores, que aparecerão como TRUE menos que inherit = FALSE seja especificado. Este é um dos motivos para não nomear o conjunto de dados como “data”.Se você está escrevendo uma função, deve usar missing() R base para verificar se um argumento está presente ou não, ao invés de exists().","code":"\nexists(\"linelist\")## [1] TRUE\nexists(\"data\")## [1] TRUE\nexists(\"data\", inherit = FALSE)## [1] FALSE"},{"path":"directories.html","id":"diretórios","chapter":"43 Interações de diretório","heading":"Diretórios","text":"Para verificar se existe um diretório, forneça o caminho arquivo (e nome arquivo) para is_dir() de fs. Role para direita para ver que retorna TRUE.Uma alternativa é file.exists() R base.","code":"\nis_dir(here(\"data\"))## C:/Users/neale/Documents/Applied Epi/repos/epirhandbook_pt/data \n##                                                            TRUE"},{"path":"directories.html","id":"arquivos","chapter":"43 Interações de diretório","heading":"Arquivos","text":"Para verificar se um arquivo específico existe, use is_file() de fs. Role para direita para ver que retorna TRUE.Uma alternativa R base é file.exists().","code":"\nis_file(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))## C:/Users/neale/Documents/Applied Epi/repos/epirhandbook_pt/data/case_linelists/linelist_cleaned.rds \n##                                                                                                TRUE"},{"path":"directories.html","id":"criar","chapter":"43 Interações de diretório","heading":"43.5 Criar","text":"","code":""},{"path":"directories.html","id":"diretórios-1","chapter":"43 Interações de diretório","heading":"Diretórios","text":"Para criar um novo diretório (pasta), você pode usar dir_create() de fs. Se o diretório já existir, ele não será criado novamente e não será retornado nenhum erro.Uma alternativa é dir.create() R base, que mostrará um erro se o diretório já existir. Em contraste, dir_create() neste cenário será silencioso.","code":"\ndir_create(here(\"data\", \"test\"))"},{"path":"directories.html","id":"arquivos-1","chapter":"43 Interações de diretório","heading":"Arquivos","text":"Você pode criar um arquivo (vazio) com file_create() de fs. Se o arquivo já existir, ele não será criado novamente ou alterado.file.create() é uma alternativa R base. Mas se o arquivo já existe, esta opção irá truncá-lo. Se você usar file_create() o arquivo não será alterado.","code":"\nfile_create(here(\"data\", \"test.rds\"))"},{"path":"directories.html","id":"criar-se-não-existir","chapter":"43 Interações de diretório","heading":"Criar se não existir","text":"EM CONSTRUÇÃO","code":""},{"path":"directories.html","id":"deletar","chapter":"43 Interações de diretório","heading":"43.6 Deletar","text":"","code":""},{"path":"directories.html","id":"objetos-r-1","chapter":"43 Interações de diretório","heading":"Objetos R","text":"Use rm() R base para remover um objeto R.","code":""},{"path":"directories.html","id":"diretórios-2","chapter":"43 Interações de diretório","heading":"Diretórios","text":"Use dir_delete() de fs.","code":""},{"path":"directories.html","id":"arquivos-2","chapter":"43 Interações de diretório","heading":"Arquivos","text":"Você pode excluir arquivos com file_delete() de fs.","code":""},{"path":"directories.html","id":"executando-outros-arquivos","chapter":"43 Interações de diretório","heading":"43.7 Executando outros arquivos","text":"","code":""},{"path":"directories.html","id":"source","chapter":"43 Interações de diretório","heading":"source()","text":"Para executar um script R partir de outro script R, você pode usar o comando source() (R base).Isso é equivalente visualizar o script R acima e clicar botão “Source” (Fonte) canto superior direito script. Isso executará o script, mas silenciosamente (sem saída para o console R), menos que seja especificada esta intenção. Veja página [Console interativo] para exemplos de uso da source() para interagir com um usuário através console R modo pergunta e resposta.","code":"\nsource(here(\"scripts\", \"cleaning_scripts\", \"clean_testing_data.R\"))"},{"path":"directories.html","id":"render","chapter":"43 Interações de diretório","heading":"render()","text":"render() é uma variação de source() mais frequentemente usada para scripts R markdown. Você fornece o input = que é o arquivo Rmarkdown (.Rmd), e também o output_format = (normalmente “html_document”, “pdf_document”, “word_document”, ““)Consulte página Relatórios com R Markdown para obter mais detalhes. Veja também documentação para render()\naqui ou inserindo ?render.","code":""},{"path":"directories.html","id":"executar-arquivos-em-um-diretório","chapter":"43 Interações de diretório","heading":"Executar arquivos em um diretório","text":"Você pode criar um loop e usá-lo em source() para todos os arquivos em um diretório, identificado com dir().\ndir().Se você deseja apenas executar determinados scripts, pode identificá-los pelos nomes da seguinte forma:Aqui está uma comparação das funções de fs e R base.","code":"\nfor(script in dir(here(\"scripts\"), pattern = \".R$\")) {   # Para cada nome de script na pasta \"scripts\" do Projeto R (com extensão .R)\n  source(here(\"scripts\", script))                        # Fonte dos arquivos com nomes correspondentes aos encontrados na pasta de scripts\n}\nscripts_to_run <- c(\n     \"epicurves.R\",\n     \"demographic_tables.R\",\n     \"survival_curves.R\"\n)\n\nfor(script in scripts_to_run) {\n  source(here(\"scripts\", script))\n}"},{"path":"directories.html","id":"importar-arquivos-em-um-diretório","chapter":"43 Interações de diretório","heading":"Importar arquivos em um diretório","text":"Consulte página Importar e exportar para importar e exportar arquivos individuais.Consulte também página Importar e exportar para métodos que importem automaticamente o arquivo mais recente, com base em uma data nome arquivo ou nos metadados arquivo.Veja na página Iteração, loops e listas um exemplo com o pacote purrr demonstrando:Dividir um dataframe e salvá-lo como vários arquivos CSVDividir um dataframe e salvar cada parte em uma planilha separada dentro de uma pasta de trabalho ExcelImportar vários arquivos CSV e combiná-los em um dataframeImportar uma pasta de trabalho Excel com várias planilhas e combiná-las em um único dataframe","code":""},{"path":"directories.html","id":"r-base-1","chapter":"43 Interações de diretório","heading":"43.8 R base","text":"Veja abaixo funções list.files() e dir(), que realizam mesma operação de listar arquivos dentro de um diretório especificado. Você pode especificar ignore.case = ou um padrão específico para procurar.Se um arquivo estiver “aberto” momento, ele será exibido em sua pasta com um til na frente, como “~$hospital_linelists.xlsx”.","code":"\nlist.files(path = here(\"data\"))\n\nlist.files(path = here(\"data\"), pattern = \".csv\")\n# dir(path = here(\"data\"), pattern = \".csv\")\n\nlist.files(path = here(\"data\"), pattern = \"evd\", ignore.case = TRUE)"},{"path":"directories.html","id":"recursos-26","chapter":"43 Interações de diretório","heading":"43.9 Recursos","text":"https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html","code":""},{"path":"collaboration.html","id":"collaboration","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44 Controle de versão e colaboração com Git e Github","text":"Este capítulo apresenta uma visão geral uso Git para programar em colaboração com outras pessoas. Tutoriais mais completos podem ser encontrados abaixo na seção Recursos.","code":""},{"path":"collaboration.html","id":"o-que-é-o-git","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.1 O que é o Git?","text":"Git é um software de controle de versões que permite rastrear alterações em uma pasta. Pode ser usado como opção de “controle de alterações” Word, LibreOffice ou Google docs, mas para todos os tipos de arquivos. É uma das opções mais poderosas e mais usadas para controle de versões.Por que eu nunca ouvi falar disso? Enquanto pessoas com formação em programação aprendem rotineiramente usar softwares de controle de versões (Git, Mercurial, Subversion ou outros), poucos de nós das disciplinas quantitativas aprendem essas habilidades. Consequentemente, maioria dos epidemiologistas nunca ouviu falar dele durante seus estudos, e tem que aprender repentinamente.Espera, já ouvi falar Github, é mesma coisa? - Não exatamente, mas costumamos usá-los juntos. E nós mostraremos como fazer. Resumidamente:Git é o sistema de controle de versão, um software. Você pode usá-lo localmente em seu computador ou para sincronizar uma pasta com um site hospedeiro. Por padrão, usa-se um terminal para fornecer instruções Git na linha de comando.Git é o sistema de controle de versão, um software. Você pode usá-lo localmente em seu computador ou para sincronizar uma pasta com um site hospedeiro. Por padrão, usa-se um terminal para fornecer instruções Git na linha de comando.Você pode usar um cliente / uma interface Git para evitar linha de comando e executar mesmas ações (pelo menos para simples e supercomuns).Você pode usar um cliente / uma interface Git para evitar linha de comando e executar mesmas ações (pelo menos para simples e supercomuns).Se você deseja armazenar sua pasta em um site hospedeiro para colaborar com outras pessoas, você pode criar uma conta Github, Gitlab, Bitbucket ou outros.Se você deseja armazenar sua pasta em um site hospedeiro para colaborar com outras pessoas, você pode criar uma conta Github, Gitlab, Bitbucket ou outros.Portanto, você pode usar o cliente ou interface Github Desktop, que usa Git em segundo plano para gerenciar seus arquivos, tanto localmente em seu computador quanto remotamente em um servidor Github.","code":""},{"path":"collaboration.html","id":"por-que-usar-o-combo-git-e-github","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.2 Por que usar o combo Git e Github?","text":"Usar o Git facilita:Arquivar versões documentadas com mudanças adicionais para que você possa recuperar facilmente qualquer versão anterior;Arquivar versões documentadas com mudanças adicionais para que você possa recuperar facilmente qualquer versão anterior;Ter ramos ( inglês branches) paralelos, ou seja, desenvolver / “trabalhar” diferentes versões com formas estruturadas de integrar mudanças após revisão.Ter ramos ( inglês branches) paralelos, ou seja, desenvolver / “trabalhar” diferentes versões com formas estruturadas de integrar mudanças após revisão.Isso pode ser feito localmente em seu computador, mesmo se você não colaborar com outras pessoas. Você já:lamentou ter excluído uma seção código, para perceber apenas dois meses depois que você realmente precisava dela?lamentou ter excluído uma seção código, para perceber apenas dois meses depois que você realmente precisava dela?voltou em um projeto que estava parado e tentou lembrar se você fez aquela modificação complicada em um dos modelos?voltou em um projeto que estava parado e tentou lembrar se você fez aquela modificação complicada em um dos modelos?teve um arquivo modelo_1.R , outro arquivo modelo_1_teste.R e ainda um outro arquivo modelo_1_nao_funciona.R para testar diferentes soluções?teve um arquivo modelo_1.R , outro arquivo modelo_1_teste.R e ainda um outro arquivo modelo_1_nao_funciona.R para testar diferentes soluções?teve um arquivo relatorio.Rmd, um arquivo relatorio_completo.Rmd , um arquivo relatorio_verdadeiro_final.Rmd, um arquivo relatorio_final_20210304.Rmd, um arquivo relatorio_final_20210402.Rmd  e amaldiçoou suas habilidades de backup?teve um arquivo relatorio.Rmd, um arquivo relatorio_completo.Rmd , um arquivo relatorio_verdadeiro_final.Rmd, um arquivo relatorio_final_20210304.Rmd, um arquivo relatorio_final_20210402.Rmd  e amaldiçoou suas habilidades de backup?Git vai ajudar com tudo isso, e vale pena aprender só por isso.entanto, ele se torna ainda mais poderoso quando usado com um repositório online para oferecer suporte projetos colaborativos, como o Github. Isso facilita:\n- Colaboração: outras pessoas podem revisar, comentar e aceitar/recusar alterações;Compartilhar seu código, dados e resultados e solicitar feedback em público (ou em particular, com sua equipe).E evita:“Opa, esqueci de enviar última versão e agora você precisa refazer dois dias de trabalho neste novo arquivo”;“Opa, esqueci de enviar última versão e agora você precisa refazer dois dias de trabalho neste novo arquivo”;Patrícia, Ruanna e Nathalie trabalharam ao mesmo tempo em um script e precisam mesclar manualmente suas alterações;Patrícia, Ruanna e Nathalie trabalharam ao mesmo tempo em um script e precisam mesclar manualmente suas alterações;Duas pessoas tentam modificar o mesmo arquivo Dropbox e Sharepoint e isso cria um erro de sincronização.Duas pessoas tentam modificar o mesmo arquivo Dropbox e Sharepoint e isso cria um erro de sincronização.","code":""},{"path":"collaboration.html","id":"isso-parece-complicado-não-sou-um-programador","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Isso parece complicado, não sou um programador","text":"Pode ser. Exemplos de usos avançados podem ser bastante assustadores. entanto, assim como R, ou mesmo Excel, você não precisa se tornar um especialista para aproveitar os benefícios da ferramenta. Aprender um pequeno número de funções e noções permite rastrear suas alterações, sincronizar seus arquivos em um repositório online e colaborar com seus colegas em um período de tempo muito curto.Devido à curva de aprendizado, o contexto de emergência pode não ser o melhor momento para aprender essas ferramentas. Mas o aprendizado pode ser alcançado por etapas. Depois de adquirir algumas noções, seu fluxo de trabalho pode ser bastante eficiente e rápido.Um bom momento para adquirir confiança uso Git, na verdade, é quando você não está trabalhando em um projeto que precise dele, quando trabalhar em colaboração não é uma necessidade.","code":""},{"path":"collaboration.html","id":"configuração","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.3 Configuração","text":"","code":""},{"path":"collaboration.html","id":"instale-o-git","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Instale o Git","text":"Git é o mecanismo por trás dos bastidores seu computador, que rastreia alterações, ramos (versões), mesclagens e reversões. Você deve primeiro instalar o Git em https://git-scm.com/downloads.","code":""},{"path":"collaboration.html","id":"instale-uma-interface-opcional-mas-recomendado","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Instale uma interface (opcional, mas recomendado)","text":"Git tem sua própria linguagem de comandos, que pode ser digitada em um terminal de linha de comando. entanto, existem muitos clientes / interfaces e, não sendo um desenvolvedor, você raramente precisará interagir diretamente com o Git na sua rotina. interfaces geralmente fornecem boas ferramentas de visualização para modificações ou ramificações de arquivos.Existem muitas opções, em todos os sistemas operacionais, desde iniciantes até os mais complexos. Boas opções para iniciantes incluem o painel RStudio Git e Github Desktop, que mostraremos neste capítulo. Opções intermediárias (mais poderosas, mas mais complexas) incluem Source Tree, Gitkracken, Smart Git e outras.Explicação rápida sobre Clientes Git.Observação: como todas interfaces usam o Git internamente, você pode tentar várias delas, alternar de uma para outra em um determinado projeto, usar o console pontualmente para uma ação que sua interface não suporta ou até mesmo realizar algumas ações online Github.Conforme observado abaixo, você pode ocasionalmente ter que escrever comandos Git em um terminal, como o painel RStudio (uma aba Console R) ou o terminal Git Bash.","code":""},{"path":"collaboration.html","id":"conta-github","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Conta Github","text":"Inscreva-se para uma conta gratuita em github.com.Pode ser solicitado que você configure autenticação de dois fatores com um aplicativo em seu telefone. Leia mais em nos documentos de ajuda Github.Se você usa o Github Desktop, pode inserir suas credenciais Gitub após instalação seguindo estas etapas. Se você não fizer isso agora, credenciais serão solicitadas mais tarde, quando você tentar clonar um projeto Github.","code":""},{"path":"collaboration.html","id":"vocabulário-conceitos-e-funções-básicas","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.4 Vocabulário, conceitos e funções básicas","text":"Assim como ao aprender R, há um pouco de vocabulário que você precisará lembrar para entender o Git. Aqui estão os princípios básicos para você começar e um tutorial interativo. Nas próximas seções, mostraremos como usar interfaces, mas é bom ter o vocabulário Git e os conceitos em mente, para construir seu modelo mental. Você precisará deles ao usar interfaces de qualquer maneira.","code":""},{"path":"collaboration.html","id":"repositório","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Repositório","text":"Um repositório Git (“repo”) é uma pasta que contém todas subpastas e arquivos seu projeto (dados, códigos, imagens etc.), além dos seus históricos de revisão. Quando você começar rastrear alterações repositório com o Git, ele criará uma pasta oculta que contém todas informações de rastreamento. Um repositório Git típico é pasta Projeto R (consulte página manual em Projetos R).Mostraremos como criar (inicializar) um repositório Git partir Github, Github Desktop ou Rstudio nas próximas seções.","code":""},{"path":"collaboration.html","id":"commits","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Commits ()","text":"Um commit é um snapshot projeto, ou seja, uma foto instantânea de um determinado momento. Ao fazer uma alteração projeto, você fará um novo commit para rastrear alterações (o delta) feitas em seus arquivos. Por exemplo, talvez você tenha editado algumas linhas de código e atualizado um conjunto de dados. Depois que suas alterações forem salvas, você pode agrupar essas alterações em um “commit”.Cada commit possui um ID exclusivo (um hash). Para fins de controle de versão, você pode recuperar seu projeto tempo com base em commits, então é melhor mantê-los relativamente pequenos e coerentes. Você também anexará uma breve descrição das mudanças, chamada de “mensagem de confirmação”.Mudanças graduais? Preparar mudanças é adicioná-las à área de teste, em preparação para o próximo commit. ideia é que você possa decidir com precisão quais alterações incluir em um determinado commit. Por exemplo, se você trabalhou na especificação modelo em um script e, posteriormente, trabalhou em uma figura em outro script, faria sentido ter dois commits diferentes (seria mais fácil caso de você querer reverter mudanças na figura, mas não o modelo).","code":""},{"path":"collaboration.html","id":"branches-ramos","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Branches (Ramos)","text":"Um branch representa uma linha independente de mudanças em seu repo, uma versão paralela e alternativa de seus arquivos de projeto.Branches são úteis para testar mudanças antes de serem incorporadas ao branch principal, que geralmente é versão primária / final / “ativa” seu projeto. Quando você terminar de experimentar em um branch, você pode trazer alterações para o seu branch principal, mesclando, ou excluí-lo, se alterações não foram tão bem-sucedidas.Observação: você não precisa colaborar com outras pessoas para usar branches, nem precisa ter um repositório online remoto.","code":""},{"path":"collaboration.html","id":"repositórios-locais-e-remotos","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Repositórios locais e remotos","text":"Clonar é criar uma cópia de um repositório Git em outro lugar.Por exemplo, você pode clonar um repositório online Github localmente em seu computador, ou começar com um repositório local e cloná-lo online para Github.Quando você clona um repositório, os arquivos projeto ficam em dois lugares:repositório LOCAL, em seu computador físico. É aqui que você faz mudanças reais nos arquivos / códigos.repositório LOCAL, em seu computador físico. É aqui que você faz mudanças reais nos arquivos / códigos.repositório online REMOTO: versões dos seus arquivos de projeto repositório Github (ou em qualquer outro site hospedeiro).repositório online REMOTO: versões dos seus arquivos de projeto repositório Github (ou em qualquer outro site hospedeiro).Para sincronizar esses repositórios, usaremos mais funções. Na verdade, ao contrário Sharepoint, Dropbox ou outro software de sincronização, o Git não atualiza automaticamente seu repositório local baseado naquele que está online ou vice-versa. Você pode escolher quando e como sincronizar.git fetch baixa novas mudanças repositório remoto, mas não muda seu repositório local. Pense nela como uma verificação de estado repositório remoto.git fetch baixa novas mudanças repositório remoto, mas não muda seu repositório local. Pense nela como uma verificação de estado repositório remoto.git pull baixa novas mudanças dos repositórios remotos e atualiza seu repositório local.git pull baixa novas mudanças dos repositórios remotos e atualiza seu repositório local.Quando você tiver feito um ou vários commits localmente, você pode usar git push para atualizar os commits repositório remoto. Isso envia suas alterações Github para que outras pessoas possam vê-las e acessá-las, se quiserem.Quando você tiver feito um ou vários commits localmente, você pode usar git push para atualizar os commits repositório remoto. Isso envia suas alterações Github para que outras pessoas possam vê-las e acessá-las, se quiserem.","code":""},{"path":"collaboration.html","id":"começar-crie-um-novo-repositório","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.5 Começar: crie um novo repositório","text":"Existem muitas maneiras de criar novos repositórios. Você pode fazer isso console, Github, em uma interface.Duas abordagens gerais são:Criar um novo Projeto R partir de um repositório Github novo ou existente (sugerido para iniciantes);Criar um repositório Github para um projeto R existente.","code":""},{"path":"collaboration.html","id":"arquivos-iniciais","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Arquivos iniciais","text":"Ao criar um novo repositório, você pode opcionalmente criar todos os arquivos abaixo ou pode adicioná-los ao seu repositório em um estágio posterior. Eles normalmente ficam na pasta “raiz” repositório.-Um arquivo README é um arquivo que alguém pode ler para entender por que seu projeto existe e o que mais precisar saber para usá-lo. Ele estará vazio início, mas você deve preenchê-lo mais tarde.Um arquivo .gitignore é um arquivo de texto em que cada linha contém pastas ou arquivos que o Git deve ignorar (não rastrear alterações). Leia mais sobre ele e veja exemplos aqui.Um arquivo .gitignore é um arquivo de texto em que cada linha contém pastas ou arquivos que o Git deve ignorar (não rastrear alterações). Leia mais sobre ele e veja exemplos aqui.Você pode escolher uma licença para o seu trabalho, para que outras pessoas saibam em quais condições podem usar ou reproduzir ele. Para obter mais informações, consulte Licenças Creative Commons.Você pode escolher uma licença para o seu trabalho, para que outras pessoas saibam em quais condições podem usar ou reproduzir ele. Para obter mais informações, consulte Licenças Creative Commons.","code":""},{"path":"collaboration.html","id":"criar-um-novo-repositório-no-githubb","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Criar um novo repositório no Githubb","text":"Para criar um novo repositório, faça login Github e procure o botão verde para criar um novo repositório. Este repositório agora vazio pode ser clonado localmente em seu computador (consulte próxima seção).Você deve escolher se deseja que seu repositório seja público, ou seja, visível para todos na internet, ou privado, visível apenas para aqueles com permissão. Isso tem implicações importantes se seus dados forem confidenciais. Se o seu repositório privado, você encontrará certas circunstâncias especiais avançadas, como se estiver usando actions Github para executar automaticamente o seu código na nuvem.","code":""},{"path":"collaboration.html","id":"clonar-de-um-repositório-github","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Clonar de um repositório Github","text":"Você pode clonar um repositório Github existente para criar um novo projeto R local em seu computador.O repositório Github pode ser algum que já existe (com conteúdo) ou pode ser um repositório vazio que você acabou de criar. Neste último caso, você está essencialmente criando o repositório Github e o projeto R local ao mesmo tempo (consulte instruções acima).Observação: se você não possui direitos de contribuição em um repositório Github, é possível primeiro bifurcar o repositório para o seu perfil, e então prosseguir com outras ações. bifurcação é explicada final deste capítulo, mas recomendamos que você leia outras seções primeiro.Etapa 1: Github, navegue até o repositório, clique botão verde “Code” e copie URL clone HTTPS (veja imagem abaixo)próxima etapa pode ser realizada em qualquer interface. Vamos ilustrar com o Rstudio desktop e com o Github.","code":""},{"path":"collaboration.html","id":"no-rstudio","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Rstudio","text":"RStudio, comece um novo projeto R clicando em File>New Project>Version Control>GitQuando solicitada “URL repositório”, cole URL HTTPS GithubAtribua ao projeto R um nome curto e informativoEscolha onde o novo Projeto R será salvo localmenteMarque “Abrir em nova sessão” e clique em “Criar projeto”Agora você está em um novo projeto RStudio local que é um clone repositório Github. O projeto local e o repositório Github agora estão vinculados.","code":""},{"path":"collaboration.html","id":"no-github-desktop","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Github Desktop","text":"Clique em Arquivo > Clonar um repositórioClique em Arquivo > Clonar um repositórioSelecione guia URLSelecione guia URLCole URL HTTPS Github na primeira caixaCole URL HTTPS Github na primeira caixaSelecione pasta na qual deseja ter seu repositório localSelecione pasta na qual deseja ter seu repositório localClique em “CLONE”Clique em “CLONE”","code":""},{"path":"collaboration.html","id":"novo-repositório-github-a-partir-de-um-projeto-r-existente","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Novo repositório Github a partir de um projeto R existente","text":"Outro cenário de configuração alternativo ocorre quando você tem um projeto R existente com conteúdo e deseja criar um repositório Github para ele.Crie um novo repositório Github vazio para o projeto (consulte instruções acima)Crie um novo repositório Github vazio para o projeto (consulte instruções acima)Clone este repositório localmente (consulte instruções HTTPS acima)Clone este repositório localmente (consulte instruções HTTPS acima)Copie todo o conteúdo de seu projeto R pré-existente (códigos, dados, etc.) para este novo repositório vazio e local (Ex.: use copiar e colar).Copie todo o conteúdo de seu projeto R pré-existente (códigos, dados, etc.) para este novo repositório vazio e local (Ex.: use copiar e colar).Abra seu novo projeto RStudio e vá para o painel Git. Os novos arquivos devem estar registrados como alterações de arquivo, agora rastreados pelo Git. Portanto, você pode agrupar essas alterações como um commit e enviar para o Github. Uma vez enviado, o repositório Github refletirá todos os arquivos.Abra seu novo projeto RStudio e vá para o painel Git. Os novos arquivos devem estar registrados como alterações de arquivo, agora rastreados pelo Git. Portanto, você pode agrupar essas alterações como um commit e enviar para o Github. Uma vez enviado, o repositório Github refletirá todos os arquivos.Consulte seção de fluxo de trabalho Github abaixo para obter detalhes sobre esse processo.","code":""},{"path":"collaboration.html","id":"como-aparecem-agora","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Como aparecem agora?","text":"","code":""},{"path":"collaboration.html","id":"no-rstudio-1","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No RStudio","text":"Depois de clonar um repositório Github para um novo projeto R, você verá RStudio uma guia “Git”. Esta guia aparece mesmo painel RStudio que seu “ambiente”Environment” R:Observe os botões circulados na imagem acima, pois eles serão comentados seguir (da esquerda para direita):Botão commit para confirmar alterações arquivo salvo branch local (isso abrirá uma nova janela)Seta azul para extrair (atualize sua versão local branch com quaisquer alterações feitas na versão Github (remota) desse branch)Seta verde para enviar (atualize quaisquer commits / alterações da sua versão local branch para versão Github (remota) desse branch)guia Git RStudioBotão para criar um NOVO branch usando qualquer branch local (mostrado à direita como base). Quase sempre você criará um branch partir branch principal (depois de extrair pela primeira vez para atualizar o branch principal)O branch que você está trabalhando momentoAlterações feitas código ou em outros arquivos aparecerão abaixo","code":""},{"path":"collaboration.html","id":"no-github-desktop-1","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Github Desktop","text":"Github Desktop é um aplicativo independente que permite gerenciar todos os seus repositórios. Ao abri-lo, interface permite que você escolha o repositório qual deseja trabalhar e, seguir, executar ações básicas Git partir dele.","code":""},{"path":"collaboration.html","id":"fluxo-de-trabalho-git-github","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.6 Fluxo de trabalho Git + Github","text":"","code":""},{"path":"collaboration.html","id":"visão-geral-do-processo","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Visão geral do processo","text":"Depois de concluir configuração (descrita acima), você terá um repositório Github conectado (clonado) um projeto R local. O branch principal (criado por padrão) é versão chamada “ao vivo” de todos os arquivos. Quando você quiser fazer modificações, é uma boa prática criar um novo branch partir branch principal (“Fazer uma cópia”). Este é um fluxo de trabalho típico Git porque criar um branch é fácil e rápido.Um fluxo de trabalho típico é o seguinte:Certifique-se de que seu repositório local está atualizado e, se não estiver, atualize;Certifique-se de que seu repositório local está atualizado e, se não estiver, atualize;Vá para o branch em que você estava trabalhando anteriormente ou crie um novo branch para testar algumas coisasVá para o branch em que você estava trabalhando anteriormente ou crie um novo branch para testar algumas coisasTrabalhe nos arquivos localmente em seu computador, faça um ou vários commits para este branchTrabalhe nos arquivos localmente em seu computador, faça um ou vários commits para este branchAtualize versão remota da filial com suas alterações (enviar)Atualize versão remota da filial com suas alterações (enviar)Quando estiver satisfeito com seu branch, você pode mesclar versão online branch que trabalhou para o branch “principal” -line e, assim, transferir suas alteraçõesQuando estiver satisfeito com seu branch, você pode mesclar versão online branch que trabalhou para o branch “principal” -line e, assim, transferir suas alteraçõesOutros membros da equipe podem estar fazendo mesma coisa com seus próprios branches, ou talvez contribuindo com commits branch que você está trabalhando também.Vamos repassar passo passo processo acima com mais detalhes abaixo. Aqui está um esquema que desenvolvemos - está formato de uma tabela dois-por-dois, portanto, deve ajudar os epidemiologistas entender.Aqui está outro diagrama.Observação: até recentemente, o termo branch “master” era usado, mas agora é chamado de branch “main” (principal).Fonte da imagem","code":""},{"path":"collaboration.html","id":"crie-um-novo-branch","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.7 Crie um novo branch","text":"Quando você seleciona um branch para trabalhar, Git redefine seu diretório de trabalho jeito que estava da última vez que você esteve neste branch.","code":""},{"path":"collaboration.html","id":"no-painel-git-no-rstudio","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No painel Git no Rstudio","text":"Certifique-se de que está branch “principal” e clique ícone roxo para criar um novo branch (veja imagem acima).Você deverá nomear seu branch com uma única palavra (pode usar sublinhado, se necessário).Você verá que localmente está mesmo projeto R, mas não está mais trabalhando branch “main”.Depois de criado, o novo branch também aparecerá site Github como um branch.Você pode visualizar branches painel Git Rstudio depois de clicar em “Histórico”","code":""},{"path":"collaboration.html","id":"no-github-desktop-2","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Github Desktop","text":"O processo é muito semelhante, você deverá dar um nome ao seu branch. Depois, você será solicitado “Publicar seu branch Github” para fazer o novo branch aparecer repositório remoto também.","code":""},{"path":"collaboration.html","id":"no-console","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No console","text":"O que realmente está acontecendo nos bastidores é que você cria um novo branch com git branch, então vai para o branch comgit checkout (_isto é, diga ao Git que seus próximos commits ocorrerão lá). seu repositório git:Para obter mais informações sobre como usar o console, consulte seção sobre comandos Git final.","code":"git branch my-new-branch  # Cria o novo branch\ngit checkout my-new-branch # Vai para o branch\ngit checkout -b my-new-branch # Os dois ao mesmo tempo (atalho)"},{"path":"collaboration.html","id":"confirmar-alterações","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.8 Confirmar alterações","text":"Agora você pode editar o código, adicionar novos arquivos, atualizar conjuntos de dados, etc.Cada uma de suas alterações será rastreada, uma vez que o respectivo arquivo salvo. Os arquivos alterados irão aparecer na aba Git RStudio, Github , ou usando o comando git status terminal (veja abaixo).Sempre que você fizer alterações substanciais (Ex.:, adicionar ou atualizar uma seção de código), pare e confirme essas alterações (commit). Pense em um commit como um “lote” de mudanças relacionadas um propósito comum. Você poderá continuar revisan um arquivo mesmo após ter confirmado alterações nele.Conselhos sobre commits: geralmente, é melhor fazer pequenos commits, que podem ser facilmente revertidos se um problema surgir, para confirmar modificações diferentes relacionadas um mesmo propósito. Para isso, você descobrirá que deve criar commits com frequência. início, você provavelmente vai esquecer, mas logo desenvolverá o hábito.","code":""},{"path":"collaboration.html","id":"no-rstudio-2","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Rstudio","text":"O exemplo abaixo mostra que, desde o último commit, o script R Markdown “Collaboration.Rmd” mudou, e várias imagens PNG foram adicionadas.Você pode estar se perguntando o que representam os quadrados amarelos, azuis, verdes e vermelhos próximos aos nomes dos arquivos. Aqui está uma parte Cheatsheet RStudio que explica seu significado. Mudanças com o quadrado amarelo (“?”) ainda podem ser preparadas, confirmadas e enviadas.Pressione o botão “Commit” na guia Git, que abrirá uma nova janela (reproduzida abaixo)Pressione o botão “Commit” na guia Git, que abrirá uma nova janela (reproduzida abaixo)Clique nome de um arquivo na caixa superior esquerdaClique nome de um arquivo na caixa superior esquerdaRevise alterações feitas arquivo (destacadas abaixo em verde ou vermelho)Revise alterações feitas arquivo (destacadas abaixo em verde ou vermelho)“Prepare” o arquivo, que incluirá essas mudanças commit. Faça isso marcando caixa ao lado nome arquivo. Como alternativa, você pode destacar vários nomes de arquivo e clicar em “Stage”“Prepare” o arquivo, que incluirá essas mudanças commit. Faça isso marcando caixa ao lado nome arquivo. Como alternativa, você pode destacar vários nomes de arquivo e clicar em “Stage”Escreva uma mensagem de confirmação que seja curta, mas descritiva (obrigatório)Escreva uma mensagem de confirmação que seja curta, mas descritiva (obrigatório)Pressione o botão “Commit”. Uma caixa pop-aparecerá mostrando o sucesso ou uma mensagem de erro.Pressione o botão “Commit”. Uma caixa pop-aparecerá mostrando o sucesso ou uma mensagem de erro.Agora você pode fazer mais alterações e mais commits, quantas vezes quiser","code":""},{"path":"collaboration.html","id":"no-github-desktop-3","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Github Desktop","text":"Você pode ver lista dos arquivos que foram alterados à esquerda. Se você selecionar um arquivo de texto, verá um resumo das modificações feitas painel direito (visualização não funcionará em arquivos mais complexos como .docs ou .xlsx).Para fazer alterações, basta marcar caixa ao lado dos nomes dos arquivos. Quando você tiver selecionado os arquivos que deseja adicionar este commit, dê um nome ao commit, uma descrição (opcional) e clique botão commit.","code":""},{"path":"collaboration.html","id":"no-console-1","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No console","text":"São usadas funções git add para selecionar / preparar arquivos egit commit para realmente fazer o commit.","code":"git status #veja as mudanças \n\ngit add new_pages/collaboration.Rmd  # selecione arquivos para o commit (= \"stage\" mudanças)\n\ngit commit -m \"Describe commit from Github Desktop\" # confirme mudanças com uma mensagem\n\ngit log  # veja informações sobre commits anteriores"},{"path":"collaboration.html","id":"corrigir-um-commit-anterior","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Corrigir um commit anterior","text":"O que acontece se você fizer o commit de algumas alterações, continuar trabalhando e perceber que fez alterações que deveriam “pertencer” ao commit anterior (na sua opinião)? Está tudo bem! Você pode anexar essas alterações ao seu commit anterior.Rstudio há uma caixa “Corrigir commit anterior” na mesma linha botão COMMIT.Por alguma razão, esta funcionalidade não foi implementada da mesma forma Github Desktop, mas há uma maneira de contornar (estranha, mas fácil!). Se você tiver confirmado suas alterações mas não enviado ainda, um botão “UNDO” aparecerá logo abaixo botão COMMIT. Clique nele e ele irá reverter seu commit (mas mantenha seus arquivos preparados e sua mensagem de commit). Salve suas mudanças, adicione novos arquivos ao commit se necessário e faça o commit novamente.console:Observação: pense antes de modificar commits que já são públicos e compartilhados com seus colaboradores.","code":"git add [SEUS ARQUIVOS] # Prepare suas novas mudanças\n\ngit commit --amend  # Corrija o commit anteriororrigir o commit anterior\n\ngit commit --amend -m \"An updated commit message\"  # Corrija o commit anterior E atualize a mensagem de commit"},{"path":"collaboration.html","id":"pull-baixarextrair-e-push-enviarsubir-alterações-para-o-github","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.9 Pull (baixar/extrair) e Push (enviar/subir) alterações para o Github","text":"“Primeiro PULL, depois PUSH”É uma boa prática fetch (buscar) e pull (baixar) antes de começar trabalhar seu projeto, para atualizar versão branch em seu computador local com quaisquer alterações que tenham sido feitas na versão remota / Github.PULL frequentemente. Não hesite. Sempre faça um pull antes de fazer um push.Quando suas mudanças forem feitas e confirmadas e você estiver feliz com o seu projeto, você pode fazer um push dos seus commits para versão remota / Github de seu branch.Observação: é muito mais fácil desfazer alterações que foram confirmadas, mas não enviadas (ou seja, ainda são locais) que alterações que foram enviadas para o repositório remoto (e talvez já extraídas por outra pessoa), por isso é melhor enviar quando terminar de introduzir mudanças estava trabalhando.","code":""},{"path":"collaboration.html","id":"no-rstudio-3","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Rstudio","text":"PULL - Primeiro, clique ícone “Pull” (seta azul para baixo) que busca e extrai ao mesmo tempo.PUSH - Clique ícone “Pull” (seta verde para cima). Pode ser necessário inserir seu nome de usuário e senha Github. Na primeira vez que você solicitado, pode ser necessário inserir duas linhas de comando Git Terminal:git config –global user.email “voce@exemplo.com” (seu endereço de email Github), egit config –global user.name “Seu nome de usuário Github”Para saber mais sobre como inserir esses comandos, consulte seção abaixo sobre comandos Git.DICA: Sua senha está sendo solicitada com muita frequência? Veja os capítulos 10 e 11 deste tutorial para se conectar um repositório usando uma chave SSH (mais complicado)","code":""},{"path":"collaboration.html","id":"no-github-desktop-4","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Github Desktop","text":"Clique botão “Buscar origem” para verificar se há novos commits repositório remoto.Se o Git encontrar novos commits repositório remoto, o botão mudará para um botão “Pull”. Como o mesmo botão é usado para fazer o pull (baixar/extrair) e fazer o push (subir/enviar), você não pode enviar suas alterações se não fizer o pull antes.Você pode ir para guia “Histórico” (perto da guia “Alterações”) para ver todos os commits (seus e dos outros). Essa é uma ótima maneira de se familiarizar com o que seus colaboradores fizeram. Você pode ler mensagem de confirmação, descrição, se houver, e comparar o código dos dois arquivos usando o painel diff.Uma vez que todas mudanças remotas tenham sido extraídas, e pelo menos uma mudança local tenha sido confirmada, você pode enviar clicando mesmo botão.","code":""},{"path":"collaboration.html","id":"console","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Console","text":"Como esperado, os comandos são fetch, pull e push .","code":"git fetch  # Existem novos commits no diretório remoto?\ngit pull   # Traga commits remotos para seu branch local\ngit push   # Envie commits locais deste branch para o branch remoto"},{"path":"collaboration.html","id":"quero-fazer-um-pull-mas-tenho-trabalho-local","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Quero fazer um pull, mas tenho trabalho local","text":"Isso pode acontecer às vezes: você fez algumas mudanças em seu repositório local, mas o repositório remoto tem commits que você não extraiu.O Git se recusará fazer um pull porque pode sobrescrever suas alterações. Existem várias estratégias para manter suas mudanças, bem descritas em Happy Git R, entre quais duas principais são:confirme suas alterações, busque alterações remotas, extraia elas, resolva conflitos, se necessário (consulte seção abaixo), e coloque tudo onlinestash suas alterações, que meio que armazena à parte, extrai, restaura (“unstash”) e então efetua o commit, resolvendo quaisquer conflitos e envia.Se não houver sobreposição entre os arquivos das mudanças remotas e os arquivos das mudanças locais, o Git pode resolver os conflitos automaticamente.Github Desktop, isso pode ser feito com botões. Para isso, vá até Branch> Stash changes.","code":""},{"path":"collaboration.html","id":"mesclar-no-branch-principal","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.10 Mesclar no branch principal","text":"Se você concluiu alterações, pode iniciar o processo de mesclagem dessas alterações branch principal. Dependendo da situação, isso pode ser rápido ou contemplar etapas acordadas de revisão e aprovação envolvendo colegas da sua equipe.","code":""},{"path":"collaboration.html","id":"localmente-no-github-desktop","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Localmente no Github Desktop","text":"É possível mesclar branches localmente usando o Github Desktop. Primeiro, vá até o branch que será o destinatário dos commits, ou seja, o branch que você deseja atualizar. Em seguida, clique em Branch > Merge current branch. Uma caixa permitirá que você selecione o branch que deseja importar.","code":""},{"path":"collaboration.html","id":"no-console-2","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No console","text":"Primeiro, volte para o branch que receberá alterações. Geralmente é o master, mas pode ser outro branch. Em seguida, mescle seu branch de trabalho master.Esta página mostra um exemplo mais avançado de branching e explica um pouco como funciona nos bastidores.","code":"git checkout master  # Volte para o master (ou para o branch que você deseja mover)\ngit merge this_fancy_new_branch"},{"path":"collaboration.html","id":"no-github-submeter-uma-requisição-de-pull","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"No Github: submeter uma requisição de pull","text":"Embora seja totalmente possível mesclar dois branches localmente, ou sem informar ninguém, uma mesclagem pode ser discutida ou investigada por várias pessoas antes de ser integrada ao branch master. Para ajudar processo, o Github oferece alguns recursos de discussão sobre mesclagem: solicitação de pull.Uma solicitação de pull (um “PR”, inglês pull request) é uma solicitação para mesclar um branch em outro (em outras palavras, uma solicitação para que _seu branch de trabalho seja extraído para o branch “main”). Uma solicitação de extração geralmente envolve vários commits e inicia uma conversa, um processo de revisão, antes de ser aceita e o branch ser mesclado. Por exemplo, você pode ler discussões de solicitação de extração github dplyr.Você pode enviar uma solicitação de pull (PR) diretamente site (conforme ilustrado abaixo) ou Github Desktop.Vá para o repositório Github (online)Visualize guia “Solicitações de pull” e clique botão “Nova solicitação de pull”Selecione menu suspenso para mesclar seu branch branch principal (main)Escreva um comentário detalhado sobre o Pull Request e clique em “Criar Pull Request”.Agora você será capaz de ver solicitação pull (exemplo na imagem abaixo):Revise guia “Arquivos alterados” para ver como o branch “main” mudaria se o branch fosse mesclado.À direita, você pode solicitar uma revisão dos colaboradores da sua equipe marcando seus IDs Github. Se desejar, você pode definir configurações repositório para exigir uma revisão de aprovação antes de mesclar com o main.Assim que solicitação pull aprovada, um botão para “Mesclar solicitação pull” ficará ativo. Clique nele.Depois de concluído, exclua seu branch conforme explicado abaixo.","code":""},{"path":"collaboration.html","id":"resolvendo-conflitos","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Resolvendo conflitos","text":"Quando duas pessoas modificam (s) mesma (s) linha (s) ao mesmo tempo, surge um conflito de mesclagem. Na verdade, o Git se recusa tomar uma decisão sobre qual versão manter, mas ajuda descobrir onde está o conflito. NÃO ENTRE EM PÂNICO. Na maioria das vezes, é muito simples de resolver.Por exemplo, Github:Após mesclagem gerar um conflito, abra o arquivo em seu editor favorito. O conflito será indicado por uma série de caracteres:O texto entre <<<<<<<HEAD e ======= vem seu repositório local, já o texto entre ======= e >>>>>>> vem outro branch (que pode ser o original, o master ou qualquer branch de sua escolha).Você precisa decidir qual versão código prefere (ou até mesmo escrever uma terceira, incluindo alterações de ambos os lados, se pertinente), excluir o resto e remover todas marcas que o Git adicionou (<<<<<<<HEAD,=======,>>>>>>>origin/master/your_branch_name).Então, salve, prepare e submeta o arquivo: este é o commit que torna versão mesclada “oficial”. Não se esqueça de enviar depois.Quanto mais você e seus colaboradores puxarem e empurrarem, menores serão os conflitos.Observação: se você se sentir à vontade com o console, há mais opções avançadas de mesclagem (Ex.: ignorando espaços em branco, dando prioridade um colaborador, etc.). ","code":""},{"path":"collaboration.html","id":"delete-seu-branch","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Delete seu branch","text":"Depois que um branch foi mesclado com o master e não mais necessário, você pode excluí-lo.","code":""},{"path":"collaboration.html","id":"github-rstudio","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.10.0.1 Github + Rstudio","text":"Vá até o repositório Github e clique botão para ver todos os branches (próximo ao menu suspenso para selecionar branches). Agora encontre seu branch e clique ícone de lixeira próximo ele. Leia mais detalhes sobre como excluir um branch aqui.Certifique-se de excluir também o branch local seu computador. Isso não acontecerá automaticamente.RStudio, certifique-se de estar branch principalPasse digitar comandos Git “Terminal” RStudio (guia adjacente ao console R) e digite: git branch -d nome_do_branch , onde “nome_do_branch” é o nome seu branch ser excluídoAtualize sua guia Git e o branch terá desaparecido","code":""},{"path":"collaboration.html","id":"no-github-desktop-5","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.10.0.2 No Github Desktop","text":"Basta verificar o branch que deseja excluir e ir até o menu Branch>Delete.","code":""},{"path":"collaboration.html","id":"forking","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Forking","text":"Você pode bifurcar um projeto (fork) se desejar contribuir com ele mas não tiver os direitos ou se desejar modificá-lo apenas para seu uso pessoal. Uma breve descrição da bifurcação pode ser encontrada aqui.Github, clique botão “Fork”:Isso irá clonar o repositório original seu próprio perfil. Agora, existem duas versões repositório Github: original, que você não pode modificar, e versão clonada seu perfil.Em seguida, você pode clonar sua versão repositório online localmente seu computador, usando qualquer um dos métodos descritos nas seções anteriores. partir de então, você poderá criar um novo branch, fazer mudanças, submetê-las e enviá-las para o seu repositório remoto.Quando estiver satisfeito com o resultado, você pode criar um “Pull Request” Github ou Github Desktop para iniciar conversa com os proprietários / responsáveis pelo repositório original.E se você precisar de alguns commits mais recentes repositório original?Imagine que alguém faça uma modificação substancial repositório oficial, que você deseja incluir em sua versão clonada. É possível sincronizar sua bifurcação (fork) com o repositório oficial. Envolve o uso terminal, mas não é tão complicado. Você precisa se lembrar principalmente que: - upstream = repositório oficial, aquele que você não pode modificar - origin = sua versão repositório em seu perfil GithubVocê pode ler este tutorial ou seguir o caminho abaixo:Primeiro, digite seu terminal Git (dentro de seu reposositório):Se você ainda não configurou o repositório upstream, deverá ver duas linhas, começando por origin. Eles mostram o repositório remoto para o qual fetch epush estão direcionados. Lembre-se, por convenção, origin é sua própria versão repositório Github. Por exemplo:Agora, adicione um novo repositório remoto:Aqui, o site é o endereço que o Github gera quando você clona um repositório (consulte seção sobre clonagem). Agora você terá quatro ponteiros remotos:Agora que configuração está feita, sempre que você quiser obter alterações repositório original (upstream), você só precisa ir (checkout) ao branch que deseja atualizar e digitar:Se houver conflitos, você terá que resolvê-los, conforme explicado na seção Resolvendo conflitos.Resumo: bifurcar é clonar, mas servidor Github. O restante das ações são ações típicas fluxo de trabalho de colaboração (clonar, enviar, puxar, confirmar, mesclar, enviar solicitações pull …).Observação: bifurcação é um conceito, não um comando Git, e também existe em outros sites de hospedagem, como Bitbucket.","code":"git remote -vgit remote add upstream https://github.com/appliedepi/epirhandbook_eng.gitgit fetch upstream # Para obter os novos commits do repositório remoto\ngit checkout the_branch_you_want_to_update\ngit merge upstream/the_branch_you_want_to_update  # Para mesclar o branch upstream em seu branch\ngit push # Para atualizar sua própria versão do repositório remoto"},{"path":"collaboration.html","id":"o-que-aprendemos","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.11 O que aprendemos","text":"Você aprendeu como:configurar o Git para rastrear modificações em suas pastas,conectar seu repositório local um repositório online remoto,confirmar alterações,sincronizar seus repositórios locais e remotos.Isso deve ajudá-lo e ser suficiente para maioria de suas demandas como epidemiologista. Normalmente não temos um uso tão avançado quanto os desenvolvedores.entanto, se você quiser (ou precisar) ir além, o Git oferece funcionalidades para simplificar históricos de commits, reverter um ou vários commits, selecionar commits, etc. Alguns deles podem soar como pura magia, mas agora que você já sabe o básico, será mais fácil avançar.Observe que embora o painel Git Rstudio e Github Desktop sejam bons para iniciantes ou para uso diário trabalho, eles não oferecem interface para algumas das funções intermediárias e avançadas Git. Algumas interfaces mais completas permitem fazer mais com cliques (geralmente ao custo de um layout mais complexo).Lembre-se que você pode usar qualquer ferramenta para rastrear seu repositório, então pode instalar uma outra interface para experimentá-la algumas vezes, ou para realizar alguma tarefa complexa não tão comum seu trabalho, e continuar usando uma interface simplificada para o resto tempo (por exemplo, usando Github Desktop na maioria das vezes e mudando para SourceTree ou Gitbash para algumas tarefas específicas).","code":""},{"path":"collaboration.html","id":"git","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.12 Comandos Git","text":"","code":""},{"path":"collaboration.html","id":"aprendizados-recomendados","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Aprendizados recomendados","text":"Para aprender os comandos Git em um tutorial interativo, consulte este site.","code":""},{"path":"collaboration.html","id":"onde-inserir-comandos","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Onde inserir comandos","text":"Você insere comandos em um shell Git.Opção 1 Você pode abrir um novo Terminal RStudio. Esta guia está ao lado R Console. Se você não conseguir digitar nenhum texto nele, clique menu suspenso abaixo de “Terminal” e selecione “Novo terminal”. Digite os comandos espaço em frente cifrão “$”.Opção 2 Você também pode abrir um shell (um terminal para inserir comandos) clicando ícone azul “engrenagens” na guia Git (próximo ao ambiente RStudio). Selecione “Shell” menu suspenso. Uma nova janela será aberta onde você pode digitar os comandos após o cifrão “$”.Opção 3 Clique com o botão direito para abrir o “Git Bash aqui”, que abrirá o mesmo tipo de terminal, ou abra o Git Bash da sua lista de aplicativos. Mais informações para iniciantes Git Bash, como encontrá-lo e alguns comandos bash que você precisará.","code":""},{"path":"collaboration.html","id":"amostra-de-comandos","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"Amostra de comandos","text":"Abaixo, apresentamos alguns comandos git comuns. Ao usá-los, lembre-se de qual branch está ativo (com check-), pois isso mudará ação!Nos comandos abaixo,  representa o nome de um branch.  representa o ID de hash de um commit específico.  representa um número. Não digite os símbolos < ou >.","code":""},{"path":"collaboration.html","id":"recursos-27","chapter":"44 Controle de versão e colaboração com Git e Github","heading":"44.13 Recursos","text":"Grande parte desta página foi baseada site “Happy Git R” de Jenny Bryan. Há uma seção muito útil neste site que ajuda solucionar erros comuns relacionados ao Git e ao R.Documentação Github.com e guia de inicialização.“IDE” cheatsheet RStudio que inclui dicas sobre o uso Git com RStudio.https://ohi-science.org/news/github-going-back--timeComandos Git para iniciantesUm tutorial interativo para aprender os comandos Git.https://www.freecodecamp.org/news/-introduction--git--absolute-beginners-86fa1d32ff71/: “básico básico” para rastrear alterações em uma pasta seu próprio computador.Esquemas legais para entender os branches: https://speakerdeck.com/alicebartlett/git--humansTutoriais de assuntos básicos e avançadoshttps://tutorialzine.com/2016/06/learn-git--30-minuteshttps://dzone.com/articles/git-tutorial-commands--operations--githttps://swcarpentry.github.io/git-novice/ (short course)https://rsjakob.gitbooks.io/git/content/chapter1.htmlO livro Pro Git é considerado uma referência oficial. Mas embora alguns capítulos estejam ok, ele pode parecer um pouco técnico. Certamente será um bom recurso se você já tiver usado um pouco o Git e quiser aprender um pouco mais precisamente sobre o que acontece e como ir mais longe.","code":""},{"path":"errors.html","id":"errors","chapter":"45 Erros comuns","heading":"45 Erros comuns","text":"Esta página inclui uma lista de erros comuns e sugere soluções para solucioná-los.","code":""},{"path":"errors.html","id":"interpretando-mensagens-de-erro","chapter":"45 Erros comuns","heading":"45.1 Interpretando mensagens de erro","text":"Os erros R podem ser enigmáticos às vezes, então use o Google como seu amigo. Pesquise mensagem de erro com “R” e procure postagens recentes em StackExchange.com, stackoverflow.com, community.rstudio.com, twitter (#rstats) e outros fóruns de perguntas e respostas usados por programadores. Tente encontrar postagens recentes que resolveram problemas semelhantes.Se você não conseguir encontrar uma resposta para o seu problema, mesmo depois de pesquisar muito, considere criar um exemplo reprodutível (“reprex”, ou um MRE para Minimal Reproducible Exemple ) e postar pergunta você mesmo. Consulte página Obtendo ajuda para dicas sobre como criar e postar um exemplo reprodutível em fóruns.","code":""},{"path":"errors.html","id":"erros-comuns","chapter":"45 Erros comuns","heading":"45.2 Erros comuns","text":"Abaixo, listamos alguns erros comuns e potenciais explicações / soluções. borrowed Noam Ross analyzed common forum posts Stack Overflow R error messages (see analysis )","code":""},{"path":"errors.html","id":"erros-de-digitação","chapter":"45 Erros comuns","heading":"Erros de digitação","text":"Se você vir um “unexpected symbol” (símbolo inesperado), verifique se há vírgulas faltando","code":"Error: unexpected symbol in:\n\"  geom_histogram(stat = \"identity\")+\n  tidyquant::geom_ma(n=7, size = 2, color = \"red\" lty\""},{"path":"errors.html","id":"erros-de-pacote","chapter":"45 Erros comuns","heading":"Erros de pacote","text":"Isso provavelmente significa que você digitou o nome da função incorretamente ou esqueceu de instalar / carregar um pacote.Você acha que está usando dplyr :: select () mas função select () foi mascarada por MASS::select () - especifique dplyr :: ou reorganize o carregamento pacote para que dplyr venha depois de todos os outros.Outros erros comuns de mascaramento vêm de: plyr::summarise() stats::filter(). Considere usar o pacote conflicted package.Se você receber um erro dizendo que precisa remover um arquivo “00LOCK”, vá para biblioteca “R” diretório seu computador (por exemplo, R/win-library/) e procure uma pasta chamada “00LOCK”. Exclua isso manualmente e tente instalar o pacote novamente. Provavelmente isso aconteceu porque um processo de instalação anterior foi interrompido.","code":"could not find function \"x\"...Error in select(data, var) : unused argument (var)Error in install.packages : ERROR: failed to lock directory ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0’ for modifying\nTry removing ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0/00LOCK’"},{"path":"errors.html","id":"erros-de-objeto","chapter":"45 Erros comuns","heading":"Erros de objeto","text":"Se você encontrar um erro como este na exportação ou importação: Verifique ortografia arquivo e caminho arquivo. Se o caminho contém barras, certifique-se de que estão para frente / e não para trás \\. Certifique-se também de usar extensão de arquivo correta (por exemplo, .csv, .xlsx).Isso significa que o objeto não existe. Talvez o código acima não tenha funcionado corretamente?Isso significa que você tentou acessar algo (um elemento de um vetor ou uma lista) que não estava lá.","code":"No such file or directory:object 'x' not found Error in 'x': subscript out of bounds"},{"path":"errors.html","id":"erros-de-sintaxe-de-função","chapter":"45 Erros comuns","heading":"Erros de sintaxe de função","text":"O erro acima (argument \".x\" missing, default) é comum em mutate() se você estiver fornecendo uma função como recode () ou replace_na(), pois espera-se que você forneça coluna nome como primeiro argumento. Isso é fácil de esquecer.","code":"# ran recode without re-stating the x variable in mutate(x = recode(x, OLD = NEW)\nError: Problem with `mutate()` input `hospital`.\nx argument \".x\" is missing, with no default\ni Input `hospital` is `recode(...)`."},{"path":"errors.html","id":"erros-lógicos","chapter":"45 Erros comuns","heading":"Erros lógicos","text":"Isso provavelmente significa que uma instrução foi aplicada algo que não era VERDADEIRO ou FALSO.","code":"Error in if"},{"path":"errors.html","id":"erros-de-fator","chapter":"45 Erros comuns","heading":"Erros de fator","text":"Se você encontrar este erro sobre níveis de fator inválidos, provavelmente tem uma coluna com uma variável tipo fator (níveis predefinidos) e tentou adicionar um novo valor ela. Converta-o para o tipo caracter antes de adicionar um novo valor.","code":"#Tried to add a value (\"Missing\") to a factor (with replace_na operating on a factor)\nProblem with `mutate()` input `age_cat`.\ni invalid factor level, NA generated\ni Input `age_cat` is `replace_na(age_cat, \"Missing\")`.invalid factor level, NA generated"},{"path":"errors.html","id":"erros-de-plotagem","chapter":"45 Erros comuns","heading":"Erros de plotagem","text":"Error: Insufficient values manual scale. 3 needed 2 provided.\nggplot() scale_fill_manual() values = c(“orange”, “purple”) … insufficient number factor levels … consider whether NA now factor level…Provavelmente tem um + extra final de um comando ggplot que você precisa excluir.","code":"Can't add x object"},{"path":"errors.html","id":"erros-de-r-markdown","chapter":"45 Erros comuns","heading":"Erros de R Markdown","text":"Se mensagem de erro contiver algo como Error options[[sprintf(\"fig.%s\", )]], verifique se opções knitr topo de cada bloco usam adequadamente .width = ou .height = e não fig.width= e fig.height=.","code":""},{"path":"errors.html","id":"diversos-1","chapter":"45 Erros comuns","heading":"Diversos","text":"Considere se você reorganizou os verbos dplyr e esqueceu de substituir um pipe (%>%) meio código ou se esqueceu um pipe na extremidade após reorganizar.","code":""},{"path":"errors.html","id":"recursos-28","chapter":"45 Erros comuns","heading":"45.3 Recursos","text":"Esta é outra postagem blog que lista erros de programação R enfrentados por iniciantes","code":""},{"path":"help.html","id":"help","chapter":"46 Conseguindo ajuda","heading":"46 Conseguindo ajuda","text":"Esta página aborda sobre como obter ajuda postando um problema (issue) Github ou postando um exemplo reprodutível (“reprex” ou MRE para Minimal reprodutible exemple) em um fórum online.","code":""},{"path":"help.html","id":"issues-problemas-do-github","chapter":"46 Conseguindo ajuda","heading":"46.1 Issues (problemas) do Github","text":"Muitos pacotes e projetos R têm seu código hospedado site Github.com. Você pode se comunicar diretamente com os autores através site, postando um “Problema”.Leia mais sobre como armazenar seu trabalho Github na página Colaboração e Github.Github, cada projeto está contido em um repositório. Cada repositório contém código, dados, saídas, documentação de ajuda etc. Existe também um veículo de comunicação com os autores denominado “Problemas”.Veja abaixo página Github para o pacote incidence2 (usado para fazer curvas epidêmicas). Você pode ver guia “Issues” (Problemas, em imglês) destacada em amarelo. Você pode ver que existem 5 questões em aberto.Nesta guia Issues você pode ver os problemas em aberto. Revise-os para garantir que seu problema não foi resolvido ainda. Você pode abrir um novo problema clicando botão verde à direita. Para fazer isso, será necessário ter uma conta Github.Siga instruções abaixo para fornecer um exemplo mínimo e reproduzível seu problema. Por favor, seja educado()! maioria das pessoas que desenvolve pacotes e projetos R estão fazendo isso seu tempo livre (como este manual!).Para ler materiais mais avançados sobre como lidar com problemas seu repositório, verifique documentação sobre problemas Github.","code":""},{"path":"help.html","id":"exemplo-reprodutível","chapter":"46 Conseguindo ajuda","heading":"46.2 Exemplo reprodutível","text":"Fornecer um exemplo reprodutível (“reprex”) é chave para obter ajuda com sua postagem ou problema Github. pessoas querem ajudá-lo, mas você precisa dar um exemplo com o qual elas possam trabalhar em seus próprios computadores. O exemplo deve:Demonstrar o problema que você encontrouSer o mais curto possível, incluindo apenas os dados e o código necessário para reproduzir o seu problemaSer reprodutível, de modo que todos os objetos (por exemplo, dados), e pacotes sejam incluídos (por exemplo, library() ou p_load())Além disso, certifique-se de não postar nenhum dado sensível com o reprex! Você pode criar dataframes de exemplo ou usar um dos dataframes embutidos R (insira data() para abrir uma lista desses conjuntos de dados).","code":""},{"path":"help.html","id":"o-pacote-reprex","chapter":"46 Conseguindo ajuda","heading":"O pacote reprex","text":"O pacote reprex pode ajudá-lo fazer um exemplo reprodutível:reprex é instalado com tidyverse, então carregue qualquer um dos pacotesInicie um script R que gere seu problema, passo passo, começando com o carregamento de pacotes e dados.Copie todo o código para área de transferência e execute o seguinte comando:Você verá uma saída HTML aparecer painel RStudio Viewer. Ele conterá todo o seu código e quaisquer avisos, erros ou resultados de plotagem. Essa saída também é copiada para sua área de transferência, para que você possa publicá-la diretamente em um problema Github ou em uma postagem fórum.Se você definir session_info = TRUE, saída de sessioninfo ::session_info() incluírá suas versões R e dos pacotes RVocê pode fornecer um diretório de trabalho para wd =Você pode ler mais sobre os argumentos e possíveis variações em documentation ou inserindo ?ReprexNo exemplo acima, o comando ggplot() não rodou porque o argumento date_format = não está correto - deveria ser date_labels =.","code":"\n# intale/carregue o tidyverse (que inclui o reprex)\npacman::p_load(tidyverse)\n# carregar pacotes\npacman::p_load(\n     tidyverse,  # manipulação de dados e visualização\n     outbreaks)  # exemplos de dados de surtos \n\n# linelist lista dos casos da epidemia de gripe\noutbreak_raw <- outbreaks::fluH7N9_china_2013  #recuperar conjunto de dados do pacote de surtos\n\n# Limpar conjunto de dados\noutbreak <- outbreak_raw %>% \n     mutate(across(contains(\"date\"), as.Date))\n\n# Visualizar epidemia\nggplot(data = outbreak)+\n     geom_histogram(\n          mapping = aes(x = date_of_onset),\n          binwidth = 7\n     )+\n  scale_x_date(\n    date_format = \"%d %m\"\n  )\nreprex::reprex()"},{"path":"help.html","id":"dados-mínimos","chapter":"46 Conseguindo ajuda","heading":"Dados mínimos","text":"pessoas que vão te ajudar precisam ser capazes de usar seus dados - de preferência, eles precisam ser capazes de criá-los com código.Para criar um conjunto de dados mínimos, considere anonimizar e usar apenas um subconjunto das observações.EM CONSTRUÇÃO - você também pode usar função dput() para criar um conjunto mínimo de dados.","code":""},{"path":"help.html","id":"postar-em-um-fórum","chapter":"46 Conseguindo ajuda","heading":"46.3 Postar em um fórum","text":"Leia muitas postagens fórum. Entenda quais postagens são bem escritas e quais não são.Primeiro, decida se deseja fazer pergunta. Você revisou extensivamente o site fórum, tentando vários termos de pesquisa, para ver se sua pergunta já foi feita?Primeiro, decida se deseja fazer pergunta. Você revisou extensivamente o site fórum, tentando vários termos de pesquisa, para ver se sua pergunta já foi feita?Dê um título informativo à sua pergunta (não algo como “Socorro! Isso não está funcionando!”).Dê um título informativo à sua pergunta (não algo como “Socorro! Isso não está funcionando!”).Escreva sua pergunta:Escreva sua pergunta:Apresente sua situação e problemaFaça um link com postagens de problemas semelhantes e explique porque eles não responderam à sua perguntaInclua qualquer informação relevante para ajudar alguém que não conhece o contexto seu trabalhoDê um exemplo reprodutível mínimo com informações seu trabalhoUse ortografia, gramática e pontuação adequadas e divida sua pergunta em parágrafos para que seja mais fácil de lerDepois de postar, monitore sua pergunta para responder qualquer pedido de esclarecimento. Seja educado() e cortês - muitas vezes pessoas que respondem estão oferecendo seu tempo para ajudá-lo. Se você tiver uma pergunta de acompanhamento, considere se deve ser uma pergunta postada separada.Depois de postar, monitore sua pergunta para responder qualquer pedido de esclarecimento. Seja educado() e cortês - muitas vezes pessoas que respondem estão oferecendo seu tempo para ajudá-lo. Se você tiver uma pergunta de acompanhamento, considere se deve ser uma pergunta postada separada.Marque pergunta como respondida, se obtiver uma resposta que atenda à solicitação original. Isso ajuda outras pessoas reconhecerem rapidamente solução mais tarde.Marque pergunta como respondida, se obtiver uma resposta que atenda à solicitação original. Isso ajuda outras pessoas reconhecerem rapidamente solução mais tarde.Leia estas postagens sobre como fazer uma boa pergunta e sobre ocódigo de conduta Stack overflow.","code":""},{"path":"help.html","id":"recursos-29","chapter":"46 Conseguindo ajuda","heading":"46.4 Recursos","text":"Página Tidyverse sobre como obter ajuda!Dicas para produzir um conjunto mínimo de dadosDocumentação para função dput","code":""},{"path":"network-drives.html","id":"network-drives","chapter":"47 R em drives (pastas) na rede","heading":"47 R em drives (pastas) na rede","text":"","code":""},{"path":"network-drives.html","id":"visão-geral-6","chapter":"47 R em drives (pastas) na rede","heading":"47.1 Visão geral","text":"O uso R em rede ou em pastas compartilhadas de uma instituição pode apresentar desafios adicionais. Esta página contém abordagens, erros comuns e sugestões sobre solução de problemas obtidos partir da nossa experiência de trabalho com estas questões. Isto inclui dicas para situações particularmente delicadas envolvendo o R Markdown.Usando R em drives na rede: Princípios geraisVocê deve obter acesso de administrador para seu computador. Configure o RStudio especificamente para ser executado como administrador.Salve os pacotes em uma biblioteca (drive, pasta) com letras sempre que possível (por exemplo, “C:”). Evite usar uma biblioteca de pacotes cujo caminho comece com “\\”.O pacote rmarkdown não deve estar em uma biblioteca de pacotes “\\”, pois assim não poderá se conectar ao TinyTex ou ao Pandoc.","code":""},{"path":"network-drives.html","id":"rstudio-como-administrador","chapter":"47 R em drives (pastas) na rede","heading":"47.2 RStudio como administrador","text":"Para abrir o RStudio, clique ícone com o botão direito mouse. Dependendo de sua máquina, você verá uma opção para “Run Administrator” (Executar como administrador). Caso contrário, você verá uma opção para selecionar Properties (Propriedades), e então deverá aparecer uma janela com opção “Compatibility” (Compatibilidade), e você poderá selecionar uma caixa de seleção “Run Administrator” (Executar como Administrador).","code":""},{"path":"network-drives.html","id":"comandos-úteis","chapter":"47 R em drives (pastas) na rede","heading":"47.3 Comandos úteis","text":"Abaixo estão alguns comandos úteis ao tentar solucionar problemas usando R em drives de rede.Você pode retornar o(s) caminho(s) para bibliotecas de pacotes que o R está usando. Eles serão listados na ordem em que R estiver usando para instalar/carregar/buscar por pacotes. Assim, se você quiser que R use uma biblioteca padrão diferente, você pode mudar ordem destes caminhos (veja abaixo).Você pode querer mudar ordem das bibliotecas de pacotes usadas pelo R. Por exemplo, se o R estiver pegando um local de biblioteca que começa com “\\” e um que começa com uma letra, por exemplo, “D:”. Você pode ajustar ordem de .libPaths() com o seguinte código.Se você estiver com dificuldades para conectar o R Markdown ao Pandoc, comece com este código para descobrir onde RStudio entende que está sua instalação Pandoc.Se você quiser ver de qual biblioteca um pacote está sendo carregado, tente o código abaixo:","code":"\n# Encontrar bibliotecas\n.libPaths()                   #  Os caminhos de sua biblioteca, listados para que o R instale/selecione.. \n                              # Nota: todas as bibliotecas serão listadas, mas para instalar em algumas \n                              # (por exemplo, C:) você pode precisar executar o RStudio como administrador \n                              # (não aparecerá no menu suspenso de install.packages) \n# Troca a ordem das bibliotecas\n# Isto pode afetar a prioridade do R encontrar um pacote. Por exemplo, você pode querer que sua biblioteca C: seja listada primeiro\nmyPaths <- .libPaths() # obter os caminhos\nmyPaths <- c(myPaths[2], myPaths[1]) # trocar os caminhos\n.libPaths(myPaths) # realocar os caminhos\n#Encontrar o Pandoc\nSys.getenv(\"RSTUDIO_PANDOC\")  # Descubra onde o RStudio entende que está sua instalação Pandoc\n# Encontrar um pacote\n# Indica a primeira localização do pacote (Note a ordem de suas bibliotecas)\nfind.package(\"rmarkdown\", lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\")) "},{"path":"network-drives.html","id":"resolução-de-problemas-e-erros-comuns","chapter":"47 R em drives (pastas) na rede","heading":"47.4 Resolução de problemas e erros comuns","text":"“Failed compile…tex rmarkdown”Verifique instalação de TinyTex, ou instale TinyTex em C:. Veja na página Introdução ao R sobre como instalar o TinyTex.rotinas da Internet não podem ser carregadasPor exemplo, Error tools::startDynamicHelp() : internet routines loadedTente selecionar versão de 32 bits RStudio em Tools/Global Options (Ferramentas/Opções Globais).\nnota: se versão de 32 bits não aparecer menu, certifique-se de não estar usando o RStudio v1.2\nTente selecionar versão de 32 bits RStudio em Tools/Global Options (Ferramentas/Opções Globais).nota: se versão de 32 bits não aparecer menu, certifique-se de não estar usando o RStudio v1.2Alternativamente, tente desinstalar R e reinstalar com versão de bit diferente (32 em vez de 64).Alternativamente, tente desinstalar R e reinstalar com versão de bit diferente (32 em vez de 64).C: o pacote não aparece como opção quando tento instalar pacotes manualmenteExecute o RStudio como administrador que esta opção vai aparecerPara executar o RStudio sempre como administrador, clique com o botão direito mouse ícone Rstudio (opção vantajosa ao usar um projeto R, em que você não clica ícone RStudio para abrir).imagem abaixo mostra como você pode selecionar manualmente biblioteca para instalação de um pacote. Esta janela aparece quando você abre o painel Packages (Pacotes) RStudio e clica em “Install” (Instalar).Erro Pandoc 1Se você estiver recebendo “pandoc error 1” ao criar scripts R Markdowns em drives de rede:Dentre muitas bibliotecas, tenha uma com letras listadas primeiro (ver códigos acima)solução acima funcionou ao programar em uma unidade local, mas em uma conexão de Internet em redeVeja mais dicas aqui: https://ciser.cornell.edu/rmarkdown-knit--html-word-pdf/Erro Pandoc 83O erro será algo parecido com: find file...rmarkdown...lua.... Isto significa que não foi possível encontrar este arquivo.Veja https://stackoverflow.com/questions/58830927/rmarkdown-unable--locate-lua-filter--knitting--wordPossibilidades:O pacote Rmarkdown não está instaladoO pacote Rmarkdown não pode ser encontradoUma questão de direitos administrador.É possível que o R não seja capaz de encontrar o arquivo pacote rmarkdown, portanto verifique qual biblioteca (pasta) o pacote rmarkdown se encontra (veja o código acima). Se o pacote foi instalado em uma biblioteca inacessível (por exemplo, que comece com “\\”), considere movê-lo manualmente para C: ou outra biblioteca que comece com uma letra. Esteja ciente de que o pacote rmarkdown tem que ser capaz de se conectar à instalação TinyTex, portanto não pode estar em uma biblioteca em uma unidade de rede.Erro Pandoc 61Por exemplo: Error: pandoc document conversion failed error 61 ou fetch...Tente executar o RStudio como administrador (clique com o botão direito mouse, selecione executar como administrador, veja instruções acima)Veja também se o pacote específico que não pôde ser carregado pode ser movido para biblioteca C:.LaTex error (ver abaixo)Um erro como: ! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' found: using draft setting. ou Error: LaTeX failed compile file_name.tex.Veja https://yihui.org/tinytex/r/#debugging para dicas de correção.Veja file_name.log para mais informações.Erro Pandoc 127Isto pode ser uma questão de RAM (espaço). Reinicie novamente sua sessão R e tente novamente.Mapeamento de drives na redeMapear uma unidade de rede pode ser arriscado. Consulte seu departamento de TI antes de tentar fazer isso.Uma dica emprestada deste fórum de discussão:Como se abre um arquivo “através de uma unidade de rede mapeada”?Primeiro, você precisará saber localização da rede à qual está tentando acessar.Em seguida, gerenciador de arquivos Windows, você precisará clicar com o botão direito mouse em “Este Computador” painel à esquerda (ou direita, dependendo da sua configuração), e selecionar “Mapear uma unidade de rede”.Passe pelo diálogo para definir localização da rede desde o início como um drive com letras de forma.Agora você tem duas maneiras de chegar ao arquivo que você está abrindo. O uso caminho com letras deve funcionar.Erro em install.packages()Se você receber um erro que inclua menção de um diretório “lock”, por exemplo: Error install.packages : ERROR: failed lock directory...Procure em sua biblioteca de pacotes e verá uma pasta cujo nome começa com “00LOCK”. Tente seguintes dicas:Apague manualmente o diretório da pasta “00LOCK” de sua biblioteca de pacotes. Tente instalar o pacote de novo.Você também pode tentar o comando pacman::p_unlock() (você também pode colocar este comando Rprofile para que ele seja executado toda vez que o projeto abrir). Tente então instalar o pacote novamente. Pode ser necessário várias tentativas.Tente executar o RStudio modo administrador, e tente instalar os pacotes um um.e tudo isso falhar, instale o pacote em outra biblioteca ou pasta (por exemplo, Temp) e depois copie manualmente pasta pacote para biblioteca desejada.","code":"\n# Verificar/instalar tinytex em C:\ntinytex::install_tinytex()\ntinytex:::is_tinytex() # deve retornar TRUE (VERDADEIRO)"},{"path":"data-table.html","id":"data-table","chapter":"48 Data Table","heading":"48 Data Table","text":"Este livro centra-se nos “verbos” (funções) pacote dplyr e operador pipe %>% pacote magrittr como método para limpar e agrupar dados, mas o pacote data.table oferece um método alternativo que você poderá incorporar em seu uso R.","code":""},{"path":"data-table.html","id":"introdução-ao-data-table","chapter":"48 Data Table","heading":"48.1 Introdução ao Data Table","text":"Uma tabela de dados (data table) é uma estrutura de dados bidimensional como um data frame, que permite realização de operações complexas de agrupamento. sintaxe data.table é estruturada para que operações possam ser realizadas em linhas, colunas e grupos.estrutura é DT[, j, ], separada por 3 partes; os argumentos , j e . O argumento permite filtrar linhas, o argumento j permite operar em colunas e o argumento permite operar em colunas por grupos.Esta página abordará os seguintes tópicos:Importação de dados e uso das funções fread() e fwrite()Filtragem de linhas utilizando o argumento iUtilização das funções de ajuda %like%, %chin% e %%Seleção e operação com colunas utilizando o argumento jOperar por grupos utilizando o argumento byAdição de dados e atualização de data tables (tabelas de dados) utilizando :=","code":""},{"path":"data-table.html","id":"carregar-pacotes-e-importar-dados","chapter":"48 Data Table","heading":"48.2 Carregar pacotes e importar dados","text":"","code":""},{"path":"data-table.html","id":"carregar-pacotes-16","chapter":"48 Data Table","heading":"Carregar pacotes","text":"Utilizando função p_load() de pacman, carregamos (e instalamos, se necessário) os pacotes necessários para esta análise.","code":"\npacman::p_load(\n  rio,        # para importar dados\n  data.table, # para agrupar e limpar dados\n  tidyverse,  # permite o uso da função pipe (%>%) neste capítulo\n  here \n  ) "},{"path":"data-table.html","id":"importar-dados-8","chapter":"48 Data Table","heading":"Importar dados","text":"Esta página vai explorar algumas das funções centrais pacote data.table recorrendo à mesma linelist de casos utilizada ao longo manual.Importamos o conjunto de dados dos casos de uma epidemia simulada de Ébola. Se você quiser baixar os dados para seguir passo passo, veja instruções na página Baixar livro e dados. O conjunto de dados é importado utilizando função import() pacote rio. Veja página em Importar e exportar para várias formas de importação de dados. Em seguida, utilizamos data.table() para converter o quadro de dados em um data table.função fread() é utilizada para importar arquivos delimitados por caracteres, como arquivos .csv, diretamente para um formato de data table. Esta função, e sua contraparte fwrite(), utilizada para escrever data.tables como arquivos delimitados, são opções muito rápidas e computacionalmente eficientes para grandes bancos de dados.primeiras 20 linhas da linelist:Comandos R Base como dim() que são utilizados para data frames também podem ser utilizados para data tables (tabelas de dados).","code":"\nlinelist <- rio::import(here(\"data\", \"linelist_cleaned.xlsx\")) %>% data.table()\ndim(linelist) #dispõe o número de linhas e colunas na tabela de dados## [1] 5888   30"},{"path":"data-table.html","id":"o-argumento-i-selecionando-e-filtrando-linhas","chapter":"48 Data Table","heading":"48.3 O argumento i: selecionando e filtrando linhas","text":"Relembrando estrutura DT[, j, ], podemos filtrar linhas usando números de linha ou expressões lógicas. O argumento é o primeiro; portanto, sintaxe DT[] ou DT[,] pode ser usada.O primeiro exemplo recupera primeiras 5 linhas data table, o segundo exemplo retorna casos com 18 anos ou mais, e o terceiro exemplo gera um subconjunto de casos com 18 anos ou mais, mas não diagnosticados Hospital Central:O uso de .N argumento representa o número total de linhas data table. Isto pode ser usado para criar subconjuntos com base nos números das linhas:","code":"\nlinelist[1:5] # retorna da 1ª à 5ª fileira\nlinelist[age >= 18] # subconjunto de casos com 18 anos ou mais\nlinelist[age >= 18 & hospital != \"Central Hospital\"] # conjunto de casos com idade igual ou superior a 18 anos, mas não diagnosticados no Hospital Central\nlinelist[.N] # retorna a última linha\nlinelist[15:.N] # retorna da 15ª à última linha"},{"path":"data-table.html","id":"funções-de-ajuda-para-filtragem","chapter":"48 Data Table","heading":"Funções de ajuda para filtragem","text":"Data tables (tabelas de dados) utilizam funções de auxílio que facilitam filtragem linhas. função %like% é utilizada para corresponder um padrão em uma coluna, %chin% é utilizada para corresponder um caractere específico, e função %% é utilizada para corresponder colunas numéricas dentro de uma faixa pré-especificada.Nos exemplos seguir, nós:\n* filtramos linhas em que variável hospital contém “Hospital”\n* filtramos linhas em que o resultado é “Recover” ou “Death”\n* filtramos linhas em que faixa etária (age) é 40-60 anos","code":"\nlinelist[hospital %like% \"Hospital\"] # filtrar linhas em que a variável hospital contém \"Hospital\"\nlinelist[outcome %chin% c(\"Recover\", \"Death\")] # filtrar linhas em que o resultado (outcome) é \"Recover\" ou \"Death\"\nlinelist[age %between% c(40, 60)] # filtrar linhas em que a faixa etária (age) é de 40-60 anos\n\n#%between% deve receber um vetor de comprimento 2, enquanto %chin% pode receber vetores de comprimento >= 1"},{"path":"data-table.html","id":"o-argumento-j-seleção-e-cálculo-nas-colunas","chapter":"48 Data Table","heading":"48.4 O argumento j: seleção e cálculo nas colunas","text":"Usando estrutura DT[, j, ], podemos selecionar colunas usando números ou nomes. O argumento j é o segundo; portanto, sintaxe DT[, j] é usada. Para facilitar os cálculos argumento j, coluna é envolvida utilizando list() ou .().","code":""},{"path":"data-table.html","id":"seleção-de-colunas","chapter":"48 Data Table","heading":"Seleção de colunas","text":"O primeiro exemplo recupera primeira, terceira e quinta colunas data table, o segundo exemplo seleciona todas colunas, exceto colunas gender, age, wt_kg e ht_cm. O terceiro exemplo utiliza o envelope .() para selecionar colunas case_id e outcome.","code":"\nlinelist[ , c(1,3,5)]\nlinelist[ , -c(\"gender\", \"age\", \"wt_kg\", \"ht_cm\")]\nlinelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] funciona tão bem quanto"},{"path":"data-table.html","id":"cálculo-nas-colunas","chapter":"48 Data Table","heading":"Cálculo nas colunas","text":"Combinando os argumentos e j é possível filtrar linhas e calcular colunas. Usar .N argumento j também representa o número total de linhas data table e pode ser útil para retornar o número de linhas após filtragem.Nos exemplos seguir, nós:\n* contamos o número de casos que permaneceram mais de 7 dias hospital\n* calculamos idade média dos casos que vieram óbito hospital militar\n* calculamos o desvio padrão, mediana, e média da idade dos casos que se recuperaram hospital centralLembre-se que usar o envelope .() argumento j facilita o cálculo, retorna um data table e permite nomeação de colunas.","code":"\nlinelist[days_onset_hosp > 7 , .N]## [1] 189\nlinelist[hospital %like% \"Military\" & outcome %chin% \"Death\", .(mean(age, na.rm = T))] #na.rm = T remove valores N/A##         V1\n## 1: 15.9084\nlinelist[hospital == \"Central Hospital\" & outcome == \"Recover\", \n                 .(mean_age = mean(age, na.rm = T),\n                   median_age = median(age, na.rm = T),\n                   sd_age = sd(age, na.rm = T))] # esta sintaxe não utiliza as funções de ajuda, mas funciona tão bem quanto##    mean_age median_age   sd_age\n## 1: 16.85185         14 12.93857"},{"path":"data-table.html","id":"the-by-argument-computing-by-groups","chapter":"48 Data Table","heading":"48.5 The by argument: computing by groups","text":"O argumento é o terceiro argumento na estrutura DT[, j, ]. Ele aceita tanto um vetor de caracteres quanto sintaxe list() ou .(). utilização da sintaxe .() argumento permite renomear coluna imediatamente.Nos exemplos seguir, nós:\n* agrupamos o número de casos por hospital\n* calculamos altura média e o peso dos casos com 18 anos ou mais, de acordo com o sexo e desfecho (se eles se recuperaram ou vieram óbito)\n* contamos o número de casos com tempo de internação > 7 dias, de acordo com o mês e o hospital em que foram admitidosData.table também permite expressões em serquência:Nestes exemplos, estamos seguindo suposição de que uma linha data table é igual um novo caso, e assim podemos usar o .N para representar o número de linhas data table. Outra função útil para representar o número de casos únicos é uniqueN(), que retorna o número de valores únicos em uma determinada entrada. Como ilustrado aqui:resposta é 3, pois os valores únicos na coluna de gênero são m, f e N/. Compare com função unique() R Base, que retorna todos os valores únicos em uma determinada entrada:Para encontrar o número de casos únicos em um determinado mês, escrevemos o seguinte:","code":"\nlinelist[, .N, .(hospital)] # número de casos por hospital##                                hospital    N\n## 1:                                Other  885\n## 2:                              Missing 1469\n## 3: St. Mark's Maternity Hospital (SMMH)  422\n## 4:                        Port Hospital 1762\n## 5:                    Military Hospital  896\n## 6:                     Central Hospital  454\nlinelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T),\n                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs representam as categorias em que os dados estão faltando##    gender outcome  mean_wt  mean_ht\n## 1:      m Recover 71.90227 178.1977\n## 2:      f   Death 63.27273 159.9448\n## 3:      m   Death 71.61770 175.4726\n## 4:      f    <NA> 64.49375 162.7875\n## 5:      m    <NA> 72.65505 176.9686\n## 6:      f Recover 62.86498 159.2996\n## 7:   <NA> Recover 67.21429 175.2143\n## 8:   <NA>   Death 69.16667 170.7917\n## 9:   <NA>    <NA> 70.25000 175.5000\nlinelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]##     month                             hospital  N\n##  1:     5                    Military Hospital  3\n##  2:     6                        Port Hospital  4\n##  3:     7                        Port Hospital  8\n##  4:     8 St. Mark's Maternity Hospital (SMMH)  5\n##  5:     8                    Military Hospital  9\n##  6:     8                                Other 10\n##  7:     8                        Port Hospital 10\n##  8:     9                        Port Hospital 28\n##  9:     9                              Missing 27\n## 10:     9                     Central Hospital 10\n## 11:     9 St. Mark's Maternity Hospital (SMMH)  6\n## 12:    10                              Missing  2\n## 13:    10                    Military Hospital  3\n## 14:     3                        Port Hospital  1\n## 15:     4                    Military Hospital  1\n## 16:     5                                Other  2\n## 17:     5                     Central Hospital  1\n## 18:     5                              Missing  1\n## 19:     6                              Missing  7\n## 20:     6 St. Mark's Maternity Hospital (SMMH)  2\n## 21:     6                    Military Hospital  1\n## 22:     7                    Military Hospital  3\n## 23:     7                                Other  1\n## 24:     7                              Missing  2\n## 25:     7 St. Mark's Maternity Hospital (SMMH)  1\n## 26:     8                     Central Hospital  2\n## 27:     8                              Missing  6\n## 28:     9                                Other  9\n## 29:     9                    Military Hospital 11\n## 30:    10                        Port Hospital  3\n## 31:    10                                Other  4\n## 32:    10 St. Mark's Maternity Hospital (SMMH)  1\n## 33:    10                     Central Hospital  1\n## 34:    11                              Missing  2\n## 35:    11                        Port Hospital  1\n## 36:    12                        Port Hospital  1\n##     month                             hospital  N\nlinelist[, .N, .(hospital)][order(-N)][1:3] #1º seleciona todos os casos por hospital, 2º ordena os casos em ordem decrescente, 3º seleciona um subconjunto dos 3 hospitais com o maior número de casos##             hospital    N\n## 1:     Port Hospital 1762\n## 2:           Missing 1469\n## 3: Military Hospital  896\nlinelist[, .(uniqueN(gender))] # lembre que o envelope .() no argumento j retorna um data table##    V1\n## 1:  3\nlinelist[, .(unique(gender))]##      V1\n## 1:    m\n## 2:    f\n## 3: <NA>\nlinelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]##     month   V1\n##  1:     5   62\n##  2:     6  100\n##  3:     7  198\n##  4:     8  509\n##  5:     9 1170\n##  6:    10 1228\n##  7:    11  813\n##  8:    12  576\n##  9:     1  434\n## 10:     2  310\n## 11:     3  290\n## 12:     4  198"},{"path":"data-table.html","id":"adicionar-e-atualizar-data-tables-tabelas-de-dados","chapter":"48 Data Table","heading":"48.6 Adicionar e atualizar data tables (tabelas de dados)","text":"O operador := é utilizado para adicionar ou atualizar dados em um data table. adição de colunas pode ser feita das seguintes maneiras:Outras agregações complexas estão além objetivo deste capítulo introdutório, mas ideia é fornecer uma alternativa popular e viável ao dplyr para agrupamento e limpeza de dados. O pacote data.table é um grande pacote que permite um código limpo e legível.","code":"\nlinelist[, adult := age >= 18] # adiciona uma coluna\nlinelist[, c(\"child\", \"wt_lbs\") := .(age < 18, wt_kg*2.204)] #para adicionar múltiplas colunas é necessário usar as sintaxes c(\"\"), list() ou .() syntax\nlinelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),\n                         no_infector_source_data = is.na(infector) | is.na(source))] #Este método utiliza `:=` como um operador funcional \nlinelist[, adult := NULL] # deleta a coluna"},{"path":"data-table.html","id":"recursos-30","chapter":"48 Data Table","heading":"48.7 Recursos","text":"Aqui estão alguns recursos úteis para maiores informações:\n* https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html\n* https://github.com/Rdatatable/data.table\n* https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf\n* https://www.machinelearningplus.com/data-manipulation/datatable--r-complete-guide/\n* https://www.datacamp.com/community/tutorials/data-table-r-tutorialVocê pode realizar qualquer função de resumo sobre dados agrupados; veja Cheat Sheet para mais informações:\nhttps://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf","code":""}]
