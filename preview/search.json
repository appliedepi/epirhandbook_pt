[{"path":"index.html","id":"section","chapter":"","heading":"","text":"Este manual se esforça para:Servir como um manual rápido de referência código RFornecer exemplos centrados em tarefas que abordam problemas epidemiológicos comunsAuxiliar os epidemiologistas na transição para o RSer acessível em ambientes com baixa conectividade com Internet por meio de uma versão offline \nEscrito por epidemiologistas, para epidemiologistasSomos epidemiologistas aplicados de todo o mundo, escrevendo em nosso tempo livre para oferecer este recurso à comunidade. Seu encorajamento e feedback são muito bem-vindos:Formulário estruturado de feedbackEmail epiRhandbook@gmail.com ou tweet @epiRhandbookSubmeta issues nosso repositório Github","code":""},{"path":"index.html","id":"como-usar-este-manual","chapter":"","heading":"Como usar este manual","text":"Navegue pelas páginas Índice, ou use caixa de buscaClique nos ícones “copiar” para copiar o códigoVocê pode seguir - junto com os dados exemplo.Consulte seção “Recursos” de cada página para obter mais materialVersão -lineVeja instruções na página Fazer o Download manual e dos dados.LínguasEsta é uma versão traduzida para Português. Se você quer colaborar em melhorá-la, corrigindo algum erro, ou traduzir para outra língua, por favor, nos contacte!","code":""},{"path":"index.html","id":"agradecimentos","chapter":"","heading":"0.1 Agradecimentos","text":"Este manual é produzido por uma colaboração de epidemiologistas de todo o mundo, aproveitando experiência de organizações que incluem agências de saúde locais, estaduais, provinciais e nacionais, Organização Mundial da Saúde (OMS), Médicos Sem Fronteiras / Médicos sem Fronteiras (MSF), sistemas hospitalares e instituições acadêmicas.Este manual é não um produto aprovado de qualquer organização específica. Embora nos esforcemos para ser precisos, não damos nenhuma garantia conteúdo deste livro.","code":""},{"path":"index.html","id":"colaboradores","chapter":"","heading":"Colaboradores","text":"Editor: Neale BatraEquipe principal projeto: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay Campbell, Paula Blomquist, Aminata Ndiaye, Isaac Florence, Isha Berry, Mathilde Mousset, Sara Hollis, Liza Coyer, Kate Kelsey, Marie-Amélie Degail Chabrat, Joao MuiangaAutores: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinRevisores: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIlustradores: Calder FongTradutores da versão em língua portuguesa (Brasil): Carolina Musso, César Augusto Galvão , Halian Vilela, Laís Relvas, Felipe Cardoso, Rafaela Tadei, Pauliana Galvão, Nathalia Zini, Paula Maçaira, João Pedro Angelici, Ademar Barbosa Dantas Junior, Eucilene Santana, Hudson Gabriel Virtuoso Fontenele","code":""},{"path":"index.html","id":"financiamento-e-apoio","chapter":"","heading":"Financiamento e apoio","text":"O manual recebeu financiamento de apoio através de uma subvenção de emergência COVID-19 da TEPHINET, rede global de Programas de Treinamento em Epidemiologia de Campo (FETPs).O apoio administrativo foi fornecido pela EPIET Alumni Network (EAN), com agradecimentos especiais à Annika Wendland. O EPIET é o Programa Europeu de Treinamento em Epidemiologia de Intervenção.Agradecimentos especiais aos Médicos Sem Fronteiras (MSF) Centro Operacional Amsterdã (OCA) por seu apoio durante o desenvolvimento deste manual.Esta publicação foi apoiada pelo Acordo Cooperativo número NU2GGH001873, financiado pelos Centros de Controle e Prevenção de Doenças através TEPHINET, um programa da Força Tarefa para Saúde Global. Seu conteúdo é de responsabilidade exclusiva dos autores e não representa necessariamente visão oficial dos Centros de Controle e Prevenção de Doenças, Departamento de Saúde e Serviços Humanos, Task Force Global Health, Inc. ou TEPHINET.","code":""},{"path":"index.html","id":"inspiração","chapter":"","heading":"Inspiração","text":"infinidade de tutoriais e vinhetas que forneceram conhecimento para o desenvolvimento conteúdo manual são creditados dentro de suas respectivas páginas.De modo mais geral, seguintes fontes forneceram inspiração para este manual:“R4Epis” project (colaboração entre MSF e RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"termos-de-uso-e-contribuição","chapter":"","heading":"Termos de Uso e Contribuição","text":"","code":""},{"path":"index.html","id":"licença","chapter":"","heading":"Licença","text":"Esta obra está licenciada sob uma Licença Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.Cursos acadêmicos e programas de treinamento de epidemiologistas são bem-vindos para usar este manual com seus alunos. Se você tiver dúvidas sobre o uso pretendido, envie um e-mail para epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"citação","chapter":"","heading":"Citação","text":"Batra, Neale, et ai. O Manual Epidemiologista R. 2021. ","code":""},{"path":"index.html","id":"contribuição","chapter":"","heading":"Contribuição","text":"Se você quiser fazer uma contribuição de conteúdo, entre em contato conosco primeiro por meio de questões Github ou por e-mail. Estamos implementando um cronograma de atualizações e criando um guia contribuidor.Observe que o projeto epiRhandbook é lançado com um Código de Conduta Contribuidor. Ao contribuir para este projeto, você concorda em respeitar seus termos.","code":""},{"path":"survey-analysis.html","id":"survey-analysis","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1 Analises de pesquisa de questionários (survey)","text":"","code":""},{"path":"survey-analysis.html","id":"visão-geral","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.1 Visão Geral","text":"Esta página demonstra o uso de vários pacotes para análise de pesquisas de questionários (tipo survey).maioria dos pacotes de pesquisa R depende pacote survey para fazer análises ponderadas.\nUtilizaremos survey assim como srvyr(que funciona como uma roupagem (wrapper)\npara o pacote survey, isto é, simplificando seu uso e permitindo uma codificação em estilo “tidyverse”) e gtsummary (que funciona como uma roupagem (wrapper) para o pacote survey, permitindo publicação de tabelas prontas).Embora o pacote original de survey não permita uma codificação em estilo “tidyverse”, ele tem o benefício adicional de permitir modelos lineares generalizados\nponderados (que serão adicionados esta página posteriormente). Também demonstraremos usando uma função pacote sitrep,\npara criar pesos de amostragem (n.b este pacote ainda não está atualmente CRAN, mas pode ser instalado partir github).maior parte desta página é baseada trabalho feito para o projeto “R4Epis”; para obter o código detalhado e modelos R-markdown\nveja página github “R4Epis”. Alguns dos códigos survey baseados em pacotes são baseados nas primeiras versões \nEPIET case studies.momento, esta página não aborda os cálculos de tamanho de amostra ou amostragem. Para uma calculadora de tamanho de amostra simples de usar, consulte\nOpenEpi. página Introdução GIS (https://epirhandbook.com/gis-basics.html) manual terá eventualmente uma seção sobre\namostragem espacial aleatória, e esta página terá eventualmente uma seção sobre estruturas de amostragem, bem como cálculos de tamanho de amostra.Dados da pesquisaTempo de observaçãoPonderaçãoObjetos de projeto de pesquisaAnálise descritivaProporções ponderadasTaxas ponderadas","code":""},{"path":"survey-analysis.html","id":"preparação","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.2 Preparação","text":"","code":""},{"path":"survey-analysis.html","id":"pacotes","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"Pacotes","text":"Este trecho de código mostra o carregamento dos pacotes necessários para análises. Neste manual, enfatizamos p_load() pacman, que instala o pacote\nse necessário e o carrega para utilização. Você também pode carregar pacotes usando library() R Base. Veja página Introdução ao R para mais informações\nsobre os pacotes R.\nAqui também demonstramos utilizando função p_load_gh() de pacman para instalar e carregar pacote github que ainda não foi publicado \nCRAN.","code":"\n## carregar pacotes do CRAN\npacman::p_load(rio,          # Importar arquivo\n               here,         # Local do arquivo\n               tidyverse,    # manipulação de dados + gráficos com ggplot2\n               tsibble,      # manipulação de bases de séries temporais\n               survey,       # funções de pesquisa\n               srvyr,        # roupagem (wraper) para o pacote survey\n               gtsummary,    # wrapper para o pacote survey, para produzir tabelas\n               apyramid,     # pacote destinado a criação de pirâmides etárias\n               patchwork,    # combinação de gráficos ggplots\n               ggforce       # para diagramas aluviais e de sankey\n               ) \n\n## carregar pacotes do github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # para funções de tempo de observação / ponderação\n)"},{"path":"survey-analysis.html","id":"carregar-dados","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"Carregar dados","text":"O conjunto de dados de exemplo utilizado nesta seção:dados fictícios da pesquisa de mortalidade.população fictícia conta para área de pesquisa.dicionário de dados para os dados fictícios da pesquisa de\nmortalidade.Isto é baseado na pesquisa pré-aprovada pelo conselho de análise ética da MSF OCA. O conjunto de dados fictício foi produzido como parte projeto “R4Epis”. Baseado em dados coletados usando KoboToolbox, que é um software de coleta de dados baseado em\nOpen Data Kit.Kobo lhe permite exportar tanto os dados coletados quanto o dicionário para esse conjunto de dados. Recomendamos fortemente que se faça isso, pois simplifica limpeza de dados e é útil para pesquisa devariáveis/questões.DICA: O dicionário de dados Kobo tem nomes de variáveis na coluna”name” da planilha de pesquisa. Os valores possíveis para cada variável\nsão especificado na planilha de escolhas. Na planilha de escolhas, coluna “name” tem o nome abreviado e colunas “label::english” e “label::french” têm nome completo. Use o pacote epidict, função msf_dict_survey() para importar um arquivo excel dicionário Kobo e formatá-lo para que possa ser usado facilmente\nem uma recodificação.CUIDADO: O conjunto de dados exemplo não é o mesmo que uma exportação (como em Kobo você exporta diferentes níveis de questionários individualmente) -\nveja o seção de dados da pesquisa abaixo para fundir diferentes níveisO conjunto de dados é importado utilizando função import() pacote rio. Veja página Importar e exportação para outrasmaneiras de importar dados.primeiras 10 linhas da pesquisa são exibidas abaixo.Também queremos importar os dados sobre população de amostragem para que possamos produzir pesos adequados. Estes dados podem estar em diferentes formatos,\nentanto, sugerimos que seja como visto abaixo (podendo ser apenas digitado numa planilha).primeiras 10 linhas da pesquisa são exibidas abaixo.Para pesquisas de cluster (grupos, agregados) você pode querer adicionar pesos de pesquisa nível cluster. Você poderia ler estes\ndados como acima. Alternativamente, se houver apenas algumas contagens, estas poderiam ser inseridas como abaixo em um tibble (data frame com alguns ajustes\npara deixá-lo mais amigável). Em qualquer caso você precisará ter uma coluna com um identificador de cluster, que corresponde aos dados de sua pesquisa, e outra\ncoluna com o número de agregados familiares em cada grupo.","code":"\n# importar os dados da pesquisa\nsurvey_data <- rio::import(\"survey_data.xlsx\")\n\n# importar o dicionário para o R\nsurvey_dict <- rio::import(\"survey_dict.xlsx\") \n# importar os dados da população\npopulation <- rio::import(\"population.xlsx\")\n## definir o número de agregados familiares em cada cluster\ncluster_counts <- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))"},{"path":"survey-analysis.html","id":"limpar-dados","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"Limpar dados","text":"Abaixo, garantimos que coluna de datas esteja formato apropriado. Há várias outras maneiras de fazer isso (veja página Trabalhando com datas para mais detalhes), porém utilização dicionário para definir datas é rápida e fácil.Também criamos uma variável de faixa etária utilizando função age_categories() pacote epikit - veja seção limpeza de dados para mais detalhes. Além disso, criamos uma variável tipo caractere, que define em\nqual distrito se encontram os vários agrupamentos.Finalmente, recodificamos todas variáveis yes/(sim/não) para variáveis TRUE/FALSE (Verdadeiro/Falso) - caso contrário, estas não poderão ser utilizadas pelas funções de proporção survey.","code":"\n## selecione os nomes das variáveis de data no dicionário \nDATEVARS <- survey_dict %>% \n  filter(type == \"date\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filtro para corresponder aos nomes das colunas de seus dados\n  pull(name) # selecione variáveis de data\n  \n## mudança para data\nsurvey_data <- survey_data %>%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## adicionar aqueles com apenas idade em meses à variável ano (dividir por doze)\nsurvey_data <- survey_data %>% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## definir a variável de faixa etária\nsurvey_data <- survey_data %>% \n     mutate(age_group = epikit::age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## criar uma variável do tipo caractere baseada em grupos de uma variável diferente\nsurvey_data <- survey_data %>% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## selecionar nomes de variáveis yes/no do dicionário\nYNVARS <- survey_dict %>% \n  filter(type == \"yn\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filtro para corresponder aos nomes das colunas de seus dados\n  pull(name) # selecionar variáveis yn (yes/no)\n  \n## recodificação\nsurvey_data <- survey_data %>%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))"},{"path":"survey-analysis.html","id":"dados-da-pesquisa","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.3 Dados da pesquisa","text":"Existem inúmeras técnicas de amostragem que podem ser usados para pesquisas. Aqui demonstraremos o código para: - Estratificado -\nConglomerados (Cluster) - Estratificado e ConglomeradosComo descrito acima (dependendo de como você projeta seu questionário) os dados para cada nível seriam exportados como um conjunto separado de dados Kobo.\nEm nosso exemplo, há um nível para domicílio e um nível para indivíduos dentro desses domicílios.Estes dois níveis estão ligados por um identificador único. Para um conjunto de dados Kobo esta variável é “_index” nível de domicílios, que corresponde\nao “_parent_index” nível individual. Isto criará novas linhas para domicílio com cada indivíduo correspondente. Para maiores detalhes, veja seção manual sobre união de bases (https://epirhandbook.com/joining-data.html).","code":"\n## juntar os dados individuais e de domicílio para formar um conjunto completo de dados\nsurvey_data <- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## criar um identificador único, combinando as peças dos dois níveis \nsurvey_data <- survey_data %>% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))"},{"path":"survey-analysis.html","id":"tempo-de-observação","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.4 Tempo de observação","text":"Para pesquisas de mortalidade, queremos agora saber quanto tempo cada indivíduo esteve presente local, para podermos calcular um taxa de mortalidade para nosso\nperíodo de interesse. Isto não é relevante para todas, mas particularmente para pesquisas de mortalidade, isso é importante, pois são conduzidas frequentemente\nentre populações móveis ou deslocadas.Para isso, definimos primeiro nosso período de tempo de interesse, também conhecido como período de retordo, ou período de recall (.e. o tempo que os participantes\nsão instruídos se reportarem quando respondem perguntas). Podemos então utilizar este período para definir datas inadequadas para o ausência, ou seja, se mortes forem relatadas fora período de interesse.Podemos usar nossas variáveis de data para definir datas de inicio e fim para cada individuo. Usamos função find_start_date() sitrep para apurar causas\npara datas e depois usar isso para calcular diferença entre os dias (pessoa - tempo).Data de início: Primeiro evento de chegada apropriado dentro de seu período de recall, ou o início de seu período de recall (que você define em previamente), ou uma\ndata após o início recall, se aplicável (por exemplo chegadas ou nascimentos).Data final: Primeiro evento de partida apropriado dentro de seu período de recall, ou o final de seu período de recall, ou uma data antes final recall se\naplicável (por exemplo, partidas e mortes).","code":"\n## definir o início/fim do período de recall\n## pode ser alterado para variáveis de data do conjunto de dados \n## (por exemplo, questionário de data de chegada e data)\nsurvey_data <- survey_data %>% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# estabelecer datas inadequadas para NA com base em regras \n## por exemplo, chegadas antes do início, partidas após o fim\nsurvey_data <- survey_data %>%\n      mutate(\n           arrived_date = if_else(arrived_date < recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date < recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date > recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date > recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n## criar novas variáveis para datas/causas de início e fim\nsurvey_data <- survey_data %>% \n     ## escolher a data mais próxima informada na pesquisa\n     ## de nascimentos, chegadas ao domicílio e chegadas ao local\n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %>%\n     ## escolher a data mais próxima informada na pesquisa\n     ## das partidas do local, morte e fim do estudo\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## rotular aqueles que estavam presentes no início/fim (exceto nascimentos/mortes)\nsurvey_data <- survey_data %>% \n     mutate(\n       ## preencher a data de início para ser o início do período de recall (para aqueles vazios) \n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## definir a causa inicial para apresentar no início se for igual ao período de recall \n       ## a menos que seja igual à data de nascimento \n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## preencher a data final para ser o fim do período de recall (para aqueles vazios) \n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## definir a causa final a apresentar ao fim se for igual ao recall final \n       ## a menos que seja igual à data da morte\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Define o tempo de observação em dias\nsurvey_data <- survey_data %>% \n  mutate(obstime = as.numeric(enddate - startdate))"},{"path":"survey-analysis.html","id":"ponderação","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.5 Ponderação","text":"É importante que você remova observações errôneas antes de acrescentar pesos à pesquisa. Por exemplo, se você tiver registros com tempos de observação negativos,\nprecisará verificá-los (você pode fazer isso com funçãoassert_positive_timespan() pacote sitrep. Outra questão é se você quiser eliminar linhas vazias (por\nexemplo, com drop_na(uid)) ou remover duplicidades (consulte seção manual sobre Eliminando duplicidades para maiores detalhes). Aqueles sem consentimento\ntambém precisarão ser removidos.Neste exemplo, filtramos para os casos que queremos remover e os armazenamos em um data frame separado - desta forma podemos descrever aqueles que foram excluídos da\npesquisa. Em seguida, utilizamos função anti_join() dplyr para remover estes casos descartados de nossos dados de pesquisa.PERIGO: Você não pode ter valores ausentes em sua variável de peso, ou qualquer uma das variáveis relevantes para o projeto de sua pesquisa (por exemplo, idade, sexo, estratos ou variáveis de agrupamento).Como mencionado acima, demonstramos como adicionar pesos para três formas de amostragem (estratificado, conglomerado e conglomerado estratificado). Estas exigem informações sobre população de origem e/ou os aglomerados pesquisados. Usaremos o código “conglomerado estratificado” para este exemplo, mas escolha o que mais apropriado para seu modelo de estudo.","code":"\n## armazene os casos que deseja remover para que possa descrevê-los (por exemplo, sem consentimento) \n## ou local/cluster errados)\ndropped <- survey_data %>% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## usar os casos descartados para remover as linhas não utilizadas do conjunto de dados da pesquisa \nsurvey_data <- anti_join(survey_data, dropped, by = names(dropped))\n# estratificado ----------------------------------------------------------------\n# criar uma variável chamada \"surv_weight_strata\n# contém pesos para cada indivíduo - por faixa etária, sexo e distrito de saúde\nsurvey_data <- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## por conglomerados (cluster) ---------------------------------------------------------------------\n\n# obter o número de pessoas entrevistadas por domicílio\n# adiciona uma variável com contagens da variável de índice doméstico\nsurvey_data <- survey_data %>%\n  add_count(index, name = \"interviewed\")\n\n\n## criar pesos para o conglomerados (cluster)\nsurvey_data <- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# estratificado e conglomerado (cluster) ------------------------------------------------------\n# criar um peso de pesquisa para o cluster e os estratos\nsurvey_data <- survey_data %>%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)"},{"path":"survey-analysis.html","id":"objetos-de-delineamento-de-pesquisa","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.6 Objetos de delineamento de pesquisa","text":"Crie um objeto de pesquisa de acordo com seu projeto de estudo. Utilizado da mesma forma que os data frames para calcular proporções de peso etc.\nCertifique-se de que todas variáveis necessárias sejam criadas antes disso.Há quatro opções, comente aquelas que você não utiliza: - Aleatório simples - Estratificado - Conglomerado (cluster) - Conglomerado estratificadoPara este modelo - vamos fingir que agrupamos pesquisas em dois estratos separados (distritos de saúde e B). Portanto, para obter estimativas gerais, precisamos ter pesos combinados de conglomerados e estratos.Como mencionado anteriormente, há dois pacotes disponíveis para fazer isto. O clássico é o survey e depois há um pacote de “roupagem” (wrapper) chamado\nsrvyr que torna os objetos e funções mais fáceis de arrumar. Demonstraremos ambos, mas observe que maioria dos códigos neste capítulo utilizará objetos\nbaseados srvyr. única exceção é que o pacote gtsummary só aceita objetos survey.","code":""},{"path":"survey-analysis.html","id":"pacote-survey","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.6.1 Pacote survey","text":"O pacote survey utiliza, forma eficaz, codificação em R base, e por isso não é possível utilizar os pipes (%>%) ou outra sintaxe dplyr.\nCom o pacote survey, utilizamos função svydesign() para definir um objeto de pesquisa com agrupamentos (cluster), pesos e estratificações apropriados.NOTA: precisamos utilizar o til (~) em frente às variáveis, pois o pacote usa sintaxe R base para atribuição variáveis baseada em fórmulas.","code":"\n# aleatório simples ------------------------------------------------------------\nbase_survey_design_simple <- svydesign(ids = ~1, # 1 para nenhuma identificação de cluster\n                   weights = NULL,               # sem adição de pesos\n                   strata = NULL,                # amostragem simples (não estratificada)\n                   data = survey_data            # especificar a base de dados\n                  )\n\n## estratificado ---------------------------------------------------------------\nbase_survey_design_strata <- svydesign(ids = ~1,  # 1 para nenhuma identificação de cluster\n                   weights = ~surv_weight_strata, # variável de peso criada acima\n                   strata = ~health_district,     # amostragem estratificada por distrito\n                   data = survey_data             # especificar a base de dados\n                  )\n\n# conglomerado ---------------------------------------------------------------------\nbase_survey_design_cluster <- svydesign(ids = ~village_name, # identificação do cluster\n                   weights = ~surv_weight_cluster, # variável de peso criada acima\n                   strata = NULL,                 # amostragem simples (não estratificada)\n                   data = survey_data              # especificar a base de dados\n                  )\n\n# conglomerado estratificado --------------------------------------------------------\nbase_survey_design <- svydesign(ids = ~village_name,      # identificação do conglomerado\n                   weights = ~surv_weight_cluster_strata, # variável de peso criada acima\n                   strata = ~health_district,             # amostragem estratificada por distrito\n                   data = survey_data                     # especificar a base de dados\n                  )"},{"path":"survey-analysis.html","id":"pacote-srvyr","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.6.2 Pacote srvyr","text":"Com o pacote srvyr* podemos utilizar função as_survey_design(), que tem os mesmos argumentos exemplificados acima, mas permite pipes (%>%),\ne assim não precisamos utilizar o til (~).","code":"\n# aleatório simples ------------------------------------------------------------\nsurvey_design_simple <- survey_data %>% \n  as_survey_design(ids = 1, # 1 para nenhuma identificação de cluster\n                   weights = NULL, # sem adição de pesos\n                   strata = NULL # amostragem simples (não estratificada)\n                  )\n## estratificado ---------------------------------------------------------------\nsurvey_design_strata <- survey_data %>%\n  as_survey_design(ids = 1, # 1 para nenhuma identificação de cluster\n                   weights = surv_weight_strata, # variável de peso criada acima\n                   strata = health_district # amostragem estratificada por distrito\n                  )\n## cluster ---------------------------------------------------------------------\nsurvey_design_cluster <- survey_data %>%\n  as_survey_design(ids = village_name, # identificação do cluster\n                   weights = surv_weight_cluster, # variável de peso criada acima\n                   strata = NULL # amostragem simples (não estratificada)\n                  )\n\n# cluster estratificado --------------------------------------------------------\nsurvey_design <- survey_data %>%\n  as_survey_design(ids = village_name, # identificação do cluster\n                   weights = surv_weight_cluster_strata, # variável de peso criada acima\n                   strata = health_district # amostragem estratificada por distrito\n                  )"},{"path":"survey-analysis.html","id":"análise-descritiva","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.7 Análise descritiva","text":"análise descritiva básica e visualização são amplamente cobertas em outros capítulos manual, portanto, não vamos nos deter aqui. Para detalhes veja os\ncapítulos Tabelas Descritivas, Testes Estatísticos,\nTabelas para Apresentação,Introdução ao ggplot e Relatórios em R markdown.Nesta seção, vamos nos concentrar em como investigar o viés em sua amostra e em como visualizá-lo. Também vamos visualizar o fluxo populacional em um ambiente de pesquisa usando diagramas aluviais/sankey.Em geral, você deve considerar incluir seguintes análises descritivas:Número final de agrupamentos, domicílios e indivíduos incluídos.Número de indivíduos excluídos e os motivos de exclusãoNúmero médio (intervalo) de domicílios por agrupamento e de indivíduos por doméstico","code":""},{"path":"survey-analysis.html","id":"viés-de-amostras","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.7.1 Viés de amostras","text":"Compare proporções em cada faixa etária entre sua amostra e população de origem. Isto é importante para poder destacar um potencial viés de amostragem.\nDa mesma forma, você poderia repetir esta análise nas distribuições por sexo.Note que estes p-valores são apenas indicativos e uma discussão descritiva (ou visualização em pirâmides etárias abaixo) dadistribuições de sua amostra de estudo,\nem comparação com população de origem, é mais importante que o próprio teste binomial. Isto se deve ao fato de que o tamanho da amostra levará, na maioria\ndas vezes, diferenças que podem ser irrelevantes após ponderação dos dados.","code":"\n## contagem e proporção da população estudada\nag <- survey_data %>% \n  group_by(age_group) %>% \n  drop_na(age_group) %>% \n  tally() %>% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## contagem e proporção da população original\npropcount <- population %>% \n  group_by(age_group) %>%\n    tally(population) %>%\n    mutate(proportion = n / sum(n))\n\n## unir as colunas de duas tabelas, agrupar por idade, e executar um \n## teste binomial para ver se n/total é significativamente diferente da \n## proporção populacional.\n  ## sufixo aqui adicionado ao texto no final das colunas em cada um dos dois \n  ## conjuntos de dados\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %>%\n  group_by(age_group) %>%\n  ## broom::tidy(binom.test()) faz um data frame a partir do teste binomial e\n  ## adicionará as variáveis p.value (p-valor), parameter (parâmetro), \n  ## conf.low (intervalo de confiança inferior), method (método, o tipo de teste),\n  ## conf.high (intervalo de confiança superior) e alternative (alternativa à hipotese nula).\n  ## Aqui usaremos apenas p.value. Você pode incluir outras colunas se quiser\n  ## informar intervalos de confiança\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%\n  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %>%\n  ## Ajustando os p-valor para corrigir os falsos positivos \n  ## (testando várias faixas etárias). Isto só fará diferença\n  ## se você tem muitas categorias etárias\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %>%\n                      \n  ## somente mostrar o p-valor acima de  0.001 (inferiores, mostrar como 0.001)\n  mutate(p.value = ifelse(p.value < 0.001, \n                          \"<0.001\", \n                          as.character(round(p.value, 3)))) %>% \n  \n  ## renomear as colunas de forma apropriada\n  select(\n    \"Faixa-etária\" = age_group,\n    \"População de estudo (n)\" = n,\n    \"População de estudo (%)\" = proportion,\n    \"População fonte (n)\" = n_pop,\n    \"População fonte (%)\" = proportion_pop,\n    \"P-valor\" = p.value\n  )## # A tibble: 5 × 6\n## # Groups:   Faixa-etária [5]\n##   `Faixa-etária` `População de estudo (n)` `População de estudo (%)` `População fonte (n)`\n##   <chr>                              <int>                     <dbl>                 <dbl>\n## 1 0-2                                   12                    0.0256                  1360\n## 2 3-14                                  42                    0.0896                  7244\n## 3 15-29                                 64                    0.136                   5520\n## 4 30-44                                 52                    0.111                   3232\n## 5 45+                                  299                    0.638                   2644\n## # ℹ 2 more variables: `População fonte (%)` <dbl>, `P-valor` <chr>"},{"path":"survey-analysis.html","id":"pirâmides-demográficas","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.7.2 Pirâmides demográficas","text":"pirâmides demográficas (ou de idade-sexo) são uma maneira fácil de visualizar distribuição em sua população pesquisada. Também vale pena considerar criação\nde Tabelas Descritivas de idade e sexo por estratos de pesquisa. Demonstraremos utilizando o pacote apyramid,\npois ele permite proporções ponderadas utilizando nosso objeto de pesquisa criado acima. Outras opções para criar Pirâmides Demográficas são amplamente cobertas nesse capítulo manual. Também utilizaremos uma função wrapper da\napyramid chamada age_pyramid() que economiza algumas linhas de código para produzir um gráfico comproporções.Como teste binomial formal de diferença, visto acima na seção de viés de amostragem, estamos interessados aqui em visualizar se nossa população amostrada é\nsubstancialmente diferente da população original e se ponderação corrige esta diferença. Para isso, usaremos o pacote patchwork para mostrar nossas visualizações ggplot lado lado; para detalhes, veja seção sobre combinação de lotes capítulo dicas ggplot manual. Visualizaremos nossa população original, nossa população não ponderada de pesquisa e nossa população ponderada de pesquisa. Você\ntambém pode considerar visualização por cada estrato de sua pesquisa - em nosso exemplo aqui, isso seria utilizando o argumento\nstack_by = \"health_district\" (veja `?age_pyramid’ para detalhes).NOTA: Os eixos x e y são invertidos em pirâmides","code":"\n## definir limites e rótulos do eixo x -----------------------------------------\n## (atualize estes números para serem os valores adequado ao seu gráfico)\nmax_prop <- 35      # escolha a maior proporção que quer mostrar\nstep <- 5           # escolha o espaço que quer mostrar entre as legendas\n\n## esta parte define o vetor usando os números acima com quebras de eixo\nbreaks <- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## esta parte define o vetor usando os números acima com limites de eixo\nlimits <- c(max_prop/100 * -1, max_prop/100)\n\n## esta parte define o vetor usando os números acima com legendas de eixo\nlabels <-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## criar gráficos individualmente ---------------------------------------------\n\n## Traçar a população de original \n## nb: precisa de ser comprimido para a população em geral (isto é, removendo distritos de saúde)\nsource_population <- population %>%\n  ## garantir que a idade e o sexo sejam fatores\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %>% \n  group_by(age_group, sex) %>% \n  ## somar as contagens para cada distrito sanitário em conjunto\n  summarise(population = sum(population)) %>% \n  ## remover o agrupamento para poder calcular a proporção total\n  ungroup() %>% \n  mutate(proportion = population / sum(population)) %>% \n  ## exibir a pirâmide \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## mostrar apenas a legenda do eixo y (caso contrário será repetida nos três gráficos)\n  labs(title = \"População de origem\", \n       y = \"\", \n       x = \"Faixa-etária (anos)\") + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## Traçar a população não ponderada da amostra \nsample_population <- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## mostrar apenas a legenda do eixo x (caso contrário será repetida nos três gráficos)\n  labs(title = \"População amostrada sem ponderação\", \n       y = \"Proporção (%)\", \n       x = \"\") + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## Traçar a população de amostra ponderada \nweighted_population <- survey_design %>% \n  ## garantir que as variáveis sejam fatores\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %>%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## mostrar apenas a legenda do eixo x (caso contrário será repetida nos três gráficos)\n  labs(title = \"População amostrada ponderada\", \n       y = \"\", \n       x = \"\")  + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## ccombinar os três gráficos   ------------------------------------------------\n## combinar três gráficos próximos uns aos outros usando + \nsource_population + sample_population + weighted_population + \n  ## mostrar apenas uma legenda e definir o tema\n  ## observe o uso de & para combinar o tema com o plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # mover legenda para baixo\n        legend.title = element_blank(),                # remover o título\n        text = element_text(size = 18),                # dimensionar o texto\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # girar texto do eixo x\n       )"},{"path":"survey-analysis.html","id":"diagrama-aluvialsankey","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.7.3 Diagrama aluvial/sankey","text":"visualização de pontos de partida e resultados para indivíduos pode ser muito útil para se ter uma visão geral. Há uma aplicação bastante óbvia para populações\nmóveis, porém existem inúmeras outras aplicações, tais como coortes ou qualquer outra situação em que há transições nos estados para indivíduos. Estes diagramas são\nconhecidos por vários nomes diferentes, incluindo aluvial, sankey e conjuntos paralelos - os detalhes estão capítulo sobre Diagramas e Gráficos.","code":"\n## resuma os dados \nflow_table <- survey_data %>%\n  count(startcause, endcause, sex) %>%  # faz contagem\n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # muda o formato para gráfico\n\n\n## trace um gráfico \n  ## no eixo x estão as causas do início e fim\n  ## a função gather_set_datagera um ID para cada combinação\n  ## dividindo (splitting) pelo y te da um combo de possibilidades de início/fim \n  ## valor (value) como \"n\" fornece a contagem (também pode ser usado com proporção)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ##linhas coloridas segundo sexo\n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## preenche as caixas de rotulagem com cinza\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## muda a cor do tetxo e ângulo (precisa ser ajustado)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## remove rótulos dos eixos\n  theme_void()+\n  ## move a legenda para baixo\n  theme(legend.position = \"bottom\")               "},{"path":"survey-analysis.html","id":"proporções-ponderadas","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.8 Proporções ponderadas","text":"Esta seção detalha como produzir tabelas para contagens e proporções ponderadas, com os intervalos de confiança associados e delineamento.\nExistem quatro opções diferentes, utilizando funções dos seguintes pacotes: survey, srvyr, sitrep e gtsummary. Para para\nproduzir uma tabela de estilo epidemiológico padrão com mínimo de código, nós recomendamos função sitrep - que é um wrapper para códigos srvyr; note,\nentretanto, que isso ainda não está CRAN e pode mudar futuro. Caso contrário, o código survey será provavelmente o mais estável longo prazo, enquanto\nsrvyr caberá melhor dentro fluxos de trabalho. Embora funções gtsummary tenham um grande potencial, elas parecem ser experimentais e incompletas\nmomento em que da escrita deste manual.","code":""},{"path":"survey-analysis.html","id":"pacote-survey-1","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.8.1 Pacote survey","text":"Podemos utilizar função svyciprop() survey para obter proporções ponderadas e intervalos de confiança de 95%. Um delineamento apropriado pode ser extraído\nutilizando o svymean() em vez da função svyprop(). Vale notar que função svyprop() parece apenas aceitar variáveis entre 0 e 1 (ou TRUE/FALSE), então, variáveis categóricas não funcionarão.NOTA: Funções survey também aceitam objetos srvyr mas aqui usamos o objeto de delineamento survey apenas por uma questão de consistênciaPodemos combinar funções de survey mostradas acima em um função chamada svy_prop; e podemos então utilize essa função junto com o map() pacote purrr\npara repetir sobre várias variáveis e criar uma tabela. Veja o capítulo Iterações e loops para mais detalhes \npacote purrr.","code":"\n##  produção contagens ponderadas \nsvytable(~died, base_survey_design)## died\n##      FALSE       TRUE \n## 1406244.43   76213.01\n##  produção proporções ponderadas \nsvyciprop(~died, base_survey_design, na.rm = T)##               2.5% 97.5%\n## died 0.0514 0.0208  0.12\n## obtem o efeito de delineamento  \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %>% \n  deff()## diedFALSE  diedTRUE \n##  3.755508  3.755508\n# Definir função para calcular contagens ponderadas, proporções, IC e efeito de delineamento\n# x é a variável entre aspas \n# O delineamento é seu objeto de desenho de pesquisa\n\nsvy_prop <- function(design, x) {\n  \n  ## colocar as variáveis de interesse em uma fórmula\n  form <- as.formula(paste0( \"~\" , x))\n  ## manter apenas a coluna TRUE do svytable\n  weighted_counts <- svytable(form, design)[[2]]\n  ## calcular proporções (multiplicar por 100 para obter porcentagens)\n  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100\n  ## extrair os intervalos de confiança e multiplicar para obter porcentagens\n  weighted_confint <- confint(weighted_props) * 100\n  ## use svymean para calcular o efeito do delinemanto e mantenha apenas a coluna TRUE\n  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## combinar em um único dataframe\n  full_table <- cbind(\n    \"Variável\"        = x,\n    \"Contagens\"           = weighted_counts,\n    \"Proporção\"      = weighted_props,\n    weighted_confint, \n    \"Efeito de delineamento\"   = design_eff\n    )\n  \n  ## retorna tabela como um dataframe\n  full_table <- data.frame(full_table, \n             ## remover os nomes das variáveis das linhas (é uma coluna separada agora)\n             row.names = NULL)\n  \n  ## mudar números de volta ao formato numérico\n  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])\n  \n  ## retornar o dataframe\n  full_table\n}\n\n## repetir em diversar variáveis para criar uma tabela  \npurrr::map(\n  ## definir variáveis de interesse\n  c(\"left\", \"died\", \"arrived\"), \n  ## função de estado usando e argumentos para essa função (delineamento)\n  svy_prop, design = base_survey_design) %>% \n  ## fundir lista em um único data frame\n  bind_rows() %>% \n  ## arredondar \n  mutate(across(where(is.numeric), round, digits = 1))##   Variável Contagens Proporção X2.5. X97.5. Efeito.de.delineamento\n## 1     left  701199.1      47.3  39.2   55.5                    2.4\n## 2     died   76213.0       5.1   2.1   12.1                    3.8\n## 3  arrived  761799.0      51.4  40.9   61.7                    3.9"},{"path":"survey-analysis.html","id":"pacote-srvyr-1","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.8.2 Pacote srvyr","text":"Com srvyr podemos usar sintaxe dplyr para criar uma tabela. Note que função survey_mean() é utilizada e o argumento da proporção é especificado, e\ntambém que mesma função é utilizada para calcular o efeito delineamento. Isto porque srvyr envolve ambas funções pacote survey svyciprop()\ne svymean(), que são utilizadas na seção acima.NOTA: Não parece ser possível obter proporções partir de variáveis categóricas utilizando srvyr, se você precisar disto então verifique seção abaixo usando sitrepTambém aqui poderíamos escrever uma função para então reiterar sobre múltiplas variáveis usando o pacote purrr. Veja o capítulo manual Iterações e loops para detalhes sobre purrr.","code":"\n## usar o objeto delineado srvyr\nsurvey_design %>% \n  summarise(\n    ## produzir as contagens ponderadas\n    counts = survey_total(died), \n    ## produzir proporções ponderadas e intervalos de confiança \n    ## multiplicar por 100 para obter uma porcentagem \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produzir o efeito de delineamento\n    deff = survey_mean(died, deff = TRUE)) %>% \n  ## manter apenas as fileiras de interesse\n  ## (remove erros padrão e repete o cálculo de proporção)\n  select(counts, props, props_low, props_upp, deff_deff)## # A tibble: 1 × 5\n##   counts props props_low props_upp deff_deff\n##    <dbl> <dbl>     <dbl>     <dbl>     <dbl>\n## 1 76213.  5.14      2.08      12.1      3.76\n# definir função para calcular contagens ponderadas, proporções, IC e delineamento\n# o desenho é seu objeto de desenho de pesquisa\n# x é a variável entre aspas \n\n\nsrvyr_prop <- function(design, x) {\n  \n  summarise(\n    ## usando o objeto delimitado de pesquisa\n    design, \n    ## produzir as contagens ponderadas\n    counts = survey_total(.data[[x]]), \n    ## produzir as proporções e intervalos de confiaça ponderados\n    ## multiplicar por 100 para obter uma porcentagem \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produzir o efeito de delineamento\n    deff = survey_mean(.data[[x]], deff = TRUE)) %>% \n  ## adicionar na variável de nome\n  mutate(variable = x) %>% \n  ## manter apenas as linhas de interesse\n  ## (remove erros padrão e repete o cálculo de proporção)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## reitera em diferentes variáveis para criar uma tabela\npurrr::map(\n  ## define  as variáveis de interesse\n  c(\"left\", \"died\", \"arrived\"), \n  ## função *state* e argumentos para essa função (delineamento)\n  ~srvyr_prop(.x, design = survey_design)) %>% \n  ## unificar lista em uma única data frame\n  bind_rows()## # A tibble: 3 × 6\n##   variable  counts props props_low props_upp deff_deff\n##   <chr>      <dbl> <dbl>     <dbl>     <dbl>     <dbl>\n## 1 left     701199. 47.3      39.2       55.5      2.38\n## 2 died      76213.  5.14      2.08      12.1      3.76\n## 3 arrived  761799. 51.4      40.9       61.7      3.93"},{"path":"survey-analysis.html","id":"pacote-sitrep","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.8.3 Pacote sitrep","text":"função tab_survey() de sitrep é um wrapper para srvyr, permitindo criação de tabelas ponderadas com codificação mínima.\nTambém permite calcular proporções ponderadas para variáveis categóricas.","code":"\n    ## usando o objeto delimitado de pesquisa\nsurvey_design %>% \n  ## passe os nomes das variáveis de interesse não cotadas\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # calcular o efeito de delineamento\n             pretty = TRUE  # fundir proporção e intervalo de confiança 95%\n             )## Warning: removing 257 missing value(s) from `education_level`## # A tibble: 9 × 5\n##   variable        value            n  deff ci               \n##   <chr>           <chr>        <dbl> <dbl> <chr>            \n## 1 arrived         TRUE       761799.  3.93 51.4% (40.9-61.7)\n## 2 arrived         FALSE      720658.  3.93 48.6% (38.3-59.1)\n## 3 left            TRUE       701199.  2.38 47.3% (39.2-55.5)\n## 4 left            FALSE      781258.  2.38 52.7% (44.5-60.8)\n## 5 died            TRUE        76213.  3.76 5.1% (2.1-12.1)  \n## 6 died            FALSE     1406244.  3.76 94.9% (87.9-97.9)\n## 7 education_level higher     171644.  4.70 42.4% (26.9-59.7)\n## 8 education_level primary    102609.  2.37 25.4% (16.2-37.3)\n## 9 education_level secondary  130201.  6.68 32.2% (16.5-53.3)"},{"path":"survey-analysis.html","id":"pacote-gtsummary","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.8.4 Pacote gtsummary","text":"Com gtsummary não parece haver ainda funções embutidas para acrescentar intervalos de confiança ou efeito de delineamento. Aqui mostramos como definir uma função\npara adicionar intervalos de confiança e depois adicionar intervalos de confiança uma tabela gtsummary criada utilizando função tbl_svysummary().","code":"\nconfidence_intervals <- function(data, variable, by, ...) {\n  \n  ## extrair os intervalos de confiança e multiplicar para obter porcentagens\n  props <- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## extrair os intervalos de confiança \n  as.numeric(confint(props) * 100) %>% ## transformar em número e multiplicar para obter o percentual\n    round(., digits = 1) %>%           ## arredondar para um dígito\n    c(.) %>%                           ## ## extrair os números da matriz\n    paste0(., collapse = \"-\")          ## combinar para caracter único\n}\n\n## usando o objeto delimitado do pacote survey\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## definir variáveis a serem incluídas\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %>% ## definir estatísticas de interesse\n  add_n() %>%  ## adicionar o peso total\n  add_stat(fns = everything() ~ confidence_intervals) %>% ## adicionar intervalos de confiança\n  ## modificar títulos das colunas\n  modify_header(\n    list(\n      n ~ \"**Total ponderado (N)**\",\n      stat_0 ~ \"**Contagem ponderada**\",\n      add_stat_1 ~ \"**95%IC**\"\n    )\n    )"},{"path":"survey-analysis.html","id":"razões-ponderadas","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.9 Razões ponderadas","text":"Da mesma forma, para relações ponderadas (como para relações de mortalidade) você pode usar o pacote survey ou o pacote srvyr.\nVocê poderia escrever funções (semelhantes àquelas acima) para iterar sobre várias variáveis. Você também poderá criar uma função para o pacote gtsummary,\ncomo acima, mas atualmente ela não tem nenhuma funcionalidade embutida.","code":""},{"path":"survey-analysis.html","id":"pacote-survey-2","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.9.1 Pacote survey","text":"","code":"\nratio <- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci <- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)##       obstime    2.5 %   97.5 %\n## died 5.981922 1.194294 10.76955"},{"path":"survey-analysis.html","id":"pcaote-srvyr","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.9.2 Pcaote srvyr","text":"","code":"\nsurvey_design %>% \n  ## razão de pesquisa usada para contabilizar o tempo de observação \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )## # A tibble: 1 × 3\n##   mortality mortality_low mortality_upp\n##       <dbl>         <dbl>         <dbl>\n## 1      5.98         0.349          11.6"},{"path":"survey-analysis.html","id":"referência","chapter":"1 Analises de pesquisa de questionários (survey)","heading":"1.10 Referência","text":"Página de estatísticas da UCLAAnalise dados de questioários gratuitamentePacote srvyrPacote gtsummaryEstudo de caso da pesquisa EPIET","code":""},{"path":"epicurves.html","id":"epicurves","chapter":"2 Curvas epidêmicas","heading":"2 Curvas epidêmicas","text":"Uma curva epidêmica (também conhecida como “epicurva”) é uma ferramenta essencial tipicamente utilizada para visualizar padrões temporais início de doenças entre um conjunto ou epidemia de casos.análise da epicurva pode revelar tendências temporais, anomalias/valores discrepantes (“outliers”), magnitude de um surto, o período mais provável de exposição, intervalos temporais entre picos de casos, e pode até ajudar identificar o modo de transmissão de uma doença não identificada (ex.: fonte pontual, fonte comum contínua, propagação pessoa-pessoa). Uma aula online sobre interpretação de epicurvas pode ser encontrada website CDC americano.Nesta página, nós demonstraremos duas abordagens para produção de curvas epidêmicas R:O pacote incidence2, que pode produzir uma epicurva com comandos simplesO pacote ggplot2, que permite customizações avançadas através de comandos mais complexosTambém serão abordados casos de uso específico:Criar gráficos de contagem agregadaMostrar ou produzir múltiplos-pequenosAplicar médias móveisMostrar quais dados são “preliminares” ou sujeitos atrasos na notificaçãoSobreposição da incidência acumulada de casos usando um segundo eixo gráfico","code":""},{"path":"epicurves.html","id":"preparação-1","chapter":"2 Curvas epidêmicas","heading":"2.1 Preparação","text":"","code":""},{"path":"epicurves.html","id":"carregue-os-pacotes-necessários","chapter":"2 Curvas epidêmicas","heading":"Carregue os pacotes necessários","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.","code":"\npacman::p_load(\n  rio,          # importar/exportar arquivos\n  here,         # caminhos de arquivos relativos \n  lubridate,    # trabalhando com datas/semanas epidemiológicas\n  aweek,        # pacote alternativo para trabalhar com datas/semanas epidemiológicas\n  incidence2,   # epicurvas de dados em uma linelist\n  i2extras,     # suplemento para o pacote incidence2\n  stringr,      # procure e manipule strings de caracteres\n  forcats,      # trabalhando com fators\n  RColorBrewer, # paleta de cores do colorbrewer2.org\n  tidyverse     # gerenciamento de dados + gráficos no ggplot2\n) "},{"path":"epicurves.html","id":"importe-os-dados","chapter":"2 Curvas epidêmicas","heading":"Importe os dados","text":"Dois exemplos de conjuntos de dados são utilizados nesta seção:Lista de linhas (linelist) com casos individuais de uma simulação de epidemiaContagens agregadas por hospital da mesma epidemia simuladaOs conjuntos de dados são importados utilizando função import() pacote rio. Veja página sobre Importar e exportar para conhecer diferentes formas de importar dados.Lista de linhas de casosNós importamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser baixar os dados para acompanhar etapa-por-etapa, veja instruções na página sobre Download manual e dados. Aqui, nós assumimos que o arquivo está diretório de trabalho. Logo, nenhuma sub-pasta é especificada endereço arquivo.primeiras 50 linhas são mostradas abaixo.Casos agregados por hospitalPara atingir os propósitos deste manual, o conjunto de dados de contagens semanais de casos agregados por hospital é criado partir da linelist, com o seguinte código.primeiras 50 linhas são mostradas abaixo:","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")\n# cria os dados de contagem no R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()"},{"path":"epicurves.html","id":"ajuste-os-parâmetros","chapter":"2 Curvas epidêmicas","heading":"Ajuste os parâmetros","text":"Para produzir um relatório, você pode querer ajustar parâmetros modificáveis, como data para qual os dados são atuais (“data dos dados”). Você pode, então, referenciar o objeto data_date em seu código ao aplicar filtros ou em legendas dinâmicas.","code":"\n## ajuste a data do relatório para o relatório\n## nota: pode ser ajustada para Sys.Date() para a data atual\ndata_date <- as.Date(\"2015-05-15\")"},{"path":"epicurves.html","id":"verifique-as-datas","chapter":"2 Curvas epidêmicas","heading":"Verifique as datas","text":"Perceba que cada coluna de datas relevantes é da classe Date e tem um intervalo apropriado de valores. Você pode fazer isso simplesmente utilizando hist(), para histograma, ou range() com na.rm=TRUE, ou com o ggplot(), como mostrado abaixo.","code":"\n# cheque o intervalo das datas de início dos sintomas\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))"},{"path":"epicurves.html","id":"epicurvas-no-ggplot2","chapter":"2 Curvas epidêmicas","heading":"2.2 Epicurvas no ggplot2","text":"Utilizar o ggplot() para criar sua epicurva permite mais flexibilidade e customização. Entretanto, é necessário mais esforço e entendimento sobre como o ggplot() funciona.Diferente pacote incidence2, ggplot você precisa controlar manualmente agregação dos casos pelo tempo (em semanas, meses, etc) e os intervalos dos rótulos eixo de data. Isto precisa ser cuidadosamente gerenciado.Os exemplos abaixo utilizam um subconjunto banco de dados linelist - apenas os casos Hospital Central.Para produzir uma epicurva com o ggplot(), existem três elementos principais:Um histograma, com os casos da linelist agregados em “classes” (Nota tradutor: tradução livre de ´bins´, que em inglês significa caixa, ou container) separados por pontos “de quebra” específicosEscalas para os eixos e seus rótulosTemas para aparência gráfico, incluindo títulos, rótulos, legendas, etc.","code":"\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")"},{"path":"epicurves.html","id":"especifique-as-classes-de-casos","chapter":"2 Curvas epidêmicas","heading":"Especifique as classes de casos","text":"Aqui nós mostramos como especificar maneira em que os casos serão agregados nas classes histogramas (“barras”). É importante reconhecer que o agrupamento dos casos nessas classes histograma não será necessariamente nos mesmos intervalos das datas que irão aparecer eixo x.seguir é mostrado, provavelmente, o código mais simples para produzir epicurvas diárias ou semanais.comando global ggplot(), o conjunto de dados é fornecido em data =. partir disto, geometria histrograma é adicionada com um +. Dentro de geom_histogram(), nós mapeamos aparência gráfico de forma que coluna date_onset é mapeada para o eixo x. Também dentro de geom_histogram(), mas não dentro de aes(), nós ajustamos o binwidth = dos containers histobrama, em dias. Se essa sintaxe ggplot2 é confusa, revise página sobre básico ggplot.CUIDADO: Criar um gráfico de casos semanas ao utilizar binwidth = 7 inicia o primeiro container de 7-dias primeiro caso, que pode ser em qualquer dia da semana! Para criar semanas específicas, veja seção abaixo.Deixe-nos observar que o primeiro caso neste conjunto de dados Hospital Central teve o início dos sintomas em:Para especificar manualmente quebras das classes histograma, não utilize o argumento binwidth =, e, em vez disso, forneça um vetor de datas para breaks =.Crie o vetor de datas com função seq.Date() R base. Esta função precisa dos argumentos =, =, e =. Por exemplo, o comando abaixo retorna datas mensais começando em 15 de janeiro e terminando em 28 de junho.Este vetor pode ser fornecido para geom_histogram() como breaks =:Uma sequência semanal simples pode ser obtida ao ajustar = \"week\". Por exemplo:Uma alternativa para o fornecimento de datas específicas de início e fim, é escrever um código dinâmico de forma que classes semanais iniciem na segunda antes primeiro caso. Nós iremos utilizar estes vetores de data nos exemplos abaixo.Vamos destrinchar o código complicado mostrado acima:O valor “” (data mais antiga da sequência) é criado da seguinte forma: menor data (min() com na.rm=TRUE) na coluna date_onset é atribuída floor_date(), pacote lubridate. floor_date() é ajustada para gerar “semanas” partir da data de início dos casos da “semana” em questão, considerando que o dia de início de cada semana é segunda (week_start = 1).Da mesma forma, o valor “” (data final da sequência) é criado utilizando função inversa ceiling_date() para retornar segunda após o último caso.O argumento “” de seq.Date() pode ser ajustado para qualquer número de dias, semanas, ou meses.Utilize week_start = 7 para semanas que iniciem DomingoComo iremos utilizar estes vetores de data nesta página, nós também definimos um vetor para o surto inteiro (o vetor acima é apenas para os casos Hospital Central).Estas saídas seq.Date() podem ser usadas para criar quebras de classes histogramas, assim como quebras para os rótulos de data, que podem ser independentes das primeiras. Leia mais sobre os rótulos de datas em seções posteriores.DICA: Para um comando ggplot() mais simples, salve quebras das classes e quebras dos rótulos de datas como vetores nomeados começo, e simplesmente os forneça em breaks =.","code":"\n# diariamente \nggplot(data = central_data) +          # escolha os dados\n  geom_histogram(                      # adicione o histograma\n    mapping = aes(x = date_onset),     # mapeia a coluna de data para o eixo x\n    binwidth = 1)+                     # casos unidos por 1 dia\n  labs(title = \"Hospital Central - Diariamente\")                # título\n\n# semanal\nggplot(data = central_data) +          # escolha os dados \n  geom_histogram(                      # adicione o histograma\n      mapping = aes(x = date_onset),   # mapeia a coluna de data para o eixo x\n      binwidth = 7)+                   # casos unidos a cada 7 dias, iniciando no primeiro caso (!)\n  labs(title = \"Hospital Central - classes de 7-dias, iniciando no primeiro caso\") # título\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")## [1] \"Thursday 01 May, 2014\"\nmonthly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # exporta para o console##  [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\" \"2014-07-01\"\n##  [7] \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\" \"2014-12-01\" \"2015-01-01\"\n## [13] \"2015-02-01\" \"2015-03-01\" \"2015-04-01\" \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n# mensalmente \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # forneça um vetor pré-definido de quebras\n  labs(title = \"Classe de casos mensais\")   # título\nweekly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n# Sequência de datas semanais iniciando nas Segundas para o HOSPITAL CENTRAL\nweekly_breaks_central <- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # segunda anterior\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # segunda após o último caso\n  by   = \"week\")\n# Sequência para o surto inteiro\nweekly_breaks_all <- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # segunda antes do primeiro caso\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # segunda após o último caso\n  by   = \"week\")"},{"path":"epicurves.html","id":"exemplo-de-epicurva-semanal","chapter":"2 Curvas epidêmicas","heading":"Exemplo de epicurva semanal","text":"Abaixo esta detalhado um exemplo de código utilizado para produzir epicurvas semanais para semanas que iniciam nas segundas, com barras alinhadas, rótulos de data, e linhas de grade verticais. Esta seção é para o usuário que precisa rapidamente de um código. Para entender cada aspecto (temas, rótulos de datas, etc.) profundamente, continue para seções subsequentes. De nota:quebras dos containers histograma são definidas com seq.Date(), como explicado acima, para iniciar na segunda anterior ao primeiro caso, e para terminar na segunda posterior ao último casoO intervalo dos rótulos de data é especificado por date_breaks = dentro de scale_x_date()O intervalo de linhas da grade vertical menores entre os rótulos de data é especificado em date_minor_breaks =expand = c(0,0) nas escalas de x e y remove o excesso de espaço em cada lado dos eixos, o que também garante que os rótulos de data iniciem partir da primeira barra.","code":"\n# ALINHAMENTO TOTAL A PARTIR DAS SEGUNDAS-FEIRAS\n#############################\n# Defina a sequência de quebras semanais\nweekly_breaks_central <- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Segunda antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Segunda após último caso\n      by   = \"week\")    # containers são de 7-dias\n\n\nggplot(data = central_data) + \n  \n  # crie o histograma: especifique os pontos de quebra do container: inicie na segunda antes do primeiro caso, termine na segunda após o último caso\n  geom_histogram(\n    \n    # mapeando a estética do gráfico\n    mapping = aes(x = date_onset),  # coluna de data mapeada para o eixo x\n    \n    # quebras da classe do histograma\n    breaks = weekly_breaks_central, # quebras do container do histograma definidas anteriormente\n    \n    # barras\n    color = \"darkblue\",     # cor das linhas ao redor das barras\n    fill = \"lightblue\"      # cor do preenchimento das barras\n  )+ \n    \n  # rótulos do eixo x\n  scale_x_date(\n    expand            = c(0,0),           # remove o espaço em excesso do eixo x antes e após as barras de casos\n    date_breaks       = \"4 weeks\",        # rótulos de data e principais linhas de grade verticais aparecem a cada 3 semanas iniciando nas segundas\n    date_minor_breaks = \"week\",           # linhas de grade menores aparecem a cada semana iniciando na segunda\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # formato dos rótulos de data\n  \n  # eixo y\n  scale_y_continuous(\n    expand = c(0,0))+             # remove o excesso de espaço do eixo y abaixo de 0 (alinha o histograma nivelado com o eixo x)\n  \n  # temas estéticos\n  theme_minimal()+                # simplifique o fundo do gráfico\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # legenda no lado esquerdo\n                                face = \"italic\"), # legenda em itálico\n    axis.title = element_text(face = \"bold\"))+    # título dos eixos em negrito\n  \n  # rótulos incluindo legendas dinâmicas\n  labs(\n    title    = \"Incidência semanal de casos (Semanas iniciadas na segunda)\",\n    subtitle = \"Observe o alinhamento das barras, linhas de grade verticais, e rótulos dos eixos nas semanas iniciadas na segunda\",\n    x        = \"Semana de aparecimetno dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados neste gráfico\"))"},{"path":"epicurves.html","id":"semanas-iniciando-no-domingo","chapter":"2 Curvas epidêmicas","heading":"Semanas iniciando no domingo","text":"Para obter o gráfico acima para semanas que iniciam domingo, algumas poucas modificações são necessárias, uma vez que o date_breaks = \"weeks\" funciona apenas para semanas iniciando às segundas.Os pontos de quebra das classes histograma precisam serem ajustados para os domingos (week_start = 7)Dentro de scale_x_date(), datas de quebra similares devem ser fornecidas para breaks = e minor_breaks =, visando garantir que os rótulos de data e linhas de grade verticais alinhem nos domingos.Por exemplo, o comando scale_x_date(), para semanas iniciando nos domingos, pode ser semelhante ao seguinte:","code":"\nscale_x_date(\n    expand = c(0,0),\n    \n    # especifique o intervalo do rótulo de datas e das linhas de grade principais\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Domingo antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Domingo após o último caso\n      by   = \"4 weeks\"),\n    \n    # especifique o intervalo das linhas de grade vertical secundárias\n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Domingo antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Domingo após o último caso\n      by   = \"week\"),\n   \n    # formato do rótulo de data\n    #date_labels = \"%a\\n%d %b\\n%Y\")+         # dia, mês acima abreviado, sobre o ano com 2-dígitos\n    label = scales::label_date_short())"},{"path":"epicurves.html","id":"grupocor-por-valor","chapter":"2 Curvas epidêmicas","heading":"Grupo/cor por valor","text":"barras histograma podem ser coloridas por grupo e podem ser “empilhadas” (o inglês stacked). Para designar coluna de agrupamento, faça seguintes modificações. Veja página sobre básico ggplot para mais detalhes.Dentro mapeamento estético histograma, aes(), mapeie o nome da coluna para os argumentos group = e fill =Remova qualquer argumento de fill = fora de aes(), uma vez que irá sobrepor-se ao argumentos que estão dentroArgumentos dentro de aes() serão aplicados por grupo, enquanto qualquer argumento fora será aplicado para todas barras (ex.: você pode querer color = fora, de forma que cada barra tenha mesma borda)Aqui é mostrado como o comando aes() pode ser utilizado para agrupar e colorir barras de acordo com o gênero:seguir, ele sendo aplicado:","code":"\naes(x = date_onset, group = gender, fill = gender)\nggplot(data = linelist) +     # comece com o linelist (muitos hospitais)\n  \n  # crie o histograma: especifique os pontos de ruptura dos containers: começe na segunda anterior ao primeiro caso, e finalize na segunda após o último caso\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # ajuste os dados para serem agrupados por hospital\n      fill = hospital),       # preenchimento da barra (cor de dentro) de acordo com o hospital\n    \n    # quebras dos contentores são nas semanas iniciadas nas segundas\n    breaks = weekly_breaks_all,   # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido em código anterior\n    \n    # Cor ao redor das barras\n    color = \"black\")"},{"path":"epicurves.html","id":"ajuste-as-cores","chapter":"2 Curvas epidêmicas","heading":"Ajuste as cores","text":"Para manualmente ajustar o preenchimento de cada grupo, utilize scale_fill_manual() (nota: scale_color_manual() é diferente!).\nUse o argumetno values = para aplicar um vetor de cores.\nUse o argumetno na.value = para especificar uma cor para os valores NA.\nUse o argumento labels = para mudar o texto dos itens da legenda. Por segurança, forneça como um vetor nomeado, como c(\"old\" = \"new\", \"old\" = \"new\") ou ajuste os valores nos próprios dados.\nUse name = para dar um título adequado à legenda\nUse o argumetno values = para aplicar um vetor de cores.Use o argumetno na.value = para especificar uma cor para os valores NA.Use o argumento labels = para mudar o texto dos itens da legenda. Por segurança, forneça como um vetor nomeado, como c(\"old\" = \"new\", \"old\" = \"new\") ou ajuste os valores nos próprios dados.Use name = para dar um título adequado à legendaPara mais dicas sobre escalas de cor e paletas, veja página sobre básico ggplot.","code":"\nggplot(data = linelist)+           # inicie com a linelist (muitos hospitais)\n  \n  # crie um histograma\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # casos agrupados por hospital\n        fill = hospital),          # barras preenchidas por hospital\n    \n    # quebra dos containers\n    breaks = weekly_breaks_all,        # sequência de quebras semanais iniciadas nas segundas, como definido em código anterior\n    \n    # Cor ao redor das barras\n    color = \"black\")+              # cor da borda para cada barra\n  \n  # especificação manual das cores\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # especifique as cores de preenchimento (\"values\") - atenção à ordem!"},{"path":"epicurves.html","id":"ajuste-a-ordem-dos-níveis","chapter":"2 Curvas epidêmicas","heading":"Ajuste a ordem dos níveis","text":"ordem em que barras agrupadas estão empilhadas é melhor ajustada ao se classificar coluna de agrupamento como sendo da classe fator (Factor). Você poderá, então, designar ordem dos níveis desse fator (e os rótulos mostrados). Veja página sobre Fatores ou dicas ggplot para mais detalhes.Antes de criar o gráfico, utilize função fct_relevel() pacote forcats para converter coluna de agrupamento para classe factor, e manualmente ajustar ordem dos níveis, como detalhado na página sobre Fatores.gráfico abaixo, única diferença gráfico anterior é que coluna hospital foi consolidada como mostrado acima, e nós utilizamos guides() para reverter ordem da legenda, de forma que “Missing” está fim da legenda.DICA: Para reverter apenas ordem da legenda, adicione o seguinte comando ggplot2: guides(fill = guide_legend(reverse = TRUE)).","code":"\n# carregue o pacote forcats para trabalhar com fators\npacman::p_load(forcats)\n\n# Defina um novo conjunto de dados com o hospital como fator\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Converta para fator e ajuste \"Missing\" e \"Other\" como níveis do topo para aparecerem no topo da epicurva## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))`.\n## Caused by warning:\n## ! 1 unknown level in `f`: Missing\nlevels(plot_data$hospital) # gere os níveis em ordem## [1] \"Other\"                                \"Ausente\"                             \n## [3] \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\nggplot(plot_data) +                     # Utilize um NOVO conjunto de dados com hospital reordenado como fator\n  \n  # crie o histograma\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # casos agrupados por hospital\n        fill = hospital),               # preenchimento da barra (cor) por hospital\n    \n    breaks = weekly_breaks_all,         # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido no topo da seção sobre ggplot\n    \n    color = \"black\")+                   # cor da borda ao redor de cada barra\n    \n  # rótulos do eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o excesso de espaço do eixo x antes e após as barras de casos\n    date_breaks       = \"3 weeks\",      # rótulos aparecem a cada 3 semanas que iniciam nas segundas\n    date_minor_breaks = \"week\",         # linhas verticais aparecem a cada semana iniciada na segunda\n    label = scales::label_date_short()) + # efficient date label\n  \n  # eixo y\n  scale_y_continuous(\n    expand = c(0,0))+                   # remova o espaço em excesso do eixo y abaixo de 0\n  \n  # especificação manual das cores, atenção para a ordem!\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # temas estéticos\n  theme_minimal()+                      # simplifique o fundo do gráfico\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # legenda no lado esquerdo em itálico\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # títulos dos eixos em negrito\n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos por hospital\",\n    subtitle = \"Hospital como um factor re-ordenado\",\n    x        = \"Semana de aparecimento dos sintomas\",\n    y        = \"Casos semanais\")"},{"path":"epicurves.html","id":"ajuste-a-legenda","chapter":"2 Curvas epidêmicas","heading":"Ajuste a legenda","text":"Leia mais sobre legendas e escalas página sobre dicas ggplot. Aqui estão alguns destaques:Edite o título da legenda por meio da função de escala ou com labs(fill = \"Legend title\") (se você estiver estilizando com color =, utilize labs(color = \"\"))theme(legend.title = element_blank()) para não ter título de legendatheme(legend.position = \"top\") para legenda acima gráfico. Pode-se também escolher também “bottom” , “left”, “right” ou “none” para posições embaixo, à esqueda, à direita ou para remover legenda, respectivamente.theme(legend.direction = \"horizontal\") legenda horizontalguides(fill = guide_legend(reverse = TRUE)) para reverter ordem da legenda","code":""},{"path":"epicurves.html","id":"barras-lado-a-lado","chapter":"2 Curvas epidêmicas","heading":"Barras lado-a-lado","text":"visualização grupo de barras lado--lado (oposto à posição de barras empilhadas) é especificado dentro de geom_histogram(), com o argumento position = \"dodge\" fora de aes()(Nota tradutor: dodge vem inglês “esquivar”).Se existirem mais de dois grupos de valores, estes podem ser difíceis de ler. Em vez disso, considere utilizar um gráfico facetado (pequenos múltiplos). Para melhorar visualização gráfico neste exemplo, campos sem informação gênero foram removidos.","code":"\nggplot(central_data %>% drop_na(gender))+   # inicie com casos do Hospital Central, excluindo as linhas sem dados do gênero\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # casos agrupados por gênero\n          fill = gender),         # barras preenchidas de acordo com o gênero\n        \n        # quebras dos containers do histrograma\n        breaks = weekly_breaks_central,   # sequência de datas semanais para o surto no Central - definido no topo da seção sobre ggplot\n        \n        color = \"black\",          # cor do contorno das barras\n        \n        position = \"dodge\")+      # barras LADO-A-LADO\n                      \n  \n  # Os rótulos no eixo x\n  scale_x_date(expand            = c(0,0),         # remova os espaços em excesso abaixo do eixo x e após as barras de casos\n               date_breaks       = \"3 weeks\",      # rótulos aparecem a cada 3 semanas iniciadas nas segundas\n               date_minor_breaks = \"week\",         # linhas verticais aparecem a cada semana iniciada nas segundas\n               label = scales::label_date_short()) + # efficient label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+             # remove o espaço extra nos eixos y entre a base das barras e os rótulos\n  \n  # escala de cores e rótulos de legendas\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # especifique as cores de preenchimento (\"values\") - atenção na ordem!\n                    na.value = \"grey\" )+     \n\n  # temas estéticos\n  theme_minimal()+                                               # um conjunto de temas para simplificar o gráfico\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n        axis.title = element_text(face = \"bold\"))+               # título dos eixos em negrito\n  \n  # rótulos\n  labs(title    = \"Incidência semanal de casos, por gênero\",\n       subtitle = \"Legenda\",\n       fill     = \"Gênero\",                                      # forneça novos títulos para os eixos\n       x        = \"Semana de início dos sintomas\",\n       y        = \"Incidência semanal dos casos notificados\")"},{"path":"epicurves.html","id":"limite-dos-eixos","chapter":"2 Curvas epidêmicas","heading":"Limite dos eixos","text":"Existem duas formas de limitar extensão dos valores dos eixos.Geralmente, o método indicado é utilizar o comando coord_cartesian(), que aceita xlim = c(min, max) e ylim = c(min, max) (onde você fornece os valores mínimos e máximos). Esta ferramenta age como um “zoom” sem, na realidade, remover qualquer dado, o que é importante para estatísticas e resumos das medidas.Alternativamente, você pode ajustar os valores mínimos e máximos das datas utilizando limits = c() dentro de scale_x_date(). Por exemplo:Da mesma forma, se você quiser que o eixo x se estenda até uma data específica (ex.: data atual), mesmo que novos casos não sejam notificados, você pode utilizar:PERIGO: Tenha cuidado ao ajustar quebras ou limites da escala eixo y (ex.: 0 30 por 5: seq(0, 30, 5)). Estes números estáticos podem cortar o seu gráfico casos seus dados mudem e ultrapassem os limites!","code":"\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # escolhe uma data mínima mas deixa a data máxima em aberto.scale_x_date(limits = c(NA, Sys.Date()) # garante que o eixo da data se estenda até a data atual"},{"path":"epicurves.html","id":"rótuloslinha-de-grade-do-eixo-de-data","chapter":"2 Curvas epidêmicas","heading":"Rótulos/linha de grade do eixo de data","text":"DICA: Lembre que os rótulos eixo das datas são independentes da agregação das datas em barras, mas visualmente podem ser importantes para alinhar classes, rótulos de data, e linhas de grade verticais.Para modificar os rótulos de data e linhas de grade, utilize função scale_x_date() em uma das seguintes formas:Se suas classes histograma são dias, semanas iniciadas em segundas, meses, ou anos:\nUtilize date_breaks = para especificar o intervalo de rótulos e linhas de grade principais (ex.: “day” (dia), “week” (semana), “3 weeks” (3 semanas), “month” (mês), ou “year” (ano))\nUtilize date_minor_breaks = para especificar o intervalo das linhas de grade verticais secundárias (entre os rótulos)\nAdicione expand = c(0,0) para iniciar os rótulos na primeira barra\nUtilize date_labels = para especificar o formato dos rótulos de data - veja página sobre Datas para dicas (utilize \\n para uma nova linha)\nUtilize date_breaks = para especificar o intervalo de rótulos e linhas de grade principais (ex.: “day” (dia), “week” (semana), “3 weeks” (3 semanas), “month” (mês), ou “year” (ano))Utilize date_minor_breaks = para especificar o intervalo das linhas de grade verticais secundárias (entre os rótulos)Adicione expand = c(0,0) para iniciar os rótulos na primeira barraUtilize date_labels = para especificar o formato dos rótulos de data - veja página sobre Datas para dicas (utilize \\n para uma nova linha)Se suas classes histograma são semanas iniciadas nos domingos:\nUtilize breaks = e minor_breaks = ao fornecer uma sequência de quebras de datas para cada um\nVocê ainda pode utilizar date_labels = e expand = para formatação, como decrito acima\nUtilize breaks = e minor_breaks = ao fornecer uma sequência de quebras de datas para cada umVocê ainda pode utilizar date_labels = e expand = para formatação, como decrito acimaAlgumas notas:Veja seção de abertura ggplot para instruções sobre como criar uma sequência de datas utilizando seq.Date().Veja esta página ou página Trabalhando com datas para dicas sobre como criar rótulos de data.","code":""},{"path":"epicurves.html","id":"demonstrações","chapter":"2 Curvas epidêmicas","heading":"Demonstrações","text":"Abaixo está uma demonstração de gráficos onde cásses e os rótulos/linhas de grade gráfico estão alinhados e desalinhados:","code":"\n# classes de 7-dias + rótulos de Segunda\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # classes de 7-dias com início no primeiro caso\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remova o excesso de espaço do eixo x abaixo e após as barras de caso\n    date_breaks = \"3 weeks\",       # Segunda a cada 3 semanas\n    date_minor_breaks = \"week\",    # Semanas iniciadas na segunda\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remova o espaço em excesso abaixo do eixo x, fazendo um nivelamento\n  \n  labs(\n    title = \"DESALINHADO\",\n    subtitle = \"! CUIDADO: barras de 7-dias iniciam nas quintas-feiras no primeiro caso\\nRótulos de data e linhas de grade nas segundas-feiras\\nObserve como os traços não alinham com as barras\")\n\n\n\n# classes de 7-dias + meses\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remova o espaço em excesso abaixo e após as barras de casos\n    date_breaks = \"months\",           # primeiro do mês\n    date_minor_breaks = \"week\",       # semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento\n  \n  labs(\n    title = \"DESALINHADO\",\n    subtitle = \"! CUIDADO: Barras de 7-dias iniciam nas quintas-feiras com o primeiro caso\\nLinhas de grade principais e rótulos de data no primeiro de cada mês\\nLinhas de grade secundárias semanalmente nas segundas\\nObserve o espaçamento diferente de algumas das linhas de grade e traços desalinhados com as barras\")\n\n\n# ALINHAMENTO TOTAL NAS SEGUNDAS: especifique manualmente as quebras das classes para serem nas segundas\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebras do histograma ajustadas para 7 dias iniciando na Segunda antes do primeiro caso\n    breaks = weekly_breaks_central,    # definido anteriormente nesta página\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remova o excesso de espaço do eixo x abaixo e após as barras de caso\n    date_breaks = \"4 weeks\",           # Segunda-feira a cada 4 semanas\n    date_minor_breaks = \"week\",        # Semanas iniciadas na segunda\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça o nivelamento\n  \n  labs(\n    title = \"Segunda ALINHADAS\",\n    subtitle = \"Classes de 7-dias manualmente ajustados para iniciarem na segunda antes do primeiro caso (28 de abril)\\nRótulos de data e linhas de grade também nas segundas\")\n\n\n# ALINHAMENTO TOTAL NA SEGUNDA COM RÓTULOS DE MESES:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebras do histograma ajustaddas para 7 dias iniciando na segunda antes do primeiro caso\n    breaks = weekly_breaks_central,            # definido anteriormente nesta página\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remova o excesso de espaço no eixo x abaixo e após as barras de casos\n    date_breaks = \"months\",            # Segunda a cada 4 semanas\n    date_minor_breaks = \"week\",        # Semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça um nivelamento\n  \n  theme(panel.grid.major = element_blank())+  # Remove as linhas de grade principais )caem no primeiro dia do mês)\n          \n  labs(\n    title = \"ALINHADO nas segundas com rótulos MENSAIS\",\n    subtitle = \"Classes de 7-dias manualmente ajustado para iniciar na segunda antes do primeiro caso (28 de abril)\\nRótulo de datas no primeiro dia do mês\\nPrincipais linhas de grade mensais removidas\")\n\n\n# ALINHAMENTO TOTAL NO DOMINGO: especifique manualmente as quebras das classes E rótulos para serem nos domingos\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebra do histograma ajustadas para serem de 7 dias, iniciando no Domingo antes do primeiro caso\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # quebras dos rótulos de datas e principais linhas de grade ajustadas para ocorrerem a cada 3 semanas iniciando no domingo antes do primeiro caso\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # linhas de grade secundárias ajustadas para iniciarem semanalmente no domingo antes do primeiro caso\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento\n  \n  labs(title = \"ALINHAMENTO nos domingos\",\n       subtitle = \"Classes de 7-dias manualmente ajustados para iniciarem no domingo antes do primeiro caso (27 de abril)\\nRótulo de datas e linhas de grade manualmente ajustadas também para os domingos\")"},{"path":"epicurves.html","id":"dados-agregados","chapter":"2 Curvas epidêmicas","heading":"Dados agregados","text":"Frequentemente, ao invés de uma linelist, você inicia com contagens agregadas de unidades, distritos, etc. Você pode criar uma epicurva com o ggplot(), mas o código será levemente diferente. Esta seção irá utilizar o conjunto de dados count_data que foi importado anteriormente, na seção de preparação dos dados. Este conjunto de dados é o linelist agregado para contagens diárias por hospital. primeiras 50 linhas são mostradas abaixo.","code":""},{"path":"epicurves.html","id":"criando-um-gráfico-de-contagens-diárias","chapter":"2 Curvas epidêmicas","heading":"Criando um gráfico de contagens diárias","text":"Nós podemos criar um gráfico de uma epicurva diária destas contagens diárias. Aqui estão diferenças código:Dentro mapeamento estético aes(), especifique y = como coluna de contagem (neste caso, o nome da coluna é n_cases)Adicione o argumento stat = \"identity\" dentro de geom_histogram(), que especifica que altura da barra deve ser o valor y = , e não o número de linhas, como é o padrãoAdicione o argumento width = para evitar linhas verticais brancas entre barras. Para contagens diárias o ajuste é 1. Para contagens semanais o ajuste é 7. Para contagens mensais, linhas brancas são um problema (cada M~es possui diferente número de dias) - considere transformar seu eixo x para um factor ordenado categoricamente (meses) e utilizando geom_col().","code":"\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # para contagens diárias, ajuste width = 1 para evitar o espaço braco entre as barras\n  labs(\n    x = \"Data de notificação\", \n    y = \"Número de casos\",\n    title = \"Incidência diária de casos, a partir dos dados de contagem diária\")"},{"path":"epicurves.html","id":"criando-um-gráfico-de-contagens-semanais","chapter":"2 Curvas epidêmicas","heading":"Criando um gráfico de contagens semanais","text":"Se os seus casos já estão contados por semana, eles podem parecer como o seguinte conjunto de dados (chamado count_data_weekly):primeiras 50 linhas de count_data_weekly são mostradas abaixo. Você pode ver que contagens foram agregadas por semanas. Cada semana é mostrada pelo primeiro dia da semana (segunda-feira, por padrão).Agora crie o gráfico de forma que x = coluna da semana epidemiológica. Lembre de adicionar y = coluna de contagens para o mapeamento estético, e adicione stat = \"identity\", como explicado acima.","code":"\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # eixo x é a semana epidemiológica (variável da classe Data)\n      y = n_cases_weekly,    # altura do eixo y nas contagens de casos semanais\n      group = hospital,      # nós estamos agrupando as barras e colorindo por hospital\n      fill = hospital),\n    stat = \"identity\")+      # isto também é requerido quando criar um gráfico dos dados de contagem\n     \n  # rótulos para o eixo x\n  scale_x_date(\n    date_breaks = \"2 months\",      # rótulos a cada 2 meses\n    date_minor_breaks = \"1 month\", # linhas de grade a cada mês\n    label = scales::label_date_short())+ # label formatting\n     \n  # Escolha a paleta de cor (utiliza o pacote RColorBrewer)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Semana de início\", \n    y = \"Incidência semanal de casos\",\n    fill = \"Hospital\",\n    title = \"Incidência semanal de casos, a partir dos dados de casos agregados por hospital\")"},{"path":"epicurves.html","id":"média-móvel","chapter":"2 Curvas epidêmicas","heading":"Média móvel","text":"Veja página sobre médias móveis para uma descrição detalhada e diferentes opções. Abaixo, uma alternativa para calcular médias móveis com o pacote slider é utilizada. Nesta abordagem, média móvel é calculada conjunto de dados antes de criar os gráficos:Agregue os dados em contagens conforme necessário (diárias, semanais, etc.) (veja página Agrupando dados)Crie uma nova coluna para salvar média móvel, criada com slide_index() pacote sliderCrie um gráfico da média móvel como uma geom_line() acima (após) o histograma da epicurvaVeja este útil resumo online pacote slider","code":"\n# carregue o pacote\npacman::p_load(slider)  # slider utilizado para calcular as médias móveis\n\n# crie um conjunto de dados de contagens diárias e média móvel de 7-dias\n#######################################################\nll_counts_7day <- linelist %>%    # inicie com o objeto linelist\n  \n  ## conte os casos por dia\n  count(date_onset, name = \"new_cases\") %>%   # crie uma nova coluna com as contagens, chamada \"new_cases\"\n  drop_na(date_onset) %>%                     # remova os casos sem a informação do dia de início dos sintomas (date_onset)\n  \n  ## calcule o número médio de casos em uma janela de 7 dias\n  mutate(\n    avg_7day = slider::slide_index(    # crie uma nova coluna\n      new_cases,                       # calcule baseado nos valores da coluna new_cases\n      .i = date_onset,                 # o indexador é a coluna de date_onset, de forma que as contagens sem datas são incluídas na janela de análise\n      .f = ~mean(.x, na.rm = TRUE),    # a função utilizada é mean() com os valores em branco removidos\n      .before = 6,                     # a janela de análise é o dia e os 6-dias anteriores\n      .complete = FALSE),              # precisa ser FALSE para unlist() funcionar na próxima etapa\n    avg_7day = unlist(avg_7day))       # converta da classe \"list\" para a classe \"numeric\"\n\n\n# crie o gráfico\n######\nggplot(data = ll_counts_7day) +  # inicie com o novo conjunto de dados criado acima\n    geom_histogram(              # crie uma epicurva em histograma\n      mapping = aes(\n        x = date_onset,          # coluna de datas no eixo x\n        y = new_cases),          # a altura é o número de novos casos diários\n        stat = \"identity\",       # altura da coluna é o valor de y\n        fill=\"#92a8d1\",          # cor legal para as barras\n        colour = \"#92a8d1\",      # mesma cor para a borda das barras\n        )+ \n    geom_line(                   # crie uma linha para a média móvel\n      mapping = aes(\n        x = date_onset,          # coluna de data para o eixo x\n        y = avg_7day,            # valor de y ajustado para a coluna de média móvel\n        lty = \"Média móvel \\nde 7-dias\"), # nome da linha na legenda\n      color=\"red\",               # cor da linha\n      size = 1) +                # espessura da linha\n    scale_x_date(                # escala da data\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # label formatting\n      expand = c(0,0)) +\n    scale_y_continuous(          # escala do eixo y\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Número de casos confirmados\",\n      fill = \"Legenda\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # remove o título da legenda"},{"path":"epicurves.html","id":"facetasmúltiplos-pequenos","chapter":"2 Curvas epidêmicas","heading":"Facetas/múltiplos pequenos","text":"Como em outros ggplots, você pode criar gráficos facetados (“múltiplos pequenos”). Como explicado na página dicas ggplot deste manual, você pode utilizar tanto facet_wrap() quanto facet_grid(). Aqui, nós demonstramos com o facet_wrap(). Para epicurvas, facet_wrap() é tipicamente mais fácil, uma vez que provavelmente você só precisa facetar uma coluna.sintaxe geral é facet_wrap(rows ~ cols), em que lado esquerdo til (~) é o nome da coluna ser espalhada através das “linhas” gráfico facetado, e lado direito til é o nome de uma coluna ser espalhada através das “colunas” gráfico facetado. De forma mais simples, só utilize um nome de coluna, lado direito til: facet_wrap(~age_cat).Eixos livres\nVocê precisará decidir se escalas dos eixos para cada faceta são “fixas” para mesmas dimensões (padrão), ou “livres” (significando que irão mudar baseado nos dados dentro da faceta). Faça isso com o argumento scales = dentro de facet_wrap() ao especificar “free_x” ou “free_y”, ou “free”.Número de colunas e linhas das facetas\nIsto pode ser especificado com ncol = e nrow = dentro de facet_wrap().Ordem dos painéis\nPara alterar ordem de aparecimento, altere ordem dos níveis da coluna de factor utilizada para criar facetas.Estética\nTamanho da fonte e face, cor da tira, etc. podem ser modificados através de theme() com argumentos como:strip.text = element_text() (tamanho, cor, face, ângulo…)strip.background = element_rect() (ex.: element_rect(fill=“grey”))strip.position = (posição da tira “bottom” (embaixo), “top” (em cima), “left” (à esquerda), ou “right” (à direita))Rótulos das tiras\nRótulos dos gráficos facetados podem ser modificados por meio de “rótulos” da coluna como um factor, ou pelo uso de um “rotulador”.Crie um rotulador como este, utilizando função as_labeller() ggplot2. Então, forneça o rotulador para o argumento labeller = de facet_wrap(), como mostrado abaixo.Um exemplo de gráfico facetado - facetado pela coluna age_cat.Veja este link para mais informações sobre os rotuladores.","code":"\nmy_labels <- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n# crie o gráfico\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # argumentos dentro de aes() aplicam-se ao grupo\n      \n    color = \"black\",      # argumentos fora de aes() aplicam-se a todos os dados\n        \n    # quebras do histograma\n    breaks = weekly_breaks_central)+  # vetor pré-definido de datas (veja mais acima nesta página)\n                      \n  # Os rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remove o espaço em excesso do eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+                       # remove o espaço em excesso do eixo y entre os fundos das barras e os rótulos\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar a plotagem\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # títulos dos eixos em negrito\n  \n  # crie as facetas\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos, por categoria de idade\",\n    subtitle = \"Legenda\",\n    fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n    x        = \"Semana de início dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia entre {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico\"))"},{"path":"epicurves.html","id":"epidemia-total-no-fundo-da-faceta","chapter":"2 Curvas epidêmicas","heading":"Epidemia total no fundo da faceta","text":"Para mostrar o total da epidemia fundo de cada faceta, adicione função gghighlight() com parênteses vazios ao ggplot. Isto é pacote gghighlight. Observe que o máximo eixo y em todas facetas é agora baseado pico da epidemia inteira. Existem mais exemplos deste pacote na página sobre dicas ggplot.","code":"\nggplot(central_data) + \n  \n  # epicurvas por grupo\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo\n    \n    color = \"black\",    # argumentos fora de aes() são aplicados a todos os dados\n    \n    # quebras do histograma\n    breaks = weekly_breaks_central)+     # vetor de datas pré-definidas (veja o topo da seção sobre ggplot)\n  \n  # adicione a epidemia total em cinza em cada faceta\n  gghighlight::gghighlight()+\n  \n  # rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o espaço em excesso do eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada 1 mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+  # remove o excesso de espaço do eixo y abaixo de 0\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # títulos dos eixos em negrito\n  \n  # crie as facetas\n  facet_wrap(\n    ~age_cat,                          # cada gráfico é um valor de age_cat\n    ncol = 4,                          # número de colunas\n    strip.position = \"top\",            # posição do título/tira da faceta\n    labeller = my_labels)+             # rotulador definido acima\n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos, por categoria de idade\",\n    subtitle = \"Legenda\",\n    fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n    x        = \"Semana de início dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico\"))"},{"path":"epicurves.html","id":"uma-faceta-com-dados","chapter":"2 Curvas epidêmicas","heading":"Uma faceta com dados","text":"Se você quer ter uma caixa de faceta que contem todos os dados, duplique o conjunto de dados inteiro e trate duplicatas como um valor de facetas. Uma função “auxiliar”, CreateAllFacet(), abaixo pode auxiliar nisso (agradecimento esse post). Quando é executado, o número de linhas duplica, e então terá uma nova coluna chamada facet, em que linhas duplicadas terão o valor “”, e linhas originais terão o valor original da coluna de facetas. Agora você só precisa facetear com coluna facet.Aqui está função auxiliar. Execute ela de forma que esteja disponível para você.Agora aplique função auxiliar para o conjunto de dados, na coluna age_cat:Alterações notáveis comando ggplot() são:Os dados utilizados agora são central_data2 (duplique linhas, com nova coluna “facet”)Rotulador precisará ser atualizado, caso usadoOpcional: para obter facetas empilhadas verticalmente: coluna facetada é movida para o lado das linhas na equação e lado esquerdo é substituído por “.” (facet_wrap(facet~.)), e ncol = 1. Você também pode precisar ajustar o comprimento e altura da imagem gráfico salvo (veja ggsave() dicas ggplot).","code":"\n# Defina uma função auxiliar\nCreateAllFacet <- function(df, col){\n     df$facet <- df[[col]]\n     temp <- df\n     temp$facet <- \"all\"\n     merged <-rbind(temp, df)\n     \n     # garanta que o valor da faceta é um fator\n     merged[[col]] <- as.factor(merged[[col]])\n     \n     return(merged)\n}\n# Crie um conjunto de dados que é duplicado e com a nova coluna \"facet\" para mostrar \"all\" (todas) as categorias de idade como outro nível da faceta\ncentral_data2 <- CreateAllFacet(central_data, col = \"age_cat\") %>%\n  \n  # ajuste os níveis do fator\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))## Warning: There was 1 warning in `mutate()`.\n## ℹ In argument: `facet = fct_relevel(...)`.\n## Caused by warning:\n## ! 1 unknown level in `f`: 70+\n# verifique os níveis\ntable(central_data2$facet, useNA = \"always\")## \n##   all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  <NA> \n##   454    84    84    82    58    73    57     7     9\nggplot(central_data2) + \n  \n  # epicurvas atuais por grupo\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo\n        color = \"black\",    # argumentos fora de aes() são aplicados a todos os dados\n        \n        # quebras do histograma\n        breaks = weekly_breaks_central)+    # vetor de datas pré-definidos (veja o topo da seção sobre o ggplot)\n                     \n  # Rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o excesso de espaço no eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+  # remove o espaço em excesso do eixo y entre a base das barras e os rótulos\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # crie as facetas\n  facet_wrap(facet~. ,                            # cada gráfico é um valor da faceta\n             ncol = 1)+            \n\n  # rótulos\n  labs(title    = \"Incidência semanal de casos, por categoria de idade\",\n       subtitle = \"Legenda\",\n       fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n       x        = \"Semana de início dos sintomas\",\n       y        = \"Incidência semanal dos casos notificados\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados no gráfico\"))"},{"path":"epicurves.html","id":"dados-preliminares","chapter":"2 Curvas epidêmicas","heading":"2.3 Dados preliminares","text":"Os dados mais recentes mostrados em epicurvas precisam, frequentemente, serem marcados como preliminares, ou sujeitos à demoras na notificação. Isto pode ser feito ao adicionar uma linha vertical e/ou retângulo sobre um número específico de dias. Aqui estão duas opções:Utilize annotate():\nPara utilizar uma linha, use annotate(geom = \"segment\"). Forneça x, xend, y, e yend. Ajuste o tamanho, tipo de linha (lty), e cor.\nPara utilizar um retângulo, use annotate(geom = \"rect\"). Forneça xmin/xmax/ymin/ymax. Ajuste cor e o alfa.\nPara utilizar uma linha, use annotate(geom = \"segment\"). Forneça x, xend, y, e yend. Ajuste o tamanho, tipo de linha (lty), e cor.Para utilizar um retângulo, use annotate(geom = \"rect\"). Forneça xmin/xmax/ymin/ymax. Ajuste cor e o alfa.Agrupe os dados por status da tentativa e utilize cores diferentes para essas barrasCUIDADO: Você pode querer experimentar geom_rect() para desenhar um retângulo, mas ajustar transparência não funciona contexto de uma linelist. Esta função sobrepõe um retângulo para cada observação/linha!. Utilize ou um alfa muito baixo (ex.: 0.01), ou outra abordagem.","code":""},{"path":"epicurves.html","id":"utilizando-annotate","chapter":"2 Curvas epidêmicas","heading":"Utilizando annotate()","text":"Dentro de annotate(geom = \"rect\"), os argumentos xmin e xmax precisam ser dados como valores da classe Date (data).Note que, devido ao fato destes dados serem agregados em barras semanais, e última barra extender para segunda após o último caso, região sombreada pode parecer cobrir 4 semanasAqui é um exemplo online de annotate()mesma linha preta vertical pode ser obtida com o código abaixo, mas, utilizando geom_vline(), você perde capacidade de controlar altura:","code":"\nggplot(central_data) + \n  \n  # histograma\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # vetor de data pré-definido - veja o topo da seção sobre o ggplot\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # escalas\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove o excesso de espaço do eixo x abaixo e após as barras de casos\n    date_breaks = \"1 month\",           # Primeiro do mês\n    date_minor_breaks = \"1 month\",     # Primeiro do mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # rótulos e tema\n  labs(\n    title = \"Utilizando annotate()\\nRetângulo e linha mostrando que os dados dos últimos 21 dias são preliminares\",\n    x = \"Semana de início de sintomas\",\n    y = \"Incidência semanal de casos\")+ \n  theme_minimal()+\n  \n  # adicione um retângulo vermelho semi-transparente nos dados preliminares\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # a nota precisa ser englobada dentro de as.Date()\n    xmax  = as.Date(Inf),                                          # a nota precisa ser englobada dentro de as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alfa fácil e intuitivo para ajustar usando annotate()\n    fill  = \"red\")+\n  \n  # adicione uma linha preta vertical no topo das outras camadas\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 dias antes dos últimos dados\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # linha inicia em y = 0\n    yend  = Inf,       # linha no topo do gráfico\n    size  = 2,         # tamanho da linha\n    color = \"black\",\n    lty   = \"solid\")+   # tipo de linha ex.: \"solid\", \"dashed\"\n\n  # adicione texto no retângulo\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Sujeito à atrasos nas notificações\",\n    angle = 90)\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")"},{"path":"epicurves.html","id":"cor-das-barras","chapter":"2 Curvas epidêmicas","heading":"Cor das barras","text":"Uma abordagem alternativa pode ser ajustar cor ou exibição das dos dados preliminares. Você pode criar uma nova coluna estágio de preparação dos dados, e utiliza-la para agrupar os dados, de forma que o aes(fill = ) dos dados preliminares possa ter uma cor ou alfa diferente das outras barras.","code":"\n# adiciona uma coluna\n############\nplot_data <- central_data %>% \n  mutate(tentative = case_when(\n    date_onset >= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # preliminares e estiverem dentro dos últimos 7 dias\n    TRUE                                       ~ \"Reliable\")) # todos os demais são confiáveis\n\n# crie o gráfico\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histograma\n  geom_histogram(\n    breaks = weekly_breaks_central,   # vetor de datas pré-definido, veja o topo da página sobre o ggplot\n    color = \"black\") +\n\n  # escalas\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove o espaço em excesso do eixo x, abaixo e após as barras de casos\n    date_breaks = \"3 weeks\",           # segundas a cada 3 semanas\n    date_minor_breaks = \"week\",        # semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # label formatting\n  \n  # rótulos e temas\n  labs(title = \"Mostra os dias que possuem notificações preliminares\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove o título da legenda"},{"path":"epicurves.html","id":"etiquetas-multiníveis-de-data","chapter":"2 Curvas epidêmicas","heading":"2.4 Etiquetas multiníveis de data","text":"Se você quiser etiquetas multiníveis de datas (ex.: mês e ano) sem duplicar etiquetas de níveis mais baixos, utilize uma das abordagens abaixo:Lembre - você pode utilizar ferramentas como \\n dentro dos argumentos de date_labels ou labels para colocar partes de cada etiqueta em uma nova linha abaixo da atual. Entretanto, o código abaixo o ajuda colocar anos ou meses (por exemplo) em uma linha abaixo e apenas uma vez. Algumas notas sobre o código abaixo:Contagem de casos são agregados em semanas por razões estéticas. Veja página sobre epicurvas (parte sobre separação dos dados agregados) para mais detalhes.Uma linha geom_area() é utilizada lugar de um histograma, uma vez que abordagem de faceteamento abaixo não funciona bem com histogramas.Agregue para contagens semanaisCrie os gráficosAs técnicas acima foram adaptadas desta e desta postagem stackoverflow.com.","code":"\n# Crie o conjunto de dados de contagens de casos por semana\n#######################################\ncentral_weekly <- linelist %>%\n  filter(hospital == \"Central Hospital\") %>%   # filtre a linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %>%  \n  count(week) %>%                              # faça um resumo das contagens de casos semanais\n  drop_na(week) %>%                            # remova os casos sem a informação de onset_date\n  complete(                                    # preencha todas as semanas com nenhum caso notificado\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # converta novos campos NA (faltantes) para contagens de 0\n# crie um gráfico com a borda da caixa no ano\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # crie uma linha, especificando x e y\n            stat = \"identity\") +             # a altura da linha é o número da contagem\n  scale_x_date(date_labels=\"%b\",             # formato do rótulo de data mostra o mês\n               date_breaks=\"month\",          # rótulos de data no primeiro dia de cada mês\n               expand=c(0,0)) +              # remove o espaço em excesso em cada extremidade\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove o espaço em excesso abaixo do eixo x\n  facet_grid(~lubridate::year(week), # crie uma faceta com o ano (da coluna da classe Date (Data))\n             space=\"free_x\",                \n             scales=\"free_x\",                # eixo x se adapta para o intervalo dos dados (não é fixo)\n             switch=\"x\") +                   # etiquetas de faceta (ano) na base\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # posicionamento das etiquetas das facetas\n        strip.background = element_rect(fill = NA, # rótulos das facetas sem preenchimento e com bordas cinzas\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # sem espaço entre os painéis das facetas\n  labs(title = \"Etiquetas de ano aninhadas, com borda cinza\")\n# crie o gráfico sem a borda de caixa no ano\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # estabeleça o x e y para o gráfico inteiro\n  geom_line(stat = \"identity\",              # crie a linha, em que a altura da linha é o número da contagem\n            color = \"#69b3a2\") +            # cor da linha\n  geom_point(size=1, color=\"#69b3a2\") +     # crie pontos nos pontos de data semanais\n  geom_area(fill = \"#69b3a2\",               # preencha a área abaixo da linha\n            alpha = 0.4)+                   # preencha a transparência\n  scale_x_date(date_labels=\"%b\",            # formato do rótulo de data mostra o mês\n               date_breaks=\"month\",         # rótulos de data no primeiro dia de cada mês\n               expand=c(0,0)) +             # remova o espaço em excesso\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remova o espaço em excesso abaixo do eixo x\n  facet_grid(~lubridate::year(week),        # faça a faceta no ano (da coluna de classe Date (data))\n             space=\"free_x\",                \n             scales=\"free_x\",               # eixo x se adapta ao intervalo de dados (não é fixo)\n             switch=\"x\") +                  # rótulos da faceta (ano) na base\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # posicionamento do rótulo da faceta\n          strip.background = element_blank(),            # rótulo da faceta sem fundo\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # borda cinza para o painel da faceta\n          panel.spacing=unit(0,\"cm\"))+                   # sem espaço entre os painéis da faceta\n  labs(title = \"Etiquetas de ano aninhadas - pontos, sombreamento, e sem borda no rótulo\")"},{"path":"epicurves.html","id":"eixo-duplo","chapter":"2 Curvas epidêmicas","heading":"2.5 Eixo duplo","text":"Embora existam discussões intensas sobre validade de eixos duplos na comunidade de visualização de dados, muitos supervisores de epidemiologia ainda querem ver uma epicurva ou gráfico similar com um percentual sobreposto com um segundo eixo. Isto é discutido mais extensivamente na página dicas ggplot, mas um exemplo utilizando o método de cowplot é mostrado abaixo:Dois gráficos distintos são feitos, e então combinados com o pacote cowplot.Os gráficos precisam ter exatamente o mesmo eixo x (ajuste os limites). contrário, os dados e rótulos não serão alinhadosCada um utiliza theme_cowplot() e um deles tem o eixo y movido para o lado direito gráficoAgora, use o cowplot para sobrepor os dois gráficos. atenção precisa ser dada ao alinhamento eixo x, ao lado eixo y, e ao uso de theme_cowplot().","code":"\n# carregue o pacote\npacman::p_load(cowplot)\n\n# Crie o primeiro gráfico de histograma de uma epicurva\n#######################################\nplot_cases <- linelist %>% \n  \n  # crie o gráfico com casos por semana\n  ggplot()+\n  \n  # crie o histograma\n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # quebras das classes a cada semana, iniciando na segunda antes do primeiro caso, e indo até a segunda após o último caso\n    breaks = weekly_breaks_all)+  # vetor pré-definido de datas semanais (veja o topo da seção sobre o ggplot)\n        \n  # especifique o início e o fim do eixo da data para alinhar com o outro gráfico\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma\n  \n  # rótulos\n  labs(\n      y = \"Casos diários\",\n      x = \"Data de aparecimento dos sintomas\"\n    )+\n  theme_cowplot()\n\n\n# crie um segundo gráfico com o percentual de óbitos por semana\n###########################################\nplot_deaths <- linelist %>%                        # inicie com a linelist\n  group_by(week = floor_date(date_onset, \"week\")) %>%  # crie a coluna week (semana)\n  \n  # utilize summarise para obter o percentual semanal de casos que morreram\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %>% \n  \n  # inicie o gráfico\n  ggplot()+\n  \n  # linha com o percentual semanal de óbitos\n  geom_line(                                # crie um linha com o percentual de mortos\n    mapping = aes(x = week, y = pct_died),  # especifique o y-altura como sendo da coluna pct_died\n    stat = \"identity\",                      # ajuste a altura da linha para o valor na coluna pct_death, e não a quantidade de linhas (que é o padrão)\n    size = 2,\n    color = \"black\")+\n  \n  # Mesmos limites no eixo de datas como no outro gráfico - alinhamento perfeito\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma\n  \n  \n  # ajustes no eixo y\n  scale_y_continuous(                # ajuste o eixo y\n    breaks = seq(0,100, 10),         # ajuste os intervalos de quebra do eixo da porcentagem\n    limits = c(0, 100),              # ajuste a extensão do eixo de porcentagem\n    position = \"right\")+             # mova o eixo de porcentagem para a direita\n  \n  # rótulo do eixo y, sem rótulo no eixo x\n  labs(x = \"\",\n       y = \"Percentual de óbitos\")+      # rótulo do eixo de porcentagem\n  \n  theme_cowplot()                   # adicione isto para unir os dois gráficos\naligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"incidência-acumulada","chapter":"2 Curvas epidêmicas","heading":"2.6 Incidência acumulada","text":"Nota: Caso esteja utilizando o pacote incidence2, veja seção sobre como você pode produzir incidência acumulada com uma simples função. Esta página irá ensinar como calcular incidência acumulada e fazer um gráfico dela utilizando ggplot().Se estiver iniciando com os casos em uma linelist, crie uma nova coluna contendo o número acumulado de casos por dia em um surto utilizando função cumsum() R base:primeiras 10 linhas são mostradas abaixo:Esta coluna de casos acumulados pode então ser utilizada para fazer um gráfico com data de início dos sintomas, date_onset, utilizando geom_line():Ela também pode ser sobreposta em uma epicurva, com dois eixos, utilizando o método cowplot descrito acima e na página dicas ggplot:Agora, use cowplot para sobrepor os dois gráficos. Atenção ao alinhamento eixo x, o lado eixo y, e o uso de theme_cowplot().","code":"\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>%                # contagem de linhas por dia (salvo na coluna \"n\")\n  mutate(                         \n    cumulative_cases = cumsum(n)       # nova coluna com a quantidade de linhas acumuladas em cada data\n    )\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n# carregue o pacote\npacman::p_load(cowplot)\n\n# crie primeiro o histograma de uma epicurva\nplot_cases <- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Casos diários\",\n    x = \"Data de início dos sintomas\"\n  )+\n  theme_cowplot()\n\n# crie um segundo gráfico com uma linha de casos acumulados\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Casos acumulados\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\naligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"recursos","chapter":"2 Curvas epidêmicas","heading":"2.7 Recursos","text":"","code":""},{"path":"gis.html","id":"gis","chapter":"3 Introdução ao GIS","heading":"3 Introdução ao GIS","text":"","code":""},{"path":"gis.html","id":"visão-geral-1","chapter":"3 Introdução ao GIS","heading":"3.1 Visão Geral","text":"Os aspectos especiais dos seus dados podem trazer vários insights à situação de um surto, e pode responder perguntas como:Onde estão os hotspots da doença?Como os hotspots mudaram ao longo tempo?Como é o acesso às unidades de saúdo? Melhorias são necessárias?O foco dessa página sobre GIS é atender às necessidades dos epidemiologistas na resposta aos surtos. Iremos explorar métodos básicos de visualização de dados espaciais utilizando os pacotes tmap e ggplot2. Também vamos caminhar por métodos básicos de gerenciamento e consulta de dados espaciais com o pacote sf. Por fim, vamos dar uma olhada em conceitos de estatística espacial tais como relações espaciais, autocorrelação espacial e regressão espacial utilizando o pacote spdep.","code":""},{"path":"gis.html","id":"terminologia","chapter":"3 Introdução ao GIS","heading":"3.2 Terminologia","text":"Abaixo introduziremos terminologia principal. Para uma introdução mais profunda ao GIS e à análise espacial, sugerimos que você revise algum dos tutoriais maiores ou cursos listados na seção de Referências.Geographic Information System (GIS) (Sistema de Informação Geográfica) - Um GIS é um framework ou ambiente para reunir, gerenciar, analisar e visualizar dados espaciais.","code":""},{"path":"gis.html","id":"softwares-gis","chapter":"3 Introdução ao GIS","heading":"Softwares GIS","text":"Alguns Softwares GIS mais conhecidos permitem interação tipo “apontar-e-clicar” (point--click) para o desenvolvimento de mapas e análises espaciais. Essas ferramentas vêm com vantagens de não precisar aprender código e com facilidade de selecionar e posicionar manualmente ícones e outras características em um mapa. Aqui temos dois dos mais conhecidos:ArcGIS - Um software GIS comercial desenvolvido pela empresa ESRI, que é muito famoso mas bastante caro.QGIS - Um software GIS gratuito e open-source que pode fazer praticamente qualquer coisa que o ArcGIS também pode. Você pode baixar o QGIS aquiUtilizar o R como um GIS pode parecer mais intimidador início, pois em vez “apontar-e-clicar”, ele tem uma interface de linha de comando (você precisa escrever código para chegar resultado esperado). entanto, essa é uma grande vantagem se você precisa produzir mapas repetitivamente ou criar análises que sejam reprodutíveis.","code":""},{"path":"gis.html","id":"dados-espaciais","chapter":"3 Introdução ao GIS","heading":"Dados espaciais","text":"duas formas primordiais de dados espaciais utilizados GIS são dados vetoriais e rasterizados.Dados Vetoriais - O formato de dados espaciais mais comum utilizado GIS. Dados vetoriais compreendem propriedades geométricas de vértices e trajetos (paths). Os dados vetoriais espaciais também podem se subdividir em três tipos amplamente utilizados:Pontos - Um ponto consiste em um par ordenado (x,y) representando um local específico em um sistema de coordenadas. Pontos são forma mais básica de dados espaciais e podem ser utilizados para representar um caso (casa de um paciente) ou um local (hospital) em um mapa.Pontos - Um ponto consiste em um par ordenado (x,y) representando um local específico em um sistema de coordenadas. Pontos são forma mais básica de dados espaciais e podem ser utilizados para representar um caso (casa de um paciente) ou um local (hospital) em um mapa.Linhas - Uma linha é composta de dois pontos conectados. Linhas possuem um comprimento, e podem ser utilizadas para representar coisas como rodovias ou rios.Linhas - Uma linha é composta de dois pontos conectados. Linhas possuem um comprimento, e podem ser utilizadas para representar coisas como rodovias ou rios.Polígonos - Um polígono é composto de pelo menos três segmentos de linha conectados por pontos. propriedades de um Polígono são comprimento (o perímetro da área) bem como própria medida da área. Polígonos podem ser utilizado para demarcar uma área (uma vila) ou uma estrutura (área de um hospita ).Polígonos - Um polígono é composto de pelo menos três segmentos de linha conectados por pontos. propriedades de um Polígono são comprimento (o perímetro da área) bem como própria medida da área. Polígonos podem ser utilizado para demarcar uma área (uma vila) ou uma estrutura (área de um hospita ).Dados Rasterizados - Um formato alternativo para dados espaciais, dados rasterizados são uma matriz de células (por exemplo, pixels) em que cada célula contém informações como altura, temperatura, inclinação, cobertura florestal, etc. Essas geralmente são fotos aéreas, imagens de satélite, etc. Os “Rasters” também podem ser utilizados como “mapas base” sob dados vetoriais.","code":""},{"path":"gis.html","id":"visualizando-dados-espaciais","chapter":"3 Introdução ao GIS","heading":"Visualizando dados espaciais","text":"Para representar visualmente os dados espaciais em um mapa, os softwares GIS exigem que você forneça informação suficiente sobre onde posicionar cada característica em relação umas às outras. Se você estiver utilizando dados vetoriais, o que vai acontecer na maioria dos casos, essas informações normalmente estarão armazenadas em um “shapefile”.Shapefiles - Um shapefile é um formato de dado comum para armazenar dados espaciais “vetoriais” que consistem de linhas, pontos ou polígonos. Um único shapefile na verdade é um conjunto de pelo menos três arquivos - .shp, .shx, e .dbf. Todos esses sub-componentes devem estar presente em um mesmo diretório (pasta) para que o shapefile possa ser lido. Esses arquivos associados podem ser comprimidos em uma pasta ZIP para ser enviado por email ou baixado de um site.O shapefile vai conter informação sobre propriedades propriamente ditas, bem como onde encontrá-las na superfície da Terra. Isso é importante pois apesar da Terra ser um globo, os mapas são tipicamente bidimensionais; escolhas sobre como “achatar” os dados espaciais podem ter grande impactos visual e na interpretação mapa produzido.Coordinate Reference Systems (CRS) (Sistemas de Referências de Coordenadas) - Um SRC é um sistema baseado em coordenadas utilizado para localizar propriedades geográficas na superfície da Terra. Ele possui alguns componentes principais:Sistema de Coordenadas - Existem muitos tipos diferentes de sistemas de coordenadas, então certifique-se de qual dos tipos suas coordenadas fazem parte. Graus de latitude/longitude são comuns, mas você pode também ver coordenadas UTM.Sistema de Coordenadas - Existem muitos tipos diferentes de sistemas de coordenadas, então certifique-se de qual dos tipos suas coordenadas fazem parte. Graus de latitude/longitude são comuns, mas você pode também ver coordenadas UTM.Unidades - Saiba qual são unidades para o seu sistema de coordenadas (exemplo: graus decimais, metros)Unidades - Saiba qual são unidades para o seu sistema de coordenadas (exemplo: graus decimais, metros)Datum - Uma versão modelada específica da Terra. Essa versão vem sendo revisada ao longo dos anos, então certifique-se de que camadas seu mapa utilizam o mesmo datum.Datum - Uma versão modelada específica da Terra. Essa versão vem sendo revisada ao longo dos anos, então certifique-se de que camadas seu mapa utilizam o mesmo datum.Projeção - Uma referência à equação matemática que foi utilizada para projetar verdadeiramente redonda Terra em uma superfície plana (mapa).Projeção - Uma referência à equação matemática que foi utilizada para projetar verdadeiramente redonda Terra em uma superfície plana (mapa).Lembre-se que você pode resumir dados espaciais sem utilizar ferramentas de mapas mostradas abaixo. Às vezes, uma simples tabela por dados geográficos (distritos, países, etc.) é todo o necessário!","code":""},{"path":"gis.html","id":"iniciando-com-gis","chapter":"3 Introdução ao GIS","heading":"3.3 Iniciando com GIS","text":"Existem alguns itens importantes que você precisará ter ou pensar respeito para fazer um mapa. Esses incluem:Uma base de dados – pode ser em formato de dados espaciais (tais como shapefiles, como mostrado acima) ou pode não ser em formato espacial (apenas um csv).Se sua base de dados não estiver em um formato espacial você também vai precisar de uma base de dados de referência. Dados de referência consistem nas representações espaciais de dados e seus atributos relacionados, que deverão incluir material contendo o local e informações sobre o endereço de propriedades específicas.\nSe você estiver trabalhando com fronteiras geográficas pré-definidas (por examplo, regiões administrativas), shapefiles de referências geralmente estão disponíveis gratuitamente para download nos sites das agências governamentais ou organizações de compartilhamento de dados. Se estiver em dúvida, um bom jeito de começar é buscar Google por “[região] shapefile”\nSe você tiver informação sobre endereços, mas não tiver latitude e longitude, talvez você precisa utilizar um motor de geocodificação (geocoding engine) para coletar os dados de referências espaciais para seus regristros.\nSe você estiver trabalhando com fronteiras geográficas pré-definidas (por examplo, regiões administrativas), shapefiles de referências geralmente estão disponíveis gratuitamente para download nos sites das agências governamentais ou organizações de compartilhamento de dados. Se estiver em dúvida, um bom jeito de começar é buscar Google por “[região] shapefile”Se você tiver informação sobre endereços, mas não tiver latitude e longitude, talvez você precisa utilizar um motor de geocodificação (geocoding engine) para coletar os dados de referências espaciais para seus regristros.Uma ideia sobre como você quer apresentar informação em suas bases para seu público alvo. Existem muitos tipos diferentes de mapas, e é importante pensar sobre qual se encaixa melhor à suas necessidades.","code":""},{"path":"gis.html","id":"tipos-de-mapas-para-visualizar-seus-dados","chapter":"3 Introdução ao GIS","heading":"Tipos de mapas para visualizar seus dados","text":"Mapa coroplético (Choropleth map) - um tipo de mapa temático onde cores, sombreamento ou padrões são utilizados para representar regiões geográficas de acordo com seus valores de um atributo. Por exemplo, um valor maior pode ser indicado por uma cor mais escura que um valor menor. Esse tipo de mapa é particularmente útil quando estamos visualizando uma variável e como seu valor muda através de regiões definidas ou áreas geopolíticas.Mapa de calor de densidade de casos (Case density heatmap) - um tipo de mapa temático em que cores são utilizada para representar intensidade de um valor, entanto, ele não utiliza regiões definidas ou fronteiras geopolíticas para agrupar os dados. Esse tipo de mapa é tipicamente utilizado para mostrar ‘hot spots’ ou áreas com uma alta densidade ou concentração de pontos.Mapa de densidade de pontos (Dot density map) - um tipo de mapa temático que usa pontos para reprensentar valores de atributos nos seus dados. Esse tipo de mapa é melhor utilizado para visualizar o espalhamento dos dados e permitir um “escaneamento” visual de agrupamentos (clusters).Mapa de símbolos proporcionais (mapa de símbolos graduados) (Proportional symbols map (graduated symbols map)) - um mapa temático similar ao mapa de coroplético mas, em vez de utilizar cores para indicar o valor de um atributo, ele utiliza um símbolo (geralmente um círculo) de acordo com o valor. Por exemplo, um valor maior pode ser indicado por um símbolo maior que um valor menor. Esse tipo de mapa é melhor utilizado quando se quer visualizar o tamanho ou quantidade dos seus dados através de regiões geográficas.Você também pode combinar vários tipos diferentes de visualização para mostrar padrões geográficos complexos. Por exemplo, os casos (pontos) mapa abaixo estão coloridos de acordo com unidade de saúde mais próxima (veja legenda). Os círculos maiores mostram áreas de alcance das unidades de saúde partir de um certo raio e os pontos vermelho-vivo mostram os casos fora alcance de qualquer uma das unidades de saúde mostradas:Nota: O foco principal dessa página sobre GIS é baseado contexo de uma resposta de campo um surto. Por isso, os conteúdos da página irão cobrir o básico de manipulação, visualização e análise de dados espaciais.","code":""},{"path":"gis.html","id":"preparação-2","chapter":"3 Introdução ao GIS","heading":"3.4 Preparação","text":"","code":""},{"path":"gis.html","id":"carregue-os-pacotes-r","chapter":"3 Introdução ao GIS","heading":"Carregue os pacotes R","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.Você pode ter uma visão geral de todos os pacotes R que lidam com dados espaciais em CRAN “Spatial Task View”.","code":"\npacman::p_load(\n  rio,           # para importar os dados\n  here,          # para localizar arquivos \n  tidyverse,     # para limpar, manipular e gerar gráficos com os dados (inclui o pacote ggplot2)\n  sf,            # para gerenciar dados espaciais utilizando o formato Simple Feature \n  stars,          # para produzir mapas simples, funciona tanto para mapas interativos quanto estáticos \n  janitor, # para limpar nomes das colunas \n  terra, #dependencia tmap\n  tmap,\n  OpenStreetMap, # para adicionar o mapa-base do OpenStreeMap ao mapa do ggplot\n  tmaptools,\n  spdep\n  \n  ) "},{"path":"gis.html","id":"amostra-de-dados-dos-casos","chapter":"3 Introdução ao GIS","heading":"Amostra de dados dos casos","text":"Para fins de demonstração, iremos trabalhar com uma amostra aleatória de 1000 casos dataframe da linelist de uma epidemia simulada de Ebola (computacionalmente, trabalhar com menos casos é mais fácil para mostrar nesse handbook). Se você quiser acompanhar análise, clique aqui para baixar linelist “limpa” (como um arquivo .rds).Uma vez que estamos tomando uma amostra aleatória dos casos, seus resultados podem parecer ligeiramente diferentes que está demonstrado aqui quando você rodar os códigos por conta própria.Importe os dados com função import() pacote rio (ela lida com vários tipos de arquivo como .xlsx, .csv, .rds - veja página Importar exportar para mais detalhes).Next select random sample 1000 rows using sample() base R.Queremos converter essa linelist, que possui classe dataframe, para um objeto da classe “sf” (spatial features). Dado que linelist possui duas colunas “lon” e “lat” representando longitude e latitude da casa de cada caso, isso será fácil.Utilizamos o pacote sf (spatial features) e sua função st_as_sf() para criar um novo objeto que chamaremos de linelist_sf. Esse novo objeto parece essencialmente mesma coisa que linelist, mas colunas lon e lat foram designadas como colunas de coordenadas, e um sistema de referência de coordenadas (SRC) foi atribuído para quando os pontos forem mostrados. O número 4326 identifica nossas coordenadas de acordo com o World Geodetic System 1984 (WGS84) - que é o padrão para coordenadas de GPS.O dataframe da linelist original tem esta forma. Nesta demonstração, iremos utilizar apenas coluna date_onset e geometry (que foi construída partir dos campos de longitude e latitude acima e são últimas colunas dataframe).","code":"\n# importa a linelist de casos limpa \nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))  \n# gera 1000 números aleatórios de linhas, a partir do número de linhas da linelist\nsample_rows <- sample(nrow(linelist), 1000)\n\n# gera um subconjunto da linelist para manter apenas as linhas da amostra, e todas as colunas\nlinelist <- linelist[sample_rows,]\n# Cria um objeto do tipo sf\nlinelist_sf <- linelist %>%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )"},{"path":"gis.html","id":"shapefiles-das-fronteiras-administrativas","chapter":"3 Introdução ao GIS","heading":"Shapefiles das fronteiras administrativas","text":"Serra Leoa: Shapefiles das fronteiras administrativasDe antemão, já baixamos todas fronteiras administrativas de Serra Leoa site da Humanitarian Data Exchange (HDX) que você encontra aqui. Caso prefira, você pode baixar esse e todos os outros dados de exemplos para esse manual através de nosso pacote de R, conforme explicado na página Download dos dados manual.Agora faremos o seguinte para salvar R o shapefile nível administrativo 3Importar o shapefileLimpar o nome das colunasFiltar linhas para manter apenas áreas de interessePara importar um shapefile usamos função read_sf() pacote sf. À ela é fornecido o caminho arquivo através da função (). - em nosso caso o arquivo está em nosso projeto R, nas subpastas “data”, “gis”, e “shp”, com o nome de arquivo “sle_adm3.shp” (veja páginas Importar e exportar e Projetos R para mais informações). Você precisará fornecer seu próprio caminho de arquivo.Em seguida usamos função clean_names() pacote janitor para padronizar os nomes das colunas shapefile. Também utilizamos filter() para manter apenas linhas com área administrativa 2 (admin2name) chamada “Western Area Urban” ou “Western Area Rural”.Abaixo, podemos ver como fica o shapefile depois da importação e limpeza. Role para direita para ver como há colunas com nível administrativo 0 (país), nível administrativo 1, nível administrativo 2, e finalmente nível administrativo 3. Cada nível tem um nome composto de letras e um identificador único chamado “pcode”. O pcode expande com cada nível administrativo que aumenta ex: SL (Serra Leoa) -> SL04 (Oeste) -> SL0410 (Area Rural Oeste) -> SL040101 (Koya Rural).","code":"\n# nível ADM3 limpo\nsle_adm3 <- sle_adm3_raw %>%\n  janitor::clean_names() %>% # padronizar o nome das colunas\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # filtrar para manter certas áreas"},{"path":"gis.html","id":"dados-populacionais","chapter":"3 Introdução ao GIS","heading":"Dados populacionais","text":"Serra Leoa: População por ADM3Novamente, esses dados podem ser baixadados site da HDX (link aqui) ou pelo pacote epirhandbook explicado nessa página. Usamos import() para carregar o arquivo .csv. Também passamos o arquivo importado para clean_names() para padronizar sintaxe dos nomes das colunas.Essa é aparência arquivo de população. Role para direita para ver como cada jurisdição tem colunas com população masculina (male), feminina (female), e população total, e subdivisões nas colunas columns por grupo de idade.","code":"\n# População por nível ADM3\nsle_adm3_pop <- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %>%\n  janitor::clean_names()"},{"path":"gis.html","id":"unidades-de-saúde","chapter":"3 Introdução ao GIS","heading":"Unidades de Saúde","text":"Serra Leoa: Dados das Unidades de Saúde OpenStreetMapNovamente, baixamos os locais das unidades de saúde HDX aqui ou por meio das instruções na página manual de Download e dados.Nós importamos o shapefile dos pontos das unidades com read_sf(), e novamente limpamos os nomes das colunas, e depois, filtramos para manter apenas os pontos marcados com “hospital”, clínica (“clinic”), ou doutores (“doctors”).Aqui está o dataframe resultante - role para direita para ver o nome da unidade e coordenadas de geometria (geometry).","code":"\n# shapefile das unidades de saúde do OSM (open street map) \nsle_hf <- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %>% \n  janitor::clean_names() %>%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))"},{"path":"gis.html","id":"criando-gráficos-das-coordenadas","chapter":"3 Introdução ao GIS","heading":"3.5 Criando gráficos das coordenadas","text":"forma mais fácil de criar um gráfico de coordenadas X-Y (longitude/latitude, pontos), nessa situação dos casos, é desenhenhá-los como pontos diretamente objeto linelist_sf que criamos na seção de preparação.O pacote tmap oferece algumas capacidades simples de fazer mapas tanto de forma estática ( modo “plot”) quanto interativa ( modo de visualização - “view”) com apenas algumas linhas de código. sintaxe tmap é parecida com ggplot2, de forma que os comandos são somados uns aos outros com o operador +. Veja mais detalhes nessa vignette.Defina o modo tmap. Neste caso iremos utilizar o modo “plot”, que produz saídas estáticas.Abaixo, os pontos são projetados sozinhos. função tm_shape() é disponibilizada com os objetos linelist_sf. Em seguida, adicionamos pontos via tm_dots(), especificando o tamanho e cor. Pelo fato de linelist_sf ser um objeto tipo sf, nós já temos duas colunas designadas que contêm coordenadas de latitude e longitude e o sistema de referência de coordenadas (CRS):Sozinhos os pontos não nos dizem muita coisa. Então devemos também projetar fronteiras administrativas:Novamente, utilizaremos tm_shape() (veja documentação) mas em vez de fornecer o shapefile com os pontos dos casos, forneceremos o shapefile das fronteiras administrativas (polygons).Com o argumento bbox = (bbox significa “bounding box”) podemos especificar coordenadas das fronteiras. Primeiro mostramos o mapa sem bbox, e depois com ele.E agora ambos, pontos e polígonos juntos:Para ler uma boa comparação das diferentes opções de criação de mapas R, leia esse blog post.","code":"\ntmap_mode(\"plot\") # escolha entre \"view\" ou \"plot\"\n# Apenas os casos (pontos)\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n# Apenas as fronteiras administrativas (polígonos)\ntm_shape(sle_adm3) +               # shapefile das fronteiras administrativas\n  tm_polygons(col = \"#F7F7F7\") +    # exibir os polígonos em cinza claro \n  tm_borders(col = \"#000000\",      # exibir as bordas com cor e peso de linha\n             lwd = 2) +\n  tm_text(\"admin3name\")            # coluna de texto para mostrar para cada polígono\n\n\n# Mesmo que acima, mas com zoom à partir do bounding box\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # vértice (do bounding box) \n                  -13.2, 8.5)) +  # vértice (do bounding box)\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n# Todos juntos \ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # Dá título ao gráfico "},{"path":"gis.html","id":"joins-espaciais","chapter":"3 Introdução ao GIS","heading":"3.6 “Joins” Espaciais","text":"Você deve estar familiarizado com o conceito de fazer join dos dados de uma base em outra. Vários métodos são discutidos na página Juntando dados desse manual. Um “join espacial” tem um propósito similar, mas lidando com os relacionamentos espaciais dos dados. Em vez de utilizar valores comuns às colunas para parear corretamente observações, você pode utilizar relações espaciais deles, tais como o fato de uma característica estar contida em outra, ou de um ponto ser o vizinho mais próximo de outro, ou contido na área de influência (buffer) de um certo raio de outro, etc.O pacote sf oferece vários métodos para fazer joins espaciais. Veja mais na documentação sobre o métodos st_join e outros tipos de join espaciais nessa referência.","code":""},{"path":"gis.html","id":"pontos-no-polígono","chapter":"3 Introdução ao GIS","heading":"Pontos no polígono","text":"Relaciona unidades administrativas aos casosAqui temos um dilema interessante: linelist dos casos não contém nenhuma informação sobre unidades administrativas dos casos. Apesar ideal ser coletar esse tipo de informação nas fases iniciais da coleta de dados, nós também podemos relacionar unidades administrativas aos casos individuais baseado em seus relacionamentos espaciais (ex: pontos que intersectam com um polígono).Abaixo, vamos fazer intersecção espacial dos locais de nossos casos (pontos) com fronteiras ADM3 (polígonos):Comece com linelist (pontos)Faça o join espacial com fronteiras, defina o tipo join em “st_intersects”Utilize select() para manter apenas algumas das novas colunas das fronteiras administrativasTodas colunas de sle_adms foram adicionadas à linelist! Agora cada caso possui colunas detalhando os níveis administativos onde eles se encontram. Nesse exemplo, queremos manter apenas duas das novas colunas (admin level 3), então usamos select() nos nomes das colunas antigas e apenas nas duas novas que temos interesse:Você pode ver abaixo, apenas para fins de conferência, os primeiros dez casos e jurisdições de seus níveis administrativos 3 (ADM3) que foram anexadas baseados em onde o ponto intersectou espacialmente com formas dos polígonos.Agora podemos descrever nossos casos por unidade administrativa - algo que não era possível antes join espacial!Também podemos criar um gráfico de barras com contagens dos casos por unidade administrativa.Nesse exemplo, iniciamos o ggplot() com linelist_adm, de forma que podemos aplicar funções de fatores como fct_infreq() que ordena barras por frequência (veja página de Fatores para dicas).","code":"\nlinelist_adm <- linelist_sf %>%  # faça join do arquivo com as fronteiras administrativas com o da linelist, baseado na intersecção espacial\n  sf::st_join(sle_adm3, join = st_intersects)\nlinelist_adm <- linelist_sf %>%   # faça join do arquivo com as fronteiras administrativas com o da linelist, baseado na intersecção espacial\n  sf::st_join(sle_adm3, join = st_intersects) %>% \n   # Mantém os nomes das colunas antigas e as duas novas de interessa das áreas administrativas\n  select(names(linelist_sf), admin3name, admin3pcod)\n# Agora você verá os nomes AD3 anexados a cada caso.\nlinelist_adm %>% select(case_id, admin3name, admin3pcod)## Simple feature collection with 1000 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -13.27095 ymin: 8.448232 xmax: -13.20522 ymax: 8.490746\n## Geodetic CRS:  WGS 84\n## First 10 features:\n##      case_id     admin3name admin3pcod                   geometry\n## 1057  e7e88e Mountain Rural   SL040102 POINT (-13.21526 8.470037)\n## 5543  ce926c        East II   SL040204 POINT (-13.21903 8.480527)\n## 2745  ed026b       West III   SL040208 POINT (-13.26625 8.473582)\n## 1721  ffb2d3       West III   SL040208 POINT (-13.25333 8.460189)\n## 347   263041        West II   SL040207 POINT (-13.23879 8.475504)\n## 2684  16b50d       West III   SL040208 POINT (-13.26552 8.468201)\n## 4961  31b6f4       West III   SL040208 POINT (-13.25887 8.452915)\n## 5146  4d87b0       West III   SL040208 POINT (-13.26706 8.454294)\n## 4001  5fab80       West III   SL040208 POINT (-13.25338 8.458909)\n## 1816  41b557       West III   SL040208 POINT (-13.26823 8.462634)\n# Cria um novo dataframe contendo as contagens de casos por unidade administrativa\ncase_adm3 <- linelist_adm %>%          # inicia com a lineliste contendo as novas colunas administrativas \n  as_tibble() %>%                      # converte para tibble para melhor exibição\n  filter(!is.na(admin3pcod))%>%\n  group_by(admin3pcod, admin3name) %>% # agrupa por unidade administrativa, por nome e pcode \n  summarise(cases = n()) %>%           # resume e conta as linhas \n  arrange(desc(cases))                 # organiza em ordem descentente \n\ncase_adm3## # A tibble: 9 × 3\n## # Groups:   admin3pcod [9]\n##   admin3pcod admin3name     cases\n##   <chr>      <chr>          <int>\n## 1 SL040102   Mountain Rural   270\n## 2 SL040208   West III         231\n## 3 SL040207   West II          179\n## 4 SL040204   East II          112\n## 5 SL040201   Central I         59\n## 6 SL040203   East I            50\n## 7 SL040206   West I            47\n## 8 SL040205   East III          25\n## 9 SL040202   Central II        20\nggplot(\n    data = linelist_adm,                     # inicia com linelist contendo informações das unidades administrativas \n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # eixo x são unidades administrativas, ordenadas por frequência (reversa) \n  geom_bar()+                                # cria as barras, altura é o número de linhas \n  coord_flip()+                              # inverte os eixos X e Y para facilitar a leitura das unidades administrativas\n  theme_classic()+                           # simplifica a cor de fundo do gráfico \n  labs(                                      # títulos e rótulos \n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )"},{"path":"gis.html","id":"vizinho-mais-próximo","chapter":"3 Introdução ao GIS","heading":"Vizinho mais próximo","text":"Achando unidade de saúde / área de influência mais próximaPode ser útil saber onde unidades de saúde estão localizadas em relação aos hotspots das doenças.Podemos utilizar o método de join st_nearest_feature da função st_join() (pacote sf) para visualizar unidades de saude mais próximas aos casos individuais.Iniciamos com o shapefile da linelist: linelist_sfFazemos o join espacial com sle_hf, que possui os locais das unidades de saúde e clínicas (pontos)Podemos ver abaixo (primeiras 50 linhas) que cada caso agora possui dados sobre clínicas/hospitais mais próximosPodemos ver que “Den Clinic” é unidade de saúde mais próxima de cerca de 30% dos casos.Para visualizar os resultados, podemos utilizar tmap - dessa vez, modo interativo para facilitar visualização","code":"\n# Unidade de saúde mais próxima a cada caso\nlinelist_sf_hf <- linelist_sf %>%                  # inicia com o shapefile da linelist \n  st_join(sle_hf, join = st_nearest_feature) %>%   # dados da clínica mais próxima com join nos dados dos casos \n  select(case_id, osm_id, name, amenity) %>%       # mantém as colunas de interesse, incluindo id, nome, tipo, e geometria da unidade de saúde\n  rename(\"nearest_clinic\" = \"name\")                # renomeia para uma maior clareza\n# Conta os casos por unidade de saúde\nhf_catchment <- linelist_sf_hf %>%   # inicia com a linelist incluindo os dados das clínicas mais próximas \n  as.data.frame() %>%                # converte o shapefile em dataframe \n  count(nearest_clinic,              # conta linhas por nome (da clínica) \n        name = \"case_n\") %>%         # define a nova coluna de contagens como \"case_n\"\n  arrange(desc(case_n))              # organiza em ordem descrescente\n\nhf_catchment                         # imprime no console##                          nearest_clinic case_n\n## 1                            Den Clinic    360\n## 2       Shriners Hospitals for Children    338\n## 3         GINER HALL COMMUNITY HOSPITAL    189\n## 4                             panasonic     40\n## 5 Princess Christian Maternity Hospital     27\n## 6                     ARAB EGYPT CLINIC     21\n## 7                  MABELL HEALTH CENTER     13\n## 8                                  <NA>     12\ntmap_mode(\"view\")   # define o modo do tmap para interativo \n\n# gera o gráfico dos pontos dos casos e clínicas \ntm_shape(linelist_sf_hf) +            # gera o gráfico dos casos \n  tm_dots(size=0.08,                  # colore os casos pelas clínicas mais próximas \n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # adiciona as clínicas ao gráfico como grandes pontos pretos\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # sobrepõe com o nome \ntm_view(set.view = c(-13.2284, 8.4699, 13), # ajusta o zoom (centra as coordenadas, e define o zoom)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")"},{"path":"gis.html","id":"áreas-de-influência-buffers","chapter":"3 Introdução ao GIS","heading":"Áreas de Influência (Buffers)","text":"Também podemos explorar quantos casos estão localizados em uma distância pé de 2.5km (~30 min) da unidade de saúde mais próxima.Nota: Para cálculos de distância mais precisos, é melhor re-projetar seu objeto sf ao sistema de projeção local respectivo, tal como UTM (Terra projetada sobre uma superfície plana). Nesse exemplo, para fins de simplicidade vamos nos ater ao sistema de coordenadas Sistema Geodésico Mundial (WGS84) (Terra representada em uma superfície esférica / redonda, portanto, unidades estão em graus decimais). Utilizaremos uma conversão geral de: 1 grau decimal = ~111km.Veja mais informações sobre projeções de mapas e sistemas de coordenadas nesse artigo da esri. Esse blog fala sobre diferentes tipos de projeções de mapas e como cada uma delas pode ser escolhida dependendo da área de interesse e o contexto seu mapa / análise.Primeiro, crie uma área de influência circular com um raio de ~2.5km ao redor de cada unidade de saúde. Isso é feito com função st_buffer() pacote tmap. Pelo fato das unidades mapa estarem em lat/long em graus decimais, é assim que “0.02” será interpretado. Se o sistema de coordenadas seu mapa em metros, o número deve ser fornecido em metros.Abaixo criamos o gráfico das zonas de influência propriamente ditas, com:Segundo, intersectamos essas áreas de influência com os casos (pontos) utilizando st_join() e com o tipo de join st_intersects. Ou seja, join dos dados das áreas de influência com os pontos que eles intersectam.Agora podemos contar os resultados: nrow(linelist_sf_hf_2k[.na(linelist_sf_hf_2k$osm_id.y), ]) dos 1000 casos não intersectam com nenhuma área de influência (esses valores estão faltando), e então residem mais de 30 min pé da da unidade de saúde mais próxima.Podemos visualizar os resultados de forma que os casos que não intersectam apareçam em vermelho.","code":"\nsle_hf_2k <- sle_hf %>%\n  st_buffer(dist=0.02)       # graus decimais representando aprox. 2.5km \ntmap_mode(\"plot\")\n# Cria as zonas de influência circulares\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # adiciona as clínicas ao gráfico como grandes pontos vermelhos \n  tm_dots(size=0.3, col='black')      \n# Intersecta os casos com as áreas de influência\nlinelist_sf_hf_2k <- linelist_sf_hf %>%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n# Casos que não intesectaram com nenhuma das áreas de influência das unidades de saúde\nlinelist_sf_hf_2k %>% \n  filter(is.na(osm_id.y)) %>%\n  nrow()## [1] 1000\ntmap_mode(\"view\")\n\n# Primeiro mostra os casos como pontos\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# adiciona as clínicas como grandes pontos pretos\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Depois sobrepõe as áreas de influência das unidades de saúde como polilinhas\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Destaca os casos que não são parte de nenhuma área de influência das unidades de saúde\n# como pontos vermelhos\ntm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# adiciona título  \ntm_layout(title = \"Cases by clinic catchment area\")"},{"path":"gis.html","id":"outros-joins-espaciais","chapter":"3 Introdução ao GIS","heading":"Outros joins espaciais","text":"Valores alternativos para o argumento join incluem (partir da documentação)st_contains_properlyst_containsst_covered_byst_coversst_crossesst_disjointst_equals_exactst_equalsst_is_within_distancest_nearest_featurest_overlapsst_touchesst_within","code":""},{"path":"gis.html","id":"mapas-coropléticos","chapter":"3 Introdução ao GIS","heading":"3.7 Mapas coropléticos","text":"Mapas coropléticos podem ser úteis para visualizar seus dados por áreas pré-definidas, geralmente unidades administrativas ou de saúde. Nas respostas aos surtos isso pode ajudar direcionar alocação de recursos para áreas específicas com altas taxas de incidência, por exemplo.Agora que já temos os nomes das unidades administrativas associadas todos os casos (veja seção sobre joins espaciais, acima), podemos começar mapear contagens dos casos por área (mapas coropléticos)Uma vez que também temos dados de população por ADM3, podemos adicionar essas informações à tabela case_adm3 criada anteriormente.Vamos começar com o dataframe case_adm3 criado passo anterior, que é uma tabela resumo com cada unidade administrativa e seus números de casos.Os dados populacionais sle_adm3_pop são obtidos utilizando left_join() pacote dplyr com base nos valores comuns ao longo das colunas admin3pcod dataframe case_adm3, e coluna adm_pcode dataframe sle_adm3_pop. Veja página Juntando dados).select() é aplicado ao novo dataframe, para manter apenas colunas úteis - total é população totalCasos por 10,000 é calculado como uma nova coluna com mutate()Faz join dessa tabela com os polígonos shapefile de ADM3 para poder mapeá-losMapeando os resultadosTambém podemos mapear taxas de incidência","code":"\n# Adiciona dados populacionais e calcula casos por 10mil \ncase_adm3 <- case_adm3 %>% \n     left_join(sle_adm3_pop,                             # adiciona colunas da base 'pop' \n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %>%  # faz join baseado nos valores comum ao longo dessas duas colunas \n     select(names(case_adm3), total) %>%                 # mantém apenas as colunas importantes, incluindo população total\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # cria uma nova coluna com taxa de casos por 10000, arredondando para 3 casas decimais\n\ncase_adm3                                                # imprime no console para visualização## # A tibble: 9 × 5\n## # Groups:   admin3pcod [9]\n##   admin3pcod admin3name     cases  total case_10kpop\n##   <chr>      <chr>          <int>  <int>       <dbl>\n## 1 SL040102   Mountain Rural   270  33993       79.4 \n## 2 SL040208   West III         231 210252       11.0 \n## 3 SL040207   West II          179 145109       12.3 \n## 4 SL040204   East II          112  99821       11.2 \n## 5 SL040201   Central I         59  69683        8.47\n## 6 SL040203   East I            50  68284        7.32\n## 7 SL040206   West I            47  60186        7.81\n## 8 SL040205   East III          25 500134        0.5 \n## 9 SL040202   Central II        20  23874        8.38\ncase_adm3_sf <- case_adm3 %>%                 # inicia com casos e taxas por unidade administrativa\n  left_join(sle_adm3, by=\"admin3pcod\") %>%    # faz join dos dados do shapefile por coluna comum\n  select(objectid, admin3pcod,                # mantém apenas algumas colunas de interesse\n         admin3name = admin3name.x,           # limpa o nome de uma coluna\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %>%                        # mantém a geometria de forma que os polígonos possam ser adicionados ao gráfico\n  st_as_sf()                                  # converte para shapefile\n# modo do tmap \ntmap_mode(\"plot\")               # visualiza o mapa estático \n\n# adiciona os polígonos\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # colore pela coluna de número de casos\n        tm_text(\"admin3name\")   # nome exibido\n# Casos por 10mil \ntmap_mode(\"plot\")             # modo de visualização estática\n\n# gráfico\ntm_shape(case_adm3_sf) +                # adiciona polígonos ao mapa \n  tm_polygons(\"case_10kpop\",            # colore pelas colunas contendo a taxa de casos\n              breaks=c(0, 10, 50, 100), # define os pontos de quebra para as cores \n              palette = \"Purples\"       # utiliza uma paleta de cor roxa\n              ) +\n  tm_text(\"admin3name\")                 # exibe o texto"},{"path":"gis.html","id":"criando-mapas-com-ggplot2","chapter":"3 Introdução ao GIS","heading":"3.8 Criando mapas com ggplot2","text":"Se você já está familiarizado em usar o ggplot2, você pode usar esse pacote para criar mapas estáticos de seus dados. função geom_sf() vai desenhar diferentes objetos baseados em quais características (pontos, linhas ou polígonos) estão em seus dados. Por exemplo, você pode usar geom_sf() em um ggplot() utilizando dados sf com geometria de polígonos para criar um mapa coroplético.Para ilustrar como isso funciona, podemos iniciar com os polígonos shapefile de ADM3 que utilizamos anteriormente. Lembre-se que esses são regiões de Níveis Administrativos 3 em Serra Leoa:Podemos utilizar função left_join() pacote dplyr para adicionar dados que queremos mapear ao objeto shapefile. Nesse caso, vamos utilizar o dataframe case_adm3 que criamos anterioremente para resumir contagem de casos por regiões administrativas; entanto, podemos utilizar essa mesma abordagem para mapear qualquer dado armazenado dataframe.Para fazer um gráfico de colunas com contagem de casos por região, utilizando ggplot2, podemos então utilizar geom_col() dessa forma:Se quisermos utilizar o ggplot2 para fazer um mapa coroplético da contagem dos casos, podemos utilizar uma sintaxe parecida para chamar função geom_sf():Podemos customizar aparência de nosso mapa utilizando gramática que é consistente ggplot2, por exemplo:Para usuários de R que estão confortáveis em trabalhar com ggplot2, função geom_sf() oferece uma implementação simples e direta que é adequada para visualizações básicas de mapas. Para aprender mais, leia vinheta geom_sf() ou o livro ggplot2.","code":"\nsle_adm3## Simple feature collection with 12 features and 19 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 12 × 20\n##    objectid admin3name  admin3pcod admin3ref_n admin2name admin2pcod admin1name admin1pcod\n##  *    <dbl> <chr>       <chr>      <chr>       <chr>      <chr>      <chr>      <chr>     \n##  1      155 Koya Rural  SL040101   Koya Rural  Western A… SL0401     Western    SL04      \n##  2      156 Mountain R… SL040102   Mountain R… Western A… SL0401     Western    SL04      \n##  3      157 Waterloo R… SL040103   Waterloo R… Western A… SL0401     Western    SL04      \n##  4      158 York Rural  SL040104   York Rural  Western A… SL0401     Western    SL04      \n##  5      159 Central I   SL040201   Central I   Western A… SL0402     Western    SL04      \n##  6      160 East I      SL040203   East I      Western A… SL0402     Western    SL04      \n##  7      161 East II     SL040204   East II     Western A… SL0402     Western    SL04      \n##  8      162 Central II  SL040202   Central II  Western A… SL0402     Western    SL04      \n##  9      163 West III    SL040208   West III    Western A… SL0402     Western    SL04      \n## 10      164 West I      SL040206   West I      Western A… SL0402     Western    SL04      \n## 11      165 West II     SL040207   West II     Western A… SL0402     Western    SL04      \n## 12      167 East III    SL040205   East III    Western A… SL0402     Western    SL04      \n## # ℹ 12 more variables: admin0name <chr>, admin0pcod <chr>, date <date>, valid_on <date>,\n## #   valid_to <date>, shape_leng <dbl>, shape_area <dbl>, rowcacode0 <chr>,\n## #   rowcacode1 <chr>, rowcacode2 <chr>, rowcacode3 <chr>, geometry <MULTIPOLYGON [°]>\nsle_adm3_dat <- sle_adm3 %>% \n  inner_join(case_adm3, by = \"admin3pcod\") # inner join = mantém apenas se existir em ambos os objetos\n\nselect(sle_adm3_dat, admin3name.x, cases) # imprime as variáveis selecionadas no console## Simple feature collection with 9 features and 2 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 9 × 3\n##   admin3name.x   cases                                                            geometry\n##   <chr>          <int>                                                  <MULTIPOLYGON [°]>\n## 1 Mountain Rural   270 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.474296, -13…\n## 2 Central I         59 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.489513, -13.…\n## 3 East I            50 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.494041, -13.…\n## 4 East II          112 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.49186, -13.…\n## 5 Central II        20 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.49146, -13.…\n## 6 West III         231 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.49621, -13.…\n## 7 West I            47 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.493132, -13.…\n## 8 West II          179 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.485505, -13…\n## 9 East III          25 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.485757, -13…\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T), # reordena o eixo x 'cases' de forma decrescente \n               y=cases)) +                                  # eixo y é o número de casos por região\n  theme_bw() +\n  labs(                                                     # define o texto da figura \n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # angula os rótulos do eixo x para 45 graus para caber melhor\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # define a cor de preenchimento (fill) para variar de acordo com a variável de contagem dos casos \nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") + # muda a cor do gradiente\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",    # define o texto da figura \n       subtitle = \"Admin level 3\"\n  )"},{"path":"gis.html","id":"mapas-base-basemaps","chapter":"3 Introdução ao GIS","heading":"3.9 Mapas Base (Basemaps)","text":"","code":""},{"path":"gis.html","id":"openstreetmap","chapter":"3 Introdução ao GIS","heading":"OpenStreetMap","text":"Descrevemos abaixo como gerar um mapa base (basemap) para um mapa ggplot2 utilizando funcionalidades OpenStreetMap. Métodos alternativos incluem utilizar o ggmap que requer um cadastro gratuito via Google (detalhes).OpenStreetMap é um projeto colaborativo para criar um mapa mundo editável e gratuito. Os dados de geolocalização fundamentais (ex: localidades de cidades, estradas, características naturais, aeroportos, escolas, hospitais, etc) são considerados saídas (outputs) principais projeto.Primeiro carregamos o pacote OpenStreetMap, de onde pegaremos nosso mapa base.Depois, criamos o objeto map, o qual definimos utilizando função openmap() pacote OpenStreetMap (documentação). Passaremos os seguintes argumentos para função:upperLeft e lowerRight dois pares de coordenadas especificando os limites tile mapa base\nNesse caso inserimos o max e min das linhas da linelist, para que o mapa responda dinamicamente aos dados\nNesse caso inserimos o max e min das linhas da linelist, para que o mapa responda dinamicamente aos dadoszoom = (se não preenchido será determinado automaticamente)type = qual tipo de mapa base - listamos várias possibilidades aqui e o código está utilizando primeira delas ([1]) “osm”mergeTiles = optamos por TRUE para que os tiles base sejam mesclados em um sóSe executarmos esse mapa base nesse momento, utilizando autoplot.OpenStreetMap() pacote OpenStreetMap, você verá que unidades nos eixos não são coordenadas de latitude/longitude. Ele está utilizando um sistema de coordenadas diferente. Para mostrar corretamente residências dos casos (que estão armazenados em lat/long), isso precisa ser modificado.Assim, nossa intenção é converter o mapa para latitude/longitude com função openproj() pacote OpenStreetMap. Nós passamos para função o mapa base map e também o Sistema de Referência de Coordenadas (SRC) que queremos. Fazemos isso passando string tipo “proj.4” para projeção WGS 1984, mas você pode passar o SRC de outras formas também. (veja esta página para compreender melhor que se trata uma string tipo proj.4)Agora, quando executamos o mapa, vemos que ao longo dos eixos estão coordenadas de latitude e longitude. O sistema de coordenadas foi convertido. Agora todos os nossos casos serão mostrados corretamente se sobrepostos ao mapa!Veja os tutoriais aqui e aqui para mais informações.","code":"\n# carrega o pacote \npacman::p_load(OpenStreetMap)\n\n# Ajusta o mapa base pelo intervalo das coordenadas de lat/long. Define o tipo do tile \nmap <- openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limites do tile do mapa base\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\nautoplot.OpenStreetMap(map)\n# Projeção WGS84\nmap_latlon <- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n# Gera o mapa. É necessário usar \"autoplot\" para funcionar com o ggplot\nautoplot.OpenStreetMap(map_latlon)"},{"path":"gis.html","id":"mapas-de-calor-de-densidade-com-contornos","chapter":"3 Introdução ao GIS","heading":"3.10 Mapas de calor de densidade com contornos","text":"Abaixo descrevemos como gerar um mapa de calor de densidade com contornos para os dados dos casos, sobre um mapa base, partir de uma linelist (uma linha por caso).Cria o tile mapa base partir OpenStreetMap, como descrito acima.Adiciona os casos da linelist utilizando colunas de latitude e longitudeConverte os pontos para um mapa de calor de densidade com stat_density_2d() ggplot2,Quando temos um mapa base com coordenadas lat/long, podemos sobrepor nossos casos utilizando coordenadas lat/long de suas residências.Utilizando função autoplot.OpenStreetMap() para criar o mapa base, funções ggplot2 podem facilmente sobrepor camadas sobre ele, como mostrado com geom_point() abaixo:O mapa acima pode ser difícil de interpretar, principalmente pelos pontos se soprepondo. Então, você pode, ao invés, gerar um mapa de densidade 2d utilizando função stat_density_2d() ggplot2. Você ainda estará utilizando coordenadas lat/lon da linelist, mas uma estimativa de densidade por kernel 2D será calculada e os resultados serão mostrados como linhas de contorno - como em um mapa topográfico. Leia documentação aqui.","code":"\n# Gera o mapa. É necessário usar \"autoplot\" para funcionar com o ggplot\nautoplot.OpenStreetMap(map_latlon)+                 # inicia com o mapa base\n  geom_point(                                       # adiciona os pontos xy a partir das colunas lo e lat da linelist\n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # remove a legenda completamente \n  labs(x = \"Longitude\",                             # títulos e rótulos \n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n# inicia com um mapa base\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # adiciona o mapa de densidade \n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # especifica a escala de cores \n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # rótulos \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")"},{"path":"gis.html","id":"mapa-de-calor-de-séries-temporais","chapter":"3 Introdução ao GIS","heading":"Mapa de calor de séries temporais","text":"O mapa de calor de densidade acima mostra os casos cumulativos. Podemos investigar o surto ao longo tempo e espaço dividindo o mapa de calor em facetas baseadas mês de início dos sintomas (symptom onset), derivado da linelist.Começamos com linelist, criando uma nova coluna com o Ano (Year) e Mês (Month) início. função format() R base modifica forma como data é exibida. Nesse caso, queremos o formato “YYYY-MM”.Agora, nós simplesmente adicionamos facetas via ggplot2 ao mapa de calor de densidade. Aplicamos função facet_wrap(), utilizando nova coluna como linhas. Nós definimos o número de colunas das facetas para 4, para fins de clareza.","code":"\n# Extrai o mês de início\nlinelist <- linelist %>% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Investiga os valores \ntable(linelist$date_onset_ym, useNA = \"always\")## \n## 2014-04 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 2015-02 \n##       1      10      13      42      91     170     194     119     100      75      45 \n## 2015-03 2015-04    <NA> \n##      55      39      46\n# pacotes \npacman::p_load(OpenStreetMap, tidyverse)\n\n# inicia com o mapa base\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # adiciona o mapa de densidade \n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # especifica a escala de cores \n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # rótulos \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # gera as facetas do gráfico por mês-ano de início \n  facet_wrap(~ date_onset_ym, ncol = 4)               "},{"path":"gis.html","id":"estatística-espacial","chapter":"3 Introdução ao GIS","heading":"3.11 Estatística espacial","text":"Grande parte de nossa discussão até aqui estava focada na visualização de dados espaciais. Em alguns casos, você também pode estar interessado em estatística espacial para quantificar relações espaciais entre os atributotos de seu dados. Essa seção vai passar uma visão global sobre alguns conceitos chave da estatística espacial, e sugerir alguns recursos que podem explorados caso você deseje fazer uma análise espacial mais aprofundada.","code":""},{"path":"gis.html","id":"relações-espaciais","chapter":"3 Introdução ao GIS","heading":"Relações espaciais","text":"Antes de calcularmos qualquer estatística espacial, precisamos especificar relações entre características de nossos dados. Existem várias formas de conceituar relações espaciais, mas uma forma simples e um modelo comumente aplicado é utilizar o conceito de adjacência - especificamente, o fato de esperarmos uma relação geográfica entre áreas que compartilham uma fronteira ou são vizinhos uns dos outros.Podemos quantificar relações de adjacências entre polígonos de regiões administrativas da base que viemos utilizando (sle_adm3) com o pacote spdep. Iremos especificar contiguidade tipo queen (rainha), o que significa que regiões serão vizinhas se compartilharem pelo menos um ponto ao longo de suas fronteiras. O método alternativo seria contiguidade tipo rook (torre), que requer que regiões compartilhem uma aresta - em nosso caso, com polígonos irregulares, diferença é trivial, mas em alguns casos escolha entre queen e rook pode fazer diferença. (Nota tradutor: Os termos queen (rainha) e rook (torre) correspondem à peças xadrez e o tipo de vizinhança que representam descritas acima estão relacionadas aos movimentos que fazem referido jogo: na diagonal para rainha, ou seja apenas com um ponto de contato com casa vizinha, e para frente ou para os lados com torre, ou seja com uma aresta -lateral quadrado- completa de contato com casa vizinha).matriz exibida acima mostra relações entre 9 regiões de nossa base sle_adm3. Um score de 0 indica duas regiões que não são vizinhas, enquanto quaisquer outros valores diferentes de zero indicam uma relação de vizinhança. Os valores na matriz estão escalados de forma que linha de cada região tenha um peso total de 1.Uma melhor forma de visualizar essas relações de vizinhança é gerando um gráfico para elas:Utilizamos uma abordagem de adjacência para identificar polígonos vizinhos; os vizinhos identificados também podem ser chamados de vizinhos baseados em contiguidade (contiguity-based neighbors). Mas, essa é apenas um das formas de escolher quais regiões são esperadas de possuírem uma relação geográfica. abordagens alternativas mais comuns para identificar relações geográficas geram vizinhos baseados em distância (distance-based neighbors); basicamente, eles são:K-vizinhos mais próximos (K-nearest neighbors) - Baseados nas distâncias entre centróides (centros geograficamente-pesados dos polígonos de cada região), seleciona n regiões mais próximas como vizinhas. Um limite de proximidade de máxima-distância também pode ser especificado. Em spdep, você pode usar knearneigh() (veja documentação).Vizinhos por limite de distância - Seleciona todos os vizinhos contidos em um limite de distância. Em spdep, essa relação de vizinhos pode ser identificada utilizando função dnearneigh() (veja documentação).","code":"\nsle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # cria vizinhos\nsle_adjmat <- spdep::nb2mat(sle_nb)    # cria uma matriz resumindo os relacionamentos entre vizinhos\nsle_listw <- spdep::nb2listw(sle_nb)   # cria um um objeto listw (lista de pesos (weights) ) -- iremos precisar disso posteriormente\n\nsle_nb## Neighbour list object:\n## Number of regions: 9 \n## Number of nonzero links: 30 \n## Percentage nonzero weights: 37.03704 \n## Average number of links: 3.333333\nround(sle_adjmat, digits = 2)##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n## 1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n## 2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n## 3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n## 4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n## 5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n## 6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n## 7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n## 8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n## 9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\n## attr(,\"call\")\n## spdep::nb2mat(neighbours = sle_nb)\nplot(sle_adm3_dat$geometry) +                                           # cria gráficos com as fronteiras das regiões \n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # adiciona relações de vizinhança"},{"path":"gis.html","id":"autocorrelação-espacial","chapter":"3 Introdução ao GIS","heading":"Autocorrelação espacial","text":"conhecida primeira lei da geografia de Tobler diz que “todas coisas estão relacionadas com todas outras, mas coisas próximas estão mais relacionadas que coisas distantes.” Na epidemiologia, isso geralmente significa que o risco de um certo desfecho de saúde em uma dada região é mais similar ao de suas regiões vizinhas que daquelas regiões mais longínquas. Esse conceito foi formalizado como autocorrelação espacial - propridedade estatística em que características geográficas com valores similares são agregados espaço. Medidas estatísticas de autocorrelação espacial podem ser utilizadas para quantificar extensão da agregação espacial em seus dados, localizar onde agregação ocorre, e identificar padrões compartilhados da autocorrelação espacial entre diferentes variáveis dos seus dados. Essa seção te dá uma visão global de algumas medidas de autocorrelação espacial mais comuns e como calculá-las R.de Moran - Esta é uma estatística resumo global da correlação entre o valor de uma varíavel em uma região e os valores da mesma variável em regiões vizinhas. O de Moran geralmente varia entre -1 e 1. O valor 0 indica que não há nenhum padrão de correlação espacial, enquanto valores próximos 1 ou -1 indicam uma autocorrelação espacial mais forte (valores similares próximos de si) ou dispersão espacial (valores dissimilares próximoas de si), respectivamente.Por exemplo, podemos calcular o de Moran para quantificar autocorrelação espacial nos casos de Ebola que mapeamos mais cedo (lembre-se, esse é um subset dos casos dataframe da linelist da epidemia simulada). O pacote spdep tem uma função moran.test, que pode fazer esse cálculo para nós:saída da função moran.test() nos mostra um valor de Moran de round(moran_i$estimate[1],2). Isso indica presença de autocorrelação espacial em nossos dados - especificamente, que regiões com números parecidos de casos de Ebola estão potencialmente próximos entre si. O p-valor fornecido por moran.test() é gerado por comparação à expectativa, sob hipótese nula, de não haver autocorrelação espacial, e pode ser utilizado caso você precise mostrar os resultados de um teste de hipóteses formal.de Moran Local - Podemos decompor o de Moran (global) calculado acima para identificar uma autocorrelação espacial localizada; ou seja, para identificar agrupamentos específicos em nossos dados. Essa estatística, que vezes é chamada de Indicador Local de Associação Espacial Local Indicator Spatial Association (LISA), resume extensão da autocorrelação espacial sobre cada região individual. Ela pode ser útil para achar regiões “quentes” ou “frias” mapa.Para mostrar um exemplo, podemos calcular e mapear ’s de Moran locais para contagens de casos de Ebola utilizados acima, com função local_moran() pacote spdep:Gi (ou G) de Getis-Ord - Essa é outra estatística comumente utilizada para análises de hotspots; em grande parte, popularidade dessa estatística está relacionada à sua utilização na ferramenta de análise de hotspots ArcGIS. Isso é baseado na premissa de que tipicamente, diferença entre os valores de uma variável entre regiões vizinhas deve seguir uma distribuição normal. Ela usa abordagem z-score para identificar regiões que possuem valores de uma dada variável que sejam significativamente mais altas (hot spot) ou significativamente mais baixas (cold spot), comparados aos seus vizinhos.Podemos calcular e mapear estatística Gi* utilizando função localG() spdep:Como você pode ver, o mapa de Gi* de Getis-Ord tem um visual ligeiramente diferente mapa de de Moran Local produzido anteriormente. Isso demonstra que o método utilizado para calcular essas duas estatísticas são ligeiramente diferentes; aquele que você vai utilizar depende seu caso de uso específico e sua pergunta experimental de interesse.Test L de Lee - Esse é um teste estatístico para correlação espacial bivariada. Ele permite que você teste se um padrão espacial para uma dada variável x é similar ao padrão espacial de outra variável y, cuja hipótese é que seja espacialmente relacionada com x.Para dar um exemplo, vamos testar se um padrão espacial dos casos de Ebola da epidemia simulada é correlacionado com o padrão espacial da população. Para iniciar, precisamos de uma variável population em nossa base sle_adm3. Podemos utilizar variável total dataframe sle_adm3_pop que carregamos anteriormente.Podemos visualizar rapidamente os padrões espaciais das duas variáveis lado lado, para ver se eles se parecem:Visualmente, os padrões parecem dissimilares. Podemos utilizar função lee.test() pacote spdep para testar estatisticamente se o padrão de autocorrelação espacial nas duas variáveis é relacionado. estística L será próxima de 0 se não houver correlação entre os padrões, e próxima de 1 se tiver uma forte correlação positiva (ou seja, os padrões são similares), e próximo de -1 se houver uma forma correlação negativa (ou seja, os padrões são inversos).saída acima mostra que estatística L de Lee para nossas duas variáveis é round(lee_test$estimate[1],2), o que indica uma fraca correlação negativa. Isso confirma nossa avaliação visual de que o padrão dos casos e população não estão relacionados entre si, e traz evidência de que o padrão espacial dos casos não é estritamente um resultado da densidade populacional em áreas de alto risco.estatística L de Lee pode ser útil para fazer esses tipos de inferência sobre relação entre variáveis espacialmente distribuídas; entanto, para descrever natureza relacionamento entre duas variáveis com mais detalhes, ou ajustar para fatores de confusão, técnicas de regressão espacial serão necessárias. Essas são descritas brevemente na seção seguinte.","code":"\nmoran_i <-spdep::moran.test(sle_adm3_dat$cases,    # vetor numérico com a variável de interesse\n                            listw=sle_listw)       # objeto listw resumindo as relações entre vizinhos\n\nmoran_i                                            # imprime os resultados do teste do I de Moran## \n##  Moran I test under randomisation\n## \n## data:  sle_adm3_dat$cases  \n## weights: sle_listw    \n## \n## Moran I statistic standard deviate = 1.696, p-value = 0.04494\n## alternative hypothesis: greater\n## sample estimates:\n## Moran I statistic       Expectation          Variance \n##        0.23347612       -0.12500000        0.04467655\n# calcula o I de Moran local\nlocal_moran <- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # variável de interesse\n  listw=sle_listw                                  # objeto listw com pesos para os vizinhos\n)\n\n# faz join dos resultados aos dados do sf (shapefile)\nsle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    \n\n# gera o mapa\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n# Faz uma análise G \ngetis_ord <- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# faz join dos resultados aos dados do sf\nsle_adm3_dat$getis_ord <- as.numeric(getis_ord)\n\n# gera o mapa\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\nsle_adm3_dat <- sle_adm3_dat %>% \n  rename(population = total)                          # renomeia 'total' para 'population'\ntmap_mode(\"plot\")\n\ncases_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # organiza em facetas 2x1 \nlee_test <- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # variável 1 para comparar \n  y=sle_adm3_dat$population,     # variável 2 para comparar \n  listw=sle_listw                # objeto listw com peso dos vizinhos\n)\n\nlee_test## \n##  Lee's L statistic randomisation\n## \n## data:  sle_adm3_dat$cases ,  sle_adm3_dat$population \n## weights: sle_listw  \n## \n## Lee's L statistic standard deviate = -0.93201, p-value = 0.8243\n## alternative hypothesis: greater\n## sample estimates:\n## Lee's L statistic       Expectation          Variance \n##       -0.13917328       -0.03562926        0.01234260"},{"path":"gis.html","id":"regressão-espacial","chapter":"3 Introdução ao GIS","heading":"Regressão espacial","text":"Talvez você queira fazer inferências estatísticas respeito dos relacionamentos entre variáveis nos seus dados espaciais. Nesses casos, pode ser útil considerar técnicas de regressão espacial - ou seja, abordagens para regressão que consideram explicitamente organização espacial das unidades dos seus dados. Algumas razões que podem fazer você considerar modelos de regressão espacial, em vez de modelos de regressão padrão tais como GLMs, incluem:Modelos padrão de regressão assumem que os resíduos são independentes uns dos outros. Na presença de fortes autocorrelações espaciais, os resíduos de um modelo padrão de regressão têm potencialidade de estarem espacialmente autocorrelacionados também, portanto, violando essa premissa. Isso pode levar problemas com interpretação dos resultados modelo, o que para o caso, um modelo espacial seria mais adequado.Modelos de regressão também assumem, tipicamente, que o efeito de uma variável x é constante sobre todas observações. caso de heterogeneidade espacial, os efeitos que queremos estimar podem variar sobre o espaço, e podemos estar interessados em quantificar essas diferenças. Nesse caso, modelos de regressão espacial oferecem mais flexibilidade para estimar e interpretar os efeitos.Os detalhes das abordagens de regressão espacial estão além escopo desse manual. Essa seção vai, ao invés, passar uma visão global dos modelos de regressão espacial mais comuns e seus usos, e sugerir referências que podem ser úteis caso você queira explorar essa área mais fundo.Modelos de Erro Espacial - Esses modelos assumem que os termos de erro ao longo de unidades espaciais são correlacionados, sendo esse o caso, os dados violariam premissas de um modelo OLS padrão. Modelos de Erro Espacial também podem ser chamados de modelos autorregressivos simultâneos (simultaneous autoregressive (SAR) models). Eles podem ser ajustados utilizando função errorsarlm() pacote spatialreg (funções de regressão espacial que costumavam fazer parte pacote spdep).Modelos de Defasagem Espacial (spacial lag models) - Esses modelos assumem que variável dependente para uma região é influenciada não apenas pelo valor das variáveis independentes em , mas também pelos valores daquelas variáveis em regiões vizinhas . Assim como os modelos de erro espacial, modelos de defasagem espacial também são descritos algumas vezes como modelos autorregressivos simultâneos (simultaneous autoregressive (SAR) models). Eles podem ser ajustados utilizando função lagsarlm() pacote spatialreg.O pacote spdep contém vários testes diagnóstico úteis para decidir entre os modelos OLS padrão, de defasagem espacial ou de erro espacial. Esses testes, chamados diagnósticos de Multiplicador de (Lagrange Multiplier diagnostics), podem ser utilizados para identificar o tipo de dependência espacial em seus dados e escolher qual modelo é mais apropriado. função lm.LMtests() pode ser utilizada para calcular todos os testes de Multiplicador de Lagrange. Anselin (1988) também demonstra uma ferramenta de fluxogramas para decidir qual modelo de regressão espacial ser utilizado baseado nos resultados dos testes de Multiplicador de Lagrange:Modelos Hierárquicos Bayesianos - Abordagens Bayesianas são comumente utilizadas para algumas aplicação em análise espacial, principalmente para mapeamento de doenças. Elas são preferidas em ocasiões onde os dados dos casos estão esparçamente distribuídas (por exemplo, caso de um desfecho raro) ou com muito “ruído” estatístico, de forma que elas podem ser utilizadas para gerar estimativas “suavizadas” risco de doenças ao considerar processos espaciais subjacentes que estavam latentes. Isso pode aumentar qualidade das estimativas. Elas também permitem ao investigador pre-especificação (via escolha de uma priori) de complexos padrões de correlação espaciais que podem existir nos dados, o que pode considerar variações espaço-dependente e -independente tanto nas variáveis independentes quanto nas dependentes. R, Modelos Hierarquicos Bayesianos podem ser ajustados utilizando o pacote CARbayes (veja documentação) ou R-INLA (veja website e livro). R também pode ser utilizado para chamar softwares externos que fazem estimativas Bayesianas, tais como JAGS ou WinBUGS.","code":""},{"path":"gis.html","id":"recursos-1","chapter":"3 Introdução ao GIS","heading":"3.12 Recursos","text":"Pacote Simple Features vignettePacote tmap vignetteggmap: Visualização Espacial com ggplot2Introdução à produção de mapas com R, visão geral de diferentes pacotesDados Espaciais R (EarthLab course)Análise de Dados Espaciais Aplicada com R livroSpatialEpiApp - um Shiny app que pode ser baixado como um pacote R, permitindo que você insira seus próprios dados e faça criação de mapas, análises de agrupamento (clusters) e estatísticas espaciais.Introdução à Economoetria Espacial com R workshop","code":""},{"path":"iteration.html","id":"iteration","chapter":"4 Iterações, loops e listas","heading":"4 Iterações, loops e listas","text":"Os epidemiologistas muitas vezes se deparam com análises repetidas em subgrupos, como países, distritos ou faixas etárias. Estas são apenas algumas das muitas situações envolvendo iteração. Codificar suas operações iterativamente usando abordagens abaixo ajudará você executar essas tarefas repetitivas mais rapidamente, reduzir chance de erro e reduzir o comprimento código.Esta página apresentará duas abordagens para operações iterativas - usando os loops e usando o pacote purrr.loops iteram código partir de uma série de entradas, mas são menos comuns em R que em outras linguagens de programação. entanto, nós os apresentamos aqui como uma ferramenta de aprendizagem e referênciaO pacote purrr é abordagem tidyverse para operações iterativas - ele funciona “mapeando” uma função em muitas entradas (valores, colunas, conjuntos de dados etc.)Ao longo caminho, mostraremos exemplos como:Importando e exportando vários arquivosCriando curvas epidemiológicas para várias jurisdiçõesExecutando testes T para várias colunas em um data frameNa seção purrr também forneceremos vários exemplos de criação e manipulação de listas.","code":""},{"path":"iteration.html","id":"preparação-3","chapter":"4 Iterações, loops e listas","heading":"4.1 Preparação","text":"","code":""},{"path":"iteration.html","id":"carregando-pacotes","chapter":"4 Iterações, loops e listas","heading":"Carregando pacotes","text":"Este trecho de código mostra o carregamento de pacotes necessários para análises. Neste livro nós enfatizamos o p_load() pacman, que instala o pacote, se necessário, e o carrega para uso. Você também pode carregar pacotes instalados com o library() R base. Veja página sobre o [R - o básico] para mais informações sobre pacotes R.","code":"\npacman::p_load(\n     rio,         # importa/exporta\n     here,        # localizador de arquivos\n     purrr,       # iteração\n     grates,      # scales in ggplot\n     tidyverse    # gerenciamento e visualização de dados\n)"},{"path":"iteration.html","id":"importando-dados","chapter":"4 Iterações, loops e listas","heading":"Importando dados","text":"Importamos o conjunto de dados de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar clique aqui para fazer download da linelist “limpa” (como um arquivo .rds). Importamos os dados com função import() pacote rio (ela lida com muitos tipos de arquivos como .xlsx, .csv, .rds - veja página Importar e exportar para detalhes).primeiras 50 linhas da linelist são exibidas abaixo.","code":"\n# importando a linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"iteration.html","id":"loops-for","chapter":"4 Iterações, loops e listas","heading":"4.2 loops for","text":"","code":""},{"path":"iteration.html","id":"iter_loops","chapter":"4 Iterações, loops e listas","heading":"loops for no R","text":"loops não são enfatizados em R, mas são comuns em outras linguagens de programação. Para iniciantes, eles podem ser úteis para aprender e praticar porque são mais fáceis de “explorar”, “depurar” e entender exatamente o que está acontecendo para cada iteração, especialmente quando você ainda não está confortável em escrever suas próprias funções .Você pode passar rapidamente loop para iterar com funções mapeadas com o purrr (consulte seção abaixo)","code":""},{"path":"iteration.html","id":"principais-componentes","chapter":"4 Iterações, loops e listas","heading":"Principais componentes","text":"Um loop tem três partes principais:sequência de itens para percorrerAs operações serem conduzidas por item na sequênciaO contêiner para armazenar os resultados (opcional)sintaxe básica é: (item em sequência) {fazer operações usando item}. Observe os parênteses e os colchetes. Os resultados podem ser impressos console ou armazenados em um objeto R (o container).Um exemplo simples de loop está abaixo.","code":"\nfor (num in c(1,2,3,4,5)) {  # a SEQUÊNCIA é definida (números 1 a 5) e o loop é aberto com \"{\"\n  print(num + 2)             # As OPERAÇÕES (adicione dois a cada número de sequência e imprima)\n}                            # O loop é fechado com \"}\"                           ## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7"},{"path":"iteration.html","id":"sequência","chapter":"4 Iterações, loops e listas","heading":"Sequência","text":"Esta é parte “” de um loop - operações serão executadas “para” cada item na sequência. sequência pode ser uma série de valores (por exemplo, nomes de jurisdições, doenças, nomes de colunas, elementos de lista, etc.), ou pode ser uma série de números consecutivos (por exemplo, 1,2,3,4,5). Cada abordagem tem suas próprias utilidades, descritas abaixo.estrutura básica de uma instrução de sequência é item em vetor.Você pode escrever qualquer caractere ou palavra lugar de “item” (por exemplo, “”, “num”, “hosp”, “distrito”, etc.). O valor desse “item” muda cada iteração loop, passando por cada valor vetor.O vetor pode ser de valores tipo caracteres, nomes de colunas ou talvez uma sequência de números - esses são os valores que mudarão cada iteração. Você pode usá-los nas operações loop usando o termo “item”.Exemplo: sequência de valores de caracteresNeste exemplo, um loop é executado para cada valor em um vetor de caracteres predefinido de nomes de hospitais.Escolhemos o termo hosp para representar valores vetor hospital_names. Para primeira iteração loop, o valor de hosp será hospital_names[[1]]. Para o segundo loop será hospital_names[[2]]. E assim por diante…Exemplo: sequência de nomes de colunasEsta é uma variação da sequência de caracteres acima, na qual os nomes de um objeto R existente são extraídos e se tornam o vetor. Por exemplo, os nomes das colunas de um data frame. Convenientemente, código de operações loop , os nomes das colunas podem ser usados para indexar (subconjunto) seu data frame original.Abaixo, sequência é o names() (nomes das colunas) data frame linelist. Nosso nome de “item” é col, que representará o nome de cada coluna à medida que os loops prosseguem.Para fins de exemplo, incluímos o código de operações dentro loop , que é executado para cada valor na sequência. Neste código, os valores de sequência (nomes das colunas) são usados para indexar (subconjunto) linelist, um de cada vez. Conforme ensinado na página Introdução ao R, colchetes duplos [[ ]] são usados para subconjunto. coluna resultante é passada para .na(), então para sum() para produzir o número de valores na coluna que estão faltando. O resultado é impresso console - um número para cada coluna.Sequência de númerosNesta abordagem, sequência é uma série de números consecutivos. Assim, o valor “item” não é um valor de caractere (por exemplo, “Hospital Central” ou “data_onset”), mas é um número. Isso é útil para fazer loop pelos data frames, pois você pode usar o número “item” dentro loop para indexar o data frame pelo número da linha.Por exemplo, digamos que você queira percorrer cada linha em seu data frame e extrair determinadas informações. Seus “itens” seriam números de linha numéricos. Frequentemente, “itens” neste caso são escritos como .O processo loop pode ser explicado em palavras como “para cada item em uma sequência de números de 1 ao número total de linhas meu data frame, faça X”. Para primeira iteração loop, o valor de “item” seria 1. Para segunda iteração, seria 2, etc.Aqui está aparência da sequência código: (1:nrow(linelist)) {OPERATIONS CODE} onde representa o “item” e 1:nrow(linelist) produz uma sequência de números de 1 até o número de linhas em linelist.Se você deseja que sequência seja de números, mas está começando de um vetor (não de um data frame), use o atalho seq_along() para retornar uma sequência de números para cada elemento vetor. Por exemplo, (seq_along(hospital_names) {OPERATIONS CODE}.O código abaixo na verdade retorna números, que se tornariam o valor de em seu respectivo loop.Uma vantagem de usar números na sequência é que é fácil também usar o número para indexar um contêiner que armazena saídas loop. Há um exemplo disso na seção Operações abaixo.","code":"\n# criando um vetor com os nomes dos hospitais\nhospital_names <- unique(linelist$hospital)\nhospital_names # printe (mostre o nome do hospital)## [1] \"Other\"                                \"Ausente\"                             \n## [3] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [5] \"Military Hospital\"                    \"Central Hospital\"\n# um 'loop for' com sequência de caracteres\n\nfor (hosp in hospital_names){       # sequência\n  \n       # OPERAÇÕES AQUI\n  }\nfor (col in names(linelist)){        # o loop é executado para cada coluna na linelist; nome da coluna representado por \"col\" \n  \n  # Exemplo de código de operações - printe o número de valores ausentes na coluna\n  print(sum(is.na(linelist[[col]])))  # linelist é indexado pelo valor atual de \"col\"\n     \n}## [1] 0\n## [1] 0\n## [1] 2087\n## [1] 256\n## [1] 0\n## [1] 936\n## [1] 1323\n## [1] 278\n## [1] 86\n## [1] 0\n## [1] 86\n## [1] 86\n## [1] 86\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 2088\n## [1] 2088\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 149\n## [1] 765\n## [1] 0\n## [1] 256\nfor (i in 1:nrow(linelist)) {  # use em um data frame\n  # OPERAÇÕES AQUI\n}  \nseq_along(hospital_names)  # use em um vetor de nomes## [1] 1 2 3 4 5 6"},{"path":"iteration.html","id":"operações","chapter":"4 Iterações, loops e listas","heading":"Operações","text":"Este é o código dentro das chaves { } loop . Você deseja que esse código seja executado para cada “item” na sequência. Portanto, tome cuidado para que cada parte seu código que muda pelo “item” seja codificada corretamente de forma que realmente mude! Por exemplo, lembre-se de usar [[ ]] para indexação.exemplo abaixo, iteramos em cada linha na linelist. Os valores gender e age de cada linha são colados e armazenados vetor de caracteres contêiner cases_demographics. Observe como também usamos indexação [[]] para salvar saída loop na posição correta vetor “contêiner”.","code":"\n# criando contêiner para armazenar resultados - um vetor de caractere\ncases_demographics <- vector(mode = \"character\", length = nrow(linelist))\n\n# o loop for\nfor (i in 1:nrow(linelist)){\n  \n  # OPERAÇÕES\n  # extraindo valores da linelist para a linha i, usando colchetes para indexação\n  row_gender  <- linelist$gender[[i]]\n  row_age     <- linelist$age_years[[i]]    # não se esqueça de indexar!\n     \n  # combinando gender-age e armazenar no vetor de contêiner no local indexado\n  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = \",\") \n\n}  # finalizando o loop for\n\n\n# exibindo as primeiras 10 linhas do contêiner\nhead(cases_demographics, 10)##  [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\""},{"path":"iteration.html","id":"contêiner","chapter":"4 Iterações, loops e listas","heading":"Contêiner","text":"Às vezes, os resultados seu loop serão impressos console ou painel RStudio Plots. Outras vezes, você desejará armazenar saídas em um “contêiner” para uso posterior. Esse contêiner pode ser um vetor, um data frame ou até mesmo uma lista.É mais eficiente criar o contêiner para os resultados antes mesmo de iniciar o loop. Na prática, isso significa criar um vetor, data frame ou lista vazio. Estes podem ser criados com funções vector() para vetores ou listas, ou com matrix() e data.frame() para um data frame.Vetor vazioUse vector() e especifique o mode = com base na classe esperada dos objetos que você irá inserir - seja “double” (para armazenar números), “character” ou “logical”. Você também deve definir o length = com antecedência. Este deve ser o comprimento da sua sequência loop .Digamos que você queira armazenar o atraso médio até admissão de cada hospital. Você usaria “double” e definiria o comprimento como o número de saídas esperadas (o número de hospitais exclusivos conjunto de dados).Data frame vazioVocê pode criar um data frame vazio especificando o número de linhas e colunas assim:Lista vaziaVocê pode querer armazenar alguns gráficos criados por um loop em uma lista. Uma lista é como um vetor, mas contém outros objetos R dentro dela que podem ser de diferentes classes. Os itens em uma lista podem ser um único número, um data frame, um vetor e até outra lista.Você realmente inicializa uma lista vazia usando o mesmo comando vector() acima, mas com mode = \"list\". Especifique o comprimento como desejar.","code":"\ndelays <- vector(\n  mode = \"double\",                            # esperamos armazenar números\n  length = length(unique(linelist$hospital))) # o número de hospitais únicos no conjunto de dados\ndelays <- data.frame(matrix(ncol = 2, nrow = 3))\nplots <- vector(mode = \"list\", length = 16)"},{"path":"iteration.html","id":"imprimindo","chapter":"4 Iterações, loops e listas","heading":"Imprimindo","text":"Observe que para “printar” (mostrar) de dentro de um loop você provavelmente precisará envolver explicitamente função print().Neste exemplo abaixo, sequência é um vetor de caracteres explícito, que é usado para acessar o subconjunto da linelist por hospital. Os resultados não são armazenados em um contêiner, mas são impressos console com função print().","code":"\nfor (hosp in hospital_names){ \n     hospital_cases <- linelist %>% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}## [1] 885\n## [1] 1469\n## [1] 422\n## [1] 1762\n## [1] 896\n## [1] 454"},{"path":"iteration.html","id":"testando-o-seu-loop","chapter":"4 Iterações, loops e listas","heading":"Testando o seu loop","text":"Para testar seu loop, você pode executar um comando para fazer uma atribuição temporária “item”, como <- 10 ou hosp <- \"Central Hospital\". Faça isso fora loop e execute apenas seu código de operações (o código entre colchetes) para ver se os resultados esperados são produzidos.","code":""},{"path":"iteration.html","id":"gráficos-em-loop","chapter":"4 Iterações, loops e listas","heading":"Gráficos em loop","text":"Para juntar todos os três componentes (contêiner, sequência e operações), vamos tentar traçar uma epicurva para cada hospital (consulte página em Curvas epidêmicas).Podemos fazer uma bela epicurva de todos os casos por gênero usando o pacote incidence2 conforme abaixo:Para produzir um gráfico separado para os casos de cada hospital, podemos colocar esse código da epicurva dentro de um loop .Primeiro, salvamos um vetor com os nomes exclusivos hospital, hospital_names. O loop será executado uma vez para cada um destes nomes: (hosp hospital_names). cada iteração loop , o nome hospital atual vetor será representado como hosp para uso dentro loop.Dentro das operações de loop, você pode escrever o código R normalmente, mas use o “item” (hosp neste caso) sabendo que seu valor será alterado. Dentro deste loop:Um filter() é aplicado linelist, de modo que coluna hospital deve ser igual ao valor atual de hospO objeto tipo incidence é criado na linelist filtradaO gráfico para o hospital atual é criado, com um título de ajuste automático que usa hospO gráfico hospital atual é salvo temporariamente e depois impressoO loop então avança para repetir com o próximo hospital em hospital_names","code":"\n# criando o objeto do tipo 'incidence'\noutbreak <- incidence2::incidence(   \n     x = linelist,                   # data frame - linelist completo\n     date_index = \"date_onset\",        # coluna de data\n     interval = \"week\",              # contagens agregadas semanalmente\n     groups = \"gender\")                # valores de grupo por gênero\n     #na_as_group = TRUE)             # o sexo ausente é um grupo próprio\n\n# plotando a epicurva\nggplot(outbreak, # nom de l'objet d'incidence\n        aes(x = date_index, #aesthetiques et axes\n            y = count, \n            fill = gender), # Fill colour of bars by gender\n       color = \"black\"      # Contour colour of bars\n       ) +  \n     geom_col() + \n     facet_wrap(~gender) +\n     theme_bw() + \n     labs(title = \"Outbreak of all cases\", #titre\n          x = \"Counts\", \n          y = \"Date\", \n          fill = \"Gender\", \n          color = \"Gender\")\n# criando o vetor dos nomes dos hospitais\nhospital_names <- unique(linelist$hospital)\n\n# para cada nome (\"hosp\") em hospital_names, crie e imprima a epicurva\nfor (hosp in hospital_names) {\n     \n     # criando objeto de incidência específico para o hospital atual\n     outbreak_hosp <- incidence2::incidence(\n          x = linelist %>% filter(hospital == hosp),   # linelist é filtrada para o hospital atual\n          date_index = \"date_onset\",\n          interval = \"week\", \n          groups = \"gender\"#,\n          #na_as_group = TRUE\n     )\n     \n     # Criando e salvando o gráfico. O título se ajusta automaticamente ao hospital atual\n      plot_hosp <- ggplot(outbreak_hosp, # incidence object name\n                         aes(x = date_index, #axes\n                             y = count, \n                             fill = gender), # fill colour by gender\n                         color = \"black\"      # colour of bar contour\n                         ) +  \n          geom_col() + \n          facet_wrap(~gender) +\n          theme_bw() + \n          labs(title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\"), #title\n               x = \"Counts\", \n               y = \"Date\", \n               fill = \"Gender\", \n               color = \"Gender\")\n     \n     # With older versions of R, remove the # before na_as_group and use this plot command instead.\n    # plot_hosp <- plot(\n#       outbreak_hosp,\n#       fill = \"gender\",\n#       color = \"black\",\n#       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n#     )\n     \n     # exibindo o gráfico para o hospital atual\n     print(plot_hosp)\n     \n} # encerrando o loop for quando ele tiver sido executado para todos os hospitais em hospital_names"},{"path":"iteration.html","id":"acompanhando-o-progresso-de-um-loop","chapter":"4 Iterações, loops e listas","heading":"Acompanhando o progresso de um loop","text":"Um loop com muitas iterações pode ser executado por muitos minutos ou até horas. Assim, pode ser útil imprimir o progresso console R. instrução (que significa “se” em inglês) abaixo pode ser colocada dentro das operações de loop para exibir cada 100 números. Basta ajustá-lo para que seja o “item” em seu loop.","code":"# loop com código para exibir o progresso a cada 100 iterações\nfor (i in seq_len(nrow(linelist))){\n\n  # print progress\n  if(i %% 100==0){    # O operador %% calcula o resto da operação\n    print(i)\n\n}"},{"path":"iteration.html","id":"iter_purrr","chapter":"4 Iterações, loops e listas","heading":"4.3 purrr e listas","text":"Outra abordagem para operações iterativas é o pacote purrr - essa é abordagem tidyverse para iteração.Se você tiver que executar mesma tarefa várias vezes, provavelmente vale pena criar uma solução generalizada que possa ser usada com várias entradas. Por exemplo, produzindo gráficos para várias jurisdições ou importando e combinando muitos arquivos.Há também algumas outras vantagens para usar o purrr - você pode usá-lo com pipes %>%, ele lida com erros melhor que o normal loop , e sintaxe é bastante limpa e simples! Se você estiver usando um loop , provavelmente poderá fazê-lo de forma mais clara e sucinta com purrr!Tenha em mente que o purrr é uma ferramenta de programação funcional. Ou seja, operações que devem ser aplicadas iterativamente são agrupadas em funções. Consulte página Escrevendo funções para aprender escrever suas próprias funções.O purrr também é quase inteiramente baseado em listas e vetores - então pense nisso como aplicar uma função cada elemento dessa lista/vetor!","code":""},{"path":"iteration.html","id":"carregando-pacotes-1","chapter":"4 Iterações, loops e listas","heading":"Carregando pacotes","text":"O purrr faz parte tidyverse, portanto, não há necessidade de instalar/carregar um pacote separado.","code":"\npacman::p_load(\n     rio,            # importa/exporta\n     here,           # caminhos de arquivos relativos\n     tidyverse,      # gerenciamento de dados e visualização\n     writexl,        # escreve arquivos Excel com várias abas\n     readxl          # importa arquivos Excel com várias abas\n)"},{"path":"iteration.html","id":"map","chapter":"4 Iterações, loops e listas","heading":"map()","text":"função principal purrr é map(), que “mapeia” (aplica) uma função para cada elemento de entrada de uma lista/vetor que você fornece.sintaxe básica é map(.x = SEQUENCE, .f = FUNCTION, ARGUMENTS). Com um pouco mais de detalhes:.x = são entradas nas quais função .f será aplicada iterativamente - ex. um vetor de nomes de jurisdição, colunas em um data frame ou uma lista de data frames.f = é função ser aplicada cada elemento da entrada .x - pode ser uma função como print() que já existe, ou uma função personalizada que você define. função geralmente é escrita após um til ~ (detalhes abaixo).Mais algumas notas sobre sintaxe:Se função não precisar de mais argumentos especificados, ela pode ser escrita sem parênteses e sem til (por exemplo, .f = mean). Para fornecer argumentos que terão o mesmo valor para cada iteração, forneça-os dentro da map() mas fora argumento .f =, como na.rm = T em map(.x = my_list, .f = média, na.rm=T).Você pode usar .x (ou simplesmente .) dentro da função .f = como um espaço reservado para o valor .x dessa iteraçãoUse sintaxe til (~) para ter maior controle sobre função - escreva função normalmente com parênteses, como: map(.x = my_list, .f = ~mean(., na.rm = T) ). Use esta sintaxe especialmente se o valor de um argumento mudar cada iteração, ou se o próprio valor .x (veja os exemplos abaixo)O resultado da função map() é uma lista - uma lista é uma classe de objeto como um vetor, mas cujos elementos podem ser de classes diferentes. Assim, uma lista produzida pela map() pode conter muitos data frames, ou muitos vetores, muitos valores únicos, ou mesmo muitas listas! Existem versões alternativas da map() explicadas abaixo que produzem outros tipos de saídas (por exemplo, map_dfr() para produzir um data frame, map_chr() para produzir vetores de caracteres e map_dbl() para produzir vetores).","code":""},{"path":"iteration.html","id":"iter_combined","chapter":"4 Iterações, loops e listas","heading":"Exemplo - importar e combinar planilhas do Excel","text":"Vamos demonstrar com uma tarefa comum de um epidemiologista: - Você deseja importar um arquivo Excel com dados caso, mas os dados são divididos em diferentes abas com nomes. Como você importa e combina com eficiência planilhas em um data frame?Digamos que recebemos arquivo Excel abaixo. Cada folha contém casos de um determinado hospital.Aqui está uma abordagem que usa função map():map() função import() para que seja executada para aba ExcelCombine em um os data frames importados usando bind_rows()Ao longo caminho, preserve o nome da aba original para cada linha, armazenando essas informações em uma nova coluna data frame finalPrimeiro, precisamos extrair os nomes das abas e salvá-los. Fornecemos o caminho arquivo Excel para função excel_sheets() pacote readxl, que extrai os nomes das abas Nós os armazenamos em um vetor de caracteres chamado sheet_names.Aqui estão os nomes:Agora que temos esse vetor de nomes, map() pode fornecê-los um um para função import(). Neste exemplo, os sheet_names são .x e import() é função .f.Lembre-se da página Importar e exportar que quando usado em arquivos Excel, import() pode aceitar o argumento = (qual) especificando aba ser importada. Dentro da função .f import(), fornecemos = .x, cujo valor mudará cada iteração através vetor sheet_names - primeiro “Central Hospital” (“Hospital Central”), depois “Military Hospital” (“Hospital Militar”) etc.Nota - porque usamos map(), os dados em cada planilha Excel serão salvos como um data frame separado dentro de uma lista. Queremos que cada um desses elementos de lista (data frame) tenha um nome, então antes de passarmos sheet_names para map(), passamos por set_names() de purrr, o que garante que cada elemento da lista recebe o nome apropriado.Salvamos lista de saída como o objeto combined.Quando inspecionamos o resultado, vemos que os dados de cada aba Excel são salvos na lista com um nome. Isso é bom, mas ainda não terminamos.Por fim, usamos função bind_rows() (dplyr) que aceita lista de data frames com estrutura semelhante e os combina em um único data frame. Para criar uma nova coluna partir elemento names da lista, usamos o argumento .id = e fornecemos o nome desejado para nova coluna.Abaixo está toda sequência de comandos:E agora temos um data frame com uma coluna contendo aba de origem!Existem variações da map() que você deve conhecer. Por exemplo, map_dfr() retorna um data frame, não uma lista. Assim, poderíamos tê-lo usado para tarefa acima e não ter que vincular linhas. Mas aí não teríamos conseguido capturar de qual aba (hospital) veio cada caso.Outras variações incluem map_chr(), map_dbl(). Estas são funções muito úteis por duas razões. Em primeiro lugar, elas convertem automaticamente saída de uma função iterativa em um vetor (não uma lista). Em segundo lugar, elas podem controlar explicitamente classe em que os dados voltam - você garante que seus dados voltem como um vetor de caracteres com map_chr(), ou vetor numérico com map_dbl(). Vamos voltar eles mais tarde na seção!funções map_at() e map_if() também são muito úteis para iteração - elas permitem que você especifique em quais elementos de uma lista você deve iterar! Estes funcionam simplesmente aplicando um vetor de índices/nomes (caso de map_at()) ou um teste lógico (caso de map_if()).Vamos usar um exemplo em que não queríamos ler primeira aba de dados hospital. Usamos map_at() em vez de map(), e especificamos o argumento .= para c(-1) que significa não usar o primeiro elemento de .x. Alternativamente, você pode fornecer um vetor de números positivos, ou nomes, para .= para especificar quais elementos usar.Observe que o nome da primeira aba ainda aparecerá como um elemento da lista de saída - mas é apenas um nome de caractere único (não um data frame). Você precisaria remover esse elemento antes de vincular linhas. Abordaremos como remover e modificar elementos de uma lista em uma seção posterior.","code":"\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\nsheet_names## [1] \"Central Hospital\"              \"Military Hospital\"            \n## [3] \"Missing\"                       \"Other\"                        \n## [5] \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\ncombined <- sheet_names %>% \n  purrr::set_names() %>% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extraindo o nome das abas\n \ncombined <- sheet_names %>%                                     # começando com os nomes das abas\n  purrr::set_names() %>%                                        # definindo seus nomes\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %>%  # iterando, importando, salvando na lista\n  bind_rows(.id = \"origin_sheet\") # combinar lista de data frames, preservando a origem em uma nova coluna\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined <- sheet_names %>% \n     purrr::set_names() %>% \n     # excluindo a primeira aba\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))"},{"path":"iteration.html","id":"divida-o-conjunto-de-dados-e-exporte","chapter":"4 Iterações, loops e listas","heading":"Divida o conjunto de dados e exporte","text":"Abaixo, damos um exemplo de como dividir um conjunto de dados em partes e, em seguida, usar iteração map() para exportar cada parte como uma aba separada Excel ou como um arquivo CSV separado.","code":""},{"path":"iteration.html","id":"conjunto-de-dados-dividido","chapter":"4 Iterações, loops e listas","heading":"Conjunto de dados dividido","text":"Digamos que temos o caso completo linelist como um data frame e agora queremos criar uma linelist separada para cada hospital e exportar cada um como um arquivo CSV separado. Abaixo, fazemos os seguintes passos:Use group_split() (dplyr) para dividir o data frame linelist por valores únicos na coluna hospital. saída é uma lista contendo um data frame por subconjunto de hospital.Podemos executar View(linelist_split) e ver que esta lista contém 6 data frames (“tibbles”), cada um representando os casos de um hospital.entanto, observe que os data frames na lista não possuem nomes por padrão! Queremos que cada um tenha um nome e, em seguida, use esse nome ao salvar o arquivo CSV.Uma abordagem para extrair os nomes é usar pull() (dplyr) para extrair coluna hospital de cada data frame na lista. Então, por segurança, convertemos os valores em caracteres e usamos unique() para obter o nome desse data frame específico. Todas essas etapas são aplicadas cada data frame via map().Agora podemos ver que cada um dos elementos da lista tem um nome. Esses nomes podem ser acessados via names(linelist_split).","code":"\nlinelist_split <- linelist %>% \n     group_split(hospital)\nnames(linelist_split) <- linelist_split %>%   # Atribuindo os nomes de data frames listados\n     # Extraia os nomes fazendo o seguinte para cada data frame:\n     map(.f = ~pull(.x, hospital)) %>%        # Puxe a coluna do hospital\n     map(.f = ~as.character(.x)) %>%          # Converta em caractere, apenas por garantia\n     map(.f = ~unique(.x))                    # Pegue o nome exclusivo do hospital\nnames(linelist_split)## [1] \"Ausente\"                              \"Central Hospital\"                    \n## [3] \"Military Hospital\"                    \"Other\"                               \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\""},{"path":"iteration.html","id":"mais-de-uma-coluna-group_split","chapter":"4 Iterações, loops e listas","heading":"Mais de uma coluna group_split()","text":"Se você quiser dividir linelist por mais de uma coluna de agrupamento, como para produzir uma lista de linelist pela interseção de hospital E sexo, precisará de uma abordagem diferente para nomear os elementos da lista. Isso envolve coletar “chaves de grupo” exclusivas usando group_keys() dplyr - elas são retornadas como um data frame. Então você pode combinar chaves de grupo em valores com unite() como mostrado abaixo, e atribuir esses nomes de conglomerados linelist_split.Agora combinamos os agrupamentos, separados por traços, e os atribuímos como os nomes dos elementos da lista em linelist_split. Isso leva algumas linhas extras, pois substituimos NA por “Ausente”, usamos unite() dplyr para combinar os valores das colunas (separados por traços) e, em seguida, convertemos em um vetor sem nome para que ele pode ser usado como nomes de linelist_split.","code":"\n# dividindo a linelist por combinações exclusivas de hospital-gênero\nlinelist_split <- linelist %>% \n     group_split(hospital, gender)\n\n# extraindo group_keys() como um data frame\ngroupings <- linelist %>% \n     group_by(hospital, gender) %>%       \n     group_keys()\n\ngroupings      # mostrando agrupamentos únicos## # A tibble: 18 × 2\n##    hospital                             gender\n##    <chr>                                <chr> \n##  1 Ausente                              f     \n##  2 Ausente                              m     \n##  3 Ausente                              <NA>  \n##  4 Central Hospital                     f     \n##  5 Central Hospital                     m     \n##  6 Central Hospital                     <NA>  \n##  7 Military Hospital                    f     \n##  8 Military Hospital                    m     \n##  9 Military Hospital                    <NA>  \n## 10 Other                                f     \n## 11 Other                                m     \n## 12 Other                                <NA>  \n## 13 Port Hospital                        f     \n## 14 Port Hospital                        m     \n## 15 Port Hospital                        <NA>  \n## 16 St. Mark's Maternity Hospital (SMMH) f     \n## 17 St. Mark's Maternity Hospital (SMMH) m     \n## 18 St. Mark's Maternity Hospital (SMMH) <NA>\n# Combinando em um valor de um nome\nnames(linelist_split) <- groupings %>% \n     mutate(across(everything(), replace_na, \"Ausente\")) %>%  # substituindo NA por \"Ausente\" em todas as colunas\n     unite(\"combined\", sep = \"-\") %>%                         # unindo todos os valores da coluna em um\n     setNames(NULL) %>% \n     as_vector() %>% \n     as.list()"},{"path":"iteration.html","id":"exportando-como-abas-do-excel","chapter":"4 Iterações, loops e listas","heading":"Exportando como abas do Excel","text":"Para exportar linelists hospital como um arquivo Excel com uma linelist por aba, podemos apenas fornecer lista nomeada linelist_split para função write_xlsx() pacote writexl. Isso tem capacidade de salvar um arquivo Excel com várias abas. Os nomes dos elementos da lista são aplicados automaticamente como os nomes das abasAgora você pode abrir o arquivo Excel e ver que cada hospital tem sua própria aba","code":"\nlinelist_split %>% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))"},{"path":"iteration.html","id":"exportando-como-arquivos-csv","chapter":"4 Iterações, loops e listas","heading":"Exportando como arquivos CSV","text":"É um comando um pouco mais complexo, mas você também pode exportar cada linelist específica hospital como um arquivo CSV separado, com um nome de arquivo específico para o hospital.Novamente usamos map(): pegamos o vetor de nomes de elementos da lista (mostrado acima) e usamos map() para iterar por eles, aplicando export() (pacote rio, veja página Importar e exportar) data frame na lista linelist_split que tem esse nome. Também usamos o nome para criar um nome de arquivo exclusivo. Aqui está como funciona:Começamos com o vetor de nomes de caracteres, passado para map() como .xComeçamos com o vetor de nomes de caracteres, passado para map() como .xA função .f é export() , que requer um data frame e um caminho de arquivo para gravarA função .f é export() , que requer um data frame e um caminho de arquivo para gravarA entrada .x (o nome hospital) é usada dentro de .f para extrair/indexar aquele elemento específico da lista linelist_split. Isso resulta em apenas um data frame por vez sendo fornecido para export().entrada .x (o nome hospital) é usada dentro de .f para extrair/indexar aquele elemento específico da lista linelist_split. Isso resulta em apenas um data frame por vez sendo fornecido para export().Por exemplo, quando map() itera para “Military Hospital” (“Hospital Militar”), então linelist_split[[.x]] é na verdade linelist_split[[\"Military Hospital\"]], retornando assim o segundo elemento de linelist_split - que são todos os casos Hospital Militar.Por exemplo, quando map() itera para “Military Hospital” (“Hospital Militar”), então linelist_split[[.x]] é na verdade linelist_split[[\"Military Hospital\"]], retornando assim o segundo elemento de linelist_split - que são todos os casos Hospital Militar.O caminho arquivo fornecido para export() é dinâmico através uso de str_glue() (consulte página Caracteres e strings):\n() é usado para obter base caminho arquivo e especificar pasta “data” (observe aspas simples para não interromper aspas duplas str_glue())\nO caminho arquivo fornecido para export() é dinâmico através uso de str_glue() (consulte página Caracteres e strings):() é usado para obter base caminho arquivo e especificar pasta “data” (observe aspas simples para não interromper aspas duplas str_glue())Em seguida, uma barra /, e novamente o .x que imprime o nome hospital atual para tornar o arquivo identificávelEm seguida, uma barra /, e novamente o .x que imprime o nome hospital atual para tornar o arquivo identificávelFinalmente extensão “.csv” que export() usa para criar um arquivo CSVFinalmente extensão “.csv” que export() usa para criar um arquivo CSVAgora você pode ver que cada arquivo é salvo na pasta “data” R Project “Epi_R_handbook”!","code":"\nnames(linelist_split) %>%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))"},{"path":"iteration.html","id":"customizar-funções","chapter":"4 Iterações, loops e listas","heading":"Customizar funções","text":"Você pode querer criar sua própria função para fornecer ao map().Digamos que queremos criar curvas epidêmicas para os casos de cada hospital. Para fazer isso usando purrr, nossa função .f pode ser ggplot() e extensões com + como de costume. Como saída de map() é sempre uma lista, os gráficos são armazenados em uma lista. Por serem gráficos, eles podem ser extraídos e plotados com função ggarrange() pacote ggpubr (documentação ).Se este código map() parecer muito confuso, você pode obter o mesmo resultado salvando seu comando ggplot() específico como uma função personalizada definida pelo usuário, por exemplo, podemos chamá-lo de make_epicurve()). Esta função é então usada dentro map(). .x será substituído iterativamente pelo nome hospital e usado como hosp_name na função make_epicurve(). Consulte página sobre Escrevendo funções.","code":"\n# carregando pacote para plotar elementos da lista\npacman::p_load(ggpubr)\n\n# mapeando o vetor de 6 \"nomes\" de hospitais (criados anteriormente)\n# usando a função ggplot especificada\n# a saída é uma lista com 6 ggplots\n\nhospital_names <- unique(linelist$hospital)\n\nmy_plots <- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# exibindo os ggplots (eles são armazenados em uma lista)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n# Criando a função\nmake_epicurve <- function(hosp_name){\n  \n  ggplot(data = linelist %>% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n# mapeando\nmy_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# exibindo os ggplots (eles são armazenados em uma lista)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)"},{"path":"iteration.html","id":"mapeando-uma-função-ao-longo-de-colunas","chapter":"4 Iterações, loops e listas","heading":"Mapeando uma função ao longo de colunas","text":"Outro caso de uso comum é mapear uma função ao longo de muitas colunas. Abaixo, mapeamos (map()) função t.test() em colunas numéricas data frame linelist, comparando os valores numéricos por gênero.Lembre-se da página em Testes estatísticos simples que t.test() pode receber entradas em um formato de fórmula, como t.test(coluna numérica ~ coluna binária). Neste exemplo, fazemos o seguinte:colunas numéricas de interesse são selecionadas de linelist - elas se tornam entradas .x para map()colunas numéricas de interesse são selecionadas de linelist - elas se tornam entradas .x para map()função t.test() é fornecida como função .f, que é aplicada cada coluna numéricaA função t.test() é fornecida como função .f, que é aplicada cada coluna numéricaDentro dos parênteses de t.test():\no primeiro ~ precede o .f que map() irá iterar sobre .x\no .x representa coluna atual sendo fornecida para função t.test()\no segundo ~ faz parte da equação teste t descrita acima\nfunção t.test() espera uma coluna binária lado direito da equação. Nós fornecemos o vetor linelist$gender independentemente e estaticamente (observe que ele não está incluído em select()).\nDentro dos parênteses de t.test():o primeiro ~ precede o .f que map() irá iterar sobre .xo .x representa coluna atual sendo fornecida para função t.test()o segundo ~ faz parte da equação teste t descrita acimaa função t.test() espera uma coluna binária lado direito da equação. Nós fornecemos o vetor linelist$gender independentemente e estaticamente (observe que ele não está incluído em select()).map() retorna uma lista, então saída é uma lista de resultados teste t - um elemento de lista para cada coluna numérica analisada.Aqui está aparência da lista t.test_results quando aberta (Visualizada) RStudio. Destacamos partes que são importantes para os exemplos nesta página.Você pode ver topo que lista inteira é chamada de t.test_results e tem cinco elementos. Esses cinco elementos são nomeados age, wt_km, ht_cm, ct_blood, temp após cada variável que foi usada em um teste t com gender da linelist.Cada um desses cinco elementos são listas, com elementos dentro deles, como p.value e conf.int. Alguns desses elementos como p.value são números únicos, enquanto alguns como estimate consistem em dois ou mais elementos (média grupo f e média grupo m).Nota: Lembre-se que se você deseja aplicar uma função apenas certas colunas em um data frame, você também pode simplesmente usar mutate() e across(), conforme explicado na página Limpeza de dados e principais funções. Abaixo está um exemplo de aplicação de .character() apenas para colunas “age”. Observe o posicionamento dos parênteses e vírgulas.","code":"\n# Resultados são salvos como uma lista\nt.test_results <- linelist %>% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # mantendo apenas algumas colunas numéricas para mapear\n  map(.f = ~t.test(.x ~ linelist$gender))        # função t.test com equação NUMERIC ~ CATEGORICAL\n# convertendo colunas com nome da coluna contendo \"idade\" para classe Character\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  "},{"path":"iteration.html","id":"extraindo-de-listas","chapter":"4 Iterações, loops e listas","heading":"Extraindo de listas","text":"Como map() produz uma saída da classe List (lista), vamos gastar algum tempo discutindo como extrair dados de listas usando funções acompanhantes purrr. Para demonstrar isso, usaremos lista t.test_results da seção anterior. Esta é uma lista de 5 listas - cada uma das 5 listas contém os resultados de um teste t entre uma coluna data frame linelist e sua coluna binária gender. Veja imagem na seção acima para uma visualização da estrutura da lista.","code":""},{"path":"iteration.html","id":"nomes-dos-elementos","chapter":"4 Iterações, loops e listas","heading":"Nomes dos elementos","text":"Para extrair os nomes dos próprios elementos, simplesmente use names() R base. Neste caso, usamos names() em t.test_results para retornar os nomes de cada sub-lista , que são os nomes das 5 variáveis que tiveram testes t realizados.","code":"\nnames(t.test_results)## [1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\""},{"path":"iteration.html","id":"elementos-por-nome-ou-posição","chapter":"4 Iterações, loops e listas","heading":"Elementos por nome ou posição","text":"Para extrair elementos da lista por nome ou por posição, você pode usar colchetes [[ ]] conforme descrito na página Introdução ao R. Abaixo usamos colchetes duplos para indexar lista t.tests_results e exibir o primeiro elemento que é o resultado teste t em age (idade).entanto, abaixo vamos demonstrar o uso das funções simples e flexíveis purrr map() e pluck() para alcançar os mesmos resultados.","code":"\nt.test_results[[1]] # primeiro elemento por posição## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results[[1]][\"p.value\"] # retorna o elemento nomeado \"p.value\" do primeiro elemento## $p.value\n## [1] 2.350374e-96"},{"path":"iteration.html","id":"pluck","chapter":"4 Iterações, loops e listas","heading":"pluck()","text":"pluck() extrai elementos por nome ou por posição. Por exemplo - para extrair os resultados teste t para idade, você pode usar pluck() assim:Indexe níveis mais profundos especificando os níveis adicionais com vírgulas. O código abaixo extrai o elemento chamado “p.value” (o p-valor)da lista age de dentro da lista t.test_results. Você também pode usar números em vez de nomes de caracteres.Você pode extrair esses elementos internos de todos os elementos de primeiro nível usando map() para executar função pluck() em cada elemento de primeiro nível. Por exemplo, o código abaixo extrai os elementos “p.value” de todas listas dentro de t.test_results. lista de resultados teste t é o .x iterado, pluck() é função .f sendo iterada e o valor “p-value” é fornecido para função.Como outra alternativa, map() oferece uma abreviação onde você pode escrever o nome elemento entre aspas, e ele irá “arrancá-lo”. Se você usar map() saída será uma lista, enquanto que se você usar map_chr() será um vetor de caractere nomeado e se você usar map_dbl() será um vetor numérico nomeado.Você pode ler mais sobre pluck() em sua documentação purrr. Ele tem uma função irmã chuck() que retornará um erro em vez de NULL se um elemento não existir.","code":"\nt.test_results %>% \n  pluck(\"age\")        # alternativamente, use pluck(1)## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results %>% \n  pluck(\"age\", \"p.value\")## [1] 2.350374e-96\nt.test_results %>%\n  map(pluck, \"p.value\")   # retorna cada p-valor## $age\n## [1] 2.350374e-96\n## \n## $wt_kg\n## [1] 2.664367e-182\n## \n## $ht_cm\n## [1] 3.515713e-144\n## \n## $ct_blood\n## [1] 0.4473498\n## \n## $temp\n## [1] 0.5735923\nt.test_results %>% \n  map_dbl(\"p.value\")   # retorna o p-valor como um vetor numérico com nome##           age         wt_kg         ht_cm      ct_blood          temp \n##  2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01"},{"path":"iteration.html","id":"convertendo-uma-lista-em-um-data-frame","chapter":"4 Iterações, loops e listas","heading":"Convertendo uma lista em um data frame","text":"Este é um tópico complexo - consulte seção Recursos para tutoriais mais completos. entanto, demonstraremos conversão da lista de resultados teste t em um data frame. Criaremos um data frame com colunas para variável, seu p-valor e médias dos dois grupos (masculino e feminino).Aqui estão algumas das novas abordagens e funções que serão usadas:função tibble() será usada para criar um tibble (como um data frame)\nEnvolvemos função tibble() com chaves { } para evitar que todo o t.test_results seja armazenado como primeira coluna tibble\nfunção tibble() será usada para criar um tibble (como um data frame)Envolvemos função tibble() com chaves { } para evitar que todo o t.test_results seja armazenado como primeira coluna tibbleDentro de tibble(), cada coluna é criada explicitamente, semelhante à sintaxe de mutate():\nO . representa t.test_results\nPara criar uma coluna com os nomes das variáveis teste t (os nomes de cada elemento da lista) usamos names() conforme descrito acima\nPara criar uma coluna com os p-valores, usamos map_dbl() conforme descrito acima para extrair os elementos p.value e convertê-los em um vetor numérico\nDentro de tibble(), cada coluna é criada explicitamente, semelhante à sintaxe de mutate():O . representa t.test_resultsPara criar uma coluna com os nomes das variáveis teste t (os nomes de cada elemento da lista) usamos names() conforme descrito acimaPara criar uma coluna com os p-valores, usamos map_dbl() conforme descrito acima para extrair os elementos p.value e convertê-los em um vetor numéricoMas agora vamos adicionar colunas contendo médias para cada grupo (masculino e feminino).Precisaríamos extrair o elemento estimate, mas na verdade ele contém dois elementos dentro dele (média grupo f e média grupo m). Portanto, não pode ser simplificado em um vetor com map_chr() ou map_dbl(). Em vez disso, usamos map(), que usado dentro de tibble() criará uma coluna da lista de classes dentro tibble! Sim, isso é possível!Depois de ter essa coluna de lista, há várias funções tidyr (parte tidyverse) que ajudam “retangular” ou “desaninhar” essas colunas de “lista aninhada”. Leia mais sobre eles aqui, ou executando vignette(\"rectangle\"). Em resumo:unnest_wider() - dá cada elemento de uma coluna de lista sua própria colunaunnest_longer() - dá cada elemento de uma coluna de lista sua própria linhahoist() - funciona como unnest_wider() mas você especifica quais elementos serão desaninhadosAbaixo, passamos o tibble para unnest_wider() especificando coluna means tibble (que é uma lista aninhada). O resultado é que means é substituído por duas novas colunas, cada uma refletindo os dois elementos que estavam anteriormente em cada célula means.","code":"\nt.test_results %>% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }## # A tibble: 5 × 2\n##   variables         p\n##   <chr>         <dbl>\n## 1 age       2.35e- 96\n## 2 wt_kg     2.66e-182\n## 3 ht_cm     3.52e-144\n## 4 ct_blood  4.47e-  1\n## 5 temp      5.74e-  1\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}## # A tibble: 5 × 3\n##   variables         p means       \n##   <chr>         <dbl> <named list>\n## 1 age       2.35e- 96 <dbl [2]>   \n## 2 wt_kg     2.66e-182 <dbl [2]>   \n## 3 ht_cm     3.52e-144 <dbl [2]>   \n## 4 ct_blood  4.47e-  1 <dbl [2]>   \n## 5 temp      5.74e-  1 <dbl [2]>\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %>% \n  unnest_wider(means)## # A tibble: 5 × 4\n##   variables         p `mean in group f` `mean in group m`\n##   <chr>         <dbl>             <dbl>             <dbl>\n## 1 age       2.35e- 96              12.7              19.6\n## 2 wt_kg     2.66e-182              45.8              59.6\n## 3 ht_cm     3.52e-144             109.              142. \n## 4 ct_blood  4.47e-  1              21.2              21.2\n## 5 temp      5.74e-  1              38.6              38.6"},{"path":"iteration.html","id":"descartar-manter-e-compactar-listas","chapter":"4 Iterações, loops e listas","heading":"Descartar, manter e compactar listas","text":"Como trabalhar com purrr geralmente envolve listas, exploraremos brevemente algumas funções purrr para modificar listas. Consulte seção Recursos para tutoriais mais completos sobre funções purrr.list_modify() tem muitos usos, um dos quais pode ser remover um elemento da listakeep() retém os elementos especificados para .p =, ou onde uma função fornecida para .p = é avaliada como TRUEdiscard() remove os elementos especificados para .p, ou onde uma função fornecida para .p = é avaliada como TRUEcompact() remove todos os elementos vaziosAqui estão alguns exemplos usando lista combined criada na seção acima em usando map() para importar e combinar vários arquivos (contém 6 data frames de linelist):Elementos podem ser removidos por nome com list_modify() e definindo o nome igual NULL.Você também pode remover elementos por critérios, fornecendo uma equação de “predicado” para .p = (uma equação que avalia como TRUE ou FALSE). Coloque um til ~ antes da função e use .x para representar o elemento da lista. Usando keep() os elementos da lista que forem avaliados como TRUE serão mantidos. Inversamente, se estiver usando discard(), os elementos da lista que forem avaliados como TRUE serão removidos.exemplo abaixo, os elementos da lista são descartados se suas classes não forem data frames.Sua função de predição também pode referenciar elementos/colunas dentro de cada item da lista. Por exemplo, abaixo, os elementos da lista onde média da coluna ct_blood é superior 25 são descartados.Este comando remove todos os elementos vazios da lista:","code":"\ncombined %>% \n  list_modify(\"Central Hospital\" = NULL)   # remove elemento da lista por nome\n# mantenha apenas elementos de lista com mais de 500 linhas\ncombined %>% \n  keep(.p = ~nrow(.x) > 500)  \n# descartando elementos que não são data frame\ncombined %>% \n  discard(.p = ~class(.x) != \"data.frame\")\n# mantenha apenas elementos onde a média da coluna ct_blood é maior que 25\ncombined %>% \n  discard(.p = ~mean(.x$ct_blood) > 25)  \n# remove todos os elementos vazios da lista\ncombined %>% \n  compact()"},{"path":"iteration.html","id":"pmap","chapter":"4 Iterações, loops e listas","heading":"pmap()","text":"ESTA SEÇÃO ESTÁ EM CONSTRUÇÃO","code":""},{"path":"iteration.html","id":"funções-apply","chapter":"4 Iterações, loops e listas","heading":"4.4 funções Apply","text":"família de funções “apply” é uma alternativa R base ao purrr para operações iterativas. Você pode ler mais sobre eles aqui.","code":""},{"path":"iteration.html","id":"recursos-2","chapter":"4 Iterações, loops e listas","heading":"4.5 Recursos","text":"para loops com Data CarpentryA página R Data Science sobre iteraçãoVinheta sobre gravação/leitura de arquivos ExcelUm tutorial purrr por jennybcOutro purrr tutorial por Rebecca BarterUm tutorial purrr para map, pmap e imappurrr cheatsheetdicas e truques purrrmanter e descartar","code":""}]
