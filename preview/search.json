[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"r-para-epidemiologia-aplicada-e-saúde-pública","chapter":"","heading":"R para epidemiologia aplicada e saúde pública","text":"Uso: Esse manual já foi utilizado mais de 1 milhão de vezes por 450,000 pessoas ao redor mundo.Objetivo: Servir como um guia de referência rápido para escrever código em R (online e offline) com exemplos centrados em exercícios que abordam problemas epidemiológicos comuns.Você está começando aprender R agora? Conheça nossos tutoriais interativos gratuitos ou o curso introdutório síncrono e virtual utilizado pelo CDC dos EUA, pela OMS, e mais de 75 outras agências de saúde e programas de treinamento em Epidemiologia de Campo.Idiomas: Inglês (English), Francês (Français), Espanhol (Español), Vietnamita (Tiếng Việt), Japonês (日本), Turco (Türkçe)Esta é uma versão traduzida para Português. Se você quer colaborar em melhorá-la, corrigindo algum erro, ou traduzir para outro idoma, por favor, nos contate!Escrito por epidemiologistas, para epidemiologistas  Applied Epi é uma organização sem fins lucrativos e um movimento de base composto por profissionais epidemiologistas que atuam na linha de frente de todo o mundo. Escrevemos em nosso tempo livre para oferecer este recurso à comunidade. Seu incentivo e feedback são muito bem-vindos:Visite nosso website e junte-se nossa lista de contatoscontact@appliedepi.org, tweet @appliedepi, ou LinkedInEnvie problemas para o nosso repositório GithubOferecemos treinamento em R ao vivo ministrado por instrutores com décadas de experiência em epidemiologia aplicada - envie-nos um e-mail para discutir.","code":""},{"path":"index.html","id":"como-usar-este-manual","chapter":"","heading":"Como usar este manual","text":"Navegue pelas páginas Índice, ou use caixa de buscaClique nos ícones “copiar” para copiar o códigoVocê pode seguir - junto com os dados exemplo.Consulte seção “Recursos” de cada página para obter mais materialVersão -lineVeja instruções na página Fazer o Download manual e dos dados.","code":""},{"path":"index.html","id":"agradecimentos","chapter":"","heading":"Agradecimentos","text":"Este manual é produzido por uma colaboração de epidemiologistas de todo o mundo, aproveitando experiência de organizações que incluem agências de saúde locais, estaduais, provinciais e nacionais, Organização Mundial da Saúde (OMS), Médicos Sem Fronteiras / Médicos sem Fronteiras (MSF), sistemas hospitalares e instituições acadêmicas.Este manual não é um produto aprovado de qualquer organização específica. Embora nos esforcemos para ser precisos, não damos nenhuma garantia conteúdo deste livro.","code":""},{"path":"index.html","id":"colaboradores","chapter":"","heading":"Colaboradores","text":"Editor: Neale BatraAutores: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinRevisores: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIlustradores: Calder FongTradutores da versão em língua portuguesa (Brasil): Carolina Musso, César Augusto Galvão , Halian Vilela, Laís Relvas, Felipe Cardoso, Rafaela Tadei, Pauliana Galvão, Nathalia Zini, Paula Maçaira, João Pedro Angelici, Ademar Barbosa Dantas Junior, Eucilene Santana, Hudson Gabriel Virtuoso Fontenele, Lucca NielsenOs tradutores agradecem ProEpi pelo apoio para tradução e contato com Applied Epi.","code":""},{"path":"index.html","id":"financiamento-e-apoio","chapter":"","heading":"Financiamento e apoio","text":"O manual recebeu financiamento de apoio através de uma subvenção de emergência COVID-19 da TEPHINET, rede global de Programas de Treinamento em Epidemiologia de Campo (FETPs).O apoio administrativo foi fornecido pela EPIET Alumni Network (EAN), com agradecimentos especiais à Annika Wendland. O EPIET é o Programa Europeu de Treinamento em Epidemiologia de Intervenção.Agradecimentos especiais aos Médicos Sem Fronteiras (MSF) Centro Operacional Amsterdã (OCA) por seu apoio durante o desenvolvimento deste manual.Esta publicação foi apoiada pelo Acordo Cooperativo número NU2GGH001873, financiado pelos Centros de Controle e Prevenção de Doenças através TEPHINET, um programa da Força Tarefa para Saúde Global. Seu conteúdo é de responsabilidade exclusiva dos autores e não representa necessariamente visão oficial dos Centros de Controle e Prevenção de Doenças, Departamento de Saúde e Serviços Humanos, Task Force Global Health, Inc. ou TEPHINET.","code":""},{"path":"index.html","id":"inspiração","chapter":"","heading":"Inspiração","text":"infinidade de tutoriais e vinhetas que forneceram conhecimento para o desenvolvimento conteúdo manual são creditados dentro de suas respectivas páginas.De modo mais geral, seguintes fontes forneceram inspiração para este manual:“R4Epis” project (colaboração entre MSF e RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"termos-de-uso-e-contribuição","chapter":"","heading":"Termos de Uso e Contribuição","text":"","code":""},{"path":"index.html","id":"licença","chapter":"","heading":"Licença","text":"Esta obra está licenciada sob uma Licença Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.Cursos acadêmicos e programas de treinamento de epidemiologistas são bem-vindos para usar este manual com seus alunos. Se você tiver dúvidas sobre o uso pretendido, envie um e-mail para contact@appliedepi.org.","code":""},{"path":"index.html","id":"citação","chapter":"","heading":"Citação","text":"Batra, Neale, et ai. O Manual Epidemiologista R. 2021. ","code":""},{"path":"index.html","id":"contribuição","chapter":"","heading":"Contribuição","text":"Se você quiser fazer uma contribuição de conteúdo, entre em contato conosco primeiro por meio de questões Github ou por e-mail. Estamos implementando um cronograma de atualizações e criando um guia contribuidor.Observe que o projeto epiRhandbook é lançado com um Código de Conduta Contribuidor. Ao contribuir para este projeto, você concorda em respeitar seus termos.","code":""},{"path":"gis.html","id":"gis","chapter":"1 Introdução ao GIS","heading":"1 Introdução ao GIS","text":"","code":""},{"path":"gis.html","id":"visão-geral","chapter":"1 Introdução ao GIS","heading":"1.1 Visão Geral","text":"Os aspectos especiais dos seus dados podem trazer vários insights à situação de um surto, e pode responder perguntas como:Onde estão os hotspots da doença?Como os hotspots mudaram ao longo tempo?Como é o acesso às unidades de saúdo? Melhorias são necessárias?O foco dessa página sobre GIS é atender às necessidades dos epidemiologistas na resposta aos surtos. Iremos explorar métodos básicos de visualização de dados espaciais utilizando os pacotes tmap e ggplot2. Também vamos caminhar por métodos básicos de gerenciamento e consulta de dados espaciais com o pacote sf. Por fim, vamos dar uma olhada em conceitos de estatística espacial tais como relações espaciais, autocorrelação espacial e regressão espacial utilizando o pacote spdep.","code":""},{"path":"gis.html","id":"terminologia","chapter":"1 Introdução ao GIS","heading":"1.2 Terminologia","text":"Abaixo introduziremos terminologia principal. Para uma introdução mais profunda ao GIS e à análise espacial, sugerimos que você revise algum dos tutoriais maiores ou cursos listados na seção de Referências.Geographic Information System (GIS) (Sistema de Informação Geográfica) - Um GIS é um framework ou ambiente para reunir, gerenciar, analisar e visualizar dados espaciais.","code":""},{"path":"gis.html","id":"softwares-gis","chapter":"1 Introdução ao GIS","heading":"Softwares GIS","text":"Alguns Softwares GIS mais conhecidos permitem interação tipo “apontar-e-clicar” (point--click) para o desenvolvimento de mapas e análises espaciais. Essas ferramentas vêm com vantagens de não precisar aprender código e com facilidade de selecionar e posicionar manualmente ícones e outras características em um mapa. Aqui temos dois dos mais conhecidos:ArcGIS - Um software GIS comercial desenvolvido pela empresa ESRI, que é muito famoso mas bastante caro.QGIS - Um software GIS gratuito e open-source que pode fazer praticamente qualquer coisa que o ArcGIS também pode. Você pode baixar o QGIS aquiUtilizar o R como um GIS pode parecer mais intimidador início, pois em vez “apontar-e-clicar”, ele tem uma interface de linha de comando (você precisa escrever código para chegar resultado esperado). entanto, essa é uma grande vantagem se você precisa produzir mapas repetitivamente ou criar análises que sejam reprodutíveis.","code":""},{"path":"gis.html","id":"dados-espaciais","chapter":"1 Introdução ao GIS","heading":"Dados espaciais","text":"duas formas primordiais de dados espaciais utilizados GIS são dados vetoriais e rasterizados.Dados Vetoriais - O formato de dados espaciais mais comum utilizado GIS. Dados vetoriais compreendem propriedades geométricas de vértices e trajetos (paths). Os dados vetoriais espaciais também podem se subdividir em três tipos amplamente utilizados:Pontos - Um ponto consiste em um par ordenado (x,y) representando um local específico em um sistema de coordenadas. Pontos são forma mais básica de dados espaciais e podem ser utilizados para representar um caso (casa de um paciente) ou um local (hospital) em um mapa.Pontos - Um ponto consiste em um par ordenado (x,y) representando um local específico em um sistema de coordenadas. Pontos são forma mais básica de dados espaciais e podem ser utilizados para representar um caso (casa de um paciente) ou um local (hospital) em um mapa.Linhas - Uma linha é composta de dois pontos conectados. Linhas possuem um comprimento, e podem ser utilizadas para representar coisas como rodovias ou rios.Linhas - Uma linha é composta de dois pontos conectados. Linhas possuem um comprimento, e podem ser utilizadas para representar coisas como rodovias ou rios.Polígonos - Um polígono é composto de pelo menos três segmentos de linha conectados por pontos. propriedades de um Polígono são comprimento (o perímetro da área) bem como própria medida da área. Polígonos podem ser utilizado para demarcar uma área (uma vila) ou uma estrutura (área de um hospita ).Polígonos - Um polígono é composto de pelo menos três segmentos de linha conectados por pontos. propriedades de um Polígono são comprimento (o perímetro da área) bem como própria medida da área. Polígonos podem ser utilizado para demarcar uma área (uma vila) ou uma estrutura (área de um hospita ).Dados Rasterizados - Um formato alternativo para dados espaciais, dados rasterizados são uma matriz de células (por exemplo, pixels) em que cada célula contém informações como altura, temperatura, inclinação, cobertura florestal, etc. Essas geralmente são fotos aéreas, imagens de satélite, etc. Os “Rasters” também podem ser utilizados como “mapas base” sob dados vetoriais.","code":""},{"path":"gis.html","id":"visualizando-dados-espaciais","chapter":"1 Introdução ao GIS","heading":"Visualizando dados espaciais","text":"Para representar visualmente os dados espaciais em um mapa, os softwares GIS exigem que você forneça informação suficiente sobre onde posicionar cada característica em relação umas às outras. Se você estiver utilizando dados vetoriais, o que vai acontecer na maioria dos casos, essas informações normalmente estarão armazenadas em um “shapefile”.Shapefiles - Um shapefile é um formato de dado comum para armazenar dados espaciais “vetoriais” que consistem de linhas, pontos ou polígonos. Um único shapefile na verdade é um conjunto de pelo menos três arquivos - .shp, .shx, e .dbf. Todos esses sub-componentes devem estar presente em um mesmo diretório (pasta) para que o shapefile possa ser lido. Esses arquivos associados podem ser comprimidos em uma pasta ZIP para ser enviado por email ou baixado de um site.O shapefile vai conter informação sobre propriedades propriamente ditas, bem como onde encontrá-las na superfície da Terra. Isso é importante pois apesar da Terra ser um globo, os mapas são tipicamente bidimensionais; escolhas sobre como “achatar” os dados espaciais podem ter grande impactos visual e na interpretação mapa produzido.Coordinate Reference Systems (CRS) (Sistemas de Referências de Coordenadas) - Um SRC é um sistema baseado em coordenadas utilizado para localizar propriedades geográficas na superfície da Terra. Ele possui alguns componentes principais:Sistema de Coordenadas - Existem muitos tipos diferentes de sistemas de coordenadas, então certifique-se de qual dos tipos suas coordenadas fazem parte. Graus de latitude/longitude são comuns, mas você pode também ver coordenadas UTM.Sistema de Coordenadas - Existem muitos tipos diferentes de sistemas de coordenadas, então certifique-se de qual dos tipos suas coordenadas fazem parte. Graus de latitude/longitude são comuns, mas você pode também ver coordenadas UTM.Unidades - Saiba qual são unidades para o seu sistema de coordenadas (exemplo: graus decimais, metros)Unidades - Saiba qual são unidades para o seu sistema de coordenadas (exemplo: graus decimais, metros)Datum - Uma versão modelada específica da Terra. Essa versão vem sendo revisada ao longo dos anos, então certifique-se de que camadas seu mapa utilizam o mesmo datum.Datum - Uma versão modelada específica da Terra. Essa versão vem sendo revisada ao longo dos anos, então certifique-se de que camadas seu mapa utilizam o mesmo datum.Projeção - Uma referência à equação matemática que foi utilizada para projetar verdadeiramente redonda Terra em uma superfície plana (mapa).Projeção - Uma referência à equação matemática que foi utilizada para projetar verdadeiramente redonda Terra em uma superfície plana (mapa).Lembre-se que você pode resumir dados espaciais sem utilizar ferramentas de mapas mostradas abaixo. Às vezes, uma simples tabela por dados geográficos (distritos, países, etc.) é todo o necessário!","code":""},{"path":"gis.html","id":"iniciando-com-gis","chapter":"1 Introdução ao GIS","heading":"1.3 Iniciando com GIS","text":"Existem alguns itens importantes que você precisará ter ou pensar respeito para fazer um mapa. Esses incluem:Uma base de dados – pode ser em formato de dados espaciais (tais como shapefiles, como mostrado acima) ou pode não ser em formato espacial (apenas um csv).Se sua base de dados não estiver em um formato espacial você também vai precisar de uma base de dados de referência. Dados de referência consistem nas representações espaciais de dados e seus atributos relacionados, que deverão incluir material contendo o local e informações sobre o endereço de propriedades específicas.\nSe você estiver trabalhando com fronteiras geográficas pré-definidas (por examplo, regiões administrativas), shapefiles de referências geralmente estão disponíveis gratuitamente para download nos sites das agências governamentais ou organizações de compartilhamento de dados. Se estiver em dúvida, um bom jeito de começar é buscar Google por “[região] shapefile”\nSe você tiver informação sobre endereços, mas não tiver latitude e longitude, talvez você precisa utilizar um motor de geocodificação (geocoding engine) para coletar os dados de referências espaciais para seus regristros.\nSe você estiver trabalhando com fronteiras geográficas pré-definidas (por examplo, regiões administrativas), shapefiles de referências geralmente estão disponíveis gratuitamente para download nos sites das agências governamentais ou organizações de compartilhamento de dados. Se estiver em dúvida, um bom jeito de começar é buscar Google por “[região] shapefile”Se você tiver informação sobre endereços, mas não tiver latitude e longitude, talvez você precisa utilizar um motor de geocodificação (geocoding engine) para coletar os dados de referências espaciais para seus regristros.Uma ideia sobre como você quer apresentar informação em suas bases para seu público alvo. Existem muitos tipos diferentes de mapas, e é importante pensar sobre qual se encaixa melhor à suas necessidades.","code":""},{"path":"gis.html","id":"tipos-de-mapas-para-visualizar-seus-dados","chapter":"1 Introdução ao GIS","heading":"Tipos de mapas para visualizar seus dados","text":"Mapa coroplético (Choropleth map) - um tipo de mapa temático onde cores, sombreamento ou padrões são utilizados para representar regiões geográficas de acordo com seus valores de um atributo. Por exemplo, um valor maior pode ser indicado por uma cor mais escura que um valor menor. Esse tipo de mapa é particularmente útil quando estamos visualizando uma variável e como seu valor muda através de regiões definidas ou áreas geopolíticas.Mapa de calor de densidade de casos (Case density heatmap) - um tipo de mapa temático em que cores são utilizada para representar intensidade de um valor, entanto, ele não utiliza regiões definidas ou fronteiras geopolíticas para agrupar os dados. Esse tipo de mapa é tipicamente utilizado para mostrar ‘hot spots’ ou áreas com uma alta densidade ou concentração de pontos.Mapa de densidade de pontos (Dot density map) - um tipo de mapa temático que usa pontos para reprensentar valores de atributos nos seus dados. Esse tipo de mapa é melhor utilizado para visualizar o espalhamento dos dados e permitir um “escaneamento” visual de agrupamentos (clusters).Mapa de símbolos proporcionais (mapa de símbolos graduados) (Proportional symbols map (graduated symbols map)) - um mapa temático similar ao mapa de coroplético mas, em vez de utilizar cores para indicar o valor de um atributo, ele utiliza um símbolo (geralmente um círculo) de acordo com o valor. Por exemplo, um valor maior pode ser indicado por um símbolo maior que um valor menor. Esse tipo de mapa é melhor utilizado quando se quer visualizar o tamanho ou quantidade dos seus dados através de regiões geográficas.Você também pode combinar vários tipos diferentes de visualização para mostrar padrões geográficos complexos. Por exemplo, os casos (pontos) mapa abaixo estão coloridos de acordo com unidade de saúde mais próxima (veja legenda). Os círculos maiores mostram áreas de alcance das unidades de saúde partir de um certo raio e os pontos vermelho-vivo mostram os casos fora alcance de qualquer uma das unidades de saúde mostradas:Nota: O foco principal dessa página sobre GIS é baseado contexo de uma resposta de campo um surto. Por isso, os conteúdos da página irão cobrir o básico de manipulação, visualização e análise de dados espaciais.","code":""},{"path":"gis.html","id":"preparação","chapter":"1 Introdução ao GIS","heading":"1.4 Preparação","text":"","code":""},{"path":"gis.html","id":"carregue-os-pacotes-r","chapter":"1 Introdução ao GIS","heading":"Carregue os pacotes R","text":"O código abaixo realiza o carregamento dos pacotes necessários para análise dos dados. Neste manual, enfatizamos o uso da função p_load(), pacman, que instala os pacotes, caso não estejam instalados, e os carrega R para utilização. Também é possível carregar pacotes instalados utilizando função library(), R base. Para mais informações sobre os pacotes R, veja página Introdução ao R.Você pode ter uma visão geral de todos os pacotes R que lidam com dados espaciais em CRAN “Spatial Task View”.","code":"\npacman::p_load(\n  rio,           # para importar os dados\n  here,          # para localizar arquivos \n  tidyverse,     # para limpar, manipular e gerar gráficos com os dados (inclui o pacote ggplot2)\n  sf,            # para gerenciar dados espaciais utilizando o formato Simple Feature \n  stars,          # para produzir mapas simples, funciona tanto para mapas interativos quanto estáticos \n  janitor, # para limpar nomes das colunas \n  terra, #dependencia tmap\n  tmap,\n  OpenStreetMap, # para adicionar o mapa-base do OpenStreeMap ao mapa do ggplot\n  tmaptools,\n  spdep\n  \n  ) "},{"path":"gis.html","id":"amostra-de-dados-dos-casos","chapter":"1 Introdução ao GIS","heading":"Amostra de dados dos casos","text":"Para fins de demonstração, iremos trabalhar com uma amostra aleatória de 1000 casos dataframe da linelist de uma epidemia simulada de Ebola (computacionalmente, trabalhar com menos casos é mais fácil para mostrar nesse handbook). Se você quiser acompanhar análise, clique aqui para baixar linelist “limpa” (como um arquivo .rds).Uma vez que estamos tomando uma amostra aleatória dos casos, seus resultados podem parecer ligeiramente diferentes que está demonstrado aqui quando você rodar os códigos por conta própria.Importe os dados com função import() pacote rio (ela lida com vários tipos de arquivo como .xlsx, .csv, .rds - veja página Importar exportar para mais detalhes).Next select random sample 1000 rows using sample() base R.Queremos converter essa linelist, que possui classe dataframe, para um objeto da classe “sf” (spatial features). Dado que linelist possui duas colunas “lon” e “lat” representando longitude e latitude da casa de cada caso, isso será fácil.Utilizamos o pacote sf (spatial features) e sua função st_as_sf() para criar um novo objeto que chamaremos de linelist_sf. Esse novo objeto parece essencialmente mesma coisa que linelist, mas colunas lon e lat foram designadas como colunas de coordenadas, e um sistema de referência de coordenadas (SRC) foi atribuído para quando os pontos forem mostrados. O número 4326 identifica nossas coordenadas de acordo com o World Geodetic System 1984 (WGS84) - que é o padrão para coordenadas de GPS.O dataframe da linelist original tem esta forma. Nesta demonstração, iremos utilizar apenas coluna date_onset e geometry (que foi construída partir dos campos de longitude e latitude acima e são últimas colunas dataframe).","code":"\n# importa a linelist de casos limpa \nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))  \n# gera 1000 números aleatórios de linhas, a partir do número de linhas da linelist\nsample_rows <- sample(nrow(linelist), 1000)\n\n# gera um subconjunto da linelist para manter apenas as linhas da amostra, e todas as colunas\nlinelist <- linelist[sample_rows,]\n# Cria um objeto do tipo sf\nlinelist_sf <- linelist %>%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )"},{"path":"gis.html","id":"shapefiles-das-fronteiras-administrativas","chapter":"1 Introdução ao GIS","heading":"Shapefiles das fronteiras administrativas","text":"Serra Leoa: Shapefiles das fronteiras administrativasDe antemão, já baixamos todas fronteiras administrativas de Serra Leoa site da Humanitarian Data Exchange (HDX) que você encontra aqui. Caso prefira, você pode baixar esse e todos os outros dados de exemplos para esse manual através de nosso pacote de R, conforme explicado na página Download dos dados manual.Agora faremos o seguinte para salvar R o shapefile nível administrativo 3Importar o shapefileLimpar o nome das colunasFiltar linhas para manter apenas áreas de interessePara importar um shapefile usamos função read_sf() pacote sf. À ela é fornecido o caminho arquivo através da função (). - em nosso caso o arquivo está em nosso projeto R, nas subpastas “data”, “gis”, e “shp”, com o nome de arquivo “sle_adm3.shp” (veja páginas Importar e exportar e Projetos R para mais informações). Você precisará fornecer seu próprio caminho de arquivo.Em seguida usamos função clean_names() pacote janitor para padronizar os nomes das colunas shapefile. Também utilizamos filter() para manter apenas linhas com área administrativa 2 (admin2name) chamada “Western Area Urban” ou “Western Area Rural”.Abaixo, podemos ver como fica o shapefile depois da importação e limpeza. Role para direita para ver como há colunas com nível administrativo 0 (país), nível administrativo 1, nível administrativo 2, e finalmente nível administrativo 3. Cada nível tem um nome composto de letras e um identificador único chamado “pcode”. O pcode expande com cada nível administrativo que aumenta ex: SL (Serra Leoa) -> SL04 (Oeste) -> SL0410 (Area Rural Oeste) -> SL040101 (Koya Rural).","code":"\n# nível ADM3 limpo\nsle_adm3 <- sle_adm3_raw %>%\n  janitor::clean_names() %>% # padronizar o nome das colunas\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # filtrar para manter certas áreas"},{"path":"gis.html","id":"dados-populacionais","chapter":"1 Introdução ao GIS","heading":"Dados populacionais","text":"Serra Leoa: População por ADM3Novamente, esses dados podem ser baixadados site da HDX (link aqui) ou pelo pacote epirhandbook explicado nessa página. Usamos import() para carregar o arquivo .csv. Também passamos o arquivo importado para clean_names() para padronizar sintaxe dos nomes das colunas.Essa é aparência arquivo de população. Role para direita para ver como cada jurisdição tem colunas com população masculina (male), feminina (female), e população total, e subdivisões nas colunas columns por grupo de idade.","code":"\n# População por nível ADM3\nsle_adm3_pop <- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %>%\n  janitor::clean_names()"},{"path":"gis.html","id":"unidades-de-saúde","chapter":"1 Introdução ao GIS","heading":"Unidades de Saúde","text":"Serra Leoa: Dados das Unidades de Saúde OpenStreetMapNovamente, baixamos os locais das unidades de saúde HDX aqui ou por meio das instruções na página manual de Download e dados.Nós importamos o shapefile dos pontos das unidades com read_sf(), e novamente limpamos os nomes das colunas, e depois, filtramos para manter apenas os pontos marcados com “hospital”, clínica (“clinic”), ou doutores (“doctors”).Aqui está o dataframe resultante - role para direita para ver o nome da unidade e coordenadas de geometria (geometry).","code":"\n# shapefile das unidades de saúde do OSM (open street map) \nsle_hf <- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %>% \n  janitor::clean_names() %>%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))"},{"path":"gis.html","id":"criando-gráficos-das-coordenadas","chapter":"1 Introdução ao GIS","heading":"1.5 Criando gráficos das coordenadas","text":"forma mais fácil de criar um gráfico de coordenadas X-Y (longitude/latitude, pontos), nessa situação dos casos, é desenhenhá-los como pontos diretamente objeto linelist_sf que criamos na seção de preparação.O pacote tmap oferece algumas capacidades simples de fazer mapas tanto de forma estática ( modo “plot”) quanto interativa ( modo de visualização - “view”) com apenas algumas linhas de código. sintaxe tmap é parecida com ggplot2, de forma que os comandos são somados uns aos outros com o operador +. Veja mais detalhes nessa vignette.Defina o modo tmap. Neste caso iremos utilizar o modo “plot”, que produz saídas estáticas.Abaixo, os pontos são projetados sozinhos. função tm_shape() é disponibilizada com os objetos linelist_sf. Em seguida, adicionamos pontos via tm_dots(), especificando o tamanho e cor. Pelo fato de linelist_sf ser um objeto tipo sf, nós já temos duas colunas designadas que contêm coordenadas de latitude e longitude e o sistema de referência de coordenadas (CRS):Sozinhos os pontos não nos dizem muita coisa. Então devemos também projetar fronteiras administrativas:Novamente, utilizaremos tm_shape() (veja documentação) mas em vez de fornecer o shapefile com os pontos dos casos, forneceremos o shapefile das fronteiras administrativas (polygons).Com o argumento bbox = (bbox significa “bounding box”) podemos especificar coordenadas das fronteiras. Primeiro mostramos o mapa sem bbox, e depois com ele.E agora ambos, pontos e polígonos juntos:Para ler uma boa comparação das diferentes opções de criação de mapas R, leia esse blog post.","code":"\ntmap_mode(\"plot\") # escolha entre \"view\" ou \"plot\"\n# Apenas os casos (pontos)\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n# Apenas as fronteiras administrativas (polígonos)\ntm_shape(sle_adm3) +               # shapefile das fronteiras administrativas\n  tm_polygons(col = \"#F7F7F7\") +    # exibir os polígonos em cinza claro \n  tm_borders(col = \"#000000\",      # exibir as bordas com cor e peso de linha\n             lwd = 2) +\n  tm_text(\"admin3name\")            # coluna de texto para mostrar para cada polígono\n\n\n# Mesmo que acima, mas com zoom à partir do bounding box\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # vértice (do bounding box) \n                  -13.2, 8.5)) +  # vértice (do bounding box)\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n# Todos juntos \ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # Dá título ao gráfico "},{"path":"gis.html","id":"joins-espaciais","chapter":"1 Introdução ao GIS","heading":"1.6 “Joins” Espaciais","text":"Você deve estar familiarizado com o conceito de fazer join dos dados de uma base em outra. Vários métodos são discutidos na página Juntando dados desse manual. Um “join espacial” tem um propósito similar, mas lidando com os relacionamentos espaciais dos dados. Em vez de utilizar valores comuns às colunas para parear corretamente observações, você pode utilizar relações espaciais deles, tais como o fato de uma característica estar contida em outra, ou de um ponto ser o vizinho mais próximo de outro, ou contido na área de influência (buffer) de um certo raio de outro, etc.O pacote sf oferece vários métodos para fazer joins espaciais. Veja mais na documentação sobre o métodos st_join e outros tipos de join espaciais nessa referência.","code":""},{"path":"gis.html","id":"pontos-no-polígono","chapter":"1 Introdução ao GIS","heading":"Pontos no polígono","text":"Relaciona unidades administrativas aos casosAqui temos um dilema interessante: linelist dos casos não contém nenhuma informação sobre unidades administrativas dos casos. Apesar ideal ser coletar esse tipo de informação nas fases iniciais da coleta de dados, nós também podemos relacionar unidades administrativas aos casos individuais baseado em seus relacionamentos espaciais (ex: pontos que intersectam com um polígono).Abaixo, vamos fazer intersecção espacial dos locais de nossos casos (pontos) com fronteiras ADM3 (polígonos):Comece com linelist (pontos)Faça o join espacial com fronteiras, defina o tipo join em “st_intersects”Utilize select() para manter apenas algumas das novas colunas das fronteiras administrativasTodas colunas de sle_adms foram adicionadas à linelist! Agora cada caso possui colunas detalhando os níveis administativos onde eles se encontram. Nesse exemplo, queremos manter apenas duas das novas colunas (admin level 3), então usamos select() nos nomes das colunas antigas e apenas nas duas novas que temos interesse:Você pode ver abaixo, apenas para fins de conferência, os primeiros dez casos e jurisdições de seus níveis administrativos 3 (ADM3) que foram anexadas baseados em onde o ponto intersectou espacialmente com formas dos polígonos.Agora podemos descrever nossos casos por unidade administrativa - algo que não era possível antes join espacial!Também podemos criar um gráfico de barras com contagens dos casos por unidade administrativa.Nesse exemplo, iniciamos o ggplot() com linelist_adm, de forma que podemos aplicar funções de fatores como fct_infreq() que ordena barras por frequência (veja página de Fatores para dicas).","code":"\nlinelist_adm <- linelist_sf %>%  # faça join do arquivo com as fronteiras administrativas com o da linelist, baseado na intersecção espacial\n  sf::st_join(sle_adm3, join = st_intersects)\nlinelist_adm <- linelist_sf %>%   # faça join do arquivo com as fronteiras administrativas com o da linelist, baseado na intersecção espacial\n  sf::st_join(sle_adm3, join = st_intersects) %>% \n   # Mantém os nomes das colunas antigas e as duas novas de interessa das áreas administrativas\n  select(names(linelist_sf), admin3name, admin3pcod)\n# Agora você verá os nomes AD3 anexados a cada caso.\nlinelist_adm %>% select(case_id, admin3name, admin3pcod)## Simple feature collection with 1000 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -13.27125 ymin: 8.448185 xmax: -13.20684 ymax: 8.490523\n## Geodetic CRS:  WGS 84\n## First 10 features:\n##      case_id     admin3name admin3pcod                   geometry\n## 1225  ce1a9f Mountain Rural   SL040102  POINT (-13.22002 8.44964)\n## 1130  839951        West II   SL040207 POINT (-13.23486 8.469294)\n## 4115  ba5769 Mountain Rural   SL040102 POINT (-13.21752 8.451579)\n## 1070  9f41d3        West II   SL040207 POINT (-13.25905 8.482262)\n## 5103  ca1223         East I   SL040203 POINT (-13.21044 8.481521)\n## 299   4086d0        West II   SL040207 POINT (-13.23743 8.470866)\n## 369   6c440c       West III   SL040208 POINT (-13.26303 8.464508)\n## 723   284b2e      Central I   SL040201  POINT (-13.22484 8.47388)\n## 3650  75e99b        West II   SL040207 POINT (-13.24797 8.466091)\n## 3996  413bec        West II   SL040207   POINT (-13.2414 8.47777)\n# Cria um novo dataframe contendo as contagens de casos por unidade administrativa\ncase_adm3 <- linelist_adm %>%          # inicia com a lineliste contendo as novas colunas administrativas \n  as_tibble() %>%                      # converte para tibble para melhor exibição\n  filter(!is.na(admin3pcod))%>%\n  group_by(admin3pcod, admin3name) %>% # agrupa por unidade administrativa, por nome e pcode \n  summarise(cases = n()) %>%           # resume e conta as linhas \n  arrange(desc(cases))                 # organiza em ordem descentente \n\ncase_adm3## # A tibble: 9 × 3\n## # Groups:   admin3pcod [9]\n##   admin3pcod admin3name     cases\n##   <chr>      <chr>          <int>\n## 1 SL040102   Mountain Rural   282\n## 2 SL040208   West III         257\n## 3 SL040207   West II          175\n## 4 SL040204   East II           98\n## 5 SL040203   East I            54\n## 6 SL040201   Central I         52\n## 7 SL040206   West I            40\n## 8 SL040202   Central II        18\n## 9 SL040205   East III          17\nggplot(\n    data = linelist_adm,                     # inicia com linelist contendo informações das unidades administrativas \n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # eixo x são unidades administrativas, ordenadas por frequência (reversa) \n  geom_bar()+                                # cria as barras, altura é o número de linhas \n  coord_flip()+                              # inverte os eixos X e Y para facilitar a leitura das unidades administrativas\n  theme_classic()+                           # simplifica a cor de fundo do gráfico \n  labs(                                      # títulos e rótulos \n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )"},{"path":"gis.html","id":"vizinho-mais-próximo","chapter":"1 Introdução ao GIS","heading":"Vizinho mais próximo","text":"Achando unidade de saúde / área de influência mais próximaPode ser útil saber onde unidades de saúde estão localizadas em relação aos hotspots das doenças.Podemos utilizar o método de join st_nearest_feature da função st_join() (pacote sf) para visualizar unidades de saude mais próximas aos casos individuais.Iniciamos com o shapefile da linelist: linelist_sfFazemos o join espacial com sle_hf, que possui os locais das unidades de saúde e clínicas (pontos)Podemos ver abaixo (primeiras 50 linhas) que cada caso agora possui dados sobre clínicas/hospitais mais próximosPodemos ver que “Den Clinic” é unidade de saúde mais próxima de cerca de 30% dos casos.Para visualizar os resultados, podemos utilizar tmap - dessa vez, modo interativo para facilitar visualização","code":"\n# Unidade de saúde mais próxima a cada caso\nlinelist_sf_hf <- linelist_sf %>%                  # inicia com o shapefile da linelist \n  st_join(sle_hf, join = st_nearest_feature) %>%   # dados da clínica mais próxima com join nos dados dos casos \n  select(case_id, osm_id, name, amenity) %>%       # mantém as colunas de interesse, incluindo id, nome, tipo, e geometria da unidade de saúde\n  rename(\"nearest_clinic\" = \"name\")                # renomeia para uma maior clareza\n# Conta os casos por unidade de saúde\nhf_catchment <- linelist_sf_hf %>%   # inicia com a linelist incluindo os dados das clínicas mais próximas \n  as.data.frame() %>%                # converte o shapefile em dataframe \n  count(nearest_clinic,              # conta linhas por nome (da clínica) \n        name = \"case_n\") %>%         # define a nova coluna de contagens como \"case_n\"\n  arrange(desc(case_n))              # organiza em ordem descrescente\n\nhf_catchment                         # imprime no console##                          nearest_clinic case_n\n## 1                            Den Clinic    387\n## 2       Shriners Hospitals for Children    339\n## 3         GINER HALL COMMUNITY HOSPITAL    152\n## 4                             panasonic     42\n## 5 Princess Christian Maternity Hospital     33\n## 6                  MABELL HEALTH CENTER     19\n## 7                                  <NA>     17\n## 8                     ARAB EGYPT CLINIC     11\ntmap_mode(\"view\")   # define o modo do tmap para interativo \n\n# gera o gráfico dos pontos dos casos e clínicas \ntm_shape(linelist_sf_hf) +            # gera o gráfico dos casos \n  tm_dots(size=0.08,                  # colore os casos pelas clínicas mais próximas \n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # adiciona as clínicas ao gráfico como grandes pontos pretos\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # sobrepõe com o nome \ntm_view(set.view = c(-13.2284, 8.4699, 13), # ajusta o zoom (centra as coordenadas, e define o zoom)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")"},{"path":"gis.html","id":"áreas-de-influência-buffers","chapter":"1 Introdução ao GIS","heading":"Áreas de Influência (Buffers)","text":"Também podemos explorar quantos casos estão localizados em uma distância pé de 2.5km (~30 min) da unidade de saúde mais próxima.Nota: Para cálculos de distância mais precisos, é melhor re-projetar seu objeto sf ao sistema de projeção local respectivo, tal como UTM (Terra projetada sobre uma superfície plana). Nesse exemplo, para fins de simplicidade vamos nos ater ao sistema de coordenadas Sistema Geodésico Mundial (WGS84) (Terra representada em uma superfície esférica / redonda, portanto, unidades estão em graus decimais). Utilizaremos uma conversão geral de: 1 grau decimal = ~111km.Veja mais informações sobre projeções de mapas e sistemas de coordenadas nesse artigo da esri. Esse blog fala sobre diferentes tipos de projeções de mapas e como cada uma delas pode ser escolhida dependendo da área de interesse e o contexto seu mapa / análise.Primeiro, crie uma área de influência circular com um raio de ~2.5km ao redor de cada unidade de saúde. Isso é feito com função st_buffer() pacote tmap. Pelo fato das unidades mapa estarem em lat/long em graus decimais, é assim que “0.02” será interpretado. Se o sistema de coordenadas seu mapa em metros, o número deve ser fornecido em metros.Abaixo criamos o gráfico das zonas de influência propriamente ditas, com:Segundo, intersectamos essas áreas de influência com os casos (pontos) utilizando st_join() e com o tipo de join st_intersects. Ou seja, join dos dados das áreas de influência com os pontos que eles intersectam.Agora podemos contar os resultados: nrow(linelist_sf_hf_2k[.na(linelist_sf_hf_2k$osm_id.y), ]) dos 1000 casos não intersectam com nenhuma área de influência (esses valores estão faltando), e então residem mais de 30 min pé da da unidade de saúde mais próxima.Podemos visualizar os resultados de forma que os casos que não intersectam apareçam em vermelho.","code":"\nsle_hf_2k <- sle_hf %>%\n  st_buffer(dist=0.02)       # graus decimais representando aprox. 2.5km \ntmap_mode(\"plot\")\n# Cria as zonas de influência circulares\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # adiciona as clínicas ao gráfico como grandes pontos vermelhos \n  tm_dots(size=0.3, col='black')      \n# Intersecta os casos com as áreas de influência\nlinelist_sf_hf_2k <- linelist_sf_hf %>%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n# Casos que não intesectaram com nenhuma das áreas de influência das unidades de saúde\nlinelist_sf_hf_2k %>% \n  filter(is.na(osm_id.y)) %>%\n  nrow()## [1] 1000\ntmap_mode(\"view\")\n\n# Primeiro mostra os casos como pontos\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# adiciona as clínicas como grandes pontos pretos\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Depois sobrepõe as áreas de influência das unidades de saúde como polilinhas\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Destaca os casos que não são parte de nenhuma área de influência das unidades de saúde\n# como pontos vermelhos\ntm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# adiciona título  \ntm_layout(title = \"Cases by clinic catchment area\")"},{"path":"gis.html","id":"outros-joins-espaciais","chapter":"1 Introdução ao GIS","heading":"Outros joins espaciais","text":"Valores alternativos para o argumento join incluem (partir da documentação)st_contains_properlyst_containsst_covered_byst_coversst_crossesst_disjointst_equals_exactst_equalsst_is_within_distancest_nearest_featurest_overlapsst_touchesst_within","code":""},{"path":"gis.html","id":"mapas-coropléticos","chapter":"1 Introdução ao GIS","heading":"1.7 Mapas coropléticos","text":"Mapas coropléticos podem ser úteis para visualizar seus dados por áreas pré-definidas, geralmente unidades administrativas ou de saúde. Nas respostas aos surtos isso pode ajudar direcionar alocação de recursos para áreas específicas com altas taxas de incidência, por exemplo.Agora que já temos os nomes das unidades administrativas associadas todos os casos (veja seção sobre joins espaciais, acima), podemos começar mapear contagens dos casos por área (mapas coropléticos)Uma vez que também temos dados de população por ADM3, podemos adicionar essas informações à tabela case_adm3 criada anteriormente.Vamos começar com o dataframe case_adm3 criado passo anterior, que é uma tabela resumo com cada unidade administrativa e seus números de casos.Os dados populacionais sle_adm3_pop são obtidos utilizando left_join() pacote dplyr com base nos valores comuns ao longo das colunas admin3pcod dataframe case_adm3, e coluna adm_pcode dataframe sle_adm3_pop. Veja página Juntando dados).select() é aplicado ao novo dataframe, para manter apenas colunas úteis - total é população totalCasos por 10,000 é calculado como uma nova coluna com mutate()Faz join dessa tabela com os polígonos shapefile de ADM3 para poder mapeá-losMapeando os resultadosTambém podemos mapear taxas de incidência","code":"\n# Adiciona dados populacionais e calcula casos por 10mil \ncase_adm3 <- case_adm3 %>% \n     left_join(sle_adm3_pop,                             # adiciona colunas da base 'pop' \n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %>%  # faz join baseado nos valores comum ao longo dessas duas colunas \n     select(names(case_adm3), total) %>%                 # mantém apenas as colunas importantes, incluindo população total\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # cria uma nova coluna com taxa de casos por 10000, arredondando para 3 casas decimais\n\ncase_adm3                                                # imprime no console para visualização## # A tibble: 9 × 5\n## # Groups:   admin3pcod [9]\n##   admin3pcod admin3name     cases  total case_10kpop\n##   <chr>      <chr>          <int>  <int>       <dbl>\n## 1 SL040102   Mountain Rural   282  33993       83.0 \n## 2 SL040208   West III         257 210252       12.2 \n## 3 SL040207   West II          175 145109       12.1 \n## 4 SL040204   East II           98  99821        9.82\n## 5 SL040203   East I            54  68284        7.91\n## 6 SL040201   Central I         52  69683        7.46\n## 7 SL040206   West I            40  60186        6.65\n## 8 SL040202   Central II        18  23874        7.54\n## 9 SL040205   East III          17 500134        0.34\ncase_adm3_sf <- case_adm3 %>%                 # inicia com casos e taxas por unidade administrativa\n  left_join(sle_adm3, by=\"admin3pcod\") %>%    # faz join dos dados do shapefile por coluna comum\n  select(objectid, admin3pcod,                # mantém apenas algumas colunas de interesse\n         admin3name = admin3name.x,           # limpa o nome de uma coluna\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %>%                        # mantém a geometria de forma que os polígonos possam ser adicionados ao gráfico\n  st_as_sf()                                  # converte para shapefile\n# modo do tmap \ntmap_mode(\"plot\")               # visualiza o mapa estático \n\n# adiciona os polígonos\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # colore pela coluna de número de casos\n        tm_text(\"admin3name\")   # nome exibido\n# Casos por 10mil \ntmap_mode(\"plot\")             # modo de visualização estática\n\n# gráfico\ntm_shape(case_adm3_sf) +                # adiciona polígonos ao mapa \n  tm_polygons(\"case_10kpop\",            # colore pelas colunas contendo a taxa de casos\n              breaks=c(0, 10, 50, 100), # define os pontos de quebra para as cores \n              palette = \"Purples\"       # utiliza uma paleta de cor roxa\n              ) +\n  tm_text(\"admin3name\")                 # exibe o texto"},{"path":"gis.html","id":"criando-mapas-com-ggplot2","chapter":"1 Introdução ao GIS","heading":"1.8 Criando mapas com ggplot2","text":"Se você já está familiarizado em usar o ggplot2, você pode usar esse pacote para criar mapas estáticos de seus dados. função geom_sf() vai desenhar diferentes objetos baseados em quais características (pontos, linhas ou polígonos) estão em seus dados. Por exemplo, você pode usar geom_sf() em um ggplot() utilizando dados sf com geometria de polígonos para criar um mapa coroplético.Para ilustrar como isso funciona, podemos iniciar com os polígonos shapefile de ADM3 que utilizamos anteriormente. Lembre-se que esses são regiões de Níveis Administrativos 3 em Serra Leoa:Podemos utilizar função left_join() pacote dplyr para adicionar dados que queremos mapear ao objeto shapefile. Nesse caso, vamos utilizar o dataframe case_adm3 que criamos anterioremente para resumir contagem de casos por regiões administrativas; entanto, podemos utilizar essa mesma abordagem para mapear qualquer dado armazenado dataframe.Para fazer um gráfico de colunas com contagem de casos por região, utilizando ggplot2, podemos então utilizar geom_col() dessa forma:Se quisermos utilizar o ggplot2 para fazer um mapa coroplético da contagem dos casos, podemos utilizar uma sintaxe parecida para chamar função geom_sf():Podemos customizar aparência de nosso mapa utilizando gramática que é consistente ggplot2, por exemplo:Para usuários de R que estão confortáveis em trabalhar com ggplot2, função geom_sf() oferece uma implementação simples e direta que é adequada para visualizações básicas de mapas. Para aprender mais, leia vinheta geom_sf() ou o livro ggplot2.","code":"\nsle_adm3## Simple feature collection with 12 features and 19 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 12 × 20\n##    objectid admin3name     admin3pcod admin3ref_n    admin2name   admin2pcod admin1name\n##  *    <dbl> <chr>          <chr>      <chr>          <chr>        <chr>      <chr>     \n##  1      155 Koya Rural     SL040101   Koya Rural     Western Are… SL0401     Western   \n##  2      156 Mountain Rural SL040102   Mountain Rural Western Are… SL0401     Western   \n##  3      157 Waterloo Rural SL040103   Waterloo Rural Western Are… SL0401     Western   \n##  4      158 York Rural     SL040104   York Rural     Western Are… SL0401     Western   \n##  5      159 Central I      SL040201   Central I      Western Are… SL0402     Western   \n##  6      160 East I         SL040203   East I         Western Are… SL0402     Western   \n##  7      161 East II        SL040204   East II        Western Are… SL0402     Western   \n##  8      162 Central II     SL040202   Central II     Western Are… SL0402     Western   \n##  9      163 West III       SL040208   West III       Western Are… SL0402     Western   \n## 10      164 West I         SL040206   West I         Western Are… SL0402     Western   \n## 11      165 West II        SL040207   West II        Western Are… SL0402     Western   \n## 12      167 East III       SL040205   East III       Western Are… SL0402     Western   \n## # ℹ 13 more variables: admin1pcod <chr>, admin0name <chr>, admin0pcod <chr>,\n## #   date <date>, valid_on <date>, valid_to <date>, shape_leng <dbl>, shape_area <dbl>,\n## #   rowcacode0 <chr>, rowcacode1 <chr>, rowcacode2 <chr>, rowcacode3 <chr>,\n## #   geometry <MULTIPOLYGON [°]>\nsle_adm3_dat <- sle_adm3 %>% \n  inner_join(case_adm3, by = \"admin3pcod\") # inner join = mantém apenas se existir em ambos os objetos\n\nselect(sle_adm3_dat, admin3name.x, cases) # imprime as variáveis selecionadas no console## Simple feature collection with 9 features and 2 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 9 × 3\n##   admin3name.x   cases                                                         geometry\n##   <chr>          <int>                                               <MULTIPOLYGON [°]>\n## 1 Mountain Rural   282 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.474296, …\n## 2 Central I         52 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.489513, -…\n## 3 East I            54 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.494041, -…\n## 4 East II           98 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.49186, -…\n## 5 Central II        18 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.49146, -…\n## 6 West III         257 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.49621, -…\n## 7 West I            40 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.493132, -…\n## 8 West II          175 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.485505, …\n## 9 East III          17 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.485757, …\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T), # reordena o eixo x 'cases' de forma decrescente \n               y=cases)) +                                  # eixo y é o número de casos por região\n  theme_bw() +\n  labs(                                                     # define o texto da figura \n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # angula os rótulos do eixo x para 45 graus para caber melhor\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # define a cor de preenchimento (fill) para variar de acordo com a variável de contagem dos casos \nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") + # muda a cor do gradiente\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",    # define o texto da figura \n       subtitle = \"Admin level 3\"\n  )"},{"path":"gis.html","id":"mapas-base-basemaps","chapter":"1 Introdução ao GIS","heading":"1.9 Mapas Base (Basemaps)","text":"","code":""},{"path":"gis.html","id":"openstreetmap","chapter":"1 Introdução ao GIS","heading":"OpenStreetMap","text":"Descrevemos abaixo como gerar um mapa base (basemap) para um mapa ggplot2 utilizando funcionalidades OpenStreetMap. Métodos alternativos incluem utilizar o ggmap que requer um cadastro gratuito via Google (detalhes).OpenStreetMap é um projeto colaborativo para criar um mapa mundo editável e gratuito. Os dados de geolocalização fundamentais (ex: localidades de cidades, estradas, características naturais, aeroportos, escolas, hospitais, etc) são considerados saídas (outputs) principais projeto.Primeiro carregamos o pacote OpenStreetMap, de onde pegaremos nosso mapa base.Depois, criamos o objeto map, o qual definimos utilizando função openmap() pacote OpenStreetMap (documentação). Passaremos os seguintes argumentos para função:upperLeft e lowerRight dois pares de coordenadas especificando os limites tile mapa base\nNesse caso inserimos o max e min das linhas da linelist, para que o mapa responda dinamicamente aos dados\nNesse caso inserimos o max e min das linhas da linelist, para que o mapa responda dinamicamente aos dadoszoom = (se não preenchido será determinado automaticamente)type = qual tipo de mapa base - listamos várias possibilidades aqui e o código está utilizando primeira delas ([1]) “osm”mergeTiles = optamos por TRUE para que os tiles base sejam mesclados em um sóSe executarmos esse mapa base nesse momento, utilizando autoplot.OpenStreetMap() pacote OpenStreetMap, você verá que unidades nos eixos não são coordenadas de latitude/longitude. Ele está utilizando um sistema de coordenadas diferente. Para mostrar corretamente residências dos casos (que estão armazenados em lat/long), isso precisa ser modificado.Assim, nossa intenção é converter o mapa para latitude/longitude com função openproj() pacote OpenStreetMap. Nós passamos para função o mapa base map e também o Sistema de Referência de Coordenadas (SRC) que queremos. Fazemos isso passando string tipo “proj.4” para projeção WGS 1984, mas você pode passar o SRC de outras formas também. (veja esta página para compreender melhor que se trata uma string tipo proj.4)Agora, quando executamos o mapa, vemos que ao longo dos eixos estão coordenadas de latitude e longitude. O sistema de coordenadas foi convertido. Agora todos os nossos casos serão mostrados corretamente se sobrepostos ao mapa!Veja os tutoriais aqui e aqui para mais informações.","code":"\n# carrega o pacote \npacman::p_load(OpenStreetMap)\n\n# Ajusta o mapa base pelo intervalo das coordenadas de lat/long. Define o tipo do tile \nmap <- openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limites do tile do mapa base\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\nautoplot.OpenStreetMap(map)\n# Projeção WGS84\nmap_latlon <- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n# Gera o mapa. É necessário usar \"autoplot\" para funcionar com o ggplot\nautoplot.OpenStreetMap(map_latlon)"},{"path":"gis.html","id":"mapas-de-calor-de-densidade-com-contornos","chapter":"1 Introdução ao GIS","heading":"1.10 Mapas de calor de densidade com contornos","text":"Abaixo descrevemos como gerar um mapa de calor de densidade com contornos para os dados dos casos, sobre um mapa base, partir de uma linelist (uma linha por caso).Cria o tile mapa base partir OpenStreetMap, como descrito acima.Adiciona os casos da linelist utilizando colunas de latitude e longitudeConverte os pontos para um mapa de calor de densidade com stat_density_2d() ggplot2,Quando temos um mapa base com coordenadas lat/long, podemos sobrepor nossos casos utilizando coordenadas lat/long de suas residências.Utilizando função autoplot.OpenStreetMap() para criar o mapa base, funções ggplot2 podem facilmente sobrepor camadas sobre ele, como mostrado com geom_point() abaixo:O mapa acima pode ser difícil de interpretar, principalmente pelos pontos se soprepondo. Então, você pode, ao invés, gerar um mapa de densidade 2d utilizando função stat_density_2d() ggplot2. Você ainda estará utilizando coordenadas lat/lon da linelist, mas uma estimativa de densidade por kernel 2D será calculada e os resultados serão mostrados como linhas de contorno - como em um mapa topográfico. Leia documentação aqui.","code":"\n# Gera o mapa. É necessário usar \"autoplot\" para funcionar com o ggplot\nautoplot.OpenStreetMap(map_latlon)+                 # inicia com o mapa base\n  geom_point(                                       # adiciona os pontos xy a partir das colunas lo e lat da linelist\n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # remove a legenda completamente \n  labs(x = \"Longitude\",                             # títulos e rótulos \n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n# inicia com um mapa base\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # adiciona o mapa de densidade \n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # especifica a escala de cores \n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # rótulos \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")"},{"path":"gis.html","id":"mapa-de-calor-de-séries-temporais","chapter":"1 Introdução ao GIS","heading":"Mapa de calor de séries temporais","text":"O mapa de calor de densidade acima mostra os casos cumulativos. Podemos investigar o surto ao longo tempo e espaço dividindo o mapa de calor em facetas baseadas mês de início dos sintomas (symptom onset), derivado da linelist.Começamos com linelist, criando uma nova coluna com o Ano (Year) e Mês (Month) início. função format() R base modifica forma como data é exibida. Nesse caso, queremos o formato “YYYY-MM”.Agora, nós simplesmente adicionamos facetas via ggplot2 ao mapa de calor de densidade. Aplicamos função facet_wrap(), utilizando nova coluna como linhas. Nós definimos o número de colunas das facetas para 4, para fins de clareza.","code":"\n# Extrai o mês de início\nlinelist <- linelist %>% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Investiga os valores \ntable(linelist$date_onset_ym, useNA = \"always\")## \n## 2014-04 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 \n##       1      11      16      31      91     187     183     130      93      63 \n## 2015-02 2015-03 2015-04    <NA> \n##      53      53      40      48\n# pacotes \npacman::p_load(OpenStreetMap, tidyverse)\n\n# inicia com o mapa base\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # adiciona o mapa de densidade \n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # especifica a escala de cores \n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # rótulos \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # gera as facetas do gráfico por mês-ano de início \n  facet_wrap(~ date_onset_ym, ncol = 4)               "},{"path":"gis.html","id":"estatística-espacial","chapter":"1 Introdução ao GIS","heading":"1.11 Estatística espacial","text":"Grande parte de nossa discussão até aqui estava focada na visualização de dados espaciais. Em alguns casos, você também pode estar interessado em estatística espacial para quantificar relações espaciais entre os atributotos de seu dados. Essa seção vai passar uma visão global sobre alguns conceitos chave da estatística espacial, e sugerir alguns recursos que podem explorados caso você deseje fazer uma análise espacial mais aprofundada.","code":""},{"path":"gis.html","id":"relações-espaciais","chapter":"1 Introdução ao GIS","heading":"Relações espaciais","text":"Antes de calcularmos qualquer estatística espacial, precisamos especificar relações entre características de nossos dados. Existem várias formas de conceituar relações espaciais, mas uma forma simples e um modelo comumente aplicado é utilizar o conceito de adjacência - especificamente, o fato de esperarmos uma relação geográfica entre áreas que compartilham uma fronteira ou são vizinhos uns dos outros.Podemos quantificar relações de adjacências entre polígonos de regiões administrativas da base que viemos utilizando (sle_adm3) com o pacote spdep. Iremos especificar contiguidade tipo queen (rainha), o que significa que regiões serão vizinhas se compartilharem pelo menos um ponto ao longo de suas fronteiras. O método alternativo seria contiguidade tipo rook (torre), que requer que regiões compartilhem uma aresta - em nosso caso, com polígonos irregulares, diferença é trivial, mas em alguns casos escolha entre queen e rook pode fazer diferença. (Nota tradutor: Os termos queen (rainha) e rook (torre) correspondem à peças xadrez e o tipo de vizinhança que representam descritas acima estão relacionadas aos movimentos que fazem referido jogo: na diagonal para rainha, ou seja apenas com um ponto de contato com casa vizinha, e para frente ou para os lados com torre, ou seja com uma aresta -lateral quadrado- completa de contato com casa vizinha).matriz exibida acima mostra relações entre 9 regiões de nossa base sle_adm3. Um score de 0 indica duas regiões que não são vizinhas, enquanto quaisquer outros valores diferentes de zero indicam uma relação de vizinhança. Os valores na matriz estão escalados de forma que linha de cada região tenha um peso total de 1.Uma melhor forma de visualizar essas relações de vizinhança é gerando um gráfico para elas:Utilizamos uma abordagem de adjacência para identificar polígonos vizinhos; os vizinhos identificados também podem ser chamados de vizinhos baseados em contiguidade (contiguity-based neighbors). Mas, essa é apenas um das formas de escolher quais regiões são esperadas de possuírem uma relação geográfica. abordagens alternativas mais comuns para identificar relações geográficas geram vizinhos baseados em distância (distance-based neighbors); basicamente, eles são:K-vizinhos mais próximos (K-nearest neighbors) - Baseados nas distâncias entre centróides (centros geograficamente-pesados dos polígonos de cada região), seleciona n regiões mais próximas como vizinhas. Um limite de proximidade de máxima-distância também pode ser especificado. Em spdep, você pode usar knearneigh() (veja documentação).Vizinhos por limite de distância - Seleciona todos os vizinhos contidos em um limite de distância. Em spdep, essa relação de vizinhos pode ser identificada utilizando função dnearneigh() (veja documentação).","code":"\nsle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # cria vizinhos\nsle_adjmat <- spdep::nb2mat(sle_nb)    # cria uma matriz resumindo os relacionamentos entre vizinhos\nsle_listw <- spdep::nb2listw(sle_nb)   # cria um um objeto listw (lista de pesos (weights) ) -- iremos precisar disso posteriormente\n\nsle_nb## Neighbour list object:\n## Number of regions: 9 \n## Number of nonzero links: 30 \n## Percentage nonzero weights: 37.03704 \n## Average number of links: 3.333333\nround(sle_adjmat, digits = 2)##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n## 1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n## 2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n## 3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n## 4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n## 5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n## 6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n## 7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n## 8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n## 9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\n## attr(,\"call\")\n## spdep::nb2mat(neighbours = sle_nb)\nplot(sle_adm3_dat$geometry) +                                           # cria gráficos com as fronteiras das regiões \n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # adiciona relações de vizinhança"},{"path":"gis.html","id":"autocorrelação-espacial","chapter":"1 Introdução ao GIS","heading":"Autocorrelação espacial","text":"conhecida primeira lei da geografia de Tobler diz que “todas coisas estão relacionadas com todas outras, mas coisas próximas estão mais relacionadas que coisas distantes.” Na epidemiologia, isso geralmente significa que o risco de um certo desfecho de saúde em uma dada região é mais similar ao de suas regiões vizinhas que daquelas regiões mais longínquas. Esse conceito foi formalizado como autocorrelação espacial - propridedade estatística em que características geográficas com valores similares são agregados espaço. Medidas estatísticas de autocorrelação espacial podem ser utilizadas para quantificar extensão da agregação espacial em seus dados, localizar onde agregação ocorre, e identificar padrões compartilhados da autocorrelação espacial entre diferentes variáveis dos seus dados. Essa seção te dá uma visão global de algumas medidas de autocorrelação espacial mais comuns e como calculá-las R.de Moran - Esta é uma estatística resumo global da correlação entre o valor de uma varíavel em uma região e os valores da mesma variável em regiões vizinhas. O de Moran geralmente varia entre -1 e 1. O valor 0 indica que não há nenhum padrão de correlação espacial, enquanto valores próximos 1 ou -1 indicam uma autocorrelação espacial mais forte (valores similares próximos de si) ou dispersão espacial (valores dissimilares próximoas de si), respectivamente.Por exemplo, podemos calcular o de Moran para quantificar autocorrelação espacial nos casos de Ebola que mapeamos mais cedo (lembre-se, esse é um subset dos casos dataframe da linelist da epidemia simulada). O pacote spdep tem uma função moran.test, que pode fazer esse cálculo para nós:saída da função moran.test() nos mostra um valor de Moran de round(moran_i$estimate[1],2). Isso indica presença de autocorrelação espacial em nossos dados - especificamente, que regiões com números parecidos de casos de Ebola estão potencialmente próximos entre si. O p-valor fornecido por moran.test() é gerado por comparação à expectativa, sob hipótese nula, de não haver autocorrelação espacial, e pode ser utilizado caso você precise mostrar os resultados de um teste de hipóteses formal.de Moran Local - Podemos decompor o de Moran (global) calculado acima para identificar uma autocorrelação espacial localizada; ou seja, para identificar agrupamentos específicos em nossos dados. Essa estatística, que vezes é chamada de Indicador Local de Associação Espacial Local Indicator Spatial Association (LISA), resume extensão da autocorrelação espacial sobre cada região individual. Ela pode ser útil para achar regiões “quentes” ou “frias” mapa.Para mostrar um exemplo, podemos calcular e mapear ’s de Moran locais para contagens de casos de Ebola utilizados acima, com função local_moran() pacote spdep:Gi (ou G) de Getis-Ord - Essa é outra estatística comumente utilizada para análises de hotspots; em grande parte, popularidade dessa estatística está relacionada à sua utilização na ferramenta de análise de hotspots ArcGIS. Isso é baseado na premissa de que tipicamente, diferença entre os valores de uma variável entre regiões vizinhas deve seguir uma distribuição normal. Ela usa abordagem z-score para identificar regiões que possuem valores de uma dada variável que sejam significativamente mais altas (hot spot) ou significativamente mais baixas (cold spot), comparados aos seus vizinhos.Podemos calcular e mapear estatística Gi* utilizando função localG() spdep:Como você pode ver, o mapa de Gi* de Getis-Ord tem um visual ligeiramente diferente mapa de de Moran Local produzido anteriormente. Isso demonstra que o método utilizado para calcular essas duas estatísticas são ligeiramente diferentes; aquele que você vai utilizar depende seu caso de uso específico e sua pergunta experimental de interesse.Test L de Lee - Esse é um teste estatístico para correlação espacial bivariada. Ele permite que você teste se um padrão espacial para uma dada variável x é similar ao padrão espacial de outra variável y, cuja hipótese é que seja espacialmente relacionada com x.Para dar um exemplo, vamos testar se um padrão espacial dos casos de Ebola da epidemia simulada é correlacionado com o padrão espacial da população. Para iniciar, precisamos de uma variável population em nossa base sle_adm3. Podemos utilizar variável total dataframe sle_adm3_pop que carregamos anteriormente.Podemos visualizar rapidamente os padrões espaciais das duas variáveis lado lado, para ver se eles se parecem:Visualmente, os padrões parecem dissimilares. Podemos utilizar função lee.test() pacote spdep para testar estatisticamente se o padrão de autocorrelação espacial nas duas variáveis é relacionado. estística L será próxima de 0 se não houver correlação entre os padrões, e próxima de 1 se tiver uma forte correlação positiva (ou seja, os padrões são similares), e próximo de -1 se houver uma forma correlação negativa (ou seja, os padrões são inversos).saída acima mostra que estatística L de Lee para nossas duas variáveis é round(lee_test$estimate[1],2), o que indica uma fraca correlação negativa. Isso confirma nossa avaliação visual de que o padrão dos casos e população não estão relacionados entre si, e traz evidência de que o padrão espacial dos casos não é estritamente um resultado da densidade populacional em áreas de alto risco.estatística L de Lee pode ser útil para fazer esses tipos de inferência sobre relação entre variáveis espacialmente distribuídas; entanto, para descrever natureza relacionamento entre duas variáveis com mais detalhes, ou ajustar para fatores de confusão, técnicas de regressão espacial serão necessárias. Essas são descritas brevemente na seção seguinte.","code":"\nmoran_i <-spdep::moran.test(sle_adm3_dat$cases,    # vetor numérico com a variável de interesse\n                            listw=sle_listw)       # objeto listw resumindo as relações entre vizinhos\n\nmoran_i                                            # imprime os resultados do teste do I de Moran## \n##  Moran I test under randomisation\n## \n## data:  sle_adm3_dat$cases  \n## weights: sle_listw    \n## \n## Moran I statistic standard deviate = 1.7931, p-value = 0.03648\n## alternative hypothesis: greater\n## sample estimates:\n## Moran I statistic       Expectation          Variance \n##        0.25122524       -0.12500000        0.04402611\n# calcula o I de Moran local\nlocal_moran <- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # variável de interesse\n  listw=sle_listw                                  # objeto listw com pesos para os vizinhos\n)\n\n# faz join dos resultados aos dados do sf (shapefile)\nsle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    \n\n# gera o mapa\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n# Faz uma análise G \ngetis_ord <- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# faz join dos resultados aos dados do sf\nsle_adm3_dat$getis_ord <- as.numeric(getis_ord)\n\n# gera o mapa\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\nsle_adm3_dat <- sle_adm3_dat %>% \n  rename(population = total)                          # renomeia 'total' para 'population'\ntmap_mode(\"plot\")\n\ncases_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # organiza em facetas 2x1 \nlee_test <- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # variável 1 para comparar \n  y=sle_adm3_dat$population,     # variável 2 para comparar \n  listw=sle_listw                # objeto listw com peso dos vizinhos\n)\n\nlee_test## \n##  Lee's L statistic randomisation\n## \n## data:  sle_adm3_dat$cases ,  sle_adm3_dat$population \n## weights: sle_listw  \n## \n## Lee's L statistic standard deviate = -0.97484, p-value = 0.8352\n## alternative hypothesis: greater\n## sample estimates:\n## Lee's L statistic       Expectation          Variance \n##       -0.14260720       -0.03429483        0.01234502"},{"path":"gis.html","id":"regressão-espacial","chapter":"1 Introdução ao GIS","heading":"Regressão espacial","text":"Talvez você queira fazer inferências estatísticas respeito dos relacionamentos entre variáveis nos seus dados espaciais. Nesses casos, pode ser útil considerar técnicas de regressão espacial - ou seja, abordagens para regressão que consideram explicitamente organização espacial das unidades dos seus dados. Algumas razões que podem fazer você considerar modelos de regressão espacial, em vez de modelos de regressão padrão tais como GLMs, incluem:Modelos padrão de regressão assumem que os resíduos são independentes uns dos outros. Na presença de fortes autocorrelações espaciais, os resíduos de um modelo padrão de regressão têm potencialidade de estarem espacialmente autocorrelacionados também, portanto, violando essa premissa. Isso pode levar problemas com interpretação dos resultados modelo, o que para o caso, um modelo espacial seria mais adequado.Modelos de regressão também assumem, tipicamente, que o efeito de uma variável x é constante sobre todas observações. caso de heterogeneidade espacial, os efeitos que queremos estimar podem variar sobre o espaço, e podemos estar interessados em quantificar essas diferenças. Nesse caso, modelos de regressão espacial oferecem mais flexibilidade para estimar e interpretar os efeitos.Os detalhes das abordagens de regressão espacial estão além escopo desse manual. Essa seção vai, ao invés, passar uma visão global dos modelos de regressão espacial mais comuns e seus usos, e sugerir referências que podem ser úteis caso você queira explorar essa área mais fundo.Modelos de Erro Espacial - Esses modelos assumem que os termos de erro ao longo de unidades espaciais são correlacionados, sendo esse o caso, os dados violariam premissas de um modelo OLS padrão. Modelos de Erro Espacial também podem ser chamados de modelos autorregressivos simultâneos (simultaneous autoregressive (SAR) models). Eles podem ser ajustados utilizando função errorsarlm() pacote spatialreg (funções de regressão espacial que costumavam fazer parte pacote spdep).Modelos de Defasagem Espacial (spacial lag models) - Esses modelos assumem que variável dependente para uma região é influenciada não apenas pelo valor das variáveis independentes em , mas também pelos valores daquelas variáveis em regiões vizinhas . Assim como os modelos de erro espacial, modelos de defasagem espacial também são descritos algumas vezes como modelos autorregressivos simultâneos (simultaneous autoregressive (SAR) models). Eles podem ser ajustados utilizando função lagsarlm() pacote spatialreg.O pacote spdep contém vários testes diagnóstico úteis para decidir entre os modelos OLS padrão, de defasagem espacial ou de erro espacial. Esses testes, chamados diagnósticos de Multiplicador de (Lagrange Multiplier diagnostics), podem ser utilizados para identificar o tipo de dependência espacial em seus dados e escolher qual modelo é mais apropriado. função lm.LMtests() pode ser utilizada para calcular todos os testes de Multiplicador de Lagrange. Anselin (1988) também demonstra uma ferramenta de fluxogramas para decidir qual modelo de regressão espacial ser utilizado baseado nos resultados dos testes de Multiplicador de Lagrange:Modelos Hierárquicos Bayesianos - Abordagens Bayesianas são comumente utilizadas para algumas aplicação em análise espacial, principalmente para mapeamento de doenças. Elas são preferidas em ocasiões onde os dados dos casos estão esparçamente distribuídas (por exemplo, caso de um desfecho raro) ou com muito “ruído” estatístico, de forma que elas podem ser utilizadas para gerar estimativas “suavizadas” risco de doenças ao considerar processos espaciais subjacentes que estavam latentes. Isso pode aumentar qualidade das estimativas. Elas também permitem ao investigador pre-especificação (via escolha de uma priori) de complexos padrões de correlação espaciais que podem existir nos dados, o que pode considerar variações espaço-dependente e -independente tanto nas variáveis independentes quanto nas dependentes. R, Modelos Hierarquicos Bayesianos podem ser ajustados utilizando o pacote CARbayes (veja documentação) ou R-INLA (veja website e livro). R também pode ser utilizado para chamar softwares externos que fazem estimativas Bayesianas, tais como JAGS ou WinBUGS.","code":""},{"path":"gis.html","id":"recursos","chapter":"1 Introdução ao GIS","heading":"1.12 Recursos","text":"Pacote Simple Features vignettePacote tmap vignetteggmap: Visualização Espacial com ggplot2Introdução à produção de mapas com R, visão geral de diferentes pacotesDados Espaciais R (EarthLab course)Análise de Dados Espaciais Aplicada com R livroSpatialEpiApp - um Shiny app que pode ser baixado como um pacote R, permitindo que você insira seus próprios dados e faça criação de mapas, análises de agrupamento (clusters) e estatísticas espaciais.Introdução à Economoetria Espacial com R workshop","code":""}]
