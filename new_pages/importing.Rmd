# Importar e exportar {}


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```



Nesta página descrevemos formas de localizar, importar e exportar arquivos:  

* Utilização do pacote **rio** para flexivelmente `import()` e `export()` muitos tipos de arquivos  
* Uso do pacote **here** para localizar arquivos relativos a uma raiz de projeto R - para evitar complicações de caminhos de arquivos que são específicos de um computador  
* Cenários específicos de importação, como por exemplo:  
  * Planilhas específicas do Excel  
  * Cabeçalhos confusos e linhas para pular  
  * Das planilhas do Google  
  * A partir de dados postados em websites  
  * Com APIs  
  * Importação do arquivo *mais recente*  
* Entrada manual de dados  
* Tipos de arquivos específicos de R, como RDS e RData  
* Exportar / salvar arquivos e gráficos



<!-- ======================================================= -->
## Visão geral

Quando você importa um "conjunto de dados" para R, você geralmente está criando um novo objeto do tipo *data frame* em seu ambiente R e definindo-o como um arquivo importado (por exemplo, Excel, CSV, TSV, RDS) que está localizado em suas pastas em um determinado caminho/endereço de arquivo.  

Você pode importar/exportar muitos tipos de arquivos, inclusive aqueles criados por outros programas estatísticos (SAS, STATA, SPSS). Você também pode se conectar a bancos de dados relacionais.  

R tem até seus próprios formatos de dados:  

* Um arquivo RDS (.rds) armazena um único objeto R, como um quadro de dados. Estes são úteis para armazenar dados limpos, pois eles mantêm as classes de colunas R. Leia mais em [esta seção](#import_rds).    
* Um arquivo RData (.Rdata) pode ser usado para armazenar vários objetos, ou mesmo um espaço de trabalho R completo. Leia mais em [esta seção](#import_rdata).  

<!-- ======================================================= -->
## O pacote **rio** {}  

O pacote R que recomendamos é: **rio**. O nome "rio" é uma abreviação de "R I/O" (input/output ).

Suas funções `import()` e `export()` podem lidar com muitos tipos diferentes de arquivos (por exemplo, .xlsx, .csv, .rds, .tsv). Quando você fornece um caminho de arquivo para qualquer uma destas funções (incluindo a extensão do arquivo como ".csv"), **rio** lerá a extensão e utilizará a ferramenta correta para importar ou exportar o arquivo.  

A alternativa ao uso do **rio** é usar funções de muitos outros pacotes, cada um dos quais é específico para um tipo de arquivo. Por exemplo, `read.csv()` (R **base** ), `read.xlsx()` (**openxlsx** pacote), e `write_csv()` (**readr** pacakge), etc. Estas alternativas podem ser difíceis de lembrar, enquanto que utilizar `import()` e `export()` de **rio*** é fácil.  

As funções do **rio** `import()` e `export()` utilizam o pacote e função apropriados para um determinado arquivo, com base em sua extensão. Veja no final desta página uma tabela completa de quais pacotes/funções **rio** utilizam em segundo plano. Ele também pode ser utilizado para importar arquivos STATA, SAS e SPSS, entre dezenas de outros tipos de arquivos.  

A importação/exportação de *shapefiles* (para mapas) requer outros pacotes, conforme detalhado na página sobre [GIS básico].   


## O pacote **here** {#here}

O pacote **here** e sua função `aqui()` tornam fácil dizer a R onde encontrar e salvar seus arquivos - em essência, ele constrói os caminhos dos arquivos.  

Utilizado em conjunto com um projeto R, **here** permite descrever a localização dos arquivos em seu projeto R em relação ao diretório *root do projeto R* (a pasta de nível superior). Isto é útil quando o projeto R pode ser compartilhado ou acessado por várias pessoas/computadores. Ele evita complicações devido aos caminhos exclusivos dos arquivos em diferentes computadores (por exemplo, `"C:/Users/Laura/Documents...'', "iniciando" o caminho do arquivo em um lugar comum a todos os usuários (a raiz do projeto R).  

Isto é como `here()` funciona dentro de um projeto R:  

* Quando o pacote **here** é carregado pela primeira vez dentro do projeto R, ele coloca um pequeno arquivo chamado ".here" na pasta raiz de seu projeto R como um "*benchmark*" ou "âncora".  
* Em seus scripts, para referenciar um arquivo nas subpastas do projeto R, você utiliza a função `here()` para construir o caminho do arquivo *em relação a essa âncora*.
* Para construir o caminho do arquivo, escreva os nomes das pastas além da raiz, entre aspas, separados por vírgulas, finalmente terminando com o nome do arquivo e a extensão do arquivo, como mostrado abaixo  
* 'here()` caminhos de arquivos podem ser utilizados tanto para importação quanto para exportação  

Por exemplo, abaixo, a função `import()` está sendo fornecida um caminho de arquivo construído com `here()`.   

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

O comando `here("data", "linelists", "ebola_linelist.xlsx")` está na verdade fornecendo o caminho completo do arquivo que é *único para o computador do usuário*:  

```
"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"
```

A beleza é que o comando R utilizando `here()` pode ser executado com sucesso em qualquer computador que acesse o projeto R.  


<span style="color: darkgreen;">**_DICA:_**  Se você não tiver certeza de onde a raiz ".here" está definida, execute a função `here()` com parênteses vazios.</span>  

Leia mais sobre o pacote **here** [neste link](https://here.r-lib.org/).  



<!-- ======================================================= -->
## Caminhos dos arquivos

Ao importar ou exportar dados, você deve fornecer um caminho para o arquivo. Você pode fazer isso de três maneiras:  

1) *Recomendado:* fornecer um caminho de arquivo "relativo" com o pacote **here**
2) Fornecer o caminho "completo" / "absoluto" do arquivo  
3) Seleção manual do arquivo  



### Caminhos 'relativo' dos arquivos {.unnumbered}

No R, os caminhos de arquivo "relativos" consistem no caminho de arquivo *relativo à* raiz de um projeto R. Eles permitem caminhos de arquivo mais simples que podem funcionar em computadores diferentes (por exemplo, se o projeto R estiver em um drive compartilhado ou for enviado por e-mail). Como descrito [acima](#here), os caminhos de arquivo relativos são facilitados pelo uso do pacote **here**.  

Um exemplo de um caminho de arquivo relativo construído com `here()` está abaixo. Supomos que o trabalho esteja em um projeto R que contém uma subpasta "dados" e dentro dela uma subpasta "linelists", na qual há o arquivo .xlsx de interesse.    

```{r, eval=F}
linelist <- import(here("dados", "linelists", "ebola_linelist.xlsx"))
```



### Caminhos 'absoluto' dos arquivos {.unnumbered}  

Caminhos de arquivo absolutos ou "completos" podem ser fornecidos para funções como `import()` mas são "frágeis", pois são exclusivos para o computador específico do usuário e portanto *não são recomendados*. 

Abaixo está um exemplo de um caminho de arquivo absoluto, onde no computador de Laura há uma pasta "analises", uma subpasta "dados" e dentro dela uma subpasta "linelists", na qual há o arquivo .xlsx de interesse.  

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analises/dados/linelists/ebola_linelist.xlsx")
```

Algumas coisas a serem observadas sobre os caminhos absolutos dos arquivos:  

* **Evite o uso de caminhos de arquivo absolutos**, pois eles quebrarão se o script for executado em um computador diferente.
* Utilize barras normais (`/`), como no exemplo acima (nota: este é *NÃO* o padrão para caminhos de arquivos do Windows)  
* Os caminhos de arquivos que começam com barras duplas (por exemplo, "//...") provavelmente **não serão reconhecidos por R** e produzirão um erro. Considere mover seu trabalho para uma unidade  "nomeado" ou " com letras" que comece com uma letra (por exemplo, "J:" ou "C:"). Consulte a página em [Interações do diretório] para obter mais detalhes sobre este assunto.  

Um cenário onde caminhos de arquivo absolutos podem ser apropriados é quando você deseja importar um arquivo de um drive compartilhado que tenha o mesmo caminho de arquivo completo para todos os usuários.  

<span style="color: darkgreen;">**_DICA:_** Para converter rapidemente todas as barras invertidas `\` em barras normais `/`, destaque o código de interesse, use Ctrl+f (no Windows), selecione a caixa de opção "Em seleção" (*In selection*), e depois usar a funcionalidade de substituição para convertê-los.</span>  



<!-- ======================================================= -->
### Selecionando um arquivo manualmente {.unnumbered}

Você pode importar dados manualmente por meio de um destes métodos:  

1) Painel Ambiente (*Environment*) do RStudio, clique em "Importar Dados"  (*Import Dataset*), e selecione o tipo de dado
2) Clique em File / Import Dataset / (selecione o tipo de dados)  
3) Para seleção manual por código, utilize o comando do R *base* `file.choose()` (deixando os parênteses vazios) para acionar a aparência de uma janela **pop-up** que permite ao usuário selecionar manualmente o arquivo de seu computador. Por exemplo:  

```{r import_choose, eval=F}
# Seleção manual de um arquivo. Quando este comando for executado, uma janela POP-UP aparecerá. 
# O caminho do arquivo selecionado será fornecido ao comando import().

my_data <- import(file.choose())
```

<span style="color: darkgreen;">**_DICA:_** A **janela pop-up window** pode aparecer ATRÁS di seu RStudio.</span>



## Importar dados

Utilizar `import()` para importar um conjunto de dados é bastante simples. Basta fornecer o caminho para o arquivo (incluindo o nome do arquivo e a extensão do arquivo) entre aspas. Se utilizar `here()` para construir o caminho do arquivo, siga as instruções acima. Abaixo estão alguns exemplos:  

Importar um arquivo csv que está localizado em seu "diretório de trabalho" ou na pasta raiz do projeto R:  

```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```


Importação da primeira planilha de uma pasta de trabalho do Excel que está localizada nas subpastas "dados" e "linelists" do projeto R (o caminho do arquivo construído utilizando `here()`):  

```{r, eval=F}
linelist <- import(here("dados", "linelists", "linelist_cleaned.xlsx"))
```

Importação de um  "quadro de dados" ( referido nesse livro como *data frame*)(um arquivo .rds) usando um caminho de arquivo absoluto:  

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```



### Planilhas específicas do Excel {.unnumbered}

Por padrão, se você fornecer uma pasta de trabalho Excel (.xlsx) para a função `import()`, a primeira planilha da pasta de trabalho será importada. Se você quiser importar uma **aba** (*sheet*) específica, inclua o nome da planilha ao `which = ` argument. Por exemplo:  

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```

Se utilizar o método `here()` para fornecer um caminho relativo para `importar()`, você ainda pode indicar uma aba específica adicionando o `which = ` argumento depois dos parênteses de fechamento da função `here()`.      

```{r import_sheet_here, eval=F}
# Demonstração: importação de uma planilha específica do Excel ao utilizar caminhos relativos com o pacote 'here'.  

linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```

Para *exportar* um *data frame* de R para uma planilha específica do Excel e ter o resto da pasta de trabalho do Excel inalterado, você terá que importar, editar e exportar com um pacote alternativo criado para este propósito, como **openxlsx***. Veja mais informações na página em [Interações do diretório] ou [nesta página do github](https://ycphs.github.io/openxlsx/).

Se sua pasta de trabalho Excel for .xlsb (pasta de trabalho Excel em formato binário) você talvez não consiga importá-la usando **rio**. Considere a possibilidade de salvá-la como .xlsx, ou usando um pacote como **readxlsb*** que é construído para [este propósito](https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html).  


<!-- ======================================================= -->
### Valores faltantes {#import_missing .unnumbered} 

Você pode querer designar que valor(es) em seu conjunto de dados que deve(m) ser considerado(s) como ausente(s)/faltante(s). Como explicado na página em [Dados faltantes], o valor em R para dados ausentes é `NA`, mas talvez o conjunto de dados que você deseja importar utilize 99, "Ausente", ou apenas espaço vazio de caracteres "" em vez disso.  

Utilize o `na = ` argumento para `import()` e forneça o(s) valor(es) entre aspas (mesmo que sejam números). Você pode especificar múltiplos valores incluindo-os dentro de um vetor, utilizando `c()` como mostrado abaixo.  

Aqui, o valor "99" no conjunto de dados importados é considerado ausente e convertido para `NA` em R.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

qualquer um dos valores "Missing", "" (célula vazia), ou "" (espaço único) no conjunto de dados importados são convertidos para `NA` em R.  

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```


<!-- ======================================================= -->
### Pular linhas {.unnumbered} 

Às vezes, você pode querer evitar a importação de uma linha específica de dados. Você pode fazer isso com o argumento `skip = ` se utilizar `import()` de **rio** em um arquivo .xlsx ou .csv. Forneça o número de linhas que você deseja pular. 

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # does not import header row
```

Infelizmente 'skip = 'aceita apenas um valor inteiro, *não* um intervalo (por exemplo, "2:10" não funciona). Para pular a importação de linhas específicas que não são consecutivas do topo, considere importar várias vezes e utilizar `bind_rows()` a partir de **dplyr***. Veja o exemplo abaixo de pular apenas a linha 2.  


### Como lidar com uma segunda linha de cabeçalho {.unnumbered}  

Às vezes, seus dados podem ter uma *segunda* linha de cabeçalho, por exemplo, se for uma linha de "dicionário de dados", como mostrado abaixo. Esta situação pode ser problemática porque pode resultar na importação de todas as colunas como a classe "caractere".

```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

Abaixo está um exemplo deste tipo de conjunto de dados (sendo a primeira linha o dicionário de dados).  

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### Remover uma segunda linha de cabeçalho {.unnumbered}  

Para ignorar a segunda linha de cabeçalho, você provavelmente precisará importar os dados duas vezes.  

1) Importar os dados para armazenar os nomes corretos das colunas  
2) Importar os dados novamente, pulando as primeiras *duas* fileiras (cabeçalho e segunda fileira)  
3) Ligar os nomes corretos no campo de dados reduzido

O argumento exato usado para ligar os nomes corretos das colunas depende do tipo de arquivo de dados (.csv, .tsv, .xlsx, etc.). Isto porque **rio** está usando uma função diferente para os diferentes tipos de arquivo (ver tabela acima).  

**Para arquivos Excel:** (`col_names = `)  

```{r, eval=F}
# import first time; store the column names
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # save true column names

# import second time; skip row 2, and assign column names to argument col_names =
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**Para arquivos CSV:** (`col.names = `)  

```{r, eval=F}
# importe a primeira vez; salve o nome das colunas
linelist_raw_names <- import("linelist_raw.csv") %>% names() # salve o nome das colunas

# note que o argumento para arquivos csv é 'col.names = '
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Opção de Backup ** - atribuir/sobreescrever cabeçalhos usando a função 'colnames()' do base

```{r, eval=F}
# assign/overwrite headers using the base 'colnames()' function
colnames(linelist_raw) <- linelist_raw_names
```


#### Fazendo um dicionário de dados {.unnumbered}  

Bônus! Se você tiver uma segunda linha que seja um dicionário de dados, você pode facilmente criar um dicionário de dados adequado a partir dele. Esta dica é adaptada a partir deste [post](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/).    


```{r}
dict <- linelist_2headers %>%             # começa: linelist com um dicionário como a primeira linha
  head(1) %>%                             # mantenha apenas os nomes das colunas e a primeira linha com o dicionário               
  pivot_longer(cols = everything(),       # faça o pivotamento de todas as coluna spara o formato "longo" 
               names_to = "Column",       # nomeie as colunas
               values_to = "Description")
```


```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```



#### Combinar duas linhas de cabeçalho {.unnumbered}  

Em alguns casos, quando seu conjunto de dados brutos tiver *duas* linhas de cabeçalho (ou mais especificamente, a segunda linha de dados é um cabeçalho secundário), você pode querer "combiná-las" ou adicionar os valores da segunda linha de cabeçalho à primeira linha de cabeçalho.  

O comando abaixo definirá os nomes das colunas do *data frame* como a combinação (colando em conjunto) dos primeiros cabeçalhos (verdadeiros) com o valor imediatamente abaixo (na primeira linha). 

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```



<!-- ======================================================= -->
### Planilhas do Google {.unnumbered}

Você pode importar dados de uma planilha on-line do Google com o pacote **googlesheet4** e autenticando seu acesso à planilha.  


```{r, eval=F}
pacman::p_load("googlesheets4")
```

Abaixo, uma planilha de demonstração do Google é importada e salva. Este comando pode solicitar a confirmação da autenticação de sua conta Google. Siga as instruções e pop-ups em seu navegador de internet para conceder permissões aos pacotes Tidyverse API para editar, criar e excluir suas planilhas no Google Drive.  


A planilha abaixo é "visualizável para qualquer pessoa com o link" e você pode tentar importá-la.  

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

A planilha também pode ser importada usando apenas a identificação da planilha, uma parte mais curta da URL:  

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```

Outro pacote, **googledrive** oferece funções úteis para escrever, editar e excluir planilhas do Google. Por exemplo, utilizando as funções `gs4_create()` e `sheet_write()` encontradas neste pacote. 

Aqui estão alguns outros tutoriais on-line úteis:  
[tutorial básico de importação de planilhas do Google](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)  
[tutorial mais detalhado](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)  
[interação entre as googlesheets4 e tidyverse](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)  



## Múltiplos arquivos- importar, exportar, dividir, combinar  

Veja a página em [Iteração, loops e listas] para exemplos de como importar e combinar vários arquivos, ou vários arquivos de pastas de trabalho Excel. Essa página também tem exemplos de como dividir um quadro de dados em partes e exportar cada uma separadamente, ou como planilhas nomeadas em uma pasta de trabalho do Excel.  




<!-- ======================================================= -->
## Importar do GitHub {#import_github}

A importação de dados diretamente do Github para R pode ser muito fácil ou pode exigir alguns passos - dependendo do tipo de arquivo. Abaixo estão algumas abordagens:  

### Arquivos CSV {.unnumbered}  

Pode ser fácil importar um arquivo .csv diretamente do Github para R com um comando R.  

1) Vá até o repo Github, localize o arquivo de interesse e clique sobre ele  
3) Clique no botão "Raw" (você verá então os dados "brutos" do csv, como mostrado abaixo)  
4) Copiar a URL (endereço web)  
5) Colocar a URL entre aspas dentro do comando `import()` no R  

```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### Arquivo XLSX {.unnumbered}  

Talvez você não consiga visualizar os dados "Raw" de alguns arquivos (por exemplo, .xlsx, .rds, .nwk, .shp)  

1) Vá até o repo Github, localize o arquivo de interesse e clique sobre ele  
2) Clique no botão "Download", como mostrado abaixo  
3) Salve o arquivo em seu computador, e importe-o para o R  


```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### Shapefiles {.unnumbered} 

Shapefiles have many sub-component files, each with a different file extention. One file will have the ".shp" extension, but others may have ".dbf", ".prj", etc.  To download a shapefile from Github, you will need to download each of the sub-component files individually, and save them in the *same* folder on your computer. In Github, click on each file individually and download them by clicking on the "Download" button.  

Once saved to your computer you can import the shapefile as shown in the [GIS basics] page using `st_read()` from the **sf** package. You only need to provide the filepath and name of the ".shp" file - as long as the other related files are within the same folder on your computer.  

Below, you can see how the shapefile "sle_adm3" consists of many files - each of which must be downloaded from Github.  

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```





<!-- ======================================================= -->
## Manual data entry {}

### Entry by rows {.unnumbered}  

Use the `tribble` function from the **tibble** package from the tidyverse ([online tibble reference](https://tibble.tidyverse.org/reference/tribble.html)).  
  
Note how column headers start with a *tilde* (`~`).  Also note that each column must contain only one class of data (character, numeric, etc.). You can use tabs, spacing, and new rows to make the data entry more intuitive and readable. Spaces do not matter between values, but each row is represented by a new line of code. For example:  

```{r import_manual_row}
# create the dataset manually by row
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

And now we display the new dataset:  

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_rows)
```


### Entry by columns {.unnumbered}  

Since a data frame consists of vectors (vertical columns), the **base** approach to manual dataframe creation in R expects you to define each column and then bind them together. This can be counter-intuitive in epidemiology, as we usually think about our data in rows (as above). 

```{r import_manual_col}
# define each vector (vertical column) separately, each with its own name
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

<span style="color: orange;">**_CAUTION:_** All vectors must be the same length (same number of values).</span>

The vectors can then be bound together using the function `data.frame()`:  

```{r}
# combine the columns into a data frame, by referencing the vector names
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

And now we display the new dataset:  

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_cols)
```




### Pasting from clipboard {.unnumbered}  

If you copy data from elsewhere and have it on your clipboard, you can try one of the two ways below:  

From the **clipr** package, you can use `read_clip_tbl()` to import as a data frame, or just just `read_clip()` to import as a character vector. In both cases, leave the parentheses empty.    

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # imports current clipboard as data frame
linelist <- clipr::read_clip()      # imports as character vector
```
You can also easily export to your system's clipboard with **clipr**. See the section below on Export.  


Alternatively, you can use the the `read.table()` function from **base** R with `file = "clipboard")` to import as a data frame:  

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # specify this as "clipboard"
  sep = "t",           # separator could be tab, or commas, etc.
  header=TRUE)         # if there is a header row
```






## Import most recent file  

Often you may receive daily updates to your datasets. In this case you will want to write code that imports the most recent file. Below we present two ways to approach this:  

* Selecting the file based on the date in the file name  
* Selecting the file based on file metadata (last modification)  


### Dates in file name {.unnumbered}  

This approach depends on three premises:  

1) You trust the dates in the file names  
2) The dates are numeric and appear in *generally* the same format (e.g. year then month then day)  
3) There are no other numbers in the file name  

We will explain each step, and then show you them combined at the end.  

First, use `dir()` from **base** R to extract just the file names for each file in the folder of interest. See the page on [Directory interactions] for more details about `dir()`. In this example, the folder of interest is the folder "linelists" within the folder "example" within "data" within the R project. 

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # get file names from folder
linelist_filenames                                              # print
```

Once you have this vector of names, you can extract the dates from them by applying `str_extract()` from **stringr** using this regular expression. It extracts any numbers in the file name (including any other characters in the middle such as dashes or slashes). You can read more about **stringr** in the [Strings and characters] page.  

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") # extract numbers and any characters in between
linelist_dates_raw  # print
```

Assuming the dates are written in generally the same date format (e.g. Year then Month then Day) and the years are 4-digits, you can use **lubridate**'s flexible conversion functions (`ymd()`, `dmy()`, or `mdy()`) to convert them to dates. For these functions, the dashes, spaces, or slashes do not matter, only the order of the numbers. Read more in the [Working with dates] page.  

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```


The **base** R function `which.max()` can then be used to return the index position (e.g. 1st, 2nd, 3rd, ...) of the maximum date value. The latest file is correctly identified as the 6th file - "case_linelist_2020-10-08.xlsx".  

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

If we condense all these commands, the complete code could look like below. Note that the `.` in the last line is a placeholder for the piped object at that point in the pipe sequence. At that point the value is simply the number 6. This is placed in double brackets to extract the 6th element of the vector of file names produced by `dir()`.    

```{r}
# load packages
pacman::p_load(
  tidyverse,         # data management
  stringr,           # work with strings/characters
  lubridate,         # work with dates
  rio,               # import / export
  here,              # relative file paths
  fs)                # directory interactions

# extract the file name of latest file
latest_file <- dir(here("data", "example", "linelists")) %>%  # file names from "linelists" sub-folder          
  str_extract("[0-9].*[0-9]") %>%                  # pull out dates (numbers)
  ymd() %>%                                        # convert numbers to dates (assuming year-month-day format)
  which.max() %>%                                  # get index of max date (latest file)
  dir(here("data", "example", "linelists"))[[.]]              # return the filename of latest linelist

latest_file  # print name of latest file
```

You can now use this name to finish the relative file path, with `here()`:  

```{r, eval=F}
here("data", "example", "linelists", latest_file) 
```

And you can now import the latest file:  

```{r, eval=F}
# import
import(here("data", "example", "linelists", latest_file)) # import 
```

 



### Use the file info {.unnumbered}  

If your files do not have dates in their names (or you do not trust those dates), you can try to extract the last modification date from the file metadata. Use functions from the package **fs** to examine the metadata information for each file, which includes the last modification time and the file path.  

Below, we provide the folder of interest to **fs**'s `dir_info()`. In this case, the folder of interest is in the R project in the folder "data", the sub-folder "example", and its sub-folder "linelists".  The result is a data frame with one line per file and columns for `modification_time`, `path`, etc. You can see a visual example of this in the page on [Directory interactions].    

We can sort this data frame of files by the column `modification_time`, and then keep only the top/latest row (file) with **base** R's `head()`. Then we can extract the file path of this latest file only with the **dplyr** function `pull()` on the column `path`. Finally we can pass this file path to `import()`. The imported file is saved as `latest_file`.  

```{r, eval=F}
latest_file <- dir_info(here("data", "example", "linelists")) %>%  # collect file info on all files in directory
  arrange(desc(modification_time)) %>%      # sort by modification time
  head(1) %>%                               # keep only the top (latest) file
  pull(path) %>%                            # extract only the file path
  import()                                  # import the file

```



<!-- ======================================================= -->
## APIs {#import_api}

An "Automated Programming Interface" (API) can be used to directly request data from a website. APIs are a set of rules that allow one software application to interact with another. The client (you) sends a "request" and receives a "response" containing content. The R packages **httr** and **jsonlite** can facilitate this process. 

Each API-enabled website will have its own documentation and specifics to become familiar with. Some sites are publicly available and can be accessed by anyone. Others, such as platforms with user IDs and credentials, require authentication to access their data. 

Needless to say, it is necessary to have an internet connection to import data via API. We will briefly give examples of use of APIs to import data, and link you to further resources.  

*Note: recall that data may be *posted* on a website without an API, which may be easier to retrieve. For example a posted CSV file may be accessible simply by providing the site URL to `import()` as described in the section on [importing from Github](#import_github).*  


### HTTP request {.unnumbered}  

The API exchange is most commonly done through an HTTP request. HTTP is Hypertext Transfer Protocol, and is the underlying format of a request/response between a client and a server. The exact input and output may vary depending on the type of API but the process is the same - a "Request" (often HTTP Request) from the user, often containing a query, followed by a "Response", containing status information about the request and possibly the requested content.  

Here are a few components of an *HTTP request*:  

* The URL of the API endpoint  
* The "Method" (or "Verb")  
* Headers  
* Body  

The HTTP request "method" is the action your want to perform. The two most common HTTP methods are `GET` and `POST` but others could include `PUT`, `DELETE`, `PATCH`, etc. When importing data into R it is most likely that you will use `GET`.  

After your request, your computer will receive a "response" in a format similar to what you sent, including URL, HTTP status (Status 200 is what you want!), file type, size, and the desired content. You will then need to parse this response and turn it into a workable data frame within your R environment.


### Packages {.unnumbered}  

The **httr** package works well for handling HTTP requests in R. It requires little prior knowledge of Web APIs and can be used by people less familiar with software development terminology. In addition, if the HTTP response is .json, you can use **jsonlite** to parse the response.  

```{r, eval=F}
# load packages
pacman::p_load(httr, jsonlite, tidyverse)
```


### Publicly-available data {.unnumbered}  

Below is an example of an HTTP request, borrowed from a tutorial from [the Trafford Data Lab](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs). This site has several other resources to learn and API exercises.

Scenario: We want to import a list of fast food outlets in the city of Trafford, UK. The data can be accessed from the API of the Food Standards Agency, which provides food hygiene rating data for the United Kingdom.  

Here are the parameters for our request:  

* HTTP verb: GET  
* API endpoint URL: http://api.ratings.food.gov.uk/Establishments  
* Selected parameters: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityId  
* Headers: “x-api-version”, 2  
* Data format(s): JSON, XML  
* Documentation: http://api.ratings.food.gov.uk/help  

The R code would be as follows:  

```{r, eval=F, warning=F, message=F}
# prepare the request
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# check for any server error ("200" is good!)
request$status_code

# submit the request, parse the response, and convert to a data frame
response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

You can now clean and use the `response` data frame, which contains one row per fast food facility.  


### Authentication required {.unnumbered}  

Some APIs require authentication - for you to prove who you are, so you can access restricted data. To import these data, you may need to first use a POST method to provide a username, password, or code. This will return an access token, that can be used for subsequent GET method requests to retrieve the desired data.  

Below is an example of querying data from *Go.Data*, which is an outbreak investigation tool. *Go.Data* uses an API for all interactions between the web front-end and smartphone applications used for data collection. *Go.Data* is used throughout the world. Because outbreak data are sensitive and you should only be able to access data for *your* outbreak, authentication is required.  

Below is some sample R code using **httr** and **jsonlite** for connecting to the *Go.Data* API to import data on contact follow-up from your outbreak.  


```{r, eval=F}
# set credentials for authorization
url <- "https://godatasampleURL.int/"           # valid Go.Data instance url
username <- "username"                          # valid Go.Data username 
password <- "password"                          # valid Go,Data password 
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # valid Go.Data outbreak ID

# get access token
url_request <- paste0(url,"api/oauth/token?access_token=123") # define base URL request

# prepare request
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # use saved username/password from above to authorize                               
    password = password),                                       
    encode = "json")

# execute request and parse response
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # flatten nested JSON
  glimpse()

# Save access token from response
access_token <- content$access_token    # save access token to allow subsequent API calls below

# import outbreak contacts
# Use the access token 
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # GET request
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # convert to text JSON

contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble
```

<span style="color: orange;">**_CAUTION:_** If you are importing large amounts of data from an API requiring authentication, it may time-out. To avoid this, retrieve access_token again before each API GET request and try using filters or limits in the query. </span> 

<span style="color: darkgreen;">**_TIP:_** The `fromJSON()` function in the **jsonlite** package does not fully un-nest the first time it's executed, so you will likely still have list items in your resulting tibble. You will need to further un-nest for certain variables; depending on how nested your .json is. To view more info on this, view the documentation for the **jsonlite** package, such as the [`flatten()` function](https://rdrr.io/cran/jsonlite/man/flatten.html). </span>


For more details, View documentation on [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), the [Contact Tracing] page or API tips on [Go.Data Github repository](https://worldhealthorganization.github.io/godata/api-docs)

You can read more about the *httr* package [here](https://httr.r-lib.org/articles/quickstart.html)  

This section was also informed by [this tutorial](https://www.dataquest.io/blog/r-api-tutorial/) and [this tutorial](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1). 




<!-- ======================================================= -->
## Export {}  

### With **rio** package {.unnumbered}
With **rio**, you can use the `export()` function in a very similar way to `import()`. First give the name of the R object you want to save (e.g. `linelist`) and then in quotes put the file path where you want to save the file, including the desired file name and file extension. For example:  

This saves the data frame `linelist` as an Excel workbook to the working directory/R project root folder:  

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # will save to working directory
```

You could save the same data frame as a csv file by changing the extension. For example, we also save it to a file path constructed with `here()`:  

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.csv"))
```


### To clipboard {.unnumbered}

To export a data frame to your computer's "clipboard" (to then paste into another software like Excel, Google Spreadsheets, etc.) you can use `write_clip()` from the **clipr** package. 

```{r, eval=F}
# export the linelist data frame to your system's clipboard
clipr::write_clip(linelist)
```




## RDS files {#import_rds}

Along with .csv, .xlsx, etc, you can also export/save R data frames as .rds files. This is a file format specific to R, and is very useful if you know you will work with the exported data again in R. 

The classes of columns are stored, so you don't have do to cleaning again when it is imported (with an Excel or even a CSV file this can be a headache!). It is also a smaller file, which is useful for export and import if your dataset is large.  

For example, if you work in an Epidemiology team and need to send files to a GIS team for mapping, and they use R as well, just send them the .rds file! Then all the column classes are retained and they have less work to do.  

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.rds"))
```



<!-- ======================================================= -->
## Rdata files and lists {#import_rdata}

`.Rdata` files can store multiple R objects - for example multiple data frames, model results, lists, etc. This can be very useful to consolidate or share a lot of your data for a given project.  

In the below example, multiple R objects are stored within the exported file "my_objects.Rdata":  

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Note: if you are trying to *import* a list, use `import_list()` from **rio** to import it with the complete original structure and contents.  

```{r, eval=F}
rio::import_list("my_list.Rdata")
```







<!-- ======================================================= -->
## Saving plots {} 

Instructions on how to save plots, such as those created by `ggplot()`, are discussed in depth in the [ggplot basics] page.  

In brief, run `ggsave("my_plot_filepath_and_name.png")` after printing your plot. You can either provide a saved plot object to the `plot = ` argument, or only specify the destination file path (with file extension) to save the most recently-displayed plot. You can also control the `width = `, `height = `, `units = `, and `dpi = `.  

How to save a network graph, such as a transmission tree, is addressed in the page on [Transmission chains]. 


<!-- ======================================================= -->
## Resources {} 

The [R Data Import/Export Manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html)  
[R 4 Data Science chapter on data import](https://r4ds.had.co.nz/data-import.html#data-import)  
[ggsave() documentation](https://ggplot2.tidyverse.org/reference/ggsave.html)  


Below is a table, taken from the **rio** online [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html). For each type of data it shows: the expected file extension, the package **rio** uses to import or export the data, and whether this functionality is included in the default installed version of **rio**.  



Format                     | Typical Extension | Import Package    | Export Package     | Installed by Default
---------------------------|-------------------|-------------------|--------------------|---------------------
Comma-separated data | .csv | data.table `fread()` | data.table |	Yes
Pipe-separated data |	.psv | data.table `fread()` | data.table | Yes
Tab-separated data| .tsv | data.table `fread()` | data.table | Yes
SAS | .sas7bdat | haven | haven | Yes
SPSS | .sav | haven | haven | Yes
Stata | .dta | haven | haven | Yes
SAS | XPORT | .xpt | haven | haven | Yes
SPSS Portable | .por | haven | | Yes
Excel | .xls | readxl | | Yes
Excel | .xlsx | readxl | openxlsx | Yes
R syntax | .R	| base | base | Yes
Saved R objects | .RData, .rda | base | base | Yes
Serialized R objects | .rds | base | base | Yes
Epiinfo | .rec | foreign | | Yes
Minitab | .mtp | foreign | | Yes
Systat | .syd |	foreign | | Yes
“XBASE” | database files | .dbf | foreign | foreign | Yes
Weka Attribute-Relation File Format | .arff | foreign | foreign | Yes
Data Interchange Format | .dif | utils | | Yes
Fortran data | no recognized extension | utils | | Yes
Fixed-width format data | .fwf | utils | utils | Yes
gzip comma-separated data | .csv.gz | utils | utils | Yes
CSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | No
EViews | .wf1 |hexView | | No
Feather R/Python interchange format | .feather | feather | feather | No
Fast Storage | .fst | fst |	fst | No
JSON | .json | jsonlite | jsonlite | No
Matlab | .mat | rmatio | rmatio | No
OpenDocument Spreadsheet | .ods | readODS | readODS | No
HTML Tables | .html | xml2 | xml2 | No
Shallow XML documents | .xml | xml2 | xml2 | No
YAML | .yml | yaml | yaml	| No
Clipboard	default is tsv | |  clipr | clipr | No



