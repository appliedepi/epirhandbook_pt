
# Curvas epidêmicas { }  

```{r, out.width=c('75%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "epicurve_top.png"))
```    


Uma curva epidêmica (também conhecida como "epicurva") é uma ferramenta essencial tipicamente utilizada para visualizar padrões temporais do início de doenças entre um conjunto ou epidemia de casos.

A análise da epicurva pode revelar tendências temporais, aberrações ("outliers"), a magnitude de um surto, o período mais provável de exposição, intervalos temporais entre picos de casos, e pode até ajudar a identificar o modo de transmissão de uma doença não identificada (ex.: fonte pontual, fonte comum contínua, propagação pessoa-pessoa). Uma aula online sobre a interpretação de epicurvas pode ser encontrada no website do [CDC americano](https://www.cdc.gov/training/quicklearns/epimode/index.html).    

Nesta página, nós demonstraremos duas abordagens para a produção de curvas epidêmicas no R:

* O pacote **incidence2**, que pode produzir uma epicurva com comandos simples
* O pacote **ggplot2**, que permite customizações avançadas através de comandos mais complexos

Também serão abordados casos de uso específico:

* Criar gráficos de contagem agregada  
* Mostrar ou produzir múltiplos-pequenos
* Aplicar médias móveis
* Mostrar quais dados são "preliminares" ou sujeitos a atrasos na notificação
* Sobreposição da incidência acumulada de casos usando um segundo eixo do gráfico

<!-- ======================================================= -->
## Preparação


### Carregue os pacotes necessários {.unnumbered}  

O código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função `p_load()`, do **pacman**, que instala os pacotes, caso não estejam instalados, *e* os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função `library()`, do R **base**. Para mais informações sobre os pacotes do R, veja a página [Básico do R].  

```{r message=F, warning=F}
pacman::p_load(
  rio,          # importar/exportar arquivos
  here,         # caminhos de arquivos relativos 
  lubridate,    # trabalhando com datas/semanas epidemiológicas
  aweek,        # pacote alternativo para trabalhar com datas/semanas epidemiológicas
  incidence2,   # epicurvas de dados em uma linelist
  i2extras,     # suplemento para o pacote incidence2
  stringr,      # procure e manipule strings de caractéres
  forcats,      # trabalhando com factors
  RColorBrewer, # paleta de cores do colorbrewer2.org
  tidyverse     # gerenciamento de dados + gráficos no ggplot2
) 
```


### Importe os dados {.unnumbered}

Dois exemplos de conjuntos de dados são utilizados nesta seção:

* Lista de linhas (linelist) com casos individuais de uma simulação de epidemia
* Contagens agregadas por hospital da mesma epidemia simulada

Os conjuntos de dados são importados utilizando a função `import()` do pacote **rio**. Veja a página sobre [Importar e  exportar]  para conhecer as diferentes formas de importar dados.


```{r, echo=F, message=F}
# importe a lista de linhas no R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# importe os dados de contagem no R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```


**Lista de linhas de casos**

Nós importamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser baixar os dados para acompanhar etapa-por-etapa, veja instruções na página sobre [Download do manual e dados]. Aqui, nós assumimos que o arquivo está no diretório de trabalho. Logo, nenhuma sub-pasta é especificada no endereço do arquivo.

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")
```

As primeiras 50 linhas são mostradas abaixo.

```{r, message=FALSE, echo=F}
# mostre os dados da linelist como uma tabela
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



**Casos agregados por hospital**  

Para atingir os propósitos deste manual, o conjunto de dados de contagens semanais de casos agregados por hospital é criado a partir da `linelist`, com o seguinte código.

```{r, eval=F}
# importa os dados de contagem no R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

As primeiras 50 linhas são mostradas abaixo:

```{r message=FALSE, echo=F}
# mostre os dados da linelist como uma tabela
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




### Ajuste os parâmetros {.unnumbered}

Para produzir um relatório, você pode querer ajustar parâmetros modificáveis, como a data para a qual os dados são atuais (a "data dos dados"). Você pode, então, referênciar o objeto `data_date` em seu código ao aplicar filtros ou em legendas dinâmicas.

```{r set_parameters}
## ajuste a data do relatório para o relatório
## nota: pode ser ajustada para Sys.Date() para a data atual
data_date <- as.Date("2015-05-15")
```



### Verifique as datas {.unnumbered}

Perceba que cada coluna de datas relevantes é da classe Date e tem um intervalo apropriado de valores. Você pode fazer isso simplesmente utilizando `hist()`, para histograma, ou `range()` com `na.rm=TRUE`, ou com o `ggplot()`, como mostrado abaixo.

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# cheque o intervalo das datas de início dos sintomas
ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset))
```



<!-- ======================================================= -->
## Criando epicurvas com o pacote **incidence2** { }

Abaixo, nós demonstramos como criar epicurvas utilizando o pacote **incidence2**. Os autores deste pacote tentaram permitir ao usuário criar e modificar epicurvas sem que necessitem conhecer a sintaxe do **ggplot2**. Boa parte do conteúdo desta página foi adaptado dos resumos deste pacote, que podem ser encontrados na página **incidence2** [do github](https://github.com/reconhub/incidence2).   


<!-- ======================================================= -->
### Exemplo simples {.unnumbered}

**2 etapas são necessárias para criar um gráfico de curva epidêmica com o pacote *incidence2*:**  

1) **Criar** um *objeto incidence* (utilizando a função `incidence()`)  
    + Forneça os dados  
    + Especifique a coluna de data no argumento `date_index = `  
    + Especifique o `interval = ` em que os casos devem ser agregados (diariamente, semanalmente, mensalemnte..)
    + Especifique quaisquer variáveis de agrupamento (ex.: gênero, hospital, desfecho)
2) **Crie o gráfico** com o objeto incidence  
    + Especifique rótulos, cores, títulos, etc.


Abaixo, nós carregamos o pacote **incidence2**, criamos o objeto incidence da `linelist` com a coluna `date_onset`, e agregamos os casos por dia. Então, geramos um resumo do objeto incidence criado.

```{r, warning=F, message=F}
# carregue o pacote incidence2
pacman::p_load(incidence2)

# crie o objetio incidence, agregando casos por dia
epi_day <- incidence(       # crie o objeto incidence
  x = linelist,             # conjunto de dados
  date_index = date_onset,  # coluna de dados
  interval = "day"          # intervalo de agrupamento das datas, por dia
  )
```

O objeto **incidence2**, por si próprio, parece um tibble (um tipo de quadro de dados), podendo ser exportado ou manipulado como um quadro de dados normal.

```{r}
class(epi_day)
```

Aqui é como ele é visualizado quando exportado. Ele possui uma coluna de `date_index` e uma coluna de contagem (`count`).  

```{r}
epi_day
```

Você também pode visualizar um resumo do objeto:

```{r}
# visualize um resumo do objeto incidence
summary(epi_day)
```

Para *criar um gráfico* do objeto *incidence*, utilize a função `plot()` no *nome do objeto incidence*. Como em segundo plano, a função `plot.incidence2()` é executada, para ler a documentação específica de **incidence2** você precisa executar `?plot.incidence2`.  

```{r}
# crie o gráfico do objeto incidence
plot(epi_day)
```

Se você observar muitas linhas pequenas brancas na vertical, tente ajustar o tamanho da sua imagem. Por exemplo, se você exportar o seu gráfico com `ggsave()`, você pode fornecer números para `width = ` e `height = `. Se você expandir o gráfico, estas linhas podem desaparecer.



### Altere o intervalo de tempo para agregar os casos {.unnumbered}  
O argumento `interval = `, da função `incidence()`, define como os casos são agrupados em barras verticais.

**Especifique o intervalo para agregar os casos**  

O pacote **incidence2** oferece flexibilida e sintaxe compreensível para especificar como você quer agregar seus casos em barras de epicurvas. Forneça um valor como os mostrados abaixo para o argumento `interval =`. Você pode escrever qualquer uma das opções abaixo no plural (ex.: week**s** ("semana**s**"), e também pode adicionar números antes (ex.: 3 months ("3 meses")). Lembre-se que precisam ser em inglês. 

Opção de argumento | Mais explicações
------------------- | ------------------------------------ |
Number (1, 7, 13, 14, etc.) | Números de dias por intervalo
"week" | nota: Segunda é o dia padrão de início
"2 weeks" | ou 3, 4, 5...
"Sunday week" | semanas começando nos domingos (poderia também utilizar Thursday (quinta-feira), etc.)
"2 Sunday weeks" | ou 3, 4, 5...
"MMWRweek" | semana começa nos domingos - veja o CDC
"month" | primeiro do mês
"quarter" | primeiro do mês do trimestre
"2 months" | ou 3, 4, 5...
"year" | primeiro dia do ano-calendário


Abaixo são mostrados exemplos de como os diferentes intervalos se apresentam quando aplicados à lista de linhas. Observe como o formato padrão e a frequência dos *rótulos* de datas no eixo x mudam conforme o intervalo de datas muda.

```{r incidence, out.width=c('50%', '50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# Crie os objetos incidence (com diferentes intervalos)
##############################
# Semanalmente (Semanas començam na segunda por padrão)
epi_wk      <- incidence(linelist, date_onset, interval = "Monday week")

# Semanas iniciando no domingo
epi_Sun_wk  <- incidence(linelist, date_onset, interval = "Sunday week")

# Três semanas (Semanas iniciam na segunda por padrão)
epi_2wk     <- incidence(linelist, date_onset, interval = "2 weeks")

# Mensalmente
epi_month   <- incidence(linelist, date_onset, interval = "month")

# Trimestralmente
epi_quarter   <- incidence(linelist, date_onset, interval = "quarter")

# Anos
epi_year   <- incidence(linelist, date_onset, interval = "year")


# Faça um gráfico dos objetos incidence (+ títulos para clareza)
############################
plot(epi_wk)+      labs(title = "Semanas iniciadas nas segundas")
plot(epi_Sun_wk)+  labs(title = "Semanas iniciadas nos domingos")
plot(epi_2wk)+     labs(title = "2 semanas iniciadas nas segundas")
plot(epi_month)+   labs(title = "Meses")
plot(epi_quarter)+ labs(title = "Trimestres")
plot(epi_year)+    labs(title = "Anos")

```


<!-- **Inicie no primeiro caso**   -->

<!-- Se você quer que os intervalos iniciem no primeiro caso, você pode adicionar o comando `standard = TRUE` na função `incidence()`. Isto apenas funciona se o intervalo for "week" (semana), "month" (mês), "quarter" (trimestre) ou "year" (ano).   -->

**Primeira data**

Opcionalmente, você pode especificar um valor da classe Date (ex.: `as.Date("2016-05-01")`) para `firstdate = ` na função `incidence()`. Neste caso, os dados serão filtrados para este intervalo, e os intervalos iniciarão nesta data.



### Grupos {.unnumbered}

Grupos são especificados no comando `incidence()`, e podem ser utilizados para colorir as barras ou para facetear os dados. Para especificar grupos em seus dados, forneça o nome(s) da(s) coluna(s) para o argumento `groups =` no comando `incidence()` (sem asteriscos ao redor do nome da coluna). Ao especificar múltiplas colunas, colone os seus nomes dentro de `c()`.

Você pode especificar que os casos com campos em brancos nas colunas de agrupamento sejam listados como um grupo `NA` distinto, ao ajustar `na_as_group = TRUE`. Do contrário, eles serão excluídos do gráfico.

* Para *colorir as barras de acordo com uma coluna de agrupamento*, você precisa fornecer novamente o nome da coluna para o argumento `fill = ` no comando `plot()`.  

* Para *embelezar baseado em uma coluna de agrupamento*, veja a seção abaixo sobre embelezamentos com o pacot **incidence2**.  

Neste exemplo, os casos do surto inteiro são agrupados pela categoria de idade. Campos em branco são incluídos como um grupo. O intervalo da epicurva é por semanas.


```{r, message=F, warning=F}
# Crie o objeto incidence, com os dados agrupados por categoria de idade
age_outbreak <- incidence(
  linelist,                # conjunto de dados utilizado
  date_index = date_onset, # coluna de datas
  interval = "week",       # Agregação semanal dos casos a partir das segundas-feiras
  groups = age_cat,        # variável age_cat é escolhida para agrupamento
  na_as_group = TRUE)      # campos em branco atribuídos ao seu próprio grupo

# crie o gráfico do objeto incidence
plot(
  age_outbreak,             # objeto incidence com a variável age_cat como agrupador
  fill = age_cat)+          # age_cat é utilizada para preencher as cores das barras (precisa ter sido ajustada como coluna de agrupamento acima)
labs(fill = "Categoria de idade") # mude o título da legenda do padrão "age_cat" (isto é uma modificação do ggplot2)
```
<span style="color: darkgreen;">**_DICA:_** Altere o título da legenda ao adicionar `+` ao comando `labs(fill = "coloque seu título")` do **ggplot2** no seu gráfico **incidence2**.</span>  

Você pode fazer as colunas agrupadas serem mostradas lado-a-lado ao ajustar `stack = FALSE` no `plot()`, como mostrado abaixo:

```{r, warning=F, message=F}
# Crie um objeto incidence de contagens mensais.
monthly_gender <- incidence(
 linelist,
 date_index = date_onset,
 interval = "month",
 groups = gender            # coloque gênero (gender) como variável de agrupamento
)

plot(
  monthly_gender,   # objeto incidence
  fill = gender,    # mostre as barras coloridas por gênero
  stack = FALSE)    # lado-a-lado (não empilhado)
``` 

Você pode atribuir FALSE ao argumento `na_as_group = ` no comando `incidence()` para remover linhas com campos em branco do gráfico.




### Dados filtrados {.unnumbered}

Para criar uma epicurva de um subconjunto dos dados:

1) Filtre os dados da linelist
2) Forneça os dados filtrados para o comando `incidence()`  
3) Faça o gráfico do objeto incidence

O exemplo abaixo utiliza dados filtrados para mostrar apenas casos do Hospital Central.

```{r, warning=F, message=F}
# filtre a linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# crie um objeto incidence utilizando os dados filtrados
central_outbreak <- incidence(central_data, date_index = date_onset, interval = "week")

# faça um gráfico do objeto incidence
plot(central_outbreak, title = "Incidência semanal de casos do Hospital Central")
```




### Contagens agregadas {.unnumbered}

Caso os seus dados originais sejam agregados (contagens), forneça o nome da coluna com a contagem de casos para o argumento `count = ` quando criar o objeto incidence com `incidence()`.  

Por exemplo, este quadro de dados `count_data` é o linelist agregado em contagens diárias por hospital. As primeiras 50 linhas são assim:

```{r message=FALSE, echo=F}
DT::datatable(head(count_data,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Se você estiver iniciando suas análises com dados de contagens diárias como no banco de dados acima, seu comando `incidence()` para converter estes dados para uma epicurva de casos semanais por hospital seria assim:

```{r}
epi_counts <- incidence(              # crie um objeto de incidência semanal
  count_data,                         # banco de dados com contagens agregadas por dia
  date_index = date_hospitalisation,  # coluna com as datas
  count = n_cases,                    # coluna com contagens
  interval = "week",                  # agregue contagens diárias por semanas
  groups = hospital                   # agrupe por hospital
  )

# faça um gráfico de uma epicurva com incidência semanal, com as barras agrupadas por hospital
plot(epi_counts,                      # objeto incidence
     fill = hospital)                 # colorir as barras por hospital
```




### Facetas/múltiplos pequenos {.unnumbered}  

Para destacar os dados por grupos (ex.: produzir "pequenos múltiplos"):

1) Especifique a coluna de interesse em `groups = ` quando você criar o objeto incidência
2) Utilize o comando `facet_plot()` em vez de `plot()`  
3) Especifique quais colunas de agrupamento utilizar como preenchimento, usando `fill = `, e quais destacar em `facets = `  

Abaixo, nós ajustamos ambas colunas `hospital` e `outcome` como colunas de agrupamento no comando `incidence()`. Então, na função `facet_plot()`, nós criamos a epicurva, especificando que queremos uma epicurva diferente para cada hospital e que, dentro de cada epicurva, as barras devem ser empilhadas e coloridas de acordo com o desfecho (outcome).
 

```{r, warning=F, message=F}
epi_wks_hosp_out <- incidence(
  linelist,                      # banco de dados
  date_index = date_onset,       # colunas com as datas
  interval = "month",            # intervalo de datos (mensal)
  groups = c(outcome, hospital)  # tanto outcome (desfecho) quanto hospital são fornecidos como colunas de agrupamento
  )

# crie o gráfico
incidence2::facet_plot(
  epi_wks_hosp_out,      # objeto incidence
  facets = hospital,     # coluna de destaque
  fill = outcome)        # coluna de preenchimento

```

Observe que o pacote **ggtree** (utilizado para mostrar árvores filogenéticas) também tem uma função `facet_plot()` - por isso especificamos `incidence2::facet_plot()` no código acima, para usar essa função do pacote **incidence2**.  



### Modificações com `plot()` {.unnumbered} 

Uma epicurva produzida pelo pacote **incidence2** pode ser modificada através destes argumentos *dentro da função `plot()`*.

**Aqui estão os argumentos `plot()` que modificam a aparência das barras:**

Argumento | Descrição | Exemplos
------------------|---------------------------------------|-------------------
`fill = `|Cor da barra. Ou o nome de uma cor, ou o nome de uma coluna previamente especificada em  `groups = ` no comando `incidence()`|`fill = "red"`, ou `fill = gender`  
`color = ` |Cor ao redor de cada barra, ou ao redor de cada agrupamento dentro de uma barra|`border = "white"` 
`legend = `|Posição da legenda|Uma das seguintes opções: "bottom", "top", "left", "right", ou "none"  
`alpha = `|Nível de transparência das barras/box|1 é totalmente opaco, 0 é totalmente transparente
`width = `|Valor entre 0 e 1 indicando o tamanho relativo das barras em relação ao seus intervalos de tempo|`width = .7`  
`show_cases = `|Valor lógico; se TRUE (verdadeiro), cada caso é mostrado como uma caixa. É melhor empregado em pequenos surtos.|`show_cases = TRUE`  

**Aqui estão os argumentos de `plot()` que modificam o eixo da data:**  

Argumento(s)|Descrição
----------------------|----------------------------------------------------
`centre_dates = `|TRUE/FALSE para as datas serem colocadas abaixo do centro, ou no topo das barras
`date_format = `|Ajuste o formato de exibição da data utilizando a sintaxe do strptime ("%"). Funciona apenas se `centre_dates = FALSE` (detalhes abaixo).  
`n.breaks = `|Número aproximado de quebras nos rótulos do eixo x.
`angle = `|Ângulo dos rótulos de data no eixo x (em graus)
`size = `|Tamanho do texto em pontos

Observe que o argumento `date_breaks = ` funciona apenas se `centre_dates = FALSE`. Forneça um valor de carácter entre aspas utilizando a sintaxe de strptime abaixo, como detalhado na página [Trabalhando com datas]. Você pode utilizar `\n` para uma "nova linha".

%d = Número do dia no mês (5, 17, 28, etc.)  
%j = Número do dia no ano (Data Juliana 001-366)  
%a = Nome abreviado do dia da semana (Mon (Seg), Tue (Ter), Wed (Qua), etc.)  
%A = Nome completo do dia da semana (Monday (Segunda), Tuesday (Terça-feira), etc.)  
%w = Número do dia na semana (0-6, Domingo é 0)  
%u = Número do dia na semana (1-7, Segunda é 1)  
%W = Número da semana no ano (00-53, Segunda é o início da semana)  
%U = Número da semana no ano (01-53, Domingo é o início da semana)  
%m = Número do mês (ex.: 01, 02, 03, 04)  
%b = Nome do mês abreviado (Jan, Feb (Fev), etc.)  
%B = Nome do mês inteiro (January (Janeiro), February (Fevereiro), etc.)  
%y = O ano em 2-dígitos (ex.: 89)  
%Y = O ano em 4-dígitos (ex.: 1989)  
%h = horas (relógio de 24-hr)  
%m = minutos  
%s = segundos  
%z = compensado a partir do GMT 
%Z = fuso horário (carácter)


<!-- <span style="color: darkgreen;">**_DICA:_** Para quebras a cada "x" intervalos (ex.: a cada 4 intervalos), utilize `n.breaks = nrow(i)/n` (onde “i” é o nome do seu objeto incidence e "n" é um número). Caso seus dados estejam agrupados, você irá precizar multiplicar "n" pelo número de grupos únicos. </span>   -->



**Aqui estão os argumentos de `plot()` que modificam os rótulos do gráfico:**

Argumento(s)|Descrição
----------------------|----------------------------------------------------
`title = `|Título do gráfico|`title = "Curva epidêmica da Síndrome Aguda de Icterícia (SAI)"`
`xlab = `|Título do eixo x|`xlab = "Data do início dos sintomas"`  
`ylab = `|Título do eixo y|`ylab = "Casos diários"`  
`size = `|Tamanho do texto do eixo x em pontos (utilizar a função theme() do ggplot para ajustar outros tamanhos)


Um exemplo utilizando muitos dos argumentos acima:

```{r, warning=F, message=F}
# filtre o linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# crie um objeto incidence utilizando os dados filtrados
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = outcome)

# faça um gráfico do objeto incidence
plot(
  central_outbreak,
  fill = outcome,                       # cor da barra/caixa
  legend = "top",                       # legenda no topo
  title = "Cases at Central Hospital",  # título
  xlab = "Week of onset",               # rótulo do eixo x
  ylab = "Week of onset",               # rótulo do eixo y
  show_cases = TRUE,                    # mostre cada caso como uma caixa individual
  alpha = 0.7,                          # transparência 
  border = "grey",                      # borda da caixa
  angle = 30,                           # ângulo dos rótulos das datas
  centre_dates = FALSE,                 # rótulo das datas na ponta das barras
  date_format = "%a %d %b %Y\n(Week %W)" # ajuste como as datas são mostradas
  )
```

Para ajustar ainda mais a aparência do gráfico, veja a seção abaixo sobre modificações com o `ggplot()`.  






### Modificações com o ggplot2 {.unnumbered}

Você pode modificar ainda mais um gráfico **incidence2** ao adicionar modificações do **ggplot2** com um `+` após fechar a função `plot()` do incidence, como demonstrado abaixo.

A seguir, o gráfico do **incidence2** termina e, então, comandos do **ggplot2** são utilizados para modificar os eixos, adicionar legendas, e ajustar a fonte em negrito e tamanho do texto.

Note que, se você adicionar `scale_x_date()`, boa parte da formatação das datas com `plot()` será substituída. Veja a seção do `ggplot()` sobre epicurvas e a página [dicas do ggplot] para mais opções.

```{r, warning=F, message=F}
# filtre a linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# crie um objeto incidence utilizando os dados filtrados
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = c(outcome))

# faça um gráfico do objeto incidence
plot(
  central_outbreak,
  fill = outcome,                       # cor da caixa/barra
  legend = "top",                       # legenda no topo
  title = "Cases at Central Hospital",  # título
  xlab = "Semana de início dos sintomas",               # rótulo do eixo x
  ylab = "Semana de início dos sintomas",               # rótulo do eixo y
  show_cases = TRUE,                    # mostre cada caso como uma caixa individual
  alpha = 0.7,                          # transparência
  border = "grey",                      # borda da caixa
  centre_dates = FALSE,                   
  date_format = "%a %d %b\n%Y (Week %W)", 
  angle = 30                           # ângulo dos rótulos das datas
  )+
  
  scale_y_continuous(
    breaks = seq(from = 0, to = 30, by = 5),  # especifique os incrementos do eixo y por 5
    expand = c(0,0))+                         # remova o espaço em excesso abaixo de 0 no eixo y
  
  # adicione uma legenda dinâmica
  labs(
    fill = "Evolução do paciente",                               # Título da legenda
    caption = stringr::str_glue(                            # legenda dinâmica - veja a página sobre carácteres e strings para mais detalhes
      "n = {central_cases} do Hospital Central
      Aparêncimento dos casos entre {earliest_date} e {latest_date}. {missing_onset} casos estão sem a data de aparêcimento e não foram mostrados",
      central_cases = nrow(central_data),
      earliest_date = format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),
      latest_date = format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),      
      missing_onset = nrow(central_data %>% filter(is.na(date_onset)))))+
  
  # ajuste o título em negrito e a posição da legenda
  theme(
    axis.title = element_text(size = 12, face = "bold"),    # título dos eixos maiores e em negrito
    axis.text = element_text(size = 10, face = "bold"),     # tamanho do texto dos eixos e em negrito
    plot.caption = element_text(hjust = 0, face = "italic") # mova a legenda para a esquerda
  )
  
```




### Altere as cores do histograma {.unnumbered}  

#### Especifique uma paleta de cores {.unnumbered}  

Forneça o nome de uma paleta de cores pré-definida para o argumento `col_pal = ` em `plot()`. O pacote **incidence2** vem com duas paletas pré-definidas: "vibrante" e "silenciosa". Na "vibrante", as primeiras 6 cores são distintas, e na "silenciosa" as primeiras 9 cores são distintas. Após estes números, as cores são interpolações/intermediárias das outras cores. Estas paletas pré-definidas podem ser encontradas [neste website](https://personal.sron.nl/~pault/#sec:qualitative). As paletas excluem o cinza, que é reservado para dados em branco (utilize `na_color = ` para mudar este padrão).

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# Crie um objeto incidence, com os dados agrupados por categoria de idade
age_outbreak <- incidence(
  linelist,
  date_index = date_onset,   # data de aparecimento para o eixo x
  interval = "week",         # casos agregados por semana
  groups = age_cat)

# crie uma epicurva com a paleta padrão
plot(age_outbreak, fill = age_cat, title = " Paleta padrão 'vibrante' do incidence2")

# faça um gráfico com uma cor diferente da paleta
#plot(age_outbreak, fill = age_cat, col_pal = muted, title = "Paleta 'silenciosa' do incidence2")
```

Você pode também utilizar uma das paletas do R **base** (coloque o nome da paleta *sem* as aspas).

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# crie o gráfico com uma paleta do base R
plot(age_outbreak, fill = age_cat, col_pal = heat.colors, title = "Paleta heat.colors do R base")

# crie um gráfico com uma paleta do base R
plot(age_outbreak, fill = age_cat, col_pal = rainbow, title = "Paleta rainbow do R base")
```

Você também pode adicionar uma paleta de cores do pacote **viridis** ou do pacote **RColorBrewer**. Primeiro estes pacotes precisam estar carregados, então adicione as suas funções `scale_fill_*()` específicas com um `+`, como mostrado abaixo.

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
pacman::p_load(RColorBrewer, viridis)

# crie o gráfico com uma paleta de cores
plot(age_outbreak, fill = age_cat, title = "Paleta Viridis")+
  scale_fill_viridis_d(
    option = "inferno",     # esquema de cores, experimente também "plasma" ou o padrão
    name = "Categoria de idade",  # nome da legenda
    na.value = "grey")      # cor para campos em branco

# crie o gráfico com uma paleta de cores
plot(age_outbreak, fill = age_cat, title = "Paleta RColorBrewer")+
  scale_fill_brewer(
    palette = "Dark2",      # paleta de cores, experimente também Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3
    name = "Categoria de idade",  # nome da legenda
    na.value = "grey")      # para campos em branco
```


#### Especifique as cores manualmente {.unnumbered}  

Para especificar as cores manualmente, adicione a função `scale_fill_manual()` do **ggplot2** na função `plot()` com um `+` e forneça os vetores do nome das cores ou os códigos HEX para o argumento `values = `. O número de cores listadas precisa ser igual ao número de grupos. Esteja ciente que, caso campos em brancos sejam um grupo, eles podem ser convertidos para um valor de caráctere como "Em branco" durante a preparação dos seus dados com a função `fct_explicit_na()`, como explicado na página sobre [Factors].  

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# escolha as cores manualmente
plot(age_outbreak, fill = age_cat, title = "Cores especificadas manualmente")+
  scale_fill_manual(
    values = c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange", "red", "lightblue"),  # cores
    name = "Categoria de idade")      # Nome para legenda
```

Como mencionado na página sobre [dicas do ggplot], você pode criar suas próprias paletas utilizando `colorRampPalette()` em um vetor de cores, e especificando o número de cores que você quer em retorno. Esta é uma boa maneira de obter muitas cores de uma vez ao especificar apenas algumas.

```{r}
my_cols <- c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange")
my_palette <- colorRampPalette(my_cols)(12)  # expanda as 6 cores acima para 12 cores
my_palette
```
          
         
### Ajuste a ordem dos níveis {.unnumbered}  

Para ajustar a ordem de aparecimento dos grupos (no gráfico e na legenda), a coluna de agrupamento precisa ser da classe Factor. Veja a página sobre [Factors] para mais informações.

Primeiro, vamos ver uma epicurva semanal por hospital com o ordenamento padrão:

```{r, message=F, warning=F}
# ORIGINAL - hospital NÃO ESTÁ como factor
###################################

# crie um objeto de incidência semanal, com as linhas agrupadas por hospital e semana
hospital_outbreak <- incidence(
  linelist,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# faça um gráfico do objeto incidence
plot(hospital_outbreak, fill = hospital, title = "ORIGINAL - hospital não é um factor")
```

Agora, para ajustar a ordem de forma que "Missing" e "Other" estejam no topo da epicurva, nós podemos fazer o seguinte:

* Carregue o pacote **forcats**, para trabalhar com a classe de Factors
* Ajuste o conjunto de dados - neste caso, nós iremos definir um novo banco de dados (`plot_data`) em que:
  * a coluna `gender` está definida como um factor, a ordem dos níveis está ajustada em `fct_relevel()`, de forma que "Other" e "Missing" vem primeiro e aparecem no topo das barras
* O objeto incidence é criado e um gráfico é criado, como anteriormente mostrado
* Nós adicionamos modificações pelo **ggplot2**  
  * `scale_fill_manual()` para manualmente configurar cores de forma que "Missing" é cinza e "Other" é bege  
 



```{r, message=F, warning=F}
# MODIFICADO - hospital como factor
###############################

# carregue o pacote forcats para trabalhar com factors
pacman::p_load(forcats)

# Converta a coluna hospital para factor, e ajuste os níveis
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Ajuste "Missing" e "Other" como níveis para estaren no topo


# Crie um objeto de incidência semanal, agrupado por hospital e semana
hospital_outbreak_mod <- incidence(
  plot_data,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# faça um gráfico do objeto incidence
plot(hospital_outbreak_mod, fill = hospital)+
  
  # especifique as cores manualmente
  scale_fill_manual(values = c("grey", "beige", "darkgreen", "green2", "orange", "red", "pink"))+                      

  # adicione os rótulos pelo ggplot
  labs(
      title = "MODIFICADO - hospital como factor",   # crie o título
      subtitle = "Outros & 'Em branco' no topo da epicurva",
      y = "Incidência semanal de casos",               # título do eixo y  
      x = "Semana de início dos sintomas",               # título do eixo x
      fill = "Hospital")                         # título da legenda     
```

<span style="color: darkgreen;">**_DICA:_** Se você quiser reverter apenas a ordem da legenda, adicione este comando do **ggplot2**: `guides(fill = guide_legend(reverse = TRUE))`.</span>  



### Linhas de grade verticais {.unnumbered}  

Se você criar um gráfico com as configurações padrão de **incidence2**, poderá reparar que as linhas de grade verticais aparecem em cada rótulo de data, e uma vez entre cada rótulo de data. Isto pode resultar em algumas linhas de grade cruzando com o topo de algumas barras.

<!-- [A FAZER Nota: este parágrafo não é aplicável com a versão 1.0.0 de incidence2). Você pode especificar o intervalo para as linhas de grade ao adicionar o comando `scale_x_date()` do  **ggplot2** no seu gráfico do **incidence2**. Dentro dele, especifique os intervalos para `date_breaks = ` e `date_minor_breaks = ` (ex.: "weeks" ou "3 weeks" ou "months"). Observe que utilizar `scale_x_date()` irá substituir qualquer formatação dos rótulos de data feitos dentro de `plot()`, de forma que você irá precisar especificar qualquer formato de string para `date_labels = ` como mostrado abaixo.   -->

Você pode remover todas as linhas de grade ao adicionar o comando `theme_classic()` do **ggplot2**.

```{r, warning=F, message=F, out.width = c('50%', '50%', '50%'), fig.show='hold'}
# crie um objeto incidence
a <- incidence(
  central_data,
  date_index = date_onset,
  interval = "Monday weeks"
)

# Linhas de grade padrão
plot(a, title = "Default lines")

# Intervalos de linhas de grade especificados
# NÃO ESTÁ FUNCIONANDO COM INCIDENCE2 1.0.0
# plot(a, title = "Weekly lines")+
#   scale_x_date(
#     date_breaks = "4 weeks",      # principais linhas verticais alinhadas com semanas
#     date_minor_breaks = "weeks",  # linhas verticais menores alinhadas semanalmente
#     date_labels = "%a\n%d\n%b")   # formato dos rótulos de data

# Sem linhas de grade
plot(a, title = "Sem linhas")+
  theme_classic()                 # remove todas as linhas de grade
```

Observe, entretanto, que ao utilizar semanas, os argumentos `date_breaks` e `date_minor_breaks` apenas funcionam para semanas iniciando em *Monday* (Segundas). Caso suas semanas iniciem por outro dia, você precisará fornecer manualmente um vetor de datas para os argumentos `breaks = ` e `minor_breaks = `. Veja a seção sobre **ggplot2** para exemplos disso utilizando `seq.Date()`.

### Incidência acumulada {.unnumbered}  

Você pode produzir facilmente um gráfico de incidência acumulada ao utilizar o objeto incidence no comando `cumulate()`, do pacote **incidence2**, e então `plot()`. Isto também funciona com `facet_plot()`.  

```{r}
# crie um objeto de incidência semanal
wkly_inci <- incidence(
  linelist,
  date_index = date_onset,
  interval = "week"
)

# faça um gráfico da incidência acumulada
wkly_inci %>% 
  cumulate() %>% 
  plot()
```


Veja a seção mais abaixo nesta página para conhecer métodos alternativos para criar gráficos de incidência acumulada com o **ggplot2** - por exemplo, colocar uma linha de incidência acumulada acima de uma epicurva.

### Média móvel  {.unnumbered}

Você pode adicionar uma média móvel em um gráfico de **incidence2** facilmente com a função `add_rolling_average()` do pacote **i2extras**. Utilize seu objeto incidence2 nesta função, e então use `plot()`. Ajuste `before = ` para o número de dias anteriores que você quer incluir na média móvel (o padrão são 2 dias). Caso seus dados sejam agrupados, a média móvel será calculada por grupo.

```{r, warning=F, message=F}
rolling_avg <- incidence(                    # crie um objeto incidence
  linelist,
  date_index = date_onset,
  interval = "week",
  groups = gender) %>% 
  
  i2extras::add_rolling_average(before = 6)  # adicione médias móveis (neste caso, por gênero)

# faça o gráfico
plot(rolling_avg, n.breaks = 3) # foi facetado automaticamente devido à média móvel dos grupos
```

Para aprender sobre como aplicar médias móveis de forma mais geral nos dados, veja a página deste manual sobre [Médias móveis].


<!-- ======================================================= -->
## Epicurvas no ggplot2 { }

Utilizar o `ggplot()` para criar sua epicurva permite mais flexibilidade e customização. Entretanto, é necessário mais esforço e entendimento sobre como o `ggplot()` funciona.

Diferente do pacote **incidence2**, no **ggplot** você precisa controlar *manualmente* a agregação dos casos pelo tempo (em semanas, meses, etc) *e* os intervalos dos rótulos no eixo de data. Isto precisa ser cuidadosamente gerenciado.

Os exemplos abaixo utilizam um subconjunto do banco de dados `linelist` - apenas os casos do Hospital Central.


```{r, echo=F}
# importe a linelist no R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r}
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")
```

```{r, eval=F, echo=F}
detach("package:tidyverse", unload=TRUE)
library(tidyverse)
```


Para produzir uma epicurva com o `ggplot()`, existem três elementos principais:

* Um histograma, com os casos da linelist agregados em "containers" separados por pontos "de quebra" específicos
* Escalas para os eixos e seus rótulos
* Temas para a aparência do gráfico, incluindo títulos, rótulos, legendas, etc.


### Especifique os containers de casos {.unnumbered}  

Aqui nós mostramos como especificar os casos que irão serem agregados em containers de histogramas ("barras"). É importante reconhecer que o agrupamento dos casos em containers de histograma **não** é necessariamente nos mesmos intervalos das datas que irão aparecer no eixo x.

A seguir é mostrado, provavelmente, o código mais simples para produzir epicurvas diárias ou semanais.

No comando global `ggplot()`, o conjunto de dados é fornecido em `data = `. A partir disto, a geometria do histrograma é adicionada com um `+`. Dentro de `geom_histogram()`, nós mapeamos a aparência do gráfico de forma que a coluna `date_onset` é mapeada para o eixo x. Também dentro de `geom_histogram()`, mas *não* dentro de `aes()`, nós ajustamos o `binwidth =` dos containers do histobrama, em dias. Se essa sintaxe do **ggplot2** é confusa, revise a página sobre [básico do ggplot].  

<span style="color: orange;">**_CUIDADO:_** Criar um gráfico de casos semanas ao utilizar `binwidth = 7` inicia o primeiro container de 7-dias no primeiro caso, que pode ser em qualquer dia da semana! Para criar semanas específicas, veja a seção abaixo.</span>


``` {r ggplot_simple,  out.width = c('50%', '50%'), fig.show='hold', warning= F, message = F}
# diariamente 
ggplot(data = central_data) +          # escolha os dados
  geom_histogram(                      # adicione o histograma
    mapping = aes(x = date_onset),     # mapeia a colune de data para o eixo x
    binwidth = 1)+                     # casos unidos por 1 dia
  labs(title = "Hospital Central - Diariamente")                # título

# semanal
ggplot(data = central_data) +          # escolha os dados 
  geom_histogram(                      # adicione o histograma
      mapping = aes(x = date_onset),   # mapeia a coluna de data para o eixo x
      binwidth = 7)+                   # casos unidos a cada 7 dias, iniciando no primeiro caso (!)
  labs(title = "Hospital Central - Containers de 7-dias, iniciando no primeiro caso") # título
```

Deixe-nos observar que o primeiro caso neste conjunto de dados do Hospital Central teve o início dos sintomas em:

```{r}
format(min(central_data$date_onset, na.rm=T), "%A %d %b, %Y")
```

**Para manualmente especificar as quebras dos containers do histograma, *não* utilize o argumento `binwidth = `, e, em vez disso, forneça um vetor de datas para `breaks = `.**  

Crie o vetor de datas com a função `seq.Date()` do R **base**. Esta função precisa dos argumentos `to = `, `from = `, e `by = `. Por exemplo, o comando abaixo retorna datas mensais começando em 15 de janeiro e terminando em 28 de junho.

```{r}
monthly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                           to = as.Date("2015-07-15"),
                           by = "months")

monthly_breaks   # exporta pro console
```

Este vetor pode ser fornecido para `geom_histogram()` como `breaks = `:  

```{r, warning=F, message=F}
# mensalmente 
ggplot(data = central_data) +  
  geom_histogram(
    mapping = aes(x = date_onset),
    breaks = monthly_breaks)+         # forneça um vetor pré-definido de quebras
  labs(title = "Containers de casos mensais")   # título
```

Uma sequência semanal simples pode ser obtida ao ajustar `by = "week"`. Por exemplo:

```{r}
weekly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                          to = as.Date("2015-07-15"),
                          by = "week")
```

 
Uma alternativa para o fornecimento de datas específicas de início e fim, é escrever um código *dinâmico* de forma que containers semanais iniciem *na segunda antes do primeiro caso*. **Nós iremos utilizar estes vetores de data nos exemplos abaixo.**  
     
```{r}
# Sequência de datas semanais iniciando nas Segundas para o HOSPITAL CENTRAL
weekly_breaks_central <- seq.Date(
  from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # segunda anterior
  to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # segunda após o último caso
  by   = "week")
```  

Vamos destrinchar o código complicado mostrado acima:

* O valor "from" (data mais antiga da sequência) é criado da seguinte forma: a menor data (`min()` com `na.rm=TRUE`) na coluna `date_onset` é atribuída a `floor_date()`, do pacote **lubridate**. `floor_date()` é ajustada para gerar "semanas" a partir da data de início dos casos da "semana" em questão, considerando que o dia de início de cada semana é segunda (`week_start = 1`).  
* Da mesma forma, o valor "to" (data final da sequência) é criado utilizando a função inversa `ceiling_date()` para retornar a segunda *após* o último caso.
* O argumento "by" de `seq.Date()` pode ser ajustado para qualquer número de dias, semanas, ou meses.
* Utilize `week_start = 7` para semanas que iniciem no Domingo

Como iremos utilizar estes vetores de data nesta página, nós também definimos um vetor para o surto inteiro (o vetor acima é apenas para os casos do Hospital Central).

```{r}
# Sequência para o surto inteiro
weekly_breaks_all <- seq.Date(
  from = floor_date(min(linelist$date_onset, na.rm=T),   "week", week_start = 1), # segunda antes do primeiro caso
  to   = ceiling_date(max(linelist$date_onset, na.rm=T), "week", week_start = 1), # segunda após o último caso
  by   = "week")
```

Estas saídas do `seq.Date()` podem ser usadas para criar quebras de constainers de histogramas, assim como as quebras para os rótulos de data, que podem ser independentes dos containers. Leia mais sobre os rótulos de datas em seções posteriores.

<span style="color: darkgreen;">**_DICA:_** Para um comando `ggplot()` mais simples, salve as quebras dos containers e as quebras dos rótulos de datas como vetores nomeados no começo, e simplesmente os forneça em `breaks = `.</span>  







### Exemplo de epicurva semanal {.unnumbered}  

**Abaixo esta detalhado um exemplo de código utilizado para produzir epicurvas semanais para semanas que iniciam nas segundas, com barras alinhadas, rótulos de data, e linhas de grade verticais.** Esta seção é para o usuário que precisa rapidamente de um código. Para entender cada aspecto (temas, rótulos de datas, etc.) profundamente, continue para as seções subsequentes. De nota:

* As *quebras dos containers do histograma* são definidas com `seq.Date()`, como explicado acima, para iniciar na segunda anterior ao primeiro caso, e para terminar na segunda posterior ao último caso
* O intervalo dos *rótulos de data* é especificado por `date_breaks =` dentro de `scale_x_date()`  
* O intervalo de linhas da grade vertical menores entre os rótulos de data é especificado em `date_minor_breaks = `  
* `expand = c(0,0)` nas escalas de x e y remove o excesso de espaço em cada lado dos eixos, o que também garante que os rótulos de data iniciem a partir da primeira barra.

```{r, warning=F, message=F}
# ALINHAMENTO TOTAL A PARTIR DAS SEGUNDAS-FEIRAS
#############################
# Defina a sequência de quebras semanais
weekly_breaks_central <- seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # Segunda antes do primeiro caso
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # Segunda após último caso
      by   = "week")    # containers são de 7-dias


ggplot(data = central_data) + 
  
  # crie o histograma: especifique os pontos de quebra do container: inicie na segunda antes do primeiro caso, termine na segunda após o último caso
  geom_histogram(
    
    # mapeando a estética do gráfico
    mapping = aes(x = date_onset),  # coluna de data mapeada para o eixo x
    
    # quebras do container do histograma
    breaks = weekly_breaks_central, # quebras do container do histograma definidas anteriormente
    
    # barras
    color = "darkblue",     # cor das linhas ao redor das barras
    fill = "lightblue"      # cor do preenchimento das barras
  )+ 
    
  # rótulos do eixo x
  scale_x_date(
    expand            = c(0,0),           # remove o espaço em excesso do eixo x antes e após as barras de casos
    date_breaks       = "4 weeks",        # rótulos de data e principais linhas de grade verticais aparecem a cada 3 semanas iniciando nas segundas
    date_minor_breaks = "week",           # linhas de grade menores aparecem a cada semana iniciando na segunda
    date_labels       = "%a\n%d %b\n%Y")+ # formato dos rótulos de data
  
  # eixo y
  scale_y_continuous(
    expand = c(0,0))+             # remove o excesso de espaço do eixo y abaixo de 0 (alinha o histograma nivelado com o eixo x)
  
  # temas estéticos
  theme_minimal()+                # simplifique o fundo do gráfico
  
  theme(
    plot.caption = element_text(hjust = 0,        # legenda no lado esquerdo
                                face = "italic"), # legenda em itálico
    axis.title = element_text(face = "bold"))+    # título dos eixos em negrito
  
  # rótulos incluindo legendas dinâmicas
  labs(
    title    = "Incidência semanal de casos (Semanas iniciadas na segunda)",
    subtitle = "Observe o alinhamento das barras, linhas de grade verticais, e rótulos dos eixos nas semanas iniciadas na segunda",
    x        = "Semana de aparecimetno dos sintomas",
    y        = "Incidência semanal dos casos notificados",
    caption  = stringr::str_glue("n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados neste gráfico"))
```


#### Semanas iniciando no domingo {.unnumbered}  

Para obter o gráfico acima para semanas que iniciam no domingo, algumas poucas modificações são necessárias, uima vez que o `date_breaks = "weeks"` funciona apenas para semanas iniciando em segundas.

* Os pontos de quebra dos *containers do histograma* precisam serem ajustados para os domingos (`week_start = 7`)  
* Dentro de `scale_x_date()`, as datas de quebra similares devem ser fornecidas para `breaks =` e `minor_breaks = `, visando garantir que os rótulos de data e linhas de grade verticais alinhem nos domingos.

Por exemplo, o comando `scale_x_date()`, para semanas iniciando nos domingos, pode ser semelhante ao seguinte:

```{r, eval=F}
scale_x_date(
    expand = c(0,0),
    
    # especifique o intervalo do rótulo de datas e das linhas de grade principais
    breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Domingo antes do primeiro caso
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Domingo após o último caso
      by   = "4 weeks"),
    
    # especifique o intervalo das linhas de grade vertical secundárias
    minor_breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Domingo antes do primeiro caso
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Domingo após o último caso
      by   = "week"),
   
    # formato do rótulo de data
    date_labels = "%a\n%d %b\n%Y")+         # dia, mês acima abreviado, sobre o ano com 2-dígitos

```



### Grupo/cor por valor {.unnumbered}

As barras do histograma podem ser coloridas por grupo e por "empilhamento". Para designar a coluna de agrupamento, faça as seguintes modificações. Veja a página sobre [básico do ggplot] para mais detalhes.

* Dentro do mapeamento estético do histograma, `aes()`, mapeie o nome da coluna para os argumentos `group = ` e `fill = `  
* Remova qualquer argumento de `fill = ` *fora* de `aes()`, uma vez que irá sobrepor-se ao argumentos que estão dentro
* Argumentos *dentro* de `aes()` serão aplicados *por grupo*, enquanto qualquer argumento *fora* será aplicado para todas as barras (ex.: você pode querer `color = ` fora, de forma que cada barra tenha a mesma borda)

Aqui é mostrado como o comando `aes()` pode ser utilizado para agrupar e colorir as barras de acordo com o gênero:

```{r, eval=F}
aes(x = date_onset, group = gender, fill = gender)
```

A seguir, ele sendo aplicado:

```{r, warning=F, message=F}
ggplot(data = linelist) +     # comece com o linelist (muitos hospitais)
  
  # crie o histograma: especifique os pontos de ruptura dos containers: começe na segunda anterior ao primeiro caso, e finalize na segunda após o último caso
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = hospital,       # ajuste os dados para serem agrupados por hospital
      fill = hospital),       # preenchimento da barra (cor de dentro) de acordo com o hospital
    
    # quebras dos contentores são nas semanas iniciadas nas segundas
    breaks = weekly_breaks_all,   # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido em código anterior
    
    # Cor ao redor das barras
    color = "black")
```


### Ajuste as cores {.unnumbered}  

* Para *manualmente* ajustar o preenchimento de cada grupo, utilize `scale_fill_manual()` (nota: `scale_color_manual()` é diferente!).
  * Use o argumetno `values = ` para aplicar um vetor de cores.
  * Use o argumetno `na.value = ` para especificar uma cor para os valores `NA`.  
  * Use o argumento `labels = ` para mudar o texto dos itens da legenda. Por segurança, forneça como um vetor nomeado, como `c("old" = "new", "old" = "new")` ou ajuste os valores nos próprios dados.
  * Use `name = ` para dar um título adequado à legenda
* Para mais dicas sobre escalas de cor e paletas, veja a página sobre [básico do ggplot].  

```{r, warning=F, message=F}
ggplot(data = linelist)+           # inicie com a linelist (muitos hospitais)
  
  # crie um histograma
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,          # casos agrupados por hospital
        fill = hospital),          # barras preenchidas por hospital
    
    # quebra dos containers
    breaks = weekly_breaks_all,        # sequência de quebras semanais iniciadas nas segundas, como definido em código anterior
    
    # Cor ao redor das barras
    color = "black")+              # cor da borda para cada barra
  
  # especificação manual das cores
  scale_fill_manual(
    values = c("black", "orange", "grey", "beige", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital") # especifique as cores de preenchimento ("values") - atenção à ordem!
```




### Ajuste a ordem dos níveis {.unnumbered}  

A ordem em que as barras agrupadas estão empilhadas é melhor ajustada ao classificar a coluna de agrupamento como da classe Factor. Você poderá, então, designar a ordem de nível do factor (e os rótulos mostrados). Veja a página sobre [Factors] ou [dicas do ggplot] para detalhes.

Antes de criar o gráfico, utilize a função `fct_relevel()` do pacote **forcats** para converter a coluna de agrupamento para a classe factor, e manualmente ajustar a ordem dos níveis, como detalhado na página sobre [Factors].

```{r}
# carregue o pacote forcats para trabalhar com factors
pacman::p_load(forcats)

# Defina um novo conjunto de dados com o hospital como factor
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Converta para factor e ajuste "Missing" e "Other" como níveis do topo para aparecerem no topo da epicurva

levels(plot_data$hospital) # gere os níveis em ordem
```

No gráfico abaixo, a única diferença do gráfico anterior é que a coluna `hospital` foi consolidada como mostrado acima, e nós utilizamos `guides()` para reverter a ordem da legenda, de forma que "Missing" está no fim da legenda.

```{r, warning=F, message=F}
ggplot(plot_data) +                     # Utilize um NOVO conjunto de dados com hospital reordenado como factor
  
  # crie o histograma
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,               # casos agrupados por hospital
        fill = hospital),               # preenchimento da barra (cor) por hospital
    
    breaks = weekly_breaks_all,         # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido no topo da seção sobre ggplot
    
    color = "black")+                   # cor da borda ao redor de cada barra
    
  # rótulos do eixo x
  scale_x_date(
    expand            = c(0,0),         # remova o excesso de espaço do eixo x antes e após as barras de casos
    date_breaks       = "3 weeks",      # rótulos aparecem a cada 3 semanas que iniciam nas segundas
    date_minor_breaks = "week",         # linhas verticais aparecem a cada semana iniciada na segunda
    date_labels       = "%d\n%b\n'%y")+ # formato do rótulo de datas
  
  # eixo y
  scale_y_continuous(
    expand = c(0,0))+                   # remova o espaço em excesso do eixo y abaixo de 0
  
  # especificação manual das cores, atenção para a ordem!
  scale_fill_manual(
    values = c("grey", "beige", "black", "orange", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital")+ 
  
  # temas estéticos
  theme_minimal()+                      # simplifique o fundo do gráfico
  
  theme(
    plot.caption = element_text(face = "italic", # legenda no lado esquerdo em itálico
                                hjust = 0), 
    axis.title = element_text(face = "bold"))+   # títulos dos eixos em negrito
  
  # rótulos
  labs(
    title    = "Incidência semanal de casos por hospital",
    subtitle = "Hospital como um factor re-ordenado",
    x        = "Semana de aparecimento dos sintomas",
    y        = "Casos semanais")
```

<span style="color: darkgreen;">**_DICA:_** Para reverter apenas a ordem da legenda, adicione o seguinte no comando **ggplot2**: `guides(fill = guide_legend(reverse = TRUE))`.</span>  





### Ajuste a legenda {.unnumbered}

Leia mais sobre legendas e escalas no página sobre [dicas do ggplot]. Aqui estão alguns destaques:

* Edite o título da legenda através da função de escala ou com `labs(fill = "Legend title")` (se você estiver estilizando com `color = `, utilize `labs(color = "")`)  
* `theme(legend.title = element_blank())` para não ter título de legenda
* `theme(legend.position = "top")` ("bottom" (na base), "left" (na esquerda), "right" (na direita), ou "none" para remover a legenda)
* `theme(legend.direction = "horizontal")` legenda horizontal 
* `guides(fill = guide_legend(reverse = TRUE))` para reverter a ordem da legenda







### Barras lado-a-lado {.unnumbered}  

A visualização do grupo de barras lado-a-lado (oposto a empilhadas) é especificado dentro de `geom_histogram()`, com o argumento `position = "dodge"` fora de `aes()`.  

Se existirem mais de dois grupos de valores, estes podem ser difíceis de ler. Em vez disso, considere utilizar um gráfico facetado (pequenos múltiplos). Para melhorar a visualização do gráfico neste exemplo, campos sem a informação do gênero foram removidos.

```{r, warning=F, message=F}
ggplot(central_data %>% drop_na(gender))+   # inicie com casos do Hospital Central, excluindo as linhas sem dados do gênero
    geom_histogram(
        mapping = aes(
          x = date_onset,
          group = gender,         # casos agrupados por gênero
          fill = gender),         # barras preenchidas de acordo com o gênero
        
        # quebras dos containers do histrograma
        breaks = weekly_breaks_central,   # sequência de datas semanais para o surto no Central - definido no topo da seção sobre ggplot
        
        color = "black",          # cor do contorno das barras
        
        position = "dodge")+      # barras LADO-A-LADO
                      
  
  # Os rótulos no eixo x
  scale_x_date(expand            = c(0,0),         # remova os espaços em excesso abaixo do eixo x e após as barras de casos
               date_breaks       = "3 weeks",      # rótulos aparecem a cada 3 semanas iniciadas nas segundas
               date_minor_breaks = "week",         # linhas verticais aparecem a cada semana iniciada nas segundas
               date_labels       = "%d\n%b\n'%y")+ # formato dos rótulos dos dados
  
  # eixo y
  scale_y_continuous(expand = c(0,0))+             # remove o espaço extra nos eixos y entre a base das barras e os rótulos
  
  # escala de cores e rótulos de legendas
  scale_fill_manual(values = c("brown", "orange"),  # especifique as cores de preenchimento ("values") - atenção na ordem!
                    na.value = "grey" )+     

  # temas estéticos
  theme_minimal()+                                               # um conjunto de temas para simplificar o gráfico
  theme(plot.caption = element_text(face = "italic", hjust = 0), # título no lado esquerdo em itálico
        axis.title = element_text(face = "bold"))+               # título dos eixos em negrito
  
  # rótulos
  labs(title    = "Incidência semanal de casos, por gênero",
       subtitle = "Legenda",
       fill     = "Gênero",                                      # forneça novos títulos para os eixos
       x        = "Semana de início dos sintomas",
       y        = "Incidência semanal dos casos notificados")
```




### Limite dos eixos {.unnumbered}  

Existem duas formas de limitar a extensão dos valores dos eixos.

Geralmente, o método indicado é utilizar o comando  `coord_cartesian()`, que aceita `xlim = c(min, max)` e `ylim = c(min, max)` (onde você fornece os valores mínimos e máximos). Esta ferramenta age como um "zoom" sem, na realidade, remover qualquer dado, o que é importante para estatísticas e resumos das medidas.

Alternativamente, você pode ajustar os valores mínimos e máximos das datas utilizando `limits = c()` dentro de `scale_x_date()`. Por exemplo:

```{r eval=F}
scale_x_date(limits = c(as.Date("2014-04-01"), NA)) # escolhe uma data mínima mas deixa a data máxima em aberto.
```

Da mesma forma, se você quiser que o eixo x se estique até uma data específica (ex.: data atual), mesmo que novos casos não sejam notificados, você pode utilizar:

```{r eval=F}
scale_x_date(limits = c(NA, Sys.Date()) # garante que o eixo da data se prolongará até a data atual
```

<span style="color: red;">**_PERIGO:_** Tenha cuidado ao ajustar  as quebras ou limites da escala do eixo y (ex.: 0 a 30 por 5: `seq(0, 30, 5)`). Estes números estáticos podem cortar o seu gráfico casos seus dados mudem e ultrapassem os limites!</span>



### Rótulos/linha de grade do eixo de data {.unnumbered} 

<span style="color: darkgreen;">**_DICA:_** Lembre que os **rótulos** do eixo das datas são independentes da agregação das datas em barras, mas visualmente podem ser importantes para alinhar containers, rótulos de data, e linhas de grade verticais.</span>

Para **modificar os rótulos de data e as linhas de grade**, utilize a função `scale_x_date()` em uma das seguintes formas:

* **Se os seus containers do histograma são dias, semanas iniciadas em segundas, meses, ou anos**:  
  * Utilize `date_breaks = ` para especificar o intervalo de rótulos e linhas de grade principais (ex.: "day" (dia), "week" (semana), "3 weeks" (3 semanas), "month" (mês), ou "year" (ano))
  * Utilize `date_minor_breaks = ` para especificar o intervalo das linhas de grade verticais secundárias (entre os rótulos)
  * Adicione `expand = c(0,0)` para iniciar os rótulos na primeira barra
  * Utilize `date_labels = ` para especificar o formato dos rótulos de data - veja a página sobre Datas para dicas (utilize `\n` para uma nova linha)  
* **Se os seus containers do histograma são semanas iniciadas nos domingos**:  
  * Utilize `breaks = ` e `minor_breaks = ` ao fornecer uma sequência de quebras de datas para cada um
  * Você ainda pode utilizar `date_labels = ` e `expand = ` para formatação, como decrito acima

Algumas notas:

* Veja a seção de abertura do ggplot para instruções sobre como criar uma sequência de datas utilizando `seq.Date()`.  
* Veja [esta página](https://rdrr.io/r/base/strptime.html) ou a página [Trabalhando com datas] para dicas sobre como criar rótulos de data.




#### Demonstrações {.unnumbered}

Abaixo esta uma demonstração de gráficos onde os containers e os rótulos/linhas de grade do gráfico estão alinhados e desalinhados:

```{r fig.show='hold', class.source = 'fold-hide', warning=F, message=F}
# containers de 7-dias + rótulos de Segunda
#############################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,                 # containers de 7-dias com início no primeiro caso
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),               # remova o excesso de espaço do eixo x abaixo e após as barras de caso
    date_breaks = "3 weeks",       # Segunda a cada 3 semanas
    date_minor_breaks = "week",    # Semanas iniciadas na segunda
    date_labels = "%a\n%d\n%b\n'%y")+  # formato do rótulo
  
  scale_y_continuous(
    expand = c(0,0))+              # remova o espaço em excesso abaixo do eixo x, fazendo um nivelamento
  
  labs(
    title = "DESALINHADO",
    subtitle = "! CUIDADO: barras de 7-dias iniciam nas quintas-feiras no primeiro caso\nRótulos de data e linhas de grade nas segundas-feiras\nObserve como os traços não alinham com as barras")



# Containers de 7-dias + meses
#####################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),                  # remova o espaço em excesso abaixo e após as barras de casos
    date_breaks = "months",           # primeiro do mês
    date_minor_breaks = "week",       # semanas iniciadas nas segundas
    date_labels = "%a\n%d %b\n%Y")+    # formato do rótulo
  
  scale_y_continuous(
    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento
  
  labs(
    title = "DESALINHADO",
    subtitle = "! CUIDADO: Barras de 7-dias iniciam nas quintas-feiras com o primeiro caso\nLinhas de grade principais e rótulos de data no primeiro de cada mês\nLinhas de grade secundárias semanalmente nas segundas\nObserve o espaçamento diferente de algumas das linhas de grade e traços desalinhados com as barras")


# ALINHAMENTO TOTAL NAS SEGUNDAS: especifique manualmente as quebras dos containers para serem nas segundas
#################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # quebras do histograma ajustadas para 7 dias iniciando na Segunda antes do primeiro caso
    breaks = weekly_breaks_central,    # definido anteriormente nesta página
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remova o excesso de espaço do eixo x abaixo e após as barras de caso
    date_breaks = "4 weeks",           # Segunda-feira a cada 4 semanas
    date_minor_breaks = "week",        # Semanas iniciadas na segunda
    date_labels = "%a\n%d %b\n%Y")+      # formato do rótulo
  
  scale_y_continuous(
    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça o nivelamento
  
  labs(
    title = "Segunda ALINHADAS",
    subtitle = "Containers de 7-dias manualmente ajustados para iniciarem na segunda antes do primeiro caso (28 de abril)\nRótulos de data e linhas de grade também nas segundas")


# ALINHAMENTO TOTAL NA SEGUNDA COM RÓTULOS DE MESES:
############################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # quebras do histograma ajustaddas para 7 dias iniciando na segunda antes do primeiro caso
    breaks = weekly_breaks_central,            # definido anteriormente nesta página
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remova o excesso de espaço no eixo x abaixo e após as barras de casos
    date_breaks = "months",            # Segunda a cada 4 semanas
    date_minor_breaks = "week",        # Semanas iniciadas nas segundas
    date_labels = "%b\n%Y")+          # formato do rótulo
  
  scale_y_continuous(
    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça um nivelamento
  
  theme(panel.grid.major = element_blank())+  # Remove as linhas de grade principais )caem no primeiro dia do mês)
          
  labs(
    title = "ALINHADO nas segundas com rótulos MENSAIS",
    subtitle = "Containers de 7-dias manualmente ajustado para iniciar na segunda antes do primeiro caso (28 de abril)\nRótulo de datas no primeiro dia do mês\nPrincipais linhas de grade mensais removidas")


# ALINHAMENTO TOTAL NO DOMINGO: especifique manualmente as quebras de containers E rótulos para serem nos domingos
############################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # quebra do histograma ajustadas para serem de 7 dias, iniciando no Domingo antes do primeiro caso
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "7 days"),
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),
    # quebras dos rótulos de datas e principais linhas de grade ajustadas para ocorrerem a cada 3 semanas iniciando no domingo antes do primeiro caso
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "3 weeks"),
    
    # linhas de grade secundárias ajustadas para iniciarem semanalmente no domingo antes do primeiro caso
    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                            by   = "7 days"),
    
    date_labels = "%a\n%d\n%b\n'%y")+  # formato do rótulo
  
  scale_y_continuous(
    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento
  
  labs(title = "ALINHAMENTO nos domingos",
       subtitle = "Containers de 7-dias manualmente ajustados para iniciarem no domingo antes do primeiro caso (27 de abril)\nRótulo de datas e linhas de grade manualmente ajustadas também para os domingos")

```





### Dados agregados {.unnumbered} 

Frequentemente, ao invés de uma linelist, você inicia com contagens agregadas de unidades, distritos, etc. Você pode criar uma epicurva com o `ggplot()`, mas o código será levemente diferente. Esta seção irá utilizar o conjunto de dados do `count_data` que foi importado anteriormente, na seção de preparação dos dados. Este conjunto de dados é o `linelist` agregado para contagens diárias por hospital. As primeiras 50 linhas são mostradas abaixo.

```{r message=FALSE, warning=F, echo=F}
# mostre a linelist como uma tabela
DT::datatable(head(count_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


#### Criando um gráfico de contagens diárias {.unnumbered}  

Nós podemos criar um gráfico de uma epicurva diária destas *contagens diárias*. Aqui estão as diferenças no código:

* Dentro do mapeamento estético `aes()`, especifique `y = ` como a coluna de contagem (neste caso, o nome da coluna é `n_cases`)
* Adicione o argumento `stat = "identity"` dentro de `geom_histogram()`, que especifica que a altura da barra deve ser o valor `y = ` , e não o número de linhas, como é o padrão
* Adicione o argumento `width = ` para evitar linhas verticais brancas entre as barras. Para contagens diárias é 1. Para contagens semanais é 7.  Para contagens mensais, linhas brancas são um problema (cada M~es possui diferente número de dias) - considere transformar seu eixo x para um factor ordenado categoricamente (meses) e utilizando `geom_col()`.


```{r, message=FALSE, warning=F}
ggplot(data = count_data)+
  geom_histogram(
   mapping = aes(x = date_hospitalisation, y = n_cases),
   stat = "identity",
   width = 1)+                # para contagens diárias, ajuste width = 1 para evitar o espaço braco entre as barras
  labs(
    x = "Data de notificação", 
    y = "Número de casos",
    title = "Incidência diária de casos, a partir dos dados de contagem diária")
```

#### Criando um gráfico de contagens semanais {.unnumbered}

Se os seus casos já estão contados por semana, eles podem parecer como o seguinte conjunto de dados (chamado `count_data_weekly`):  

```{r, warning=F, message=F, echo=F}
# Crie um conjunto de dados semanal com uma coluna de semana epidemiológica
count_data_weekly <- count_data %>%
  mutate(epiweek = lubridate::floor_date(date_hospitalisation, "week")) %>% 
  group_by(hospital, epiweek, .drop=F) %>% 
  summarize(n_cases_weekly = sum(n_cases, na.rm=T))   
```

As primeiras 50 linhas de `count_data_weekly` são mostradas abaixo. Você pode ver que as contagens foram agregadas por semanas. Cada semana é mostrada pelo primeiro dia da semana (segunda-feira, por padrão).

```{r message=FALSE, echo=F}
# mostre os dados da linelist como uma tabela
DT::datatable(count_data_weekly, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Agora crie o gráfico de forma que `x = ` a coluna da semana epidemiológica. Lembre de adicionar `y = ` a coluna de contagens para o mapeamento estético, e adicione `stat = "identity"`, como explicado acima.

```{r, warning=F, message=F}
ggplot(data = count_data_weekly)+
  
  geom_histogram(
    mapping = aes(
      x = epiweek,           # eixo x é a semana epidemiológica (da calsse Data)
      y = n_cases_weekly,    # altura do eixo y nas contagens de casos semanais
      group = hospital,      # nós estamos agrupando as barras e colorindo por hospital
      fill = hospital),
    stat = "identity")+      # isto também é requerido quando criar um gráfico dos dados de contagem
     
  # rótulos para o eixo x
  scale_x_date(
    date_breaks = "2 months",      # rótulos a cada 2 meses
    date_minor_breaks = "1 month", # linhas de grade a cada mês
    date_labels = '%b\n%Y')+       # rotulado por mês com o ano abaixo
     
  # Escolha a paleta de cor (utiliza o pacote RColorBrewer)
  scale_fill_brewer(palette = "Pastel2")+ 
  
  theme_minimal()+
  
  labs(
    x = "Semana de início", 
    y = "Incidência semanal de casos",
    fill = "Hospital",
    title = "Incidência semanal de casos, a partir dos dados de casos agregados por hospital")
```




### Média móvel {.unnumbered}

Veja a página sobre [médias móveis] para uma descrição detalhada e diferentes opções. Abaixo, uma alternativa para calcular as médias móveis com o pacote **slider** é utilizada. Nesta abordagem, *a média móvel é calculada no conjunto de dados antes de criar os gráficos*:  

1) Agregue os dados em contagens conforme necessário (diárias, semanais, etc.) (veja a página [Agrupando dados])  
2) Crie uma nova coluna para salvar a média móvel, criada com `slide_index()` do pacote **slider**  
3) Crie um gráfico da média móvel como uma `geom_line()` acima do (após) o histograma da epicurva

Veja este útil [resumo online do pacote **slider**](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)  


```{r, warning=F, message=F}
# carregue o pacote
pacman::p_load(slider)  # slider utilizado para calcular as médias móveis

# crie um conjunto de dados de contagens diárias e média móvel de 7-dias
#######################################################
ll_counts_7day <- linelist %>%    # inicie com o objeto linelist
  
  ## conte os casos por dia
  count(date_onset, name = "new_cases") %>%   # crie uma nova coluna com as contagens, chamada "new_cases"
  drop_na(date_onset) %>%                     # remova os casos sem a informação do dia de início dos sintomas (date_onset)
  
  ## calcule o número médio de casos em uma janela de 7 dias
  mutate(
    avg_7day = slider::slide_index(    # crie uma nova coluna
      new_cases,                       # calcule baseado nos valores da coluna new_cases
      .i = date_onset,                 # o indexador é a coluna de date_onset, de forma que as contagens sem datas são incluídas na janela de análise
      .f = ~mean(.x, na.rm = TRUE),    # a função utilizada é mean() com os valores em branco removidos
      .before = 6,                     # a janela de análise é o dia e os 6-dias anteriores
      .complete = FALSE),              # precisa ser FALSE para unlist() funcionar na próxima etapa
    avg_7day = unlist(avg_7day))       # converta da classe "list" para a classe "numeric"


# crie o gráfico
######
ggplot(data = ll_counts_7day) +  # inicie com o novo conjunto de dados criado acima
    geom_histogram(              # crie uma epicurva em histograma
      mapping = aes(
        x = date_onset,          # coluna de datas no eixo x
        y = new_cases),          # a altura é o número de novos casos diários
        stat = "identity",       # altura da coluna é o valor de y
        fill="#92a8d1",          # cor legal para as barras
        colour = "#92a8d1",      # mesma cor para a borda das barras
        )+ 
    geom_line(                   # crie uma linha para a média móvel
      mapping = aes(
        x = date_onset,          # coluna de data para o eixo x
        y = avg_7day,            # valor de y ajustado para a coluna de média móvel
        lty = "Média móvel \nde 7-dias"), # nome da linha na legenda
      color="red",               # cor da linha
      size = 1) +                # espessura da linha
    scale_x_date(                # escala da data
      date_breaks = "1 month",
      date_labels = '%d/%m',
      expand = c(0,0)) +
    scale_y_continuous(          # escala do eixo y
      expand = c(0,0),
      limits = c(0, NA)) +       
    labs(
      x="",
      y ="Número de casos confirmados",
      fill = "Legenda")+ 
    theme_minimal()+
    theme(legend.title = element_blank())  # remove o título da legenda
```




### Facetas/múltiplos pequenos {.unnumbered}

Como em outros ggplots, você pode criar gráficos facetados ("múltiplos pequenos"). Como explicado na página [dicas do ggplot] deste manual, você pode utilizar tanto `facet_wrap()` quanto `facet_grid()`. Aqui, nós demonstramos com o `facet_wrap()`. Para epicurvas, `facet_wrap()` é tipicamente mais fácil, uma vez que provavelmente você só precisa facetar uma coluna.

A sintaxe geral é `facet_wrap(rows ~ cols)`, em que no lado esquerdo do til (~) é o nome da coluna a ser espalhada através das "linhas" do gráfico facetado, e no lado direito do til é o nome de uma coluna a ser espalhada através das "colunas" do gráfico facetado. De forma mais simples, só utilize um nome de coluna, no lado direito do til: `facet_wrap(~age_cat)`.  


**Eixos livres**  
Você precisará decidir se as escalas dos eixos para cada faceta são "fixas" para as mesmas dimensões (padrão), ou "livres" (significando que irão mudar baseado nos dados dentro da faceta). Faça isso com o argumento `scales = ` dentro de `facet_wrap()` ao especificar "free_x" ou "free_y", ou "free".  


**Número de colunas e linhas das facetas**  
Isto pode ser especificado com `ncol = ` e `nrow = ` dentro de `facet_wrap()`. 


**Ordem dos painéis**  
Para alterar a ordem de aparecimento, altere a ordem dos níveis da coluna de factor utilizada para criar as facetas.


**Estética**  
Tamanho da fonte e face, cor da tira, etc. podem ser modificados através de `theme()` com argumentos como:

* `strip.text = element_text()` (tamanho, cor, face, ângulo...)
* `strip.background = element_rect()` (ex.:  element_rect(fill="grey"))  
* `strip.position = ` (posição da tira "bottom" (abaixo), "top" (acima), "left" (esquerda), ou "right" (direita))  


**Rótulos das tiras**  
Rótulos dos gráficos facetados podem ser modificados através de "rótulos" da coluna como um factor, ou pelo uso de um "rotulador".  

Crie um rotulador como este, utilizando a função `as_labeller()` do **ggplot2**. Então, forneça o rotulador para o argumento `labeller = ` de `facet_wrap()`, como mostrado abaixo.

```{r, class.source = 'fold-show'}
my_labels <- as_labeller(c(
     "0-4"   = "Ages 0-4",
     "5-9"   = "Ages 5-9",
     "10-14" = "Ages 10-14",
     "15-19" = "Ages 15-19",
     "20-29" = "Ages 20-29",
     "30-49" = "Ages 30-49",
     "50-69" = "Ages 50-69",
     "70+"   = "Over age 70"))
```

**Um exemplo de gráfico facetado** - facetado pela coluna `age_cat`.


```{r, warning=F, message=F}
# crie o gráfico
###########
ggplot(central_data) + 
  
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),    # argumentos dentro de aes() aplicam-se ao grupo
      
    color = "black",      # argumentos fora de aes() aplicam-se a todos os dados
        
    # quebras do histograma
    breaks = weekly_breaks_central)+  # vetor pré-definido de datas (veja mais acima nesta página)
                      
  # Os rótulos no eixo x
  scale_x_date(
    expand            = c(0,0),         # remove o espaço em excesso do eixo x abaixo e após as barras de casos
    date_breaks       = "2 months",     # rótulos aparecem a cada 2 meses
    date_minor_breaks = "1 month",      # linhas verticais aparecem a cada mês
    date_labels       = "%b\n'%y")+     # formato dos rótulos de data
  
  # eixo y
  scale_y_continuous(expand = c(0,0))+                       # remove o espaço em excesso do eixo y entre os fundos das barras e os rótulos
  
  # temas estéticos
  theme_minimal()+                                           # um conjunto de temas para simplificar a plotagem
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # título no lado esquerdo em itálico
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "grey"))+         # títulos dos eixos em negrito
  
  # crie as facetas
  facet_wrap(
    ~age_cat,
    ncol = 4,
    strip.position = "top",
    labeller = my_labels)+             
  
  # rótulos
  labs(
    title    = "Incidência semanal de casos, por categoria de idade",
    subtitle = "Legenda",
    fill     = "Categoria de idade",                                      # forneça um novo título para a legenda
    x        = "Semana de início dos sintomas",
    y        = "Incidência semanal dos casos notificados",
    caption  = stringr::str_glue("n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia entre {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico"))
```

Veja este [link](https://ggplot2.tidyverse.org/reference/labellers.html) para mais informações sobre os rotuladores.




#### Epidemia total no fundo da faceta {.unnumbered}

Para mostrar o total da epidemia no fundo de cada faceta, adicione a função `gghighlight()` com parênteses vazios ao ggplot. Isto é do pacote **gghighlight**. Observe que o máximo do eixo y em todas as facetas é agora baseado no pico da epidemia inteira. Existem mais exemplos deste pacote na página sobre [dicas do ggplot].  

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # epicurvas por grupo
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo
    
    color = "black",    # argumentos fora de aes() são aplicados a todos os dados
    
    # quebras do histograma
    breaks = weekly_breaks_central)+     # vetor de datas pré-definidas (veja o topo da seção sobre ggplot)
  
  # adicione a epidemia total em cinza em cada faceta
  gghighlight::gghighlight()+
  
  # rótulos no eixo x
  scale_x_date(
    expand            = c(0,0),         # remova o espaço em excesso do eixo x abaixo e após as barras de casos
    date_breaks       = "2 months",     # rótulos aparecem a cada 2 meses
    date_minor_breaks = "1 month",      # linhas verticais aparecem a cada 1 mês
    date_labels       = "%b\n'%y")+     # formato dos rótulos de data
  
  # eixo y
  scale_y_continuous(expand = c(0,0))+  # remove o excesso de espaço do eixo y abaixo de 0
  
  # temas estéticos
  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # título no lado esquerdo em itálico
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "white"))+        # títulos dos eixos em negrito
  
  # crie as facetas
  facet_wrap(
    ~age_cat,                          # cada gráfico é um valor de age_cat
    ncol = 4,                          # número de colunas
    strip.position = "top",            # posição do título/tira da faceta
    labeller = my_labels)+             # rotulador definido acima
  
  # rótulos
  labs(
    title    = "Incidência semanal de casos, por categoria de idade",
    subtitle = "Legenda",
    fill     = "Categoria de idade",                                      # forneça um novo título para a legenda
    x        = "Semana de início dos sintomas",
    y        = "Incidência semanal dos casos notificados",
    caption  = stringr::str_glue("n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico"))
```


#### Uma faceta com dados {.unnumbered}  

Se você quer ter uma caixa de faceta que contem todos os dados, duplique o conjunto de dados inteiro e trate as duplicatas como um valor de facetas. Uma função "auxiliar", `CreateAllFacet()`, abaixo pode auxiliar nisso (agradecimento a esse [post](https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2)). Quando é executado, o número de linhas duplica, e então terá uma nova coluna chamada `facet`, em que as linhas duplicadas terão o valor "all", e as linhas originais terão o valor original da coluna de facetas. Agora você só precisa facetear com a coluna `facet`.   

Aqui está a função auxiliar. Execute ela de forma que esteja disponível para você.

```{r}
# Defina uma função auxiliar
CreateAllFacet <- function(df, col){
     df$facet <- df[[col]]
     temp <- df
     temp$facet <- "all"
     merged <-rbind(temp, df)
     
     # garanta que o valor da faceta é um factor
     merged[[col]] <- as.factor(merged[[col]])
     
     return(merged)
}
```

Agora aplique a função auxiliar para o conjunto de dados, na coluna `age_cat`:  

```{r}
# Crie um conjunto de dados que é duplicado e com a nova coluna "facet" para mostrar "all" (todas) as categorias de idade como outro nível da faceta
central_data2 <- CreateAllFacet(central_data, col = "age_cat") %>%
  
  # ajuste os níveis do factor
  mutate(facet = fct_relevel(facet, "all", "0-4", "5-9",
                             "10-14", "15-19", "20-29",
                             "30-49", "50-69", "70+"))

# verifique os níveis
table(central_data2$facet, useNA = "always")
```

Alterações notáveis no comando `ggplot()` são:  

* Os dados utilizados agora são central_data2 (duplique as linhas, com a nova coluna "facet")
* Rotulador precisará ser atualizado, caso usado
* Opcional: para obter facetas empilhadas verticalmente: a coluna facetada é movida para o lado das linhas na equação e no lado esquerdo é substituído por "." (`facet_wrap(facet~.)`), e `ncol = 1`. Você também pode precisar ajustar o comprimento e altura da imagem do gráfico salvo (veja `ggsave()` no [dicas do ggplot]).  

```{r, fig.height=12, fig.width=5, warning=F, message=F}
ggplot(central_data2) + 
  
  # epicurvas atuais por grupo
  geom_histogram(
        mapping = aes(
          x = date_onset,
          group = age_cat,
          fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo
        color = "black",    # argumentos fora de aes() são aplicados a todos os dados
        
        # quebras do histograma
        breaks = weekly_breaks_central)+    # vetor de datas pré-definidos (veja o topo da seção sobre o ggplot)
                     
  # Rótulos no eixo x
  scale_x_date(
    expand            = c(0,0),         # remova o excesso de espaço no eixo x abaixo e após as barras de casos
    date_breaks       = "2 months",     # rótulos aparecem a cada 2 meses
    date_minor_breaks = "1 month",      # linhas verticais aparecem a cada mês
    date_labels       = "%b\n'%y")+     # formato dos rótulos de data
  
  # eixo y
  scale_y_continuous(expand = c(0,0))+  # remove o espaço em excesso do eixo y entre a base das barras e os rótulos
  
  # temas estéticos
  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # título no lado esquerdo em itálico
    axis.title = element_text(face = "bold"),
    legend.position = "bottom")+               
  
  # crie as facetas
  facet_wrap(facet~. ,                            # cada gráfico é um valor da faceta
             ncol = 1)+            

  # rótulos
  labs(title    = "Incidência semanal de casos, por categoria de idade",
       subtitle = "Legenda",
       fill     = "Categoria de idade",                                      # forneça um novo título para a legenda
       x        = "Semana de início dos sintomas",
       y        = "Incidência semanal dos casos notificados",
       caption  = stringr::str_glue("n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados no gráfico"))
```








## Dados preliminares


Os dados mais recentes mostrados em epicurvas precisam, frequentemente, serem marcados como preliminares, ou sujeitos à demoras na notificação. Isto pode ser feito ao adicionar uma linha vertical e/ou retângulo sobre um número específico de dias. Aqui estão duas opções:

1) Utilize `annotate()`:  
    + Para utilizar uma linha, use `annotate(geom = "segment")`. Forneça `x`, `xend`, `y`, e `yend`. Ajuste o tamanho, tipo de linha (`lty`), e cor.
    + Para utilizar um retângulo, use `annotate(geom = "rect")`. Forneça xmin/xmax/ymin/ymax. Ajuste a cor e o alfa.
2) Agrupe os dados por status preliminar e com cor diferente

<span style="color: orange;">**_CUIDADO:_** Você pode querer experimentar `geom_rect()` para desenhar um retângulo, mas ajustar a transparência não funciona no contexto de uma linelist. Esta função sobrepõe um retângulo para cada observação/linha!. Utilize ou um alfa muito baixo (ex.: 0.01), ou outra abordagem.</span>

### Utilizando `annotate()` {.unnumbered}

* Dentro de `annotate(geom = "rect")`, os argumentos `xmin` e `xmax` precisam serem dados valores da classe Date (data).
* Note que, devido ao fato destes dados serem agregados em barras semanais, e a última barra extender para a segunda após o último caso, a região sombreada pode parecer cobrir 4 semanas
* Aqui é um [exemplo online](https://ggplot2.tidyverse.org/reference/annotate.html) de `annotate()`


```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # histograma
  geom_histogram(
    mapping = aes(x = date_onset),
    
    breaks = weekly_breaks_central,   # vetor de data pré-definido - veja o topo da seção sobre o ggplot
    
    color = "darkblue",
    
    fill = "lightblue") +

  # escalas
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),                   # remove o excesso de espaço do eixo x abaixo e após as barras de casos
    date_breaks = "1 month",           # Primeiro do mês
    date_minor_breaks = "1 month",     # Primeiro do mês
    date_labels = "%b\n'%y")+          # formato do rótulo
  
  # rótulos e tema
  labs(
    title = "Utilizando annotate()\nRetângulo e linha mostrando que os dados dos últimos 21 dias são preliminares",
    x = "Semana de início de sintomas",
    y = "Incidência semanal de casos")+ 
  theme_minimal()+
  
  # adicione um retângulo vermelho semi-transparente nos dados preliminares
  annotate(
    "rect",
    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # a nota precisa ser englobada dentro de as.Date()
    xmax  = as.Date(Inf),                                          # a nota precisa ser englobada dentro de as.Date()
    ymin  = 0,
    ymax  = Inf,
    alpha = 0.2,          # alfa fácil e intuitivo para ajustar usando annotate()
    fill  = "red")+
  
  # adicione uma linha preta vertical no topo das outras camadas
  annotate(
    "segment",
    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 dias antes dos últimos dados
    xend  = max(central_data$date_onset, na.rm = T) - 21, 
    y     = 0,         # linha inicia em y = 0
    yend  = Inf,       # linha no topo do gráfico
    size  = 2,         # tamanho da linha
    color = "black",
    lty   = "solid")+   # tipo de linha ex.: "solid", "dashed"

  # adicione texto no retângulo
  annotate(
    "text",
    x = max(central_data$date_onset, na.rm = T) - 15,
    y = 15,
    label = "Sujeito à atrasos nas notificações",
    angle = 90)
```


A mesma linha preta vertical pode ser obtida com o código abaixo, mas, utilizando `geom_vline()`, você perde a capacidade de controlar a altura:

```{r, eval=F}
geom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,
           size = 2,
           color = "black")
```



### Cor das barras {.unnumbered}  

Uma abordagem alternativa pode ser ajustar a cor ou exibição das dos dados preliminares. Você pode criar uma nova coluna no estágio de preparação dos dados, e utiliza-la para agrupar os dados, de forma que o `aes(fill = )` dos dados preliminares possa ter uma cor ou alfa diferente das outras barras.

```{r, message=F, warning=F}
# adiciona uma coluna
############
plot_data <- central_data %>% 
  mutate(tentative = case_when(
    date_onset >= max(date_onset, na.rm=T) - 7 ~ "Tentative", # preliminares e estiverem dentro dos últimos 7 dias
    TRUE                                       ~ "Reliable")) # todos os demais são confiáveis

# crie o gráfico
######
ggplot(plot_data, aes(x = date_onset, fill = tentative)) + 
  
  # histograma
  geom_histogram(
    breaks = weekly_breaks_central,   # vetor de datas pré-definido, veja o topo da página sobre o ggplot
    color = "black") +

  # escalas
  scale_y_continuous(expand = c(0,0))+
  scale_fill_manual(values = c("lightblue", "grey"))+
  scale_x_date(
    expand = c(0,0),                   # remove o espaço em excesso do eixo x, abaixo e após as barras de casos
    date_breaks = "3 weeks",           # segundas a cada 3 semanas
    date_minor_breaks = "week",        # semanas iniciadas nas segundas
    date_labels = "%d\n%b\n'%y")+      # formato do rótulo
  
  # rótulos e temas
  labs(title = "Mostra os dias que possuem notificações preliminares",
    subtitle = "")+ 
  theme_minimal()+
  theme(legend.title = element_blank())                 # remove o título da legenda
  
```


## Etiquetas multiníveis de data  

Se você quiser etiquetas multiníveis de datas (ex.: mês e ano) *sem duplicar as etiquetas de níveis mais baixos*, utilize uma das abordagens abaixo:

Lembre - você pode utilizar ferramentas como `\n` *dentro* dos argumentos de `date_labels` ou `labels` para colocar partes de cada etiqueta em uma nova linha abaixo da atual. Entretanto, o código abaixo o ajuda a colocar anos ou meses (por exemplo) em uma linha abaixo *e apenas uma vez*. Algumas notas sobre o código abaixo:

* Contagem de casos são agregados em semanas por razões estéticas. Veja a página sobre epicurvas (parte sobre a separação dos dados agregados) para mais detalhes.
* Uma linha `geom_area()` é utilizada no lugar de um histograma, uma vez que a abordagem de faceteamento abaixo não funciona bem com histogramas.


**Agregue para contagens semanais**

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}

# Crie o conjunto de dados de contagens de casos por semana
#######################################
central_weekly <- linelist %>%
  filter(hospital == "Central Hospital") %>%   # filtre a linelist
  mutate(week = lubridate::floor_date(date_onset, unit = "weeks")) %>%  
  count(week) %>%                              # faça um resumo das contagens de casos semanais
  drop_na(week) %>%                            # remova os casos sem a informação de onset_date
  complete(                                    # preencha todas as semanas com nenhum caso notificado
    week = seq.Date(
      from = min(week),   
      to   = max(week),
      by   = "week"),
    fill = list(n = 0))                        # converta novos campos NA (em branco) para contagens de 0
```

**Crie os gráficos**  

```{r, warning=F, message=F}
# crie um gráfico com a borda da caixa no ano
##############################
ggplot(central_weekly) +
  geom_area(aes(x = week, y = n),    # crie uma linha, especificando x e y
            stat = "identity") +             # a altura da linha é o número da contagem
  scale_x_date(date_labels="%b",             # formato do rótulo de data mostra o mês
               date_breaks="month",          # rótulos de data no primeiro dia de cada mês
               expand=c(0,0)) +              # remove o espaço em excesso em cada extremidade
  scale_y_continuous(
    expand  = c(0,0))+                       # remove o espaço em excesso abaixo do eixo x
  facet_grid(~lubridate::year(week), # crie uma faceta com o ano (da coluna da classe Date (Data))
             space="free_x",                
             scales="free_x",                # eixo x se adapta para o intervalo dos dados (não é fixo)
             switch="x") +                   # etiquetas de faceta (ano) na base
  theme_bw() +
  theme(strip.placement = "outside",         # posicionamento das etiquetas das facetas
        strip.background = element_rect(fill = NA, # rótulos das facetas sem preenchimento e com bordas cinzas
                                        colour = "grey50"),
        panel.spacing = unit(0, "cm"))+      # sem espaço entre os painéis das facetas
  labs(title = "Etiquetas de ano aninhadas, com borda cinza")


# crie o gráfico sem a borda de caixa no ano
#################################
ggplot(central_weekly,
       aes(x = week, y = n)) +              # estabeleça o x e y para o gráfico inteiro
  geom_line(stat = "identity",              # crie a linha, em que a altura da linha é o número da contagem
            color = "#69b3a2") +            # cor da linha
  geom_point(size=1, color="#69b3a2") +     # crie pontos nos pontos de data semanais
  geom_area(fill = "#69b3a2",               # preencha a área abaixo da linha
            alpha = 0.4)+                   # preencha a transparência
  scale_x_date(date_labels="%b",            # formato do rótulo de data mostra o mês
               date_breaks="month",         # rótulos de data no primeiro dia de cada mês
               expand=c(0,0)) +             # remova o espaço em excesso
  scale_y_continuous(
    expand  = c(0,0))+                      # remova o espaço em excesso abaixo do eixo x
  facet_grid(~lubridate::year(week),        # faça a faceta no ano (da coluna de classe Date (data))
             space="free_x",                
             scales="free_x",               # eixo x se adapta ao intervalo de dados (não é fixo)
             switch="x") +                  # rótulos da faceta (ano) na base
  theme_bw() +
  theme(strip.placement = "outside",                     # posicionamento do rótulo da faceta
          strip.background = element_blank(),            # rótulo da faceta sem fundo
          panel.grid.minor.x = element_blank(),          
          panel.border = element_rect(colour="grey40"),  # borda cinza para o painel da faceta
          panel.spacing=unit(0,"cm"))+                   # sem espaço entre os painéis da faceta
  labs(title = "Etiquetas de ano aninhadas - pontos, sombreamento, e sem borda no rótulo")
```

As técnicas acima foram adaptadas [desta](https://stackoverflow.com/questions/44616530/axis-labels-on-two-lines-with-nested-x-variables-year-below-months) e [desta](https://stackoverflow.com/questions/20571306/multi-row-x-axis-labels-in-ggplot-line-chart) postagem no stackoverflow.com.  






<!-- ======================================================= -->
## Eixo duplo { }  

Embora existam discussões intensas sobre a validade de eixos duplos na comunidade de visualização de dados, muitos supervisores de epidemiologia ainda querem ver uma epicurva ou gráfico similar com um percentual sobreposto com um segundo eixo. Isto é discutido mais extensivamente na página [dicas do ggplot], mas um exemplo utilizando o método de **cowplot** é mostrado abaixo:

* Dois gráficos distintos são feitos, e então combinados com o pacote **cowplot**.  
* Os gráficos precisam ter exatamente o mesmo eixo x (ajuste os limites). Do contrário, os dados e rótulos não serão alinhados
* Cada um utiliza `theme_cowplot()` e um deles tem o eixo y movido para o lado direito do gráfico

```{r, warning=F, message=F}
# carregue o pacote
pacman::p_load(cowplot)

# Crie o primeiro gráfico de histograma de uma epicurva
#######################################
plot_cases <- linelist %>% 
  
  # crie o gráfico com casos por semana
  ggplot()+
  
  # crie o histograma
  geom_histogram(
    
    mapping = aes(x = date_onset),
    
    # quebras de containers a cada semana, iniciando na segunda antes do primeiro caso, e indo até a segunda após o último caso
    breaks = weekly_breaks_all)+  # vetor pré-definido de datas semanais (veja o topo da seção sobre o ggplot)
        
  # especifique o início e o fim do eixo da data para alinhar com o outro gráfico
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma
  
  # rótulos
  labs(
      y = "Casos diários",
      x = "Data de aparecimento dos sintomas"
    )+
  theme_cowplot()


# crie um segundo gráfico com o percentual de óbitos por semana
###########################################
plot_deaths <- linelist %>%                        # inicie com a linelist
  group_by(week = floor_date(date_onset, "week")) %>%  # crie a coluna week (semana)
  
  # utilize summarise para obter o percentual semanal de casos que morreram
  summarise(n_cases = n(),
            died = sum(outcome == "Death", na.rm=T),
            pct_died = 100*died/n_cases) %>% 
  
  # inicie o gráfico
  ggplot()+
  
  # linha com o percentual semanal de óbitos
  geom_line(                                # crie um linha com o percentual de mortos
    mapping = aes(x = week, y = pct_died),  # especifique o y-altura como sendo da coluna pct_died
    stat = "identity",                      # ajuste a altura da linha para o valor na coluna pct_death, e não a quantidade de linhas (que é o padrão)
    size = 2,
    color = "black")+
  
  # Mesmos limites no eixo de datas como no outro gráfico - alinhamento perfeito
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma
  
  
  # ajustes no eixo y
  scale_y_continuous(                # ajuste o eixo y
    breaks = seq(0,100, 10),         # ajuste os intervalos de quebra do eixo da porcentagem
    limits = c(0, 100),              # ajuste a extensão do eixo de porcentagem
    position = "right")+             # mova o eixo de porcentagem para a direita
  
  # rótulo do eixo y, sem rótulo no eixo x
  labs(x = "",
       y = "Percentual de óbitos")+      # rótulo do eixo de porcentagem
  
  theme_cowplot()                   # adicione isto para unir os dois gráficos
```

Agora, use o **cowplot** para sobrepor os dois gráficos. A atenção precisa ser dada ao alinhamento do eixo x, ao lado do eixo y, e ao uso de `theme_cowplot()`.  

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```




## Incidência acumulada {}

Nota: Caso esteja utilizando o pacote **incidence2**, veja a seção sobre como você pode produzir incidência acumulada com uma simples função. Esta página irá ensinar como calcular a incidência acumulada e fazer um gráfico dela utilizando `ggplot()`.  

Se estiver iniciando com os casos em uma linelist, crie uma nova coluna contendo o número acumulado de casos por dia em um surto utilizando a função `cumsum()` do R **base**:    

```{r}
cumulative_case_counts <- linelist %>% 
  count(date_onset) %>%                # contagem de linhas por dia (salvo na coluna "n")
  mutate(                         
    cumulative_cases = cumsum(n)       # nova coluna com a quantidade de linhas acumuladas em cada data
    )
```

As primeiras 10 linhas são mostradas abaixo:

```{r message=FALSE, echo=F}
# mostra os dados da linelist como uma tabela
DT::datatable(head(cumulative_case_counts, 10), rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```



Esta coluna de casos acumulados pode então ser utilizada para fazer um gráfico com a data de início dos sintomas, `date_onset`, utilizando `geom_line()`:

```{r, warning=F, message=F}
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")

plot_cumulative
```


Ela também pode ser sobreposta em uma epicurva, com dois eixos, utilizando o método **cowplot** descrito acima e na página [dicas do ggplot]:

```{r, warning=F, message=F}
# carregue o pacote
pacman::p_load(cowplot)

# crie primeiro o histograma de uma epicurva
plot_cases <- ggplot()+
  geom_histogram(          
    data = linelist,
    aes(x = date_onset),
    binwidth = 1)+
  labs(
    y = "Casos diários",
    x = "Data de início dos sintomas"
  )+
  theme_cowplot()

# crie um segundo gráfico com uma linha de casos acumulados
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")+
  scale_y_continuous(
    position = "right")+
  labs(x = "",
       y = "Casos acumulados")+
  theme_cowplot()+
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks = element_blank())
```

Agora, use **cowplot** para sobrepor os dois gráficos. Atenção ao alinhamento do eixo x, o lado do eixo y, e o uso de `theme_cowplot()`.  

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```


<!-- ======================================================= -->
## Recursos { }








